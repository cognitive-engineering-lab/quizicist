

1. What is the main aim of lifetimes? 
a. To prevent dangling references
b. To make sure references are valid 
c. To compare scopes 
d. To determine if the code is valid

2. What is the borrow checker? 
a. A tool to determine if the code is valid 
b. A way to compare scopes 
c. A tool to prevent dangling references 
d. A way to make sure references are valid

3. Why do we need to annotate lifetimes? 
a. So the borrow checker can determine if the code is valid 
b. So we can make sure references are valid 
c. So we can prevent dangling references 
d. So the lifetime of references can be related in different ways

4. How does Rust determine if the code in Listing 10-16 is invalid? 
a. By comparing the size of the two lifetimes 
b. By using the borrow checker 
c. By determining if the value of r is referring to has gone out of scope 
d. By making sure the reference in r will always be valid

5. What is the difference between lifetime annotations and generic lifetime parameters? 
a. Lifetime annotations change how long references live, while generic lifetime parameters describe relationships between lifetimes of multiple references 
b. Lifetime annotations describe relationships between lifetimes of multiple references, while generic lifetime parameters change how long references live 
c. Generic lifetime parameters change how long references live, while lifetime annotations do not have much meaning 
d. There is no difference between lifetime annotations and generic lifetime parameters