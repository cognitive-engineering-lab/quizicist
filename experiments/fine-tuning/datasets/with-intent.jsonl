{"prompt": "The final flow control structure that appears on the AP Exam is called recursion. It is not represented in the free-response questions and appears at least once in the multiple-choice questions (but typically only a few times). This structure has a result similar to a loop, but approaches the task in a different manner. \nRemember those little wind-up toys you played with when you were little? You know, the plastic teeth or bunny (or whatever) with the little white knob on the side? You would wind the knob over and over, and when you let go, the little teeth would move across the table. The more you wound the knob, the longer the teeth would walk. Since the winding is the same action repeated, it can be considered a loop. The unwinding action, however, differentiates this situation from a while or for loop. When an unwinding or \u201cwinding down\u201d occurs as a result of a \u201cwinding up,\u201d recursion is lurking in the shadows. \nThe distinguishing characteristic of a recursive method is a call to the very method itself; this statement is called a recursive call. In order to prevent an infinite loop, the recursive method includes a base case, which signals execution to stop recursing and return to each prior recursive call, finishing the job for each. Let\u2019s use an easy example to illustrate this somewhat confusing topic, and then we\u2019ll spice up the example a bit afterward.\nSuppose you have a giant bag of small, multicolored, candy-coated chocolates. As a programmer, you naturally do not want to eat these candies in a haphazard manner; instead, you want to use some sort of algorithm. You decide that you will eat random candies, one at a time, until you reach your favorite color; when your favorite color is reached, you will systematically eat the same colors you ate previously, in backward order. \nFor example, if you eat red -> blue -> orange -> blue -> green, and green is your base case, you will then eat blue -> orange -> blue -> red and the recursion is complete. Pretty tough to remember, right? Well, a recursive method renders this task a cinch. In pseudocode, \neatCandy (color of current candy) \n{ \n    if (current candy color is green) \n        done eating; \n    else \n        eat more candy; \n} \n\nAlthough there is no for or while loop in the code, the recursive call to the method will exhibit a looping quality; unlike our previous loops, however, there is a forward/backward progression, as described above. \nLet\u2019s add to this task: tell the user that you\u2019re done eating once you finish. Would adding the following line after the if-else statement accomplish this task? \ndisplay I\u2019m done; \n\nThe way recursion works, the task will be accomplished, although perhaps not according to plan. When the base case is reached, execution of the current method is completed, and then the process continues all the way back to the initial recursive call. Since the \u201cI\u2019m done\u201d message is displayed after, and regardless of, the if-else, it will be displayed each time a recursive iteration completes. The result is the displaying of \u201cI\u2019m done\u201d once for every candy that you ate. Nine candies, nine \u201cI\u2019m done\u201d outputs. It works, but probably not as planned. \nAlthough it is more common to use a for loop to step through an array, it is also possible to use a recursion. For example, say you have a lineup of football players, each of whom has a numbered helmet. You want to step through the lineup and find the position of the person who has \u201c9\u201d written on his helmet.\nA recursive solution for this problem is very easy to implement. You need to look through an array of int values and find the position of a specific value, if it\u2019s there. \nFirst, we\u2019ll need to describe the problem in recursive terms. \nIf we\u2019ve looked through every item, then return \u20131. \nIf the current item in the array is a match, return its position. Or else, restart the process with the next item in the array. \n\npublic int findPosition(int nums[], int key, int currentIndex) { \n    //if we\u2019ve already looked through \n    //the entire array \n    if (nums.length <= currentIndex) \n        return -1; \n    //if the next item in the array is a match, \n    //then return it \n    if (nums[currentIndex] == key)\n        return currentIndex; \n    //else, step past the current item in the array, \n    //and repeat the search on the next item \n    return findPosition(nums, key, currentIndex + 1);\n} \n\nThis example is slightly more subtle than the others because we\u2019re carrying information from one recursive call to the next. Specifically, we\u2019re using the currentIndex field to pass information from one recursive call to another. Thus, the first recursive call starts looking at position 0, the next one at position 1, and so on. \nLet\u2019s go back to our football-player example. You want to step through a lineup of football players and return the position of the player who has the helmet with \u201c9\u201d written on it. Your code would be of the following form: \nint [] players = //represents the football players \nint pos = findPosition(players, 9, 0);\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following method:\n// precondition: x >= 0\npublic int mystery (int x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    else\n    {\n        return ((x % 10) + mystery(x / 10));\n    }\n}\n\nWhich of the following is returned as a result of the call mystery(3543)?\nCorrect: 15\nIncorrect: 10\nIncorrect: 22\nIncorrect: 180\nIncorrect: Nothing is returned due to infinite recursion.\n\nEND"}
{"prompt": "The final flow control structure that appears on the AP Exam is called recursion. It is not represented in the free-response questions and appears at least once in the multiple-choice questions (but typically only a few times). This structure has a result similar to a loop, but approaches the task in a different manner. \nRemember those little wind-up toys you played with when you were little? You know, the plastic teeth or bunny (or whatever) with the little white knob on the side? You would wind the knob over and over, and when you let go, the little teeth would move across the table. The more you wound the knob, the longer the teeth would walk. Since the winding is the same action repeated, it can be considered a loop. The unwinding action, however, differentiates this situation from a while or for loop. When an unwinding or \u201cwinding down\u201d occurs as a result of a \u201cwinding up,\u201d recursion is lurking in the shadows. \nThe distinguishing characteristic of a recursive method is a call to the very method itself; this statement is called a recursive call. In order to prevent an infinite loop, the recursive method includes a base case, which signals execution to stop recursing and return to each prior recursive call, finishing the job for each. Let\u2019s use an easy example to illustrate this somewhat confusing topic, and then we\u2019ll spice up the example a bit afterward.\nSuppose you have a giant bag of small, multicolored, candy-coated chocolates. As a programmer, you naturally do not want to eat these candies in a haphazard manner; instead, you want to use some sort of algorithm. You decide that you will eat random candies, one at a time, until you reach your favorite color; when your favorite color is reached, you will systematically eat the same colors you ate previously, in backward order. \nFor example, if you eat red -> blue -> orange -> blue -> green, and green is your base case, you will then eat blue -> orange -> blue -> red and the recursion is complete. Pretty tough to remember, right? Well, a recursive method renders this task a cinch. In pseudocode, \neatCandy (color of current candy) \n{ \n    if (current candy color is green) \n        done eating; \n    else \n        eat more candy; \n} \n\nAlthough there is no for or while loop in the code, the recursive call to the method will exhibit a looping quality; unlike our previous loops, however, there is a forward/backward progression, as described above. \nLet\u2019s add to this task: tell the user that you\u2019re done eating once you finish. Would adding the following line after the if-else statement accomplish this task? \ndisplay I\u2019m done; \n\nThe way recursion works, the task will be accomplished, although perhaps not according to plan. When the base case is reached, execution of the current method is completed, and then the process continues all the way back to the initial recursive call. Since the \u201cI\u2019m done\u201d message is displayed after, and regardless of, the if-else, it will be displayed each time a recursive iteration completes. The result is the displaying of \u201cI\u2019m done\u201d once for every candy that you ate. Nine candies, nine \u201cI\u2019m done\u201d outputs. It works, but probably not as planned. \nAlthough it is more common to use a for loop to step through an array, it is also possible to use a recursion. For example, say you have a lineup of football players, each of whom has a numbered helmet. You want to step through the lineup and find the position of the person who has \u201c9\u201d written on his helmet.\nA recursive solution for this problem is very easy to implement. You need to look through an array of int values and find the position of a specific value, if it\u2019s there. \nFirst, we\u2019ll need to describe the problem in recursive terms. \nIf we\u2019ve looked through every item, then return \u20131. \nIf the current item in the array is a match, return its position. Or else, restart the process with the next item in the array. \n\npublic int findPosition(int nums[], int key, int currentIndex) { \n    //if we\u2019ve already looked through \n    //the entire array \n    if (nums.length <= currentIndex) \n        return -1; \n    //if the next item in the array is a match, \n    //then return it \n    if (nums[currentIndex] == key)\n        return currentIndex; \n    //else, step past the current item in the array, \n    //and repeat the search on the next item \n    return findPosition(nums, key, currentIndex + 1);\n} \n\nThis example is slightly more subtle than the others because we\u2019re carrying information from one recursive call to the next. Specifically, we\u2019re using the currentIndex field to pass information from one recursive call to another. Thus, the first recursive call starts looking at position 0, the next one at position 1, and so on. \nLet\u2019s go back to our football-player example. You want to step through a lineup of football players and return the position of the player who has the helmet with \u201c9\u201d written on it. Your code would be of the following form: \nint [] players = //represents the football players \nint pos = findPosition(players, 9, 0);\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following recursive method:\npublic int mystery(int x)\n{\n    if (x == 1)\n        return 2;\n    else\n        return 2 * mystery(x \u2013 1);\n}\n\nWhat value is returned as a result of the call mystery(6)?\nCorrect: 64\nIncorrect: 2\nIncorrect: 12\nIncorrect: 32\nIncorrect: 128\n\nEND"}
{"prompt": "The final flow control structure that appears on the AP Exam is called recursion. It is not represented in the free-response questions and appears at least once in the multiple-choice questions (but typically only a few times). This structure has a result similar to a loop, but approaches the task in a different manner. \nRemember those little wind-up toys you played with when you were little? You know, the plastic teeth or bunny (or whatever) with the little white knob on the side? You would wind the knob over and over, and when you let go, the little teeth would move across the table. The more you wound the knob, the longer the teeth would walk. Since the winding is the same action repeated, it can be considered a loop. The unwinding action, however, differentiates this situation from a while or for loop. When an unwinding or \u201cwinding down\u201d occurs as a result of a \u201cwinding up,\u201d recursion is lurking in the shadows. \nThe distinguishing characteristic of a recursive method is a call to the very method itself; this statement is called a recursive call. In order to prevent an infinite loop, the recursive method includes a base case, which signals execution to stop recursing and return to each prior recursive call, finishing the job for each. Let\u2019s use an easy example to illustrate this somewhat confusing topic, and then we\u2019ll spice up the example a bit afterward.\nSuppose you have a giant bag of small, multicolored, candy-coated chocolates. As a programmer, you naturally do not want to eat these candies in a haphazard manner; instead, you want to use some sort of algorithm. You decide that you will eat random candies, one at a time, until you reach your favorite color; when your favorite color is reached, you will systematically eat the same colors you ate previously, in backward order. \nFor example, if you eat red -> blue -> orange -> blue -> green, and green is your base case, you will then eat blue -> orange -> blue -> red and the recursion is complete. Pretty tough to remember, right? Well, a recursive method renders this task a cinch. In pseudocode, \neatCandy (color of current candy) \n{ \n    if (current candy color is green) \n        done eating; \n    else \n        eat more candy; \n} \n\nAlthough there is no for or while loop in the code, the recursive call to the method will exhibit a looping quality; unlike our previous loops, however, there is a forward/backward progression, as described above. \nLet\u2019s add to this task: tell the user that you\u2019re done eating once you finish. Would adding the following line after the if-else statement accomplish this task? \ndisplay I\u2019m done; \n\nThe way recursion works, the task will be accomplished, although perhaps not according to plan. When the base case is reached, execution of the current method is completed, and then the process continues all the way back to the initial recursive call. Since the \u201cI\u2019m done\u201d message is displayed after, and regardless of, the if-else, it will be displayed each time a recursive iteration completes. The result is the displaying of \u201cI\u2019m done\u201d once for every candy that you ate. Nine candies, nine \u201cI\u2019m done\u201d outputs. It works, but probably not as planned. \nAlthough it is more common to use a for loop to step through an array, it is also possible to use a recursion. For example, say you have a lineup of football players, each of whom has a numbered helmet. You want to step through the lineup and find the position of the person who has \u201c9\u201d written on his helmet.\nA recursive solution for this problem is very easy to implement. You need to look through an array of int values and find the position of a specific value, if it\u2019s there. \nFirst, we\u2019ll need to describe the problem in recursive terms. \nIf we\u2019ve looked through every item, then return \u20131. \nIf the current item in the array is a match, return its position. Or else, restart the process with the next item in the array. \n\npublic int findPosition(int nums[], int key, int currentIndex) { \n    //if we\u2019ve already looked through \n    //the entire array \n    if (nums.length <= currentIndex) \n        return -1; \n    //if the next item in the array is a match, \n    //then return it \n    if (nums[currentIndex] == key)\n        return currentIndex; \n    //else, step past the current item in the array, \n    //and repeat the search on the next item \n    return findPosition(nums, key, currentIndex + 1);\n} \n\nThis example is slightly more subtle than the others because we\u2019re carrying information from one recursive call to the next. Specifically, we\u2019re using the currentIndex field to pass information from one recursive call to another. Thus, the first recursive call starts looking at position 0, the next one at position 1, and so on. \nLet\u2019s go back to our football-player example. You want to step through a lineup of football players and return the position of the player who has the helmet with \u201c9\u201d written on it. Your code would be of the following form: \nint [] players = //represents the football players \nint pos = findPosition(players, 9, 0);\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following recursive method:\npublic static int mystery(int x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    else\n    {\n        return (x + mystery(x / 2) + mystery(x / 4));\n    }\n}\n\nWhat value is returned as a result of a call to mystery(10)?\nCorrect: 22\nIncorrect: 10\nIncorrect: 12\nIncorrect: 20\nIncorrect: 35\n\nEND"}
{"prompt": "The final flow control structure that appears on the AP Exam is called recursion. It is not represented in the free-response questions and appears at least once in the multiple-choice questions (but typically only a few times). This structure has a result similar to a loop, but approaches the task in a different manner. \nRemember those little wind-up toys you played with when you were little? You know, the plastic teeth or bunny (or whatever) with the little white knob on the side? You would wind the knob over and over, and when you let go, the little teeth would move across the table. The more you wound the knob, the longer the teeth would walk. Since the winding is the same action repeated, it can be considered a loop. The unwinding action, however, differentiates this situation from a while or for loop. When an unwinding or \u201cwinding down\u201d occurs as a result of a \u201cwinding up,\u201d recursion is lurking in the shadows. \nThe distinguishing characteristic of a recursive method is a call to the very method itself; this statement is called a recursive call. In order to prevent an infinite loop, the recursive method includes a base case, which signals execution to stop recursing and return to each prior recursive call, finishing the job for each. Let\u2019s use an easy example to illustrate this somewhat confusing topic, and then we\u2019ll spice up the example a bit afterward.\nSuppose you have a giant bag of small, multicolored, candy-coated chocolates. As a programmer, you naturally do not want to eat these candies in a haphazard manner; instead, you want to use some sort of algorithm. You decide that you will eat random candies, one at a time, until you reach your favorite color; when your favorite color is reached, you will systematically eat the same colors you ate previously, in backward order. \nFor example, if you eat red -> blue -> orange -> blue -> green, and green is your base case, you will then eat blue -> orange -> blue -> red and the recursion is complete. Pretty tough to remember, right? Well, a recursive method renders this task a cinch. In pseudocode, \neatCandy (color of current candy) \n{ \n    if (current candy color is green) \n        done eating; \n    else \n        eat more candy; \n} \n\nAlthough there is no for or while loop in the code, the recursive call to the method will exhibit a looping quality; unlike our previous loops, however, there is a forward/backward progression, as described above. \nLet\u2019s add to this task: tell the user that you\u2019re done eating once you finish. Would adding the following line after the if-else statement accomplish this task? \ndisplay I\u2019m done; \n\nThe way recursion works, the task will be accomplished, although perhaps not according to plan. When the base case is reached, execution of the current method is completed, and then the process continues all the way back to the initial recursive call. Since the \u201cI\u2019m done\u201d message is displayed after, and regardless of, the if-else, it will be displayed each time a recursive iteration completes. The result is the displaying of \u201cI\u2019m done\u201d once for every candy that you ate. Nine candies, nine \u201cI\u2019m done\u201d outputs. It works, but probably not as planned. \nAlthough it is more common to use a for loop to step through an array, it is also possible to use a recursion. For example, say you have a lineup of football players, each of whom has a numbered helmet. You want to step through the lineup and find the position of the person who has \u201c9\u201d written on his helmet.\nA recursive solution for this problem is very easy to implement. You need to look through an array of int values and find the position of a specific value, if it\u2019s there. \nFirst, we\u2019ll need to describe the problem in recursive terms. \nIf we\u2019ve looked through every item, then return \u20131. \nIf the current item in the array is a match, return its position. Or else, restart the process with the next item in the array. \n\npublic int findPosition(int nums[], int key, int currentIndex) { \n    //if we\u2019ve already looked through \n    //the entire array \n    if (nums.length <= currentIndex) \n        return -1; \n    //if the next item in the array is a match, \n    //then return it \n    if (nums[currentIndex] == key)\n        return currentIndex; \n    //else, step past the current item in the array, \n    //and repeat the search on the next item \n    return findPosition(nums, key, currentIndex + 1);\n} \n\nThis example is slightly more subtle than the others because we\u2019re carrying information from one recursive call to the next. Specifically, we\u2019re using the currentIndex field to pass information from one recursive call to another. Thus, the first recursive call starts looking at position 0, the next one at position 1, and so on. \nLet\u2019s go back to our football-player example. You want to step through a lineup of football players and return the position of the player who has the helmet with \u201c9\u201d written on it. Your code would be of the following form: \nint [] players = //represents the football players \nint pos = findPosition(players, 9, 0);\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the following nonrecursive method:\n//precondition: x >= 0\npublic static int mystery(int x)\n{\n    int sum = 0;\n    while(x >= 0)\n    {\n        sum += x;\n        x--;\n    }\n    return sum;\n}\n\nWhich of the following recursive methods are equivalent to the method above?\nI. public static int mystery2(int x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    return (x + mystery2(x \u2013 1));\n}\nII. public static int mystery3 (int x)\n{\n    if (x == 0)\n        return 0;\n    else\n        return mystery3(x \u2013 1);\n}\nIII. public static int mystery4 (int x) {\n    if (x == 1)\n    {\n        return 1:\n    }\n    return (x + mystery 4(x \u2013 1));\n}\nCorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: II and III only\n\nEND"}
{"prompt": "The final flow control structure that appears on the AP Exam is called recursion. It is not represented in the free-response questions and appears at least once in the multiple-choice questions (but typically only a few times). This structure has a result similar to a loop, but approaches the task in a different manner. \nRemember those little wind-up toys you played with when you were little? You know, the plastic teeth or bunny (or whatever) with the little white knob on the side? You would wind the knob over and over, and when you let go, the little teeth would move across the table. The more you wound the knob, the longer the teeth would walk. Since the winding is the same action repeated, it can be considered a loop. The unwinding action, however, differentiates this situation from a while or for loop. When an unwinding or \u201cwinding down\u201d occurs as a result of a \u201cwinding up,\u201d recursion is lurking in the shadows. \nThe distinguishing characteristic of a recursive method is a call to the very method itself; this statement is called a recursive call. In order to prevent an infinite loop, the recursive method includes a base case, which signals execution to stop recursing and return to each prior recursive call, finishing the job for each. Let\u2019s use an easy example to illustrate this somewhat confusing topic, and then we\u2019ll spice up the example a bit afterward.\nSuppose you have a giant bag of small, multicolored, candy-coated chocolates. As a programmer, you naturally do not want to eat these candies in a haphazard manner; instead, you want to use some sort of algorithm. You decide that you will eat random candies, one at a time, until you reach your favorite color; when your favorite color is reached, you will systematically eat the same colors you ate previously, in backward order. \nFor example, if you eat red -> blue -> orange -> blue -> green, and green is your base case, you will then eat blue -> orange -> blue -> red and the recursion is complete. Pretty tough to remember, right? Well, a recursive method renders this task a cinch. In pseudocode, \neatCandy (color of current candy) \n{ \n    if (current candy color is green) \n        done eating; \n    else \n        eat more candy; \n} \n\nAlthough there is no for or while loop in the code, the recursive call to the method will exhibit a looping quality; unlike our previous loops, however, there is a forward/backward progression, as described above. \nLet\u2019s add to this task: tell the user that you\u2019re done eating once you finish. Would adding the following line after the if-else statement accomplish this task? \ndisplay I\u2019m done; \n\nThe way recursion works, the task will be accomplished, although perhaps not according to plan. When the base case is reached, execution of the current method is completed, and then the process continues all the way back to the initial recursive call. Since the \u201cI\u2019m done\u201d message is displayed after, and regardless of, the if-else, it will be displayed each time a recursive iteration completes. The result is the displaying of \u201cI\u2019m done\u201d once for every candy that you ate. Nine candies, nine \u201cI\u2019m done\u201d outputs. It works, but probably not as planned. \nAlthough it is more common to use a for loop to step through an array, it is also possible to use a recursion. For example, say you have a lineup of football players, each of whom has a numbered helmet. You want to step through the lineup and find the position of the person who has \u201c9\u201d written on his helmet.\nA recursive solution for this problem is very easy to implement. You need to look through an array of int values and find the position of a specific value, if it\u2019s there. \nFirst, we\u2019ll need to describe the problem in recursive terms. \nIf we\u2019ve looked through every item, then return \u20131. \nIf the current item in the array is a match, return its position. Or else, restart the process with the next item in the array. \n\npublic int findPosition(int nums[], int key, int currentIndex) { \n    //if we\u2019ve already looked through \n    //the entire array \n    if (nums.length <= currentIndex) \n        return -1; \n    //if the next item in the array is a match, \n    //then return it \n    if (nums[currentIndex] == key)\n        return currentIndex; \n    //else, step past the current item in the array, \n    //and repeat the search on the next item \n    return findPosition(nums, key, currentIndex + 1);\n} \n\nThis example is slightly more subtle than the others because we\u2019re carrying information from one recursive call to the next. Specifically, we\u2019re using the currentIndex field to pass information from one recursive call to another. Thus, the first recursive call starts looking at position 0, the next one at position 1, and so on. \nLet\u2019s go back to our football-player example. You want to step through a lineup of football players and return the position of the player who has the helmet with \u201c9\u201d written on it. Your code would be of the following form: \nint [] players = //represents the football players \nint pos = findPosition(players, 9, 0);\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following method:\npublic int mystery(int x, int y)\n{\n    if (x >= 100 || y <= 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return mystery(x + 10, y \u2013 3);\n    }\n}\nWhat value is returned by the call mystery (30, 18)?\nCorrect: 1\nIncorrect: 0\nIncorrect: 6\nIncorrect: 7\nIncorrect: Nothing will be returned due to infinite recursion.\n\nEND"}
{"prompt": "The final flow control structure that appears on the AP Exam is called recursion. It is not represented in the free-response questions and appears at least once in the multiple-choice questions (but typically only a few times). This structure has a result similar to a loop, but approaches the task in a different manner. \nRemember those little wind-up toys you played with when you were little? You know, the plastic teeth or bunny (or whatever) with the little white knob on the side? You would wind the knob over and over, and when you let go, the little teeth would move across the table. The more you wound the knob, the longer the teeth would walk. Since the winding is the same action repeated, it can be considered a loop. The unwinding action, however, differentiates this situation from a while or for loop. When an unwinding or \u201cwinding down\u201d occurs as a result of a \u201cwinding up,\u201d recursion is lurking in the shadows. \nThe distinguishing characteristic of a recursive method is a call to the very method itself; this statement is called a recursive call. In order to prevent an infinite loop, the recursive method includes a base case, which signals execution to stop recursing and return to each prior recursive call, finishing the job for each. Let\u2019s use an easy example to illustrate this somewhat confusing topic, and then we\u2019ll spice up the example a bit afterward.\nSuppose you have a giant bag of small, multicolored, candy-coated chocolates. As a programmer, you naturally do not want to eat these candies in a haphazard manner; instead, you want to use some sort of algorithm. You decide that you will eat random candies, one at a time, until you reach your favorite color; when your favorite color is reached, you will systematically eat the same colors you ate previously, in backward order. \nFor example, if you eat red -> blue -> orange -> blue -> green, and green is your base case, you will then eat blue -> orange -> blue -> red and the recursion is complete. Pretty tough to remember, right? Well, a recursive method renders this task a cinch. In pseudocode, \neatCandy (color of current candy) \n{ \n    if (current candy color is green) \n        done eating; \n    else \n        eat more candy; \n} \n\nAlthough there is no for or while loop in the code, the recursive call to the method will exhibit a looping quality; unlike our previous loops, however, there is a forward/backward progression, as described above. \nLet\u2019s add to this task: tell the user that you\u2019re done eating once you finish. Would adding the following line after the if-else statement accomplish this task? \ndisplay I\u2019m done; \n\nThe way recursion works, the task will be accomplished, although perhaps not according to plan. When the base case is reached, execution of the current method is completed, and then the process continues all the way back to the initial recursive call. Since the \u201cI\u2019m done\u201d message is displayed after, and regardless of, the if-else, it will be displayed each time a recursive iteration completes. The result is the displaying of \u201cI\u2019m done\u201d once for every candy that you ate. Nine candies, nine \u201cI\u2019m done\u201d outputs. It works, but probably not as planned. \nAlthough it is more common to use a for loop to step through an array, it is also possible to use a recursion. For example, say you have a lineup of football players, each of whom has a numbered helmet. You want to step through the lineup and find the position of the person who has \u201c9\u201d written on his helmet.\nA recursive solution for this problem is very easy to implement. You need to look through an array of int values and find the position of a specific value, if it\u2019s there. \nFirst, we\u2019ll need to describe the problem in recursive terms. \nIf we\u2019ve looked through every item, then return \u20131. \nIf the current item in the array is a match, return its position. Or else, restart the process with the next item in the array. \n\npublic int findPosition(int nums[], int key, int currentIndex) { \n    //if we\u2019ve already looked through \n    //the entire array \n    if (nums.length <= currentIndex) \n        return -1; \n    //if the next item in the array is a match, \n    //then return it \n    if (nums[currentIndex] == key)\n        return currentIndex; \n    //else, step past the current item in the array, \n    //and repeat the search on the next item \n    return findPosition(nums, key, currentIndex + 1);\n} \n\nThis example is slightly more subtle than the others because we\u2019re carrying information from one recursive call to the next. Specifically, we\u2019re using the currentIndex field to pass information from one recursive call to another. Thus, the first recursive call starts looking at position 0, the next one at position 1, and so on. \nLet\u2019s go back to our football-player example. You want to step through a lineup of football players and return the position of the player who has the helmet with \u201c9\u201d written on it. Your code would be of the following form: \nint [] players = //represents the football players \nint pos = findPosition(players, 9, 0);\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the following incomplete method:\npublic int mystery(int x)\n{\n    if (x <= 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return (/ * missing code * /);\n    }\n}\n\nWhich of the following could be used to replace / * missing code * / so that the value of mystery(10) is 32?\nCorrect: 2 * mystery(x \u2013 2)\nIncorrect: mystery(x \u2013 1) + mystery(x \u2013 2)\nIncorrect: 2 * mystery(x \u2013 1)\nIncorrect: 4 * mystery(x \u2013 4)\nIncorrect: 4 + mystery(x \u2013 1)END"}
{"prompt": "When a group of statements, including control structures, is assembled into a single unit, the unit is called a class. Similar to a word processing document or a picture file stored on your computer, a class is stored on your computer in a file. Unlike a word processing document, however, a class must follow specific rules in order to conform to Java and, as a result, to be understood by the compiler. Remember that your brilliantly constructed program is useless unless the compiler can successfully translate it into machine code.\nThe structure of a class, at this level anyway, is straightforward. Take all of the statements you\u2019ve written before this chapter, put curly brackets around them, kind of like a huge block, name it, and save it. The naming conventions for a class are similar to those of a variable, except that they should begin with a capital letter. The name of the class should reference the purpose or function of the class. For example, a class that calculates a GPA might be called GPA or GradePointAvg. The way we declare a class in Java is using the header:\npublic class GradePointAvg\n{\n\t// statements not shown\n}\n\nWell, Actually\u2026 This is a convention but not a rule. You can have all of the code on a single line if your heart so desires, but that would be very bad form.\nNote that the statements in the class reside at least one tab stop across the page. If the programmer would like to use more white space within the structures of the class, they will be tabbed further into the page:\npublic class GradePointAvg\n{\n\t// other code and variable declarations not shown\n\twhile (/* condition not shown */)\n\t{\n\t\t// looped statements not shown\n\t}\n}\n\nTypically, variable declarations are placed into the code first, right after the class header, as a sort of \u201csetup\u201d for the rest of the class. Of course, this is not a rule, but it is a good guideline in order to keep your code readable.\nThis class would be saved to the computer as GradePointAvg.java; the .java extension helps the compiler to recognize the file as containing Java code. If the code compiles (there are no syntax errors), the compiler will create another file in the same folder called GradePointAvg.class; this file is unreadable to the programmer because it is encoded in machine language. The computer, however, uses this file to execute the program. The .java file is called the source code of the program, since it defines the program\u2019s actions and functions.\nRemember that classes are executed top-down\u2014i.e., line 1 followed by line 2, etc. If programmers want to alter top-down execution, they must use a flow control structure, as we studied before.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Which of the following class declarations would cause a compile-time error? Assume the rest of the code compiles as intended.\nCorrect: public class 4APCalculus\nIncorrect: public class Calculus\nIncorrect: public class apCalculus\nIncorrect: public class APCalculus\nIncorrect: public class APCalculus extends Calculus\n\nEND"}
{"prompt": "Picture a Java class as a closet, with essentially limitless possibilities. If you were to declare a single shelf to hold, say, board game boxes\u2026that would be a great way to organize your collection of games, toys, and other sophisticated possessions.\nA class is organized in this way using methods.\nA method is a group of code that performs a specific task.\n\nAlthough a class can simply contain a list of commands, any program that accomplishes a task could easily balloon to 100 lines of code, or more. Instead of writing a class that contains a giant list of disorganized code, writing separate methods for each small task (within the overarching task) is an excellent way to make your code more readable. In addition, method based classes enable easier flow control.\nTo understand this concept, let\u2019s break down a bright, sunny Saturday in the middle of the summer (don\u2019t worry\u2014you will make it). Perhaps some of the activities you would do might include getting out of bed (obviously), eating breakfast, taking a shower, getting ready for the beach, driving to the beach, enjoying the beach, and eating lunch. Each of these activities has its own specific components; for example, part of eating breakfast includes drinking orange juice and taking a daily vitamin supplement. The pseudocode of a program that simulates this Saturday\u2019s activities might look like this:\npublic class Saturday1\n{\n\thear alarm;\n\tturn off alarm;\n\tget out of bed;\n\tmake breakfast;\n\teat breakfast;\u2026\n\nYou get the idea\u2026. A long list of commands that occur top-down. Now, consider each of these general activities as a separate grouping of smaller activities, called a method. Each small activity will be defined later, but your Saturday class would look much cleaner:\npublic class Saturday2\n{\n\twake up method; // includes alarm\n\teat breakfast method; // includes preparation, OJ, vitamin, etc.\n\ttake a shower method; // includes preparing for the shower, etc.\n\tbeach method; // includes prep for the beach, driving to the beach, etc.\n\teat lunch method;\n}\n\nThe result is a cleaner, more structured class that is easier to read. A class that is created to control a larger program, such as Saturday2, is called a driver class because it drives the program through its general structure which will, in turn, execute the smaller commands. Note also that if, for some reason, the programmer wanted the simulation to take a shower before eating breakfast, the two lines would be switched in Saturday2 and the job would be done. Performing the same change in Saturday1 would involve switching multiple lines of code. Even more poignant would be a simulation that repeats method calls, such as one that represents your extra hungry older brother, who eats breakfast twice. The driver would simply call the breakfast method twice (or use a loop to call it more than twice) and the job would be completed.\nAn object class is a different kind of class which houses the \u201cguts\u201d of the methods that the driver class calls. As you understand this setup, you will see that your driver classes begin to shorten, while your object classes expand. For example, the driver of a car truly performs a relatively small set of actions in order to drive the car: start the engine, buckle the seatbelt, check the mirrors, accelerate, brake, steer. The driver does not actually understand (nor does he need to) exactly how these operations work: he just does them. How does the accelerator pedal actually make the car move more quickly? Doesn\u2019t matter. The \u201cdriver\u201d just operates the pedal and the rest happens under the hood. The object class is the \u201cunder the hood\u201d class. It defines all of the aspects of an object; more specifically, it defines what the object has and what the object does.\nThe object class referred to in this section should not be confused with the Object class in the Java language which is the Parent class of all classes. The Object class is part of the Java.lang package. Every class in Java is a descendent of this class. Every class in Java inherits the methods of the Object class.\nFor the AP Exam, you must be able to write, troubleshoot, and understand object AND driver classes, as well as understand how they interact. These skills are HUGE in the free-response questions!\nBack to the breakfast example\u2026 pseudocode for the object class might look something like this:\npublic class Saturday3\n{\n\twake up(\u2026)\n\t{\n\t\thear alarm;\n\t\tturn off alarm;\n\t\tget out of bed;\n\t}\n\tbreakfast(\u2026)\n\t{\n\t\tmake breakfast;\n\t\teat breakfast;\n\t}\n\nSince our object class could be used for any day of the week, not just Saturday, BeachDay might be a more appropriate name for this class. The driver class from before, which executes a series of actions for this particular day, might be called Saturday.\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: Which of the following statements would best describe an efficient design to represent a pair of sunglasses?\nCorrect: A PairOfSunglasses class with methods that unfold, clean, and wear the objects in the class\nIncorrect: Three classes: UnfoldGlasses, CleanGlasses, and WearGlasses\nIncorrect: An UnfoldGlasses class with methods CleanGlasses and WearGlasses\nIncorrect: A PairOfSunglasses class with boolean variables unfolded, cleaned, and worn\nIncorrect: A UseSunglasses class with statements that unfold, clean, and wear the sunglasses\n\nEND"}
{"prompt": "Now that we have written classes to run a program, we must get these classes to interact correctly in order to create a functioning program. We have the driver, we have the car, now we need to put the driver into the car to eagerly drive to the AP Computer Science A Exam on exam day.\nThe driver and object classes must reside in the same folder on the computer. If you are using an interactive development environment (as opposed to command line programming), you often have to create a \u201cProject\u201d or some similar structure in the software that will hold all of the program\u2019s files in one place. Remember that the driver depends on the object class in order to compile, and the object class depends on the driver to make it actually do anything.\n\nConsider a program that will take \u201cflower\u201d objects and \u201cplant\u201d them into a garden. The flower objects might be outlined in an object class called Flower. One class will perform the planting, so we can call it MakeGarden.\nSuppose the Flower constructor method has the following header: public Flower(int xPosition, int yPosition) where xPosition and yPosition are the horizontal and vertical coordinates in the garden, respectively, where the flower object will be planted. Our driver would have to first \u201ccreate\u201d the flowers, and then plant them accordingly.\nIn order to create an object, we must instantiate the object using its corresponding class. Each time we instantiate a flower object, we must assign it an object reference variable; as the fancy name implies, this is just a variable name. Some lines in MakeGarden might look like this:\nFlower f1 = new Flower(2, 1);\nFlower f2 = new Flower(2, 2);\nFlower f3 = new Flower(2, 3);\n\nThese lines will instantiate three different flower objects, each containing its own instance data. f1, f2, and f3 are used to distinguish between the objects. We can then use these objects to perform methods. Consider a plant method in the Flower class; this method would \u201cplant\u201d the flower and might have the following header:\npublic void plant()\n\nIn MakeGarden, we must invoke this method through the objects. Let\u2019s say we want to plant only f1 and f3, but not f2. We would add the following lines:\nf1.plant();\nf3.plant();\n\nNow let\u2019s say the plant method, instead, returns whether or not the plant was successfully planted. This altered plant method might have the header:\npublic boolean plant()\n\nNow we can use the returned data to output an appropriate message in the driver:\nif (f1.plant())\n\tSystem.out.print(\"Planted successfully.\");\nelse\n\tSystem.out.print(\"There was a problem.\");\n\nBecause we are invoking f1.plant, f1 should be planted as requested. Since the plant method returns a boolean value, we can place f1.plant in the context of an if statement (it produces a truth value so it is considered a condition) and now it also functions as part of a control structure. Awesome!\nLet\u2019s add to our garden situation. As you know, other items can appear in a garden besides flowers. Plants, bushes, and weeds can appear in gardens. Each of these items would probably have its own object class, since their instance data and methods would be different from those of flowers. For example, a flower has flower petals, while a plant does not; weeds often grow on their own without water, whereas most flowers and plants do not. Regardless, separate object classes can be created for each of these object types, and the driver can hold them all together, as long as they are all stored in the same folder on the computer.\nAssuming each of these object classes has been created and each corresponding object class has a plant method as outlined above, MakeGarden might include these lines:\nFlower f1 = new Flower();\nFlower f2 = new Flower();\nPlant p1 = new Plant();\nPlant p2 = new Plant();\nWeed w1 = new Weed();\nif (f1.plant())\n\tSystem.out.println(\"Planted successfully\");\nif (f2.plant())\n\tSystem.out.println(\"Planted successfully\");\nif (p1.plant())\n\tSystem.out.println(\"Planted successfully\");\nif (w1.plant())\n\tSystem.out.println(\"You have a weed.\");\n\nNote that MakeGarden does not instantiate any Bush objects, and does not attempt to plant the p2 object. Note also that we cannot see the entire class!\nThe programmer has the task of deciding which objects to instantiate of which type, when and whether to use them, and how to use them appropriately, based on their class specifications. Still think you can go directly to the final draft?\nLet\u2019s add another layer. Programmers often recognize that an object is actually composed of many smaller, or more basic, objects. If you think about a flower, it actually has several parts, each of which has data and does particular actions. As a result, we could write object classes for, say, the stalk and the root system. The Stalk class and the RootSystem class, then, would reside as attributes of each flower. Their classes, again, must be placed in the same folder as the rest of the program\u2019s classes. The programmer can then set up the Flower class as follows:\npublic class Flower\n{\n\t// other data not shown\n\tprivate Stalk st;\n\tprivate RootSystem rootSys;\n\tpublic Flower()\n\t{\n\t\tst = new Stalk();\n\t\trootSys = new RootSystem();\n\t\t// other commands not shown\n\t}\n\t// other methods not shown\n}\nThis means that every Flower object has a stalk and a root system. The Flower class, then, is called an aggregate class because it is made up of, among other data, instances of other classes. This setup is more realistic; think of any object in your room, and you can probably see pretty quickly that it is made of smaller objects, each with its own data and methods. A laptop computer has keys, ports, and a screen, which can all be considered objects because they have stuff and do stuff. A dresser has drawers, but we can go even deeper\u2026a drawer has walls and a floor and can be opened or closed\u2026the floor of a drawer has a shape and is made of a certain material and can be broken if the drawer is overstuffed\u2026you get the idea. Luckily, as programmers, we get to decide the detail of the object classes, and the answer typically lies in the desired function of the program, as we stated before. Do you really need to know what material the floor of the drawer is made of? Most people do not, although a furniture retailer might. Again, it all depends on the application.\nThe free-response questions on the AP Exam will present some sort of context and will often tell you exactly what class(es) and/or method(s) to write, so they don\u2019t get a wild variety of solutions from test takers around the world.\nOtherwise, they could literally be forced to read thousands of completely different approaches to a given task. This fact is not good for our creativity, but it\u2019s great for scoring a 5; save your creative juices for those extra college classes you can take when you AP out of CS!\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Use class Chair and method sitOnChair to answer the following question.\npublic class Chair\n{\n    private int numberOfLegs = 4;\n    private boolean padded;\n    public Chair(boolean soft)\n    {\n        if (soft) padded = true;\n        else padded = false;\n    }\n}\npublic void sitOnChair( )\n{\n    <implementation not shown>\n}\n\nThe method sitOnChair belongs to another class and is supposed to allow the user to \u201csit\u201d on a Chair if the chair is padded. Which of the following code segments could be used to replace <implementation not shown> so that sitOnChair will work as intended?\nI. Chair c = new Chair(true);\nc.sit();\nII. Chair c = new Chair(true);\nIII. Chair c = new Chair(true);\nif (c.padded) System.out.print(\"You are sitting.\");\nCorrect: None\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and IIIEND"}
{"prompt": "Picture a Java class as a closet, with essentially limitless possibilities. If you were to declare a single shelf to hold, say, board game boxes\u2026that would be a great way to organize your collection of games, toys, and other sophisticated possessions.\nA class is organized in this way using methods.\nA method is a group of code that performs a specific task.\n\nAlthough a class can simply contain a list of commands, any program that accomplishes a task could easily balloon to 100 lines of code, or more. Instead of writing a class that contains a giant list of disorganized code, writing separate methods for each small task (within the overarching task) is an excellent way to make your code more readable. In addition, method based classes enable easier flow control.\nTo understand this concept, let\u2019s break down a bright, sunny Saturday in the middle of the summer (don\u2019t worry\u2014you will make it). Perhaps some of the activities you would do might include getting out of bed (obviously), eating breakfast, taking a shower, getting ready for the beach, driving to the beach, enjoying the beach, and eating lunch. Each of these activities has its own specific components; for example, part of eating breakfast includes drinking orange juice and taking a daily vitamin supplement. The pseudocode of a program that simulates this Saturday\u2019s activities might look like this:\npublic class Saturday1\n{\n\thear alarm;\n\tturn off alarm;\n\tget out of bed;\n\tmake breakfast;\n\teat breakfast;\u2026\n\nYou get the idea\u2026. A long list of commands that occur top-down. Now, consider each of these general activities as a separate grouping of smaller activities, called a method. Each small activity will be defined later, but your Saturday class would look much cleaner:\npublic class Saturday2\n{\n\twake up method; // includes alarm\n\teat breakfast method; // includes preparation, OJ, vitamin, etc.\n\ttake a shower method; // includes preparing for the shower, etc.\n\tbeach method; // includes prep for the beach, driving to the beach, etc.\n\teat lunch method;\n}\n\nThe result is a cleaner, more structured class that is easier to read. A class that is created to control a larger program, such as Saturday2, is called a driver class because it drives the program through its general structure which will, in turn, execute the smaller commands. Note also that if, for some reason, the programmer wanted the simulation to take a shower before eating breakfast, the two lines would be switched in Saturday2 and the job would be done. Performing the same change in Saturday1 would involve switching multiple lines of code. Even more poignant would be a simulation that repeats method calls, such as one that represents your extra hungry older brother, who eats breakfast twice. The driver would simply call the breakfast method twice (or use a loop to call it more than twice) and the job would be completed.\nAn object class is a different kind of class which houses the \u201cguts\u201d of the methods that the driver class calls. As you understand this setup, you will see that your driver classes begin to shorten, while your object classes expand. For example, the driver of a car truly performs a relatively small set of actions in order to drive the car: start the engine, buckle the seatbelt, check the mirrors, accelerate, brake, steer. The driver does not actually understand (nor does he need to) exactly how these operations work: he just does them. How does the accelerator pedal actually make the car move more quickly? Doesn\u2019t matter. The \u201cdriver\u201d just operates the pedal and the rest happens under the hood. The object class is the \u201cunder the hood\u201d class. It defines all of the aspects of an object; more specifically, it defines what the object has and what the object does.\nThe object class referred to in this section should not be confused with the Object class in the Java language which is the Parent class of all classes. The Object class is part of the Java.lang package. Every class in Java is a descendent of this class. Every class in Java inherits the methods of the Object class.\nFor the AP Exam, you must be able to write, troubleshoot, and understand object AND driver classes, as well as understand how they interact. These skills are HUGE in the free-response questions!\nBack to the breakfast example\u2026 pseudocode for the object class might look something like this:\npublic class Saturday3\n{\n\twake up(\u2026)\n\t{\n\t\thear alarm;\n\t\tturn off alarm;\n\t\tget out of bed;\n\t}\n\tbreakfast(\u2026)\n\t{\n\t\tmake breakfast;\n\t\teat breakfast;\n\t}\n\nSince our object class could be used for any day of the week, not just Saturday, BeachDay might be a more appropriate name for this class. The driver class from before, which executes a series of actions for this particular day, might be called Saturday.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Use class Chair and method sitOnChair to answer the following question.\npublic class Chair\n{\n    private int numberOfLegs = 4;\n    private boolean padded;\n    public Chair(boolean soft)\n    {\n        if (soft) padded = true;\n        else padded = false;\n    }\n}\npublic void sitOnChair( )\n{\n    <implementation not shown>\n}\n\nWhich of the following modifications, if any, would help to make the Chair class MOST useful to the sitOnChair method, based on the task attempted in Question 3?\nCorrect: Adding an accessor method that returns the value of padded\nIncorrect: Adding an accessor method that returns the value of numberOfLegs\nIncorrect: Adding a mutator method that changes the value of numberOfLegs\nIncorrect: Adding a mutator method that changes the value of padded\nIncorrect: Adding an accessor method that returns the values of both numberOfLegs and padded\n\nEND"}
{"prompt": "One more item that needs to be mentioned\u2026 do you see how each method in the object class has a \u201ctitle,\u201d or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let\u2019s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() // just do it, we\u2019ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() // closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() // opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running\u2026\"); 23 }\n24  }\n\nOUTPUT:\nApp is running\u2026\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4\u20137 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which \u201cbuilds\u201d the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,\u2026)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer\u2019s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method\u2019s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field\u2014in this case, updates hasApp to true once the \u201capp\u201d is \u201cdownloaded.\u201d As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it\u2019s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action\u2014the car starting\u2014a method would be a great way to keep the \u201ccar starting\u201d commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways\u2014for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four\u2026), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and/or numbers of parameters.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the following method:\npublic int halfRoot(int n)\n{\n    return Math.sqrt(n) / 2;\n}\n\nWhich of the following method calls would cause a run-time error?\nCorrect: None will cause a run-time error.\n\n\nIncorrect: halfRoot(\u20132)\nIncorrect: halfRoot(3)\nIncorrect: halfRoot((int)2.0)\nIncorrect: halfRoot(3.0)END"}
{"prompt": "All of this data that is passed from driver classes to object classes and vice versa creates a complicated operation that\u2019s occurring behind the scenes. Consider this example: the programmer decides to write a class that represents a vinyl record player (for music), or \u201cturntable.\u201d The driver class will then operate the turntable, turning it on and off, controlling it, and putting on/taking off the desired record. For this program, we will have three classes: Turntable and Record, which represent each of these objects, and PlayRecord, which will be the driver that relates them.\nIn theory, we would have to perform the following steps in the driver:\ncreate (instantiate) a turntable object\ncreate one or more record objects\nplace the record onto the turntable\nswitch on the turntable\n\nSome code from these classes might look like this:\npublic class Record\n{\n\t// data not shown\n\tpublic Record()\n\t// constructor code and other methods not shown\n}\n\npublic class Turntable\n{\n private Record r;\n // other data not shown\n public Turntable(Record r1)\n {\n\tr = r1;\n\t// other statements not shown\n }\n // other methods not shown\n}\n\npublic class PlayRecord\n{\n\tpublic static void play()\n\t{\n\t\tRecord rec = new Record();\n\t\tTurntable tt = new Turntable(rec);\n\t\t// other statements not shown\n\t}\n\t// other methods not shown\n}\n\nIn this example, note that Turntable is an aggregate class, since part of its instance data involves another object. More importantly for this section, note the instantiation of the Record object in the driver, the \u201cpassing\u201d of that object to the Turntable class, and the assignment r = r1. When an object is passed to another class and, as a result, received through a parameter, a reference is created to the object. Think of it this way: if you just picked up your favorite Taylor Swift record (you know you love her) and wanted to play it, you wouldn\u2019t need two copies of the album. In the same way, we don\u2019t have to create a copy of the Record object; we just need to create another reference to it in order for it to be used in the Turntable class. This is the only way the Turntable class can use this record, since it was instantiated in the driver. The record can then be used in context (in this case, assigned to the data field r) and then the reference will disappear once the constructor is over. Since the reference is not an actual copy of the object, its life is not affected.\nAnother way to think of references is to think of superheroes and their secret identities. Clark Kent was just another name for the person; he was still Superman the whole time. They were the same guy with the same superpowers, the same attributes, and the same ability to perform cool superhero actions. Therefore, \u201cClark Kent\u201d was simply a reference created to refer to the same guy.\nIt is extremely important to know that primitive data is not copied by reference; it is copied by value itself.\nWhen received as a parameter, primitive data is actually copied, while object data will simply receive a new reference to the object itself. Primitives are copied by value; objects are copied by reference.\nHere\u2019s the really confusing part\u2014or maybe not really. If a copy of a primitive data value is made, then the two copies (the original and the new one) exist exclusively. Therefore, if you change the value of one copy, the other is not affected. On the other hand, if a new reference to an object is made, then a modification of the object through the reference will be reflected by all references. Again, the superhero example: if Superman dyed his hair blond because it was all the rage, then both Clark Kent and Superman will have blond hair. They are two names that reference the same guy, so any changes will be reflected in all the references. If we suddenly decided that Superman/Clark Kent should be called \u201cBlue Guy\u201d instead of either of these two names, we are still referring to the same guy; he now has three aliases instead of two.\nThis is important for understanding object equality. Two objects are considered equivalent only if they are, in fact, the same object. In the superhero example above, Clark Kent is equal to Superman, since they are the exact same person.\nNow imagine that Superman has an identical twin brother named Duperman with alter ego Klarc Tenk. Since Duperman and Klarc Tenk are the same person, Duperman is equal to Klarc Tenk. Therefore, in Java Duperman == Klarc Tenk is true. However, even though they are identical twins, Superman and Duperman are different people. Therefore, Superman is not equal to Duperman. In Java, Superman and Duperman could be identified as identical twins using the equals method of the Object class. The equals method takes an Object parameter and returns true if and only if the two object have identical data, regardless of whether they are the same object. While the boolean statement Superman == Duperman is false, the statement Superman.equals(Duperman) is true.\nSometimes to call a method it may be necessary for the calling object to be able to refer to itself. When an object calls a method, an implicit reference is assigned to the calling object. The name of this implicit reference is this. The keyword this is a reference to the current calling object and may be used as an object variable. For example:\nthis.mySize\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Use the incomplete class declarations to answer the following question.\npublic class Number\n{\n    private int value;\n    public Number(int someNum)\n    {\n        if (someNum >= 0)\n            value = someNum;\n    }\n    public int changeVal(int newVal)\n    {\n        / * missing code * /\n    }\n    public int getValue()\n    {\n        return value;\n    }\n}\n\npublic class NumChanger\n{\n    public void change()\n    {\n        Number n1 = new Number(5);\n        Number n2 = new Number(5);\n        int sum1 = n1.getValue() + n2.getValue();\n        int oldn1Val = n1.changeValue(10);\n        n2 = n1;\n        int sum2 = n1.getValue() + n2.getValue();\n        System.out.print(sum1 + \" \" + sum2);\n    }\n    //other methods not shown\n}\n\nThe changeVal method in Number should reassign value to be the value taken as the parameter and return the original value. Which of the following code segments should be used to replace / * missing code * / so that changeVal will work as intended?\nCorrect: int oldVal = value;\nvalue = newVal;\nreturn oldVal;\n\n\nIncorrect: value = newVal;\nreturn value;\nIncorrect: value = newVal;\nreturn 5;\nIncorrect: int oldVal = value\nvalue = newVal;\nIncorrect: int oldVal = value;\nvalue = newVal;\nreturn value;END"}
{"prompt": "All of this data that is passed from driver classes to object classes and vice versa creates a complicated operation that\u2019s occurring behind the scenes. Consider this example: the programmer decides to write a class that represents a vinyl record player (for music), or \u201cturntable.\u201d The driver class will then operate the turntable, turning it on and off, controlling it, and putting on/taking off the desired record. For this program, we will have three classes: Turntable and Record, which represent each of these objects, and PlayRecord, which will be the driver that relates them.\nIn theory, we would have to perform the following steps in the driver:\ncreate (instantiate) a turntable object\ncreate one or more record objects\nplace the record onto the turntable\nswitch on the turntable\n\nSome code from these classes might look like this:\npublic class Record\n{\n\t// data not shown\n\tpublic Record()\n\t// constructor code and other methods not shown\n}\n\npublic class Turntable\n{\n private Record r;\n // other data not shown\n public Turntable(Record r1)\n {\n\tr = r1;\n\t// other statements not shown\n }\n // other methods not shown\n}\n\npublic class PlayRecord\n{\n\tpublic static void play()\n\t{\n\t\tRecord rec = new Record();\n\t\tTurntable tt = new Turntable(rec);\n\t\t// other statements not shown\n\t}\n\t// other methods not shown\n}\n\nIn this example, note that Turntable is an aggregate class, since part of its instance data involves another object. More importantly for this section, note the instantiation of the Record object in the driver, the \u201cpassing\u201d of that object to the Turntable class, and the assignment r = r1. When an object is passed to another class and, as a result, received through a parameter, a reference is created to the object. Think of it this way: if you just picked up your favorite Taylor Swift record (you know you love her) and wanted to play it, you wouldn\u2019t need two copies of the album. In the same way, we don\u2019t have to create a copy of the Record object; we just need to create another reference to it in order for it to be used in the Turntable class. This is the only way the Turntable class can use this record, since it was instantiated in the driver. The record can then be used in context (in this case, assigned to the data field r) and then the reference will disappear once the constructor is over. Since the reference is not an actual copy of the object, its life is not affected.\nAnother way to think of references is to think of superheroes and their secret identities. Clark Kent was just another name for the person; he was still Superman the whole time. They were the same guy with the same superpowers, the same attributes, and the same ability to perform cool superhero actions. Therefore, \u201cClark Kent\u201d was simply a reference created to refer to the same guy.\nIt is extremely important to know that primitive data is not copied by reference; it is copied by value itself.\nWhen received as a parameter, primitive data is actually copied, while object data will simply receive a new reference to the object itself. Primitives are copied by value; objects are copied by reference.\nHere\u2019s the really confusing part\u2014or maybe not really. If a copy of a primitive data value is made, then the two copies (the original and the new one) exist exclusively. Therefore, if you change the value of one copy, the other is not affected. On the other hand, if a new reference to an object is made, then a modification of the object through the reference will be reflected by all references. Again, the superhero example: if Superman dyed his hair blond because it was all the rage, then both Clark Kent and Superman will have blond hair. They are two names that reference the same guy, so any changes will be reflected in all the references. If we suddenly decided that Superman/Clark Kent should be called \u201cBlue Guy\u201d instead of either of these two names, we are still referring to the same guy; he now has three aliases instead of two.\nThis is important for understanding object equality. Two objects are considered equivalent only if they are, in fact, the same object. In the superhero example above, Clark Kent is equal to Superman, since they are the exact same person.\nNow imagine that Superman has an identical twin brother named Duperman with alter ego Klarc Tenk. Since Duperman and Klarc Tenk are the same person, Duperman is equal to Klarc Tenk. Therefore, in Java Duperman == Klarc Tenk is true. However, even though they are identical twins, Superman and Duperman are different people. Therefore, Superman is not equal to Duperman. In Java, Superman and Duperman could be identified as identical twins using the equals method of the Object class. The equals method takes an Object parameter and returns true if and only if the two object have identical data, regardless of whether they are the same object. While the boolean statement Superman == Duperman is false, the statement Superman.equals(Duperman) is true.\nSometimes to call a method it may be necessary for the calling object to be able to refer to itself. When an object calls a method, an implicit reference is assigned to the calling object. The name of this implicit reference is this. The keyword this is a reference to the current calling object and may be used as an object variable. For example:\nthis.mySize\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Use the incomplete class declarations to answer the following question.\npublic class Number\n{\n    private int value;\n    public Number(int someNum)\n    {\n        if (someNum >= 0)\n            value = someNum;\n    }\n    public int changeVal(int newVal)\n    {\n        / * missing code * /\n    }\n    public int getValue()\n    {\n        return value;\n    }\n}\n\npublic class NumChanger\n{\n    public void change()\n    {\n        Number n1 = new Number(5);\n        Number n2 = new Number(5);\n        int sum1 = n1.getValue() + n2.getValue();\n        int oldn1Val = n1.changeValue(10);\n        n2 = n1;\n        int sum2 = n1.getValue() + n2.getValue();\n        System.out.print(sum1 + \" \" + sum2);\n    }\n    //other methods not shown\n}\n\nWhat will be printed as a result of executing the change method? Assume changeVal in the Number class works as intended.\nCorrect: None of these\n\n\nIncorrect: 5 5\nIncorrect: 5 10\nIncorrect: 10 5\nIncorrect: 10 10END"}
{"prompt": "All of this data that is passed from driver classes to object classes and vice versa creates a complicated operation that\u2019s occurring behind the scenes. Consider this example: the programmer decides to write a class that represents a vinyl record player (for music), or \u201cturntable.\u201d The driver class will then operate the turntable, turning it on and off, controlling it, and putting on/taking off the desired record. For this program, we will have three classes: Turntable and Record, which represent each of these objects, and PlayRecord, which will be the driver that relates them.\nIn theory, we would have to perform the following steps in the driver:\ncreate (instantiate) a turntable object\ncreate one or more record objects\nplace the record onto the turntable\nswitch on the turntable\n\nSome code from these classes might look like this:\npublic class Record\n{\n\t// data not shown\n\tpublic Record()\n\t// constructor code and other methods not shown\n}\n\npublic class Turntable\n{\n private Record r;\n // other data not shown\n public Turntable(Record r1)\n {\n\tr = r1;\n\t// other statements not shown\n }\n // other methods not shown\n}\n\npublic class PlayRecord\n{\n\tpublic static void play()\n\t{\n\t\tRecord rec = new Record();\n\t\tTurntable tt = new Turntable(rec);\n\t\t// other statements not shown\n\t}\n\t// other methods not shown\n}\n\nIn this example, note that Turntable is an aggregate class, since part of its instance data involves another object. More importantly for this section, note the instantiation of the Record object in the driver, the \u201cpassing\u201d of that object to the Turntable class, and the assignment r = r1. When an object is passed to another class and, as a result, received through a parameter, a reference is created to the object. Think of it this way: if you just picked up your favorite Taylor Swift record (you know you love her) and wanted to play it, you wouldn\u2019t need two copies of the album. In the same way, we don\u2019t have to create a copy of the Record object; we just need to create another reference to it in order for it to be used in the Turntable class. This is the only way the Turntable class can use this record, since it was instantiated in the driver. The record can then be used in context (in this case, assigned to the data field r) and then the reference will disappear once the constructor is over. Since the reference is not an actual copy of the object, its life is not affected.\nAnother way to think of references is to think of superheroes and their secret identities. Clark Kent was just another name for the person; he was still Superman the whole time. They were the same guy with the same superpowers, the same attributes, and the same ability to perform cool superhero actions. Therefore, \u201cClark Kent\u201d was simply a reference created to refer to the same guy.\nIt is extremely important to know that primitive data is not copied by reference; it is copied by value itself.\nWhen received as a parameter, primitive data is actually copied, while object data will simply receive a new reference to the object itself. Primitives are copied by value; objects are copied by reference.\nHere\u2019s the really confusing part\u2014or maybe not really. If a copy of a primitive data value is made, then the two copies (the original and the new one) exist exclusively. Therefore, if you change the value of one copy, the other is not affected. On the other hand, if a new reference to an object is made, then a modification of the object through the reference will be reflected by all references. Again, the superhero example: if Superman dyed his hair blond because it was all the rage, then both Clark Kent and Superman will have blond hair. They are two names that reference the same guy, so any changes will be reflected in all the references. If we suddenly decided that Superman/Clark Kent should be called \u201cBlue Guy\u201d instead of either of these two names, we are still referring to the same guy; he now has three aliases instead of two.\nThis is important for understanding object equality. Two objects are considered equivalent only if they are, in fact, the same object. In the superhero example above, Clark Kent is equal to Superman, since they are the exact same person.\nNow imagine that Superman has an identical twin brother named Duperman with alter ego Klarc Tenk. Since Duperman and Klarc Tenk are the same person, Duperman is equal to Klarc Tenk. Therefore, in Java Duperman == Klarc Tenk is true. However, even though they are identical twins, Superman and Duperman are different people. Therefore, Superman is not equal to Duperman. In Java, Superman and Duperman could be identified as identical twins using the equals method of the Object class. The equals method takes an Object parameter and returns true if and only if the two object have identical data, regardless of whether they are the same object. While the boolean statement Superman == Duperman is false, the statement Superman.equals(Duperman) is true.\nSometimes to call a method it may be necessary for the calling object to be able to refer to itself. When an object calls a method, an implicit reference is assigned to the calling object. The name of this implicit reference is this. The keyword this is a reference to the current calling object and may be used as an object variable. For example:\nthis.mySize\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: The following method is intended to output \"Strings match.\" if the two strings contain identical data and otherwise print \"Strings do not match.\"\npublic void match(String s, String t)\n{\nif (/ * missing code * /)\n    System.out.println(\"Strings match.\");\nelse\n    System.out.println(\"Strings do not match.\");\n}\n\nWhich of the following statements could replace / * missing code * / to allow the method to work as intended?\nI. s.compareTo(t) == 0\nII. compareTo(s, t) == 0\nIII. s == t\nCorrect: I only\nIncorrect: III only\nIncorrect: I and III only\nIncorrect: II and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "The static keyword can appear in two contexts at this level. A static variable is an attribute that is shared among all instances of a class. When the value of this variable is changed, the alteration is reflected by all of the objects instantiated through that class. A classic example of a static variable is the high score list on a video game. Consider the video game Tetris. After you launch the game, you start a new game and play until you lose\u2026 then, since you are obsessed with Tetris, you start over. If each game of that you play is considered an object of the same class, a static variable might be the high score. Every time you start (or instantiate) a new game, the high score remains the same as it was when it was initially set. Once a new high score is set, every new game will reflect the new high score, rendering the old high score non-existent (or second best, etc.).\nIn an object class, a static variable is declared with the rest of the instance data at the top of the class, preceded by the keyword static. Static variables are often used for identification numbers or for counters. Consider this short program:\npublic class Box\n{\n\tprivate static int boxNumber = 0;\n\t// other data fields not shown\n\tpublic Box()\n\t{\n\t\tboxNumber++;\n\t\t// other statements not shown\n\t}\n}\n\npublic class BoxCreator\n{\n\tpublic BoxCreator()\n\t{\n\t\tBox box1 = new Box();\n\t\tBox box2 = new Box();\n\t}\n}\n\nAs each Box object is instantiated in BoxCreator, the static variable in the Box class will be updated. That way, the next time a box is created, the box number value is incremented for all box objects. The static variable is not an attribute of each individual box; rather, it is a shared value among all boxes. Contrast this setup with a non-static declaration of boxNumber; every time a box is instantiated, its boxNumber would start as 0 and then be incremented, making every box have the same boxNumber value of 1.\nIn order to show that this structure is actually working, let\u2019s create an accessor method to let the driver \u201csee,\u201d or access, the value of boxNumber. This method is necessary for this result since boxNumber has been declared private. A non-constructor method that is designed to access and/or modify a static variable is a static method and must be declared as such. To add this functionality and test it, here are our new object and driver classes:\npublic class Box\n{\n\tprivate static int boxNumber = 0;\n\t// other data fields not shown\n\tpublic Box()\n\t{\n\t\tboxNumber++;\n\t\t// other statements not shown\n\t}\n\tstatic public int getBoxNum()\n\t{\n\t\treturn boxNumber;\n\t}\n}\n\npublic class BoxCreator\n{\n\tpublic BoxCreator()\n\t{\n\t\tBox box1 = new Box();\n\t\tBox box2 = new Box();\n\t\tSystem.out.print (Box.getBoxNum() + \" boxes created so far.\");\n\t}\n}\n\nNotice the method call from BoxCreator does not use an object reference variable; rather, the class is used directly. Since static variables are shared among all instances, the programmer needs to access static methods (and therefore, static variables) through the class itself.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: A class called ComputerMouse has a static variable connector and a static method getConnector. Which of the following statements is true based on this information?\nCorrect: In order to invoke getConnector, a new ComputerMouse object does not need to be instantiated; getConnector must be called directly through the object class.\nIncorrect: In order to invoke getConnector, a new ComputerMouse object must be instantiated and then getConnector must be called through that object.\nIncorrect: Since connector is declared static, getConnector is shared among all objects in the program.\nIncorrect: Since connector is declared static, ComputerMouse objects cannot be mutated during execution.\nIncorrect: Since connector is declared static, all of the methods in ComputerMouse must also be declared static.\n\nEND"}
{"prompt": "When a group of statements, including control structures, is assembled into a single unit, the unit is called a class. Similar to a word processing document or a picture file stored on your computer, a class is stored on your computer in a file. Unlike a word processing document, however, a class must follow specific rules in order to conform to Java and, as a result, to be understood by the compiler. Remember that your brilliantly constructed program is useless unless the compiler can successfully translate it into machine code.\nThe structure of a class, at this level anyway, is straightforward. Take all of the statements you\u2019ve written before this chapter, put curly brackets around them, kind of like a huge block, name it, and save it. The naming conventions for a class are similar to those of a variable, except that they should begin with a capital letter. The name of the class should reference the purpose or function of the class. For example, a class that calculates a GPA might be called GPA or GradePointAvg. The way we declare a class in Java is using the header:\npublic class GradePointAvg\n{\n\t// statements not shown\n}\n\nWell, Actually\u2026 This is a convention but not a rule. You can have all of the code on a single line if your heart so desires, but that would be very bad form.\nNote that the statements in the class reside at least one tab stop across the page. If the programmer would like to use more white space within the structures of the class, they will be tabbed further into the page:\npublic class GradePointAvg\n{\n\t// other code and variable declarations not shown\n\twhile (/* condition not shown */)\n\t{\n\t\t// looped statements not shown\n\t}\n}\n\nTypically, variable declarations are placed into the code first, right after the class header, as a sort of \u201csetup\u201d for the rest of the class. Of course, this is not a rule, but it is a good guideline in order to keep your code readable.\nThis class would be saved to the computer as GradePointAvg.java; the .java extension helps the compiler to recognize the file as containing Java code. If the code compiles (there are no syntax errors), the compiler will create another file in the same folder called GradePointAvg.class; this file is unreadable to the programmer because it is encoded in machine language. The computer, however, uses this file to execute the program. The .java file is called the source code of the program, since it defines the program\u2019s actions and functions.\nRemember that classes are executed top-down\u2014i.e., line 1 followed by line 2, etc. If programmers want to alter top-down execution, they must use a flow control structure, as we studied before.\n\n\nThe following question asks about a hypothetical program or design choice with multiple options:\n\n###\n\n", "completion": "Question: A development team is building an online bookstore that customers can use to order books. Information about inventory and customer orders is kept in a database. Code must be developed that will store and retrieve data from the database. The development team decides to put the database code in separate classes from the rest of the program. Which of the following would be an advantage of this plan?\nI. The database access code could be reused in other applications that also need to access the database.\nII. The database access code can be tested independently. It will be possible to test the database access code before the interface is developed.\nIII. A team of programmers can be assigned to work just on the code that is used to access the database. The programmers can work independently from other programmers, such as those who develop the user interface.\nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II onlyEND"}
{"prompt": "One more item that needs to be mentioned\u2026 do you see how each method in the object class has a \u201ctitle,\u201d or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let\u2019s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() // just do it, we\u2019ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() // closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() // opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running\u2026\"); 23 }\n24  }\n\nOUTPUT:\nApp is running\u2026\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4\u20137 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which \u201cbuilds\u201d the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,\u2026)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer\u2019s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method\u2019s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field\u2014in this case, updates hasApp to true once the \u201capp\u201d is \u201cdownloaded.\u201d As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it\u2019s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action\u2014the car starting\u2014a method would be a great way to keep the \u201ccar starting\u201d commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways\u2014for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four\u2026), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and/or numbers of parameters.\n\n\nThe following question asks about general programming knowledge:\n\n###\n\n", "completion": "Question: In Java, instance fields (also known as instance variables) and methods can be designated public or private. Which of the following best characterizes the designation that should be used?\nCorrect: Instance fields should always be private so that clients can\u2019t directly access them. Methods can be either public or private.\nIncorrect: Instance fields and methods should always be public. This makes it easier for client programs to access data fields and use the methods of the class.\nIncorrect: Instance fields should be either public or private, depending on whether or not it is beneficial for client programs to access them directly. All methods should be public. A private method is useless because a client program can\u2019t access it.\nIncorrect: Keep all methods and instance fields private. This enforces encapsulation.\nIncorrect: All instance fields should be public so client programs can access them, and all methods should be private.\n\nEND"}
{"prompt": "When a group of statements, including control structures, is assembled into a single unit, the unit is called a class. Similar to a word processing document or a picture file stored on your computer, a class is stored on your computer in a file. Unlike a word processing document, however, a class must follow specific rules in order to conform to Java and, as a result, to be understood by the compiler. Remember that your brilliantly constructed program is useless unless the compiler can successfully translate it into machine code.\nThe structure of a class, at this level anyway, is straightforward. Take all of the statements you\u2019ve written before this chapter, put curly brackets around them, kind of like a huge block, name it, and save it. The naming conventions for a class are similar to those of a variable, except that they should begin with a capital letter. The name of the class should reference the purpose or function of the class. For example, a class that calculates a GPA might be called GPA or GradePointAvg. The way we declare a class in Java is using the header:\npublic class GradePointAvg\n{\n\t// statements not shown\n}\n\nWell, Actually\u2026 This is a convention but not a rule. You can have all of the code on a single line if your heart so desires, but that would be very bad form.\nNote that the statements in the class reside at least one tab stop across the page. If the programmer would like to use more white space within the structures of the class, they will be tabbed further into the page:\npublic class GradePointAvg\n{\n\t// other code and variable declarations not shown\n\twhile (/* condition not shown */)\n\t{\n\t\t// looped statements not shown\n\t}\n}\n\nTypically, variable declarations are placed into the code first, right after the class header, as a sort of \u201csetup\u201d for the rest of the class. Of course, this is not a rule, but it is a good guideline in order to keep your code readable.\nThis class would be saved to the computer as GradePointAvg.java; the .java extension helps the compiler to recognize the file as containing Java code. If the code compiles (there are no syntax errors), the compiler will create another file in the same folder called GradePointAvg.class; this file is unreadable to the programmer because it is encoded in machine language. The computer, however, uses this file to execute the program. The .java file is called the source code of the program, since it defines the program\u2019s actions and functions.\nRemember that classes are executed top-down\u2014i.e., line 1 followed by line 2, etc. If programmers want to alter top-down execution, they must use a flow control structure, as we studied before.\n\n\nThe following question asks about general programming knowledge:\n\n###\n\n", "completion": "Question: Which of the following are signs of a well-designed program?\nI. Clients know how data is stored in the class.\nII. Classes and methods can be tested independently.\nIII. The implementation of a method can be changed without changing the programs that use the method.\nCorrect: II and III\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and II\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "One more item that needs to be mentioned\u2026 do you see how each method in the object class has a \u201ctitle,\u201d or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let\u2019s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() // just do it, we\u2019ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() // closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() // opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running\u2026\"); 23 }\n24  }\n\nOUTPUT:\nApp is running\u2026\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4\u20137 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which \u201cbuilds\u201d the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,\u2026)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer\u2019s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method\u2019s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field\u2014in this case, updates hasApp to true once the \u201capp\u201d is \u201cdownloaded.\u201d As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it\u2019s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action\u2014the car starting\u2014a method would be a great way to keep the \u201ccar starting\u201d commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways\u2014for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four\u2026), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and/or numbers of parameters.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following class:\npublic class Sample\n{\n    public void writeMe(Object obj)\n    {\n        System.out.println(\"object\");\n    }\n    public void writeMe(String s)\n    {\n        System.out.println(\"string\");\n    }\n}\n\nWhat will be the result of executing the following?\nSample s = new Sample( );\nString tmp = new String(\"hi\");\ns.writeMe(tmp);\nCorrect: \"string\"\nIncorrect: Compile-time error\nIncorrect: \"hi\"\nIncorrect: \"object\"\nIncorrect: Run-time error\n\nEND"}
{"prompt": "One more item that needs to be mentioned\u2026 do you see how each method in the object class has a \u201ctitle,\u201d or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let\u2019s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() // just do it, we\u2019ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() // closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() // opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running\u2026\"); 23 }\n24  }\n\nOUTPUT:\nApp is running\u2026\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4\u20137 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which \u201cbuilds\u201d the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,\u2026)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer\u2019s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method\u2019s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field\u2014in this case, updates hasApp to true once the \u201capp\u201d is \u201cdownloaded.\u201d As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it\u2019s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action\u2014the car starting\u2014a method would be a great way to keep the \u201ccar starting\u201d commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways\u2014for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four\u2026), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and/or numbers of parameters.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following class:\npublic class Sample\n{\n    public void writeMe(Object obj)\n    {\n        System.out.println(\"object\");\n    }\n    public void writeMe(String s)\n    {\n        System.out.println(\"string\");\n    }\n}\n\nWhat will be the result of executing the following?\nSample s = new Sample( );\nObject tmp = new Object( );\ns.writeMe(tmp);\nCorrect: \"object\"\nIncorrect: Compile-time error\nIncorrect: \"string\"\nIncorrect: \"tmp\"\nIncorrect: Run-time error\n\nEND"}
{"prompt": "One more item that needs to be mentioned\u2026 do you see how each method in the object class has a \u201ctitle,\u201d or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let\u2019s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() // just do it, we\u2019ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() // closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() // opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running\u2026\"); 23 }\n24  }\n\nOUTPUT:\nApp is running\u2026\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4\u20137 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which \u201cbuilds\u201d the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,\u2026)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer\u2019s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method\u2019s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field\u2014in this case, updates hasApp to true once the \u201capp\u201d is \u201cdownloaded.\u201d As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it\u2019s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action\u2014the car starting\u2014a method would be a great way to keep the \u201ccar starting\u201d commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways\u2014for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four\u2026), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and/or numbers of parameters.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following class:\npublic class Sample\n{\n    public void writeMe(Object obj)\n    {\n        System.out.println(\"object\");\n    }\n    public void writeMe(String s)\n    {\n        System.out.println(\"string\");\n    }\n}\n\nWhat will be the result of executing the following?\nSample s = new Sample( );\nObject tmp = new String(\"hi\");\ns.writeMe(tmp);\nCorrect: \"object\"\nIncorrect: Compile-time error\nIncorrect: \"hi\"\nIncorrect: \"string\"\nIncorrect: Run-time error\n\nEND"}
{"prompt": "One more item that needs to be mentioned\u2026 do you see how each method in the object class has a \u201ctitle,\u201d or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let\u2019s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() // just do it, we\u2019ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() // closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() // opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running\u2026\"); 23 }\n24  }\n\nOUTPUT:\nApp is running\u2026\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4\u20137 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which \u201cbuilds\u201d the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,\u2026)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer\u2019s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method\u2019s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field\u2014in this case, updates hasApp to true once the \u201capp\u201d is \u201cdownloaded.\u201d As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it\u2019s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action\u2014the car starting\u2014a method would be a great way to keep the \u201ccar starting\u201d commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways\u2014for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four\u2026), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and/or numbers of parameters.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following class:\npublic class Sample\n{\n    public void writeMe(Object obj)\n    {\n        System.out.println(\"object\");\n    }\n    public void writeMe(String s)\n    {\n        System.out.println(\"string\");\n    }\n}\n\nWhat will be the result of executing the following?\nSample s = new Sample( );\nString tmp = new Object( );\ns.writeMe(tmp);\nCorrect: Compile-time error\nIncorrect: \"hi\"\nIncorrect: \"object\"\nIncorrect: \"string\"\nIncorrect: Run-time error\n\nEND"}
{"prompt": "Now that we have written classes to run a program, we must get these classes to interact correctly in order to create a functioning program. We have the driver, we have the car, now we need to put the driver into the car to eagerly drive to the AP Computer Science A Exam on exam day.\nThe driver and object classes must reside in the same folder on the computer. If you are using an interactive development environment (as opposed to command line programming), you often have to create a \u201cProject\u201d or some similar structure in the software that will hold all of the program\u2019s files in one place. Remember that the driver depends on the object class in order to compile, and the object class depends on the driver to make it actually do anything.\n\nConsider a program that will take \u201cflower\u201d objects and \u201cplant\u201d them into a garden. The flower objects might be outlined in an object class called Flower. One class will perform the planting, so we can call it MakeGarden.\nSuppose the Flower constructor method has the following header: public Flower(int xPosition, int yPosition) where xPosition and yPosition are the horizontal and vertical coordinates in the garden, respectively, where the flower object will be planted. Our driver would have to first \u201ccreate\u201d the flowers, and then plant them accordingly.\nIn order to create an object, we must instantiate the object using its corresponding class. Each time we instantiate a flower object, we must assign it an object reference variable; as the fancy name implies, this is just a variable name. Some lines in MakeGarden might look like this:\nFlower f1 = new Flower(2, 1);\nFlower f2 = new Flower(2, 2);\nFlower f3 = new Flower(2, 3);\n\nThese lines will instantiate three different flower objects, each containing its own instance data. f1, f2, and f3 are used to distinguish between the objects. We can then use these objects to perform methods. Consider a plant method in the Flower class; this method would \u201cplant\u201d the flower and might have the following header:\npublic void plant()\n\nIn MakeGarden, we must invoke this method through the objects. Let\u2019s say we want to plant only f1 and f3, but not f2. We would add the following lines:\nf1.plant();\nf3.plant();\n\nNow let\u2019s say the plant method, instead, returns whether or not the plant was successfully planted. This altered plant method might have the header:\npublic boolean plant()\n\nNow we can use the returned data to output an appropriate message in the driver:\nif (f1.plant())\n\tSystem.out.print(\"Planted successfully.\");\nelse\n\tSystem.out.print(\"There was a problem.\");\n\nBecause we are invoking f1.plant, f1 should be planted as requested. Since the plant method returns a boolean value, we can place f1.plant in the context of an if statement (it produces a truth value so it is considered a condition) and now it also functions as part of a control structure. Awesome!\nLet\u2019s add to our garden situation. As you know, other items can appear in a garden besides flowers. Plants, bushes, and weeds can appear in gardens. Each of these items would probably have its own object class, since their instance data and methods would be different from those of flowers. For example, a flower has flower petals, while a plant does not; weeds often grow on their own without water, whereas most flowers and plants do not. Regardless, separate object classes can be created for each of these object types, and the driver can hold them all together, as long as they are all stored in the same folder on the computer.\nAssuming each of these object classes has been created and each corresponding object class has a plant method as outlined above, MakeGarden might include these lines:\nFlower f1 = new Flower();\nFlower f2 = new Flower();\nPlant p1 = new Plant();\nPlant p2 = new Plant();\nWeed w1 = new Weed();\nif (f1.plant())\n\tSystem.out.println(\"Planted successfully\");\nif (f2.plant())\n\tSystem.out.println(\"Planted successfully\");\nif (p1.plant())\n\tSystem.out.println(\"Planted successfully\");\nif (w1.plant())\n\tSystem.out.println(\"You have a weed.\");\n\nNote that MakeGarden does not instantiate any Bush objects, and does not attempt to plant the p2 object. Note also that we cannot see the entire class!\nThe programmer has the task of deciding which objects to instantiate of which type, when and whether to use them, and how to use them appropriately, based on their class specifications. Still think you can go directly to the final draft?\nLet\u2019s add another layer. Programmers often recognize that an object is actually composed of many smaller, or more basic, objects. If you think about a flower, it actually has several parts, each of which has data and does particular actions. As a result, we could write object classes for, say, the stalk and the root system. The Stalk class and the RootSystem class, then, would reside as attributes of each flower. Their classes, again, must be placed in the same folder as the rest of the program\u2019s classes. The programmer can then set up the Flower class as follows:\npublic class Flower\n{\n\t// other data not shown\n\tprivate Stalk st;\n\tprivate RootSystem rootSys;\n\tpublic Flower()\n\t{\n\t\tst = new Stalk();\n\t\trootSys = new RootSystem();\n\t\t// other commands not shown\n\t}\n\t// other methods not shown\n}\nThis means that every Flower object has a stalk and a root system. The Flower class, then, is called an aggregate class because it is made up of, among other data, instances of other classes. This setup is more realistic; think of any object in your room, and you can probably see pretty quickly that it is made of smaller objects, each with its own data and methods. A laptop computer has keys, ports, and a screen, which can all be considered objects because they have stuff and do stuff. A dresser has drawers, but we can go even deeper\u2026a drawer has walls and a floor and can be opened or closed\u2026the floor of a drawer has a shape and is made of a certain material and can be broken if the drawer is overstuffed\u2026you get the idea. Luckily, as programmers, we get to decide the detail of the object classes, and the answer typically lies in the desired function of the program, as we stated before. Do you really need to know what material the floor of the drawer is made of? Most people do not, although a furniture retailer might. Again, it all depends on the application.\nThe free-response questions on the AP Exam will present some sort of context and will often tell you exactly what class(es) and/or method(s) to write, so they don\u2019t get a wild variety of solutions from test takers around the world.\nOtherwise, they could literally be forced to read thousands of completely different approaches to a given task. This fact is not good for our creativity, but it\u2019s great for scoring a 5; save your creative juices for those extra college classes you can take when you AP out of CS!\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the following class:\npublic class Sample\n{\n    int val = 0;\n}\nIs val an attribute or a method?\nCorrect: val is an attribute.\nIncorrect: Neither: a compile-time error occurs when we try to execute this code.\nIncorrect: val is a method.\nIncorrect: val is both an attribute and a method.\nIncorrect: Neither: val is a primitive.\n\nEND"}
{"prompt": "One more item that needs to be mentioned\u2026 do you see how each method in the object class has a \u201ctitle,\u201d or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let\u2019s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() // just do it, we\u2019ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() // closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() // opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running\u2026\"); 23 }\n24  }\n\nOUTPUT:\nApp is running\u2026\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4\u20137 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which \u201cbuilds\u201d the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,\u2026)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer\u2019s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method\u2019s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field\u2014in this case, updates hasApp to true once the \u201capp\u201d is \u201cdownloaded.\u201d As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it\u2019s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action\u2014the car starting\u2014a method would be a great way to keep the \u201ccar starting\u201d commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways\u2014for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four\u2026), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and/or numbers of parameters.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following class:\npublic class Sample\n{\n    public String writeMe(String s)\n    {\n        System.out.println(\"object\");\n    }\n    public void writeMe(String s)\n    {\n        System.out.println(\"string\");\n    }\n}\n\nWhat will be the result of executing the following?\nSample s = new Sample( );\nObject tmp = new Object( );\ns.writeMe(tmp);\nCorrect: Compile-time error\nIncorrect: \"hi\"\nIncorrect: \"object\"\nIncorrect: \"string\"\nIncorrect: Run-time errorEND"}
{"prompt": "There are two big limitations of the powerful array structure in Java: an array has a fixed length and it can store only one type of data. If you wanted to represent, say, a friend\u2019s collection of action figures, an array would require all of the action figures to be the same type. Generally speaking, they must all be flying superheroes, or they must all have protective body armor, etc. \nLikewise, a collection of action figures represented as an array could store only a fixed number of action figures, no more and no less. If there are extra, unused slots, they stay there, which could be problematic if you have an array of helmeted heroes and you try to remove the helmet from every element in every index of the array. Once you reach the first empty spot, there is no hero and therefore no helmet, so the directions do not make sense; in Java, the compiler will return a NullPointerException for this situation. \nAn ArrayList addresses both of these issues. An ArrayList object is dynamically sized, expanding and compressing as elements are added and removed. An ArrayList can also store multiple types of data, without limit. \nLet\u2019s use an example to understand the advantages and disadvantages of arrays versus ArrayLists. Consider your lunch bag that you take to school. If you wanted to represent your lunch bag using an array or ArrayList structure, which would be more accurate?\nNaturally, the answer to this question depends on (1) the details of the objects in the bag\u2014in this case, the types of lunch items\u2014and (2) the programmer\u2019s choice of which is more appropriate. If your lunch contains a sandwich object, a fruit object, and a drink object, the ArrayList structure might be a better choice. Furthermore, as the components of the lunch are removed, the lunch bag theoretically shrinks (or can shrink). An ArrayList seems appropriate. \nLet\u2019s consider the same lunch example, but this time, suppose the items are stored in a plastic container with compartments. Regardless of whether you have not yet eaten your lunch, you are done with your lunch, or it\u2019s currently anytime in between, the number and setup of the compartments do not change. We will discuss a workaround for \u201ctricking\u201d the array into thinking the lunch objects are all the same type. These facts and abilities render an array structure more appropriate than an ArrayList. \nTo further demonstrate the usefulness of an ArrayList structure, note that it is also possible to create a typed ArrayList, which allows only objects of the same type to be stored in the list. This structure combines useful aspects of both arrays and ArrayLists. \nIn order to instantiate an ArrayList called lunchBag that will store the various components of our lunch, we use the following line of code: \nArrayList lunchBag = new ArrayList(); \n\nNote that, unlike the syntax we use for instantiating an array, neither the type of object nor the length of the list is defined initially. \nIn order to access data from within the list, particular methods must be invoked; unlike for array structures in Java, there is not a convenient bracket notation available with lists. To return the second object, an Apple object, in the ArrayList and store it using the variable food, the line of code would be\nApple red = lunchBag.get(1); \n\nThere are several other useful methods available in the List class, and they are all mentioned in the AP Exam Quick Reference, although their functionality is (obviously) not given. These methods include add, set, remove, and size. \nIf the programmer decides it is more appropriate to keep the dynamic sizing ability of the ArrayList while fixing the type of data it can hold (as in an array), it would be instantiated as follows: \nArrayList<Apple> lunchBag = new ArrayList<Apple>(); \n\nOne of the drawbacks of using ArrayList is that only objects can be stored in an ArrayList. The primitive data types int and double cannot be stored in ArrayLists. If programmers want to store integer and double data types, they must use the Integer or Double wrapper classes. Integer and Double objects can be created using integers and doubles, respectively, as parameters. For example, \nInteger n = new Integer(5); \nDouble x = new Double(6.1); \n\nTo call the values, use the intValue() and doubleValue() methods. The following commands \nint a = n.intValue(); \nint y = x.doubleValue(); \n\nassign a = 5 and y = 6.1.\n\nAdditionally, the AP Computer Science Java Subset includes the static variables MIN_VALUE and MAX_VALUE of the Integer class. These store the minimum and maximum possible values of the integer data type.\n\nArray vs Arraylist\nAfter an array is created, it cannot be resized. --> ArrayLists will automatically resize as new elements are added.\nNo import statement is needed to use an array, unless the array holds elements that require an import statement. --> You must import java.util.ArrayList, or use the full package name whenever you use an ArrayList.\nElements are accessed using index notation (e.g., myArray[2]). --> Elements are accessed using methods of the ArrayList class (e.g., myList.get(2), myList.add(\"George\")).\nArrays can be constructed to hold either primitives or object references. --> ArrayList instances can hold only object references, not primitives. The Integer and Double wrapper classes must be used to store integer and double primitives in an ArrayList.\nEach array can be declared for only one type of element. For example, if an array is declared to hold strings, you cannot store an integer in it. --> An ArrayList can hold a heterogeneous collection of objects. For example, the following is perfectly legal (though not recommended): ArrayList list = new ArrayList(); list.add(new String(\"A String\">)); list.add(new Integer(4));\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nArrayList list = new ArrayList( );\nlist.add(\"A\");\nlist.add(\"B\");\nlist.add(0, \"C\");\nlist.add(\"D\");\nlist.set(2, \"E\");\nlist.remove(1);\nSystem.out.println(list);\n\nWhat is printed as a result of executing the code segment?\nCorrect: [C, E, D]\nIncorrect: [A, B, C, D, E]\nIncorrect: [A, B, D, E]\nIncorrect: [A, D, E]\nIncorrect: [A, C, D, E]\n\nEND"}
{"prompt": "There are two big limitations of the powerful array structure in Java: an array has a fixed length and it can store only one type of data. If you wanted to represent, say, a friend\u2019s collection of action figures, an array would require all of the action figures to be the same type. Generally speaking, they must all be flying superheroes, or they must all have protective body armor, etc. \nLikewise, a collection of action figures represented as an array could store only a fixed number of action figures, no more and no less. If there are extra, unused slots, they stay there, which could be problematic if you have an array of helmeted heroes and you try to remove the helmet from every element in every index of the array. Once you reach the first empty spot, there is no hero and therefore no helmet, so the directions do not make sense; in Java, the compiler will return a NullPointerException for this situation. \nAn ArrayList addresses both of these issues. An ArrayList object is dynamically sized, expanding and compressing as elements are added and removed. An ArrayList can also store multiple types of data, without limit. \nLet\u2019s use an example to understand the advantages and disadvantages of arrays versus ArrayLists. Consider your lunch bag that you take to school. If you wanted to represent your lunch bag using an array or ArrayList structure, which would be more accurate?\nNaturally, the answer to this question depends on (1) the details of the objects in the bag\u2014in this case, the types of lunch items\u2014and (2) the programmer\u2019s choice of which is more appropriate. If your lunch contains a sandwich object, a fruit object, and a drink object, the ArrayList structure might be a better choice. Furthermore, as the components of the lunch are removed, the lunch bag theoretically shrinks (or can shrink). An ArrayList seems appropriate. \nLet\u2019s consider the same lunch example, but this time, suppose the items are stored in a plastic container with compartments. Regardless of whether you have not yet eaten your lunch, you are done with your lunch, or it\u2019s currently anytime in between, the number and setup of the compartments do not change. We will discuss a workaround for \u201ctricking\u201d the array into thinking the lunch objects are all the same type. These facts and abilities render an array structure more appropriate than an ArrayList. \nTo further demonstrate the usefulness of an ArrayList structure, note that it is also possible to create a typed ArrayList, which allows only objects of the same type to be stored in the list. This structure combines useful aspects of both arrays and ArrayLists. \nIn order to instantiate an ArrayList called lunchBag that will store the various components of our lunch, we use the following line of code: \nArrayList lunchBag = new ArrayList(); \n\nNote that, unlike the syntax we use for instantiating an array, neither the type of object nor the length of the list is defined initially. \nIn order to access data from within the list, particular methods must be invoked; unlike for array structures in Java, there is not a convenient bracket notation available with lists. To return the second object, an Apple object, in the ArrayList and store it using the variable food, the line of code would be\nApple red = lunchBag.get(1); \n\nThere are several other useful methods available in the List class, and they are all mentioned in the AP Exam Quick Reference, although their functionality is (obviously) not given. These methods include add, set, remove, and size. \nIf the programmer decides it is more appropriate to keep the dynamic sizing ability of the ArrayList while fixing the type of data it can hold (as in an array), it would be instantiated as follows: \nArrayList<Apple> lunchBag = new ArrayList<Apple>(); \n\nOne of the drawbacks of using ArrayList is that only objects can be stored in an ArrayList. The primitive data types int and double cannot be stored in ArrayLists. If programmers want to store integer and double data types, they must use the Integer or Double wrapper classes. Integer and Double objects can be created using integers and doubles, respectively, as parameters. For example, \nInteger n = new Integer(5); \nDouble x = new Double(6.1); \n\nTo call the values, use the intValue() and doubleValue() methods. The following commands \nint a = n.intValue(); \nint y = x.doubleValue(); \n\nassign a = 5 and y = 6.1.\n\nAdditionally, the AP Computer Science Java Subset includes the static variables MIN_VALUE and MAX_VALUE of the Integer class. These store the minimum and maximum possible values of the integer data type.\n\nArray vs Arraylist\nAfter an array is created, it cannot be resized. --> ArrayLists will automatically resize as new elements are added.\nNo import statement is needed to use an array, unless the array holds elements that require an import statement. --> You must import java.util.ArrayList, or use the full package name whenever you use an ArrayList.\nElements are accessed using index notation (e.g., myArray[2]). --> Elements are accessed using methods of the ArrayList class (e.g., myList.get(2), myList.add(\"George\")).\nArrays can be constructed to hold either primitives or object references. --> ArrayList instances can hold only object references, not primitives. The Integer and Double wrapper classes must be used to store integer and double primitives in an ArrayList.\nEach array can be declared for only one type of element. For example, if an array is declared to hold strings, you cannot store an integer in it. --> An ArrayList can hold a heterogeneous collection of objects. For example, the following is perfectly legal (though not recommended): ArrayList list = new ArrayList(); list.add(new String(\"A String\">)); list.add(new Integer(4));\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following data fields and method:\nprivate ArrayList letters;\n// precondition: letters.size( ) > 0\n// letters contains String objects\npublic void letterRemover( )\n{\n    int i = 0;\n    while (i < letters.size( ))\n    {\n        if (letters.get(i).equals(\"A\"))\n            letters.remove(i);\n        i++;\n    }\n}\n\nAssume that ArrayList letters originally contains the following String values:\n[A, B, A, A, C, D, B]\n\nWhat will letters contain as a result of executing letterRemover( )?\nCorrect: [B, A, C, D, B]\nIncorrect: [A, B, A, A, C, D, B]\nIncorrect: [B, C, D, B]\nIncorrect: [A, B, A, C, D, B]\nIncorrect: [A, A, B, C, D, B, D]\n\nEND"}
{"prompt": "There are two big limitations of the powerful array structure in Java: an array has a fixed length and it can store only one type of data. If you wanted to represent, say, a friend\u2019s collection of action figures, an array would require all of the action figures to be the same type. Generally speaking, they must all be flying superheroes, or they must all have protective body armor, etc. \nLikewise, a collection of action figures represented as an array could store only a fixed number of action figures, no more and no less. If there are extra, unused slots, they stay there, which could be problematic if you have an array of helmeted heroes and you try to remove the helmet from every element in every index of the array. Once you reach the first empty spot, there is no hero and therefore no helmet, so the directions do not make sense; in Java, the compiler will return a NullPointerException for this situation. \nAn ArrayList addresses both of these issues. An ArrayList object is dynamically sized, expanding and compressing as elements are added and removed. An ArrayList can also store multiple types of data, without limit. \nLet\u2019s use an example to understand the advantages and disadvantages of arrays versus ArrayLists. Consider your lunch bag that you take to school. If you wanted to represent your lunch bag using an array or ArrayList structure, which would be more accurate?\nNaturally, the answer to this question depends on (1) the details of the objects in the bag\u2014in this case, the types of lunch items\u2014and (2) the programmer\u2019s choice of which is more appropriate. If your lunch contains a sandwich object, a fruit object, and a drink object, the ArrayList structure might be a better choice. Furthermore, as the components of the lunch are removed, the lunch bag theoretically shrinks (or can shrink). An ArrayList seems appropriate. \nLet\u2019s consider the same lunch example, but this time, suppose the items are stored in a plastic container with compartments. Regardless of whether you have not yet eaten your lunch, you are done with your lunch, or it\u2019s currently anytime in between, the number and setup of the compartments do not change. We will discuss a workaround for \u201ctricking\u201d the array into thinking the lunch objects are all the same type. These facts and abilities render an array structure more appropriate than an ArrayList. \nTo further demonstrate the usefulness of an ArrayList structure, note that it is also possible to create a typed ArrayList, which allows only objects of the same type to be stored in the list. This structure combines useful aspects of both arrays and ArrayLists. \nIn order to instantiate an ArrayList called lunchBag that will store the various components of our lunch, we use the following line of code: \nArrayList lunchBag = new ArrayList(); \n\nNote that, unlike the syntax we use for instantiating an array, neither the type of object nor the length of the list is defined initially. \nIn order to access data from within the list, particular methods must be invoked; unlike for array structures in Java, there is not a convenient bracket notation available with lists. To return the second object, an Apple object, in the ArrayList and store it using the variable food, the line of code would be\nApple red = lunchBag.get(1); \n\nThere are several other useful methods available in the List class, and they are all mentioned in the AP Exam Quick Reference, although their functionality is (obviously) not given. These methods include add, set, remove, and size. \nIf the programmer decides it is more appropriate to keep the dynamic sizing ability of the ArrayList while fixing the type of data it can hold (as in an array), it would be instantiated as follows: \nArrayList<Apple> lunchBag = new ArrayList<Apple>(); \n\nOne of the drawbacks of using ArrayList is that only objects can be stored in an ArrayList. The primitive data types int and double cannot be stored in ArrayLists. If programmers want to store integer and double data types, they must use the Integer or Double wrapper classes. Integer and Double objects can be created using integers and doubles, respectively, as parameters. For example, \nInteger n = new Integer(5); \nDouble x = new Double(6.1); \n\nTo call the values, use the intValue() and doubleValue() methods. The following commands \nint a = n.intValue(); \nint y = x.doubleValue(); \n\nassign a = 5 and y = 6.1.\n\nAdditionally, the AP Computer Science Java Subset includes the static variables MIN_VALUE and MAX_VALUE of the Integer class. These store the minimum and maximum possible values of the integer data type.\n\nArray vs Arraylist\nAfter an array is created, it cannot be resized. --> ArrayLists will automatically resize as new elements are added.\nNo import statement is needed to use an array, unless the array holds elements that require an import statement. --> You must import java.util.ArrayList, or use the full package name whenever you use an ArrayList.\nElements are accessed using index notation (e.g., myArray[2]). --> Elements are accessed using methods of the ArrayList class (e.g., myList.get(2), myList.add(\"George\")).\nArrays can be constructed to hold either primitives or object references. --> ArrayList instances can hold only object references, not primitives. The Integer and Double wrapper classes must be used to store integer and double primitives in an ArrayList.\nEach array can be declared for only one type of element. For example, if an array is declared to hold strings, you cannot store an integer in it. --> An ArrayList can hold a heterogeneous collection of objects. For example, the following is perfectly legal (though not recommended): ArrayList list = new ArrayList(); list.add(new String(\"A String\">)); list.add(new Integer(4));\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following method:\nprivate ArrayList myList;\n// precondition: myList.size( ) > 0\n// myList contains String objects\npublic void myMethod( )\n{\n    for (int i = 0; i < myList.size( ) \u2013 1; i++)  {\n        myList.remove(i);\n        System.out.print(myList.get(i) + \" \");\n    }\n}\n\nAssume that myList originally contains the following String values: [A, B, C, D, E]\nWhat will be printed when the method above executes?\nCorrect: B D\nIncorrect: A B C D E\nIncorrect: A C E\nIncorrect: B D E\nIncorrect: Nothing will be printed due to an IndexOutOfBoundsException.\n\nEND"}
{"prompt": "There are two big limitations of the powerful array structure in Java: an array has a fixed length and it can store only one type of data. If you wanted to represent, say, a friend\u2019s collection of action figures, an array would require all of the action figures to be the same type. Generally speaking, they must all be flying superheroes, or they must all have protective body armor, etc. \nLikewise, a collection of action figures represented as an array could store only a fixed number of action figures, no more and no less. If there are extra, unused slots, they stay there, which could be problematic if you have an array of helmeted heroes and you try to remove the helmet from every element in every index of the array. Once you reach the first empty spot, there is no hero and therefore no helmet, so the directions do not make sense; in Java, the compiler will return a NullPointerException for this situation. \nAn ArrayList addresses both of these issues. An ArrayList object is dynamically sized, expanding and compressing as elements are added and removed. An ArrayList can also store multiple types of data, without limit. \nLet\u2019s use an example to understand the advantages and disadvantages of arrays versus ArrayLists. Consider your lunch bag that you take to school. If you wanted to represent your lunch bag using an array or ArrayList structure, which would be more accurate?\nNaturally, the answer to this question depends on (1) the details of the objects in the bag\u2014in this case, the types of lunch items\u2014and (2) the programmer\u2019s choice of which is more appropriate. If your lunch contains a sandwich object, a fruit object, and a drink object, the ArrayList structure might be a better choice. Furthermore, as the components of the lunch are removed, the lunch bag theoretically shrinks (or can shrink). An ArrayList seems appropriate. \nLet\u2019s consider the same lunch example, but this time, suppose the items are stored in a plastic container with compartments. Regardless of whether you have not yet eaten your lunch, you are done with your lunch, or it\u2019s currently anytime in between, the number and setup of the compartments do not change. We will discuss a workaround for \u201ctricking\u201d the array into thinking the lunch objects are all the same type. These facts and abilities render an array structure more appropriate than an ArrayList. \nTo further demonstrate the usefulness of an ArrayList structure, note that it is also possible to create a typed ArrayList, which allows only objects of the same type to be stored in the list. This structure combines useful aspects of both arrays and ArrayLists. \nIn order to instantiate an ArrayList called lunchBag that will store the various components of our lunch, we use the following line of code: \nArrayList lunchBag = new ArrayList(); \n\nNote that, unlike the syntax we use for instantiating an array, neither the type of object nor the length of the list is defined initially. \nIn order to access data from within the list, particular methods must be invoked; unlike for array structures in Java, there is not a convenient bracket notation available with lists. To return the second object, an Apple object, in the ArrayList and store it using the variable food, the line of code would be\nApple red = lunchBag.get(1); \n\nThere are several other useful methods available in the List class, and they are all mentioned in the AP Exam Quick Reference, although their functionality is (obviously) not given. These methods include add, set, remove, and size. \nIf the programmer decides it is more appropriate to keep the dynamic sizing ability of the ArrayList while fixing the type of data it can hold (as in an array), it would be instantiated as follows: \nArrayList<Apple> lunchBag = new ArrayList<Apple>(); \n\nOne of the drawbacks of using ArrayList is that only objects can be stored in an ArrayList. The primitive data types int and double cannot be stored in ArrayLists. If programmers want to store integer and double data types, they must use the Integer or Double wrapper classes. Integer and Double objects can be created using integers and doubles, respectively, as parameters. For example, \nInteger n = new Integer(5); \nDouble x = new Double(6.1); \n\nTo call the values, use the intValue() and doubleValue() methods. The following commands \nint a = n.intValue(); \nint y = x.doubleValue(); \n\nassign a = 5 and y = 6.1.\n\nAdditionally, the AP Computer Science Java Subset includes the static variables MIN_VALUE and MAX_VALUE of the Integer class. These store the minimum and maximum possible values of the integer data type.\n\nArray vs Arraylist\nAfter an array is created, it cannot be resized. --> ArrayLists will automatically resize as new elements are added.\nNo import statement is needed to use an array, unless the array holds elements that require an import statement. --> You must import java.util.ArrayList, or use the full package name whenever you use an ArrayList.\nElements are accessed using index notation (e.g., myArray[2]). --> Elements are accessed using methods of the ArrayList class (e.g., myList.get(2), myList.add(\"George\")).\nArrays can be constructed to hold either primitives or object references. --> ArrayList instances can hold only object references, not primitives. The Integer and Double wrapper classes must be used to store integer and double primitives in an ArrayList.\nEach array can be declared for only one type of element. For example, if an array is declared to hold strings, you cannot store an integer in it. --> An ArrayList can hold a heterogeneous collection of objects. For example, the following is perfectly legal (though not recommended): ArrayList list = new ArrayList(); list.add(new String(\"A String\">)); list.add(new Integer(4));\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nArrayList list = new ArrayList( );\nfor (int i = 1; i <= 8; i++)\n{\n    list.add(new Integer(i));\n}\nfor (int j = 1; j < list.size( ); j++)\n{\n    list.set(j / 2, list.get(j));\n}\nSystem.out.println(list);\n\nWhat is printed as a result of executing the code segment?\nCorrect: [2, 4, 6, 8, 5, 6, 7, 8]\nIncorrect: [1, 2, 3, 4, 5, 6, 7, 8]\nIncorrect: [1, 2, 3, 4]\nIncorrect: [1, 2, 3, 4, 1, 2, 3, 4]\nIncorrect: [2, 2, 4, 4, 6, 6, 8, 8]END"}
{"prompt": "Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let\u2019s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an \u201carray of arrays,\u201d which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn\u2019t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array\u2014 just a fancy one. It\u2019s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint[][] num = new int [4][4];\nfor (int i = 0; i < num.length; i++)\n{\n    for (int k = 0; k < num.length; k++\n    {\n        num[i][k] = i * k;\n    }\n}\n\nWhat are the contents of num after the code segment has executed?\nCorrect: 0 0 0 0\n0 1 2 3\n0 2 4 6\n0 3 6 9\nIncorrect: 0 1 2 3\n1 2 3 4\n2 3 4 5\n3 4 5 6\nIncorrect: 0 3 6 9\n0 2 4 6\n0 1 2 3\n0 0 0 0\nIncorrect: 1 1 1 1\n2 2 2 2\n3 3 3 3\n4 4 4 4\nIncorrect: 0 0 0 0\n1 2 3 4\n2 4 6 8\n3 6 9 12\n\nEND"}
{"prompt": "Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let\u2019s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an \u201carray of arrays,\u201d which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn\u2019t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array\u2014 just a fancy one. It\u2019s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: The following class, Arr2d, is meant to represent a 2-dimensional array object. The constructor will initialize Arr2d using the number of rows and columns that have been passed. Choose the statement that will initialize the array in the constructor.\npublic class Arr2D {\n    private int [][] arr;\n    Arr2D (int rows, int columns)\n    {\n        /*missing code */\n    }\n}\nCorrect: arr = new String [rows][columns];\nIncorrect: int [] arr = new String [rows][columns];\nIncorrect: int [][] arr = new String [rows - 1][columns - 1];\nIncorrect: arr = new String [rows - 1][columns - 1];\nIncorrect: int arr [][] = new String [rows][columns];\n\nEND"}
{"prompt": "Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let\u2019s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an \u201carray of arrays,\u201d which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn\u2019t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array\u2014 just a fancy one. It\u2019s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint [][] numbers = {{1, 2, 3, 4}, {5, 6, 7, 8}};\nfor (int [] nums : numbers)\n    for (int n : nums)\n        System.out.print(n + \" \");\nSystem.out.print(\"\\n\");\n\nWhat is printed as a result of executing the code segment?\nCorrect: 1 2 3 4 5 6 7 8\nIncorrect: 1 2 3 4\n5 6 7 8\nIncorrect: 1 2\n3 4\n5 6\n7 8\nIncorrect: 5 6 7 8\n1 2 3 4\nIncorrect: A compiler error would occur.\n\nEND"}
{"prompt": "Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let\u2019s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an \u201carray of arrays,\u201d which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn\u2019t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array\u2014 just a fancy one. It\u2019s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint[][] numbers = new int [4][4];\ninitializeIt(numbers);\nint total = 0;\nfor (int z = 0; z < numbers.length; z++)\n{\n    total += numbers[z][numbers [0].length \u2013 1 \u2013 z];\n}\n\nThe call to initializeIt() on the second line initializes the array numbers so that it looks like the following:\n1 2 5 3\n7 9 4 0\n3 3 2 5\n4 5 8 1\n\nWhat will be the value of total after the code has executed?\nCorrect: 14\nIncorrect: 11\nIncorrect: 12\nIncorrect: 13\nIncorrect: 15\n\nEND"}
{"prompt": "Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let\u2019s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an \u201carray of arrays,\u201d which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn\u2019t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array\u2014 just a fancy one. It\u2019s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint[][] numbers = new int[3][6];\ninitializeIt(numbers);\nint total = 0;\nfor (int j = 0; j < numbers.length; j++)\n{\n    for (int k = 0; k < numbers[0].length; k += 2)  {\n        total+= numbers[j][k];\n    }\n}\n\nThe call to initializeIt() on the second line initializes the array numbers so that it looks like the following:\n2 4 6 3 2 1\n5 6 7 4 2 9\n4 0 5 6 4 2\n\nWhat will be the value of total after the code has executed?\nCorrect: 37\nIncorrect: 18\nIncorrect: 35\nIncorrect: 72\nIncorrect: 101\n\nEND"}
{"prompt": "Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let\u2019s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an \u201carray of arrays,\u201d which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn\u2019t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array\u2014 just a fancy one. It\u2019s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint[][] num = new int[4][4];\nfor (int i = 0; i < num.length; i++)\n{\n    for (int k = 0; k < num[0].length; k++)\n    {\n        num[i][k] = i * k;\n    }\n}\n\nWhat are the contents of num after the code segment has executed?\nCorrect: 0 0 0 0\n0 1 2 3\n0 2 4 6\n0 3 6 9\nIncorrect: 0 1 2 3\n1 2 3 4\n2 3 4 5\n3 4 5 6\nIncorrect: 0 3 6 9\n0 2 4 6\n0 1 2 3\n0 0 0 0\nIncorrect: 1 1 1 1\n2 2 2 2\n3 3 3 3\n4 4 4 4\nIncorrect: 0 0 0 0\n1 2 3 4\n2 4 6 8\n3 6 9 12\n\nEND"}
{"prompt": "Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let\u2019s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an \u201carray of arrays,\u201d which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn\u2019t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array\u2014 just a fancy one. It\u2019s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint [][] numbers = {{1, 2, 3, 4},{5, 6, 7, 8}}; initializeIt(numbers);\nString line =\u201d\u201d;\nfor (int a = 0; a < numbers[0].length; a++)\n{\n    for (int b = 0; b < numbers.length; b++)\n    {\n        line += numbers[b][a] + \u201c \u201c;\n    }\n    line += \u201c\\n\u201d;\n}\nSystem.out.println(line);\n\nThe call to initializeIt() on the second line initializes the array so that it looks like the following:\n1 2 3 4\n5 6 7 8\n\nWhat will be printed after the code has executed?\nCorrect: 1 5\n2 6\n3 4\n4 8\n\n\nIncorrect: 1 2 3 4\n5 6 7 8\nIncorrect: 5 6 7 8\n1 2 3 4\nIncorrect: 8 7 6 5\n4 3 2 1\nIncorrect: 1 2\n3 4\n5 6\n7 8END"}
{"prompt": "Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let\u2019s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an \u201carray of arrays,\u201d which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn\u2019t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array\u2014 just a fancy one. It\u2019s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following client code and method:\nint [][] numbers = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\nint [] myArr = mystery(numbers, 2);\nfor (int j: myArr)\n    System.out.print(j + \" \");\n\npublic static int [] mystery(int [][] arr, int n) {\n    int [] m = new int[arr.length];\n    for (int i = 0; i < arr.length; i++)\n        m[i] = arr[i][n];\n    return m;\n}\n\nWhat will be printed after the code executes?\nCorrect: 3 7 11\n\n\nIncorrect: 5 6 7 8\nIncorrect: 2 6 10\nIncorrect: 9 10 11 12\nIncorrect: 4 8 12END"}
{"prompt": "Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let\u2019s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an \u201carray of arrays,\u201d which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn\u2019t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array\u2014 just a fancy one. It\u2019s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code:\nint [][] numbers = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\nfor (int r = numbers.length - 1; r > 0 ; r--)  {\n    for (int c = 0; c < numbers[r].length; c++)\n    {\n        numbers[r - 1][c] = numbers[r][c];\n    }\n}\n\nWhich of the following represents the current values in the array?\nCorrect: 9 10 11 12\n9 10 11 12\n9 10 11 12\nIncorrect: 1 2 3 4\n5 6 7 8\n9 10 11 12\nIncorrect: 9 10 11 12\n5 6 7 8\n1 2 3 4\nIncorrect: 1 2 3 4\n1 2 3 4\n1 2 3 4\nIncorrect: 12 11 10 9\n8 7 6 5\n4 3 2 1END"}
{"prompt": "Consider a situation in which you need a study break and decide to visit your local bakery for a snack. Your favorite dessert is typically Italian cannoli but you will also accept an apple turnover. But apple turnovers are somewhat dry, so you will buy one only if they are selling coffee that day.\nSince this example is relatively complicated, let\u2019s break it into chunks. We will use pseudocode for this example.\nLet\u2019s outline the conditions presented in this example, in order:\n    The bakery has cannoli.\n    The bakery has apple turnovers.\n    The bakery has coffee.\n\nThe complication here is that some of these decisions depend on others. For example, if the bakery DOES have cannoli, then it doesn\u2019t matter whether it has apple turnovers. Again, step by step: start with condition (1)\nif (bakery has cannoli) buy dessert;\n\nNow, another decision must be made, based on this decision; if the bakery DOES have cannoli, we get our desired dessert. If it does NOT have cannoli, we must try the apple turnover.\nif (bakery has cannoli)\n    buy dessert; // occurs only if bakery has cannoli\nelse if (bakery has apple turnovers) // occurs only if bakery has no cannoli\n    buy dessert; // occurs only if bakery has apple turnovers\n\nNote the else keyword used here. else is used if the programmer wants a statement to execute if the condition is false.\nIt\u2019s not that easy, though\u2026we must consider the coffee. Since you will buy an apple turnover only if there is ALSO coffee for sale, the && operator is appropriate here:\n1 if (bakery has cannoli)\n2 buy dessert; // bakery has cannoli\n3 else if (bakery has apple turnovers && bakery has coffee) // no cannoli\n4 buy dessert; // bakery has apple turnovers AND coffee\n\nThis pseudocode seems to work, but we must check for logical errors.\nUsing the numbered lines of pseudocode, let\u2019s trace the possibilities using a trace table.\nhas cannoli: line 1, condition is true -> line 2, buy dessert\nno cannoli, no turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, no turnovers, yes coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, yes coffee: line 1, false -> line 3, true -> line 4, buy dessert\n\nMoral of the story: This bakery had better get itself together.\n\nThere is a lot of pseudocode here! Controlling the flow of a program can be difficult and confusing, which is why it is a popular topic on the AP Exam. But it is also important because most programs, like most things we do in life, rely on conditions and react accordingly.\nIf we look at the bakery example one more time, the line\nbuy dessert;\n\noccurs twice. Good programming style attempts to repeat the same lines of code as little as possible, if ever. Therefore, we can rearrange the boolean operators in the following way, creating the same result:\nif (bakery has cannoli OR (bakery has apple turnovers AND bakery has coffee))\n    buy dessert;\n\nThat is a hefty boolean condition; however, it (1) eliminates the repetition of code and (2) provides a more \u201celegant\u201d programming solution. \u201cElegant\u201d is a relative term, of course, but the AP Exam often uses this subjective term to write code and to confuse you. Either way, you should be familiar with both ways.\nThe AP Exam free-response questions do not require you to write code with \u201celegance\u201d; in the free-response questions they will accept any code solution as long as it fulfills the specifications of the question.\nTo make things more complicated (or more life-like), consider a further idea. What if we want to execute several commands when a condition is true (or false) instead of just one? For example, using the bakery case, let\u2019s say that buying cannoli is so exciting that we must devour it right away. In other words, if the conditions are met for the bakery having cannoli, we want to buy it AND eat it. The pseudocode would look something like:\n1 if (bakery has cannoli)\n2 {\n3   buy dessert; // bakery has cannoli\n4   eat dessert;\n5 }\n6 else if (bakery has apple turnovers && bakery has coffee) // no cannoli\n7   buy dessert; // bakery has apple turnovers AND coffee\n\nThe { and } symbols in lines 2 and 5 indicate blocking, a technique used in flow control statements that allows the programmer to execute a series of commands (instead of just one) when a given condition is satisfied.\n\nHere is a summary for evaluating boolean expressions:\nAn && (and) expression is true if BOTH A and B are true. An || (or) expression is true if EITHER A or B is true, or if they are both true.\nThe ! (not) operator simply reverses the truth value of the variable.\nThe truth value of an expression is often abbreviated to a single letter. Thus, A may represent an expression such as x >= 0. The expression will either be true or false depending on the value of x, but for simplicity\u2019s sake we just refer to the whole expression as A.\nConsider the following three expressions:\nTo evaluate A && B\nFirst evaluate A. If A is false then stop: the whole expression is false. Since false && anything is false, there is no need to continue after the first false has been evaluated. This idea is called short-circuit evaluation. This idea is used (and tested) frequently. However, if A is true, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate A || B\nFirst evaluate A. If A is true then stop: the whole expression is true. Since true || anything is true, there is no need to continue after the first true has been evaluated. This is short-circuit evaluation again. However, if A is false, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate !A\nFirst evaluate A. If A is true, the whole expression is false. If A is false, the whole expression is true.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the following code.\nint x = 0;\nif (x == 0)\n    System.out.print(\u201c1\u201d);\nelse\n    System.out.print(\u201c2\u201d);\n    System.out.print(\u201c3\u201d);\n\nWhich of the following best describes the result of executing the code segment?\nCorrect: Since the value of x is 0, the first print statement will be performed, producing 13 as the output.\nIncorrect: Since the value of x is 0, the first print statement will be performed, producing 1 as the output.\nIncorrect: Since the value of x is 0, the first print statement will be performed, producing 123 as the output.\nIncorrect: == is not the correct boolean operator, so a syntax error will be produced by the compiler prior to execution.\nIncorrect: == is not the correct boolean operator, so a logical error will be produced by the compiler prior to execution.\n\nEND"}
{"prompt": "Consider a situation in which you need a study break and decide to visit your local bakery for a snack. Your favorite dessert is typically Italian cannoli but you will also accept an apple turnover. But apple turnovers are somewhat dry, so you will buy one only if they are selling coffee that day.\nSince this example is relatively complicated, let\u2019s break it into chunks. We will use pseudocode for this example.\nLet\u2019s outline the conditions presented in this example, in order:\n    The bakery has cannoli.\n    The bakery has apple turnovers.\n    The bakery has coffee.\n\nThe complication here is that some of these decisions depend on others. For example, if the bakery DOES have cannoli, then it doesn\u2019t matter whether it has apple turnovers. Again, step by step: start with condition (1)\nif (bakery has cannoli) buy dessert;\n\nNow, another decision must be made, based on this decision; if the bakery DOES have cannoli, we get our desired dessert. If it does NOT have cannoli, we must try the apple turnover.\nif (bakery has cannoli)\n    buy dessert; // occurs only if bakery has cannoli\nelse if (bakery has apple turnovers) // occurs only if bakery has no cannoli\n    buy dessert; // occurs only if bakery has apple turnovers\n\nNote the else keyword used here. else is used if the programmer wants a statement to execute if the condition is false.\nIt\u2019s not that easy, though\u2026we must consider the coffee. Since you will buy an apple turnover only if there is ALSO coffee for sale, the && operator is appropriate here:\n1 if (bakery has cannoli)\n2 buy dessert; // bakery has cannoli\n3 else if (bakery has apple turnovers && bakery has coffee) // no cannoli\n4 buy dessert; // bakery has apple turnovers AND coffee\n\nThis pseudocode seems to work, but we must check for logical errors.\nUsing the numbered lines of pseudocode, let\u2019s trace the possibilities using a trace table.\nhas cannoli: line 1, condition is true -> line 2, buy dessert\nno cannoli, no turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, no turnovers, yes coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, yes coffee: line 1, false -> line 3, true -> line 4, buy dessert\n\nMoral of the story: This bakery had better get itself together.\n\nThere is a lot of pseudocode here! Controlling the flow of a program can be difficult and confusing, which is why it is a popular topic on the AP Exam. But it is also important because most programs, like most things we do in life, rely on conditions and react accordingly.\nIf we look at the bakery example one more time, the line\nbuy dessert;\n\noccurs twice. Good programming style attempts to repeat the same lines of code as little as possible, if ever. Therefore, we can rearrange the boolean operators in the following way, creating the same result:\nif (bakery has cannoli OR (bakery has apple turnovers AND bakery has coffee))\n    buy dessert;\n\nThat is a hefty boolean condition; however, it (1) eliminates the repetition of code and (2) provides a more \u201celegant\u201d programming solution. \u201cElegant\u201d is a relative term, of course, but the AP Exam often uses this subjective term to write code and to confuse you. Either way, you should be familiar with both ways.\nThe AP Exam free-response questions do not require you to write code with \u201celegance\u201d; in the free-response questions they will accept any code solution as long as it fulfills the specifications of the question.\nTo make things more complicated (or more life-like), consider a further idea. What if we want to execute several commands when a condition is true (or false) instead of just one? For example, using the bakery case, let\u2019s say that buying cannoli is so exciting that we must devour it right away. In other words, if the conditions are met for the bakery having cannoli, we want to buy it AND eat it. The pseudocode would look something like:\n1 if (bakery has cannoli)\n2 {\n3   buy dessert; // bakery has cannoli\n4   eat dessert;\n5 }\n6 else if (bakery has apple turnovers && bakery has coffee) // no cannoli\n7   buy dessert; // bakery has apple turnovers AND coffee\n\nThe { and } symbols in lines 2 and 5 indicate blocking, a technique used in flow control statements that allows the programmer to execute a series of commands (instead of just one) when a given condition is satisfied.\n\nHere is a summary for evaluating boolean expressions:\nAn && (and) expression is true if BOTH A and B are true. An || (or) expression is true if EITHER A or B is true, or if they are both true.\nThe ! (not) operator simply reverses the truth value of the variable.\nThe truth value of an expression is often abbreviated to a single letter. Thus, A may represent an expression such as x >= 0. The expression will either be true or false depending on the value of x, but for simplicity\u2019s sake we just refer to the whole expression as A.\nConsider the following three expressions:\nTo evaluate A && B\nFirst evaluate A. If A is false then stop: the whole expression is false. Since false && anything is false, there is no need to continue after the first false has been evaluated. This idea is called short-circuit evaluation. This idea is used (and tested) frequently. However, if A is true, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate A || B\nFirst evaluate A. If A is true then stop: the whole expression is true. Since true || anything is true, there is no need to continue after the first true has been evaluated. This is short-circuit evaluation again. However, if A is false, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate !A\nFirst evaluate A. If A is true, the whole expression is false. If A is false, the whole expression is true.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the following boolean expression.\n(X && !Y) || (!X && Y)\n\nWhich of the following condition(s) will always cause the expression to evaluate to true?\nCorrect: X and Y have opposite truth values\n\n\nIncorrect: X is true\nIncorrect: Y is false\nIncorrect: X and Y are both true\nIncorrect: X and Y have the same truth valuesEND"}
{"prompt": "Consider a situation in which you need a study break and decide to visit your local bakery for a snack. Your favorite dessert is typically Italian cannoli but you will also accept an apple turnover. But apple turnovers are somewhat dry, so you will buy one only if they are selling coffee that day.\nSince this example is relatively complicated, let\u2019s break it into chunks. We will use pseudocode for this example.\nLet\u2019s outline the conditions presented in this example, in order:\n    The bakery has cannoli.\n    The bakery has apple turnovers.\n    The bakery has coffee.\n\nThe complication here is that some of these decisions depend on others. For example, if the bakery DOES have cannoli, then it doesn\u2019t matter whether it has apple turnovers. Again, step by step: start with condition (1)\nif (bakery has cannoli) buy dessert;\n\nNow, another decision must be made, based on this decision; if the bakery DOES have cannoli, we get our desired dessert. If it does NOT have cannoli, we must try the apple turnover.\nif (bakery has cannoli)\n    buy dessert; // occurs only if bakery has cannoli\nelse if (bakery has apple turnovers) // occurs only if bakery has no cannoli\n    buy dessert; // occurs only if bakery has apple turnovers\n\nNote the else keyword used here. else is used if the programmer wants a statement to execute if the condition is false.\nIt\u2019s not that easy, though\u2026we must consider the coffee. Since you will buy an apple turnover only if there is ALSO coffee for sale, the && operator is appropriate here:\n1 if (bakery has cannoli)\n2 buy dessert; // bakery has cannoli\n3 else if (bakery has apple turnovers && bakery has coffee) // no cannoli\n4 buy dessert; // bakery has apple turnovers AND coffee\n\nThis pseudocode seems to work, but we must check for logical errors.\nUsing the numbered lines of pseudocode, let\u2019s trace the possibilities using a trace table.\nhas cannoli: line 1, condition is true -> line 2, buy dessert\nno cannoli, no turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, no turnovers, yes coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, yes coffee: line 1, false -> line 3, true -> line 4, buy dessert\n\nMoral of the story: This bakery had better get itself together.\n\nThere is a lot of pseudocode here! Controlling the flow of a program can be difficult and confusing, which is why it is a popular topic on the AP Exam. But it is also important because most programs, like most things we do in life, rely on conditions and react accordingly.\nIf we look at the bakery example one more time, the line\nbuy dessert;\n\noccurs twice. Good programming style attempts to repeat the same lines of code as little as possible, if ever. Therefore, we can rearrange the boolean operators in the following way, creating the same result:\nif (bakery has cannoli OR (bakery has apple turnovers AND bakery has coffee))\n    buy dessert;\n\nThat is a hefty boolean condition; however, it (1) eliminates the repetition of code and (2) provides a more \u201celegant\u201d programming solution. \u201cElegant\u201d is a relative term, of course, but the AP Exam often uses this subjective term to write code and to confuse you. Either way, you should be familiar with both ways.\nThe AP Exam free-response questions do not require you to write code with \u201celegance\u201d; in the free-response questions they will accept any code solution as long as it fulfills the specifications of the question.\nTo make things more complicated (or more life-like), consider a further idea. What if we want to execute several commands when a condition is true (or false) instead of just one? For example, using the bakery case, let\u2019s say that buying cannoli is so exciting that we must devour it right away. In other words, if the conditions are met for the bakery having cannoli, we want to buy it AND eat it. The pseudocode would look something like:\n1 if (bakery has cannoli)\n2 {\n3   buy dessert; // bakery has cannoli\n4   eat dessert;\n5 }\n6 else if (bakery has apple turnovers && bakery has coffee) // no cannoli\n7   buy dessert; // bakery has apple turnovers AND coffee\n\nThe { and } symbols in lines 2 and 5 indicate blocking, a technique used in flow control statements that allows the programmer to execute a series of commands (instead of just one) when a given condition is satisfied.\n\nHere is a summary for evaluating boolean expressions:\nAn && (and) expression is true if BOTH A and B are true. An || (or) expression is true if EITHER A or B is true, or if they are both true.\nThe ! (not) operator simply reverses the truth value of the variable.\nThe truth value of an expression is often abbreviated to a single letter. Thus, A may represent an expression such as x >= 0. The expression will either be true or false depending on the value of x, but for simplicity\u2019s sake we just refer to the whole expression as A.\nConsider the following three expressions:\nTo evaluate A && B\nFirst evaluate A. If A is false then stop: the whole expression is false. Since false && anything is false, there is no need to continue after the first false has been evaluated. This idea is called short-circuit evaluation. This idea is used (and tested) frequently. However, if A is true, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate A || B\nFirst evaluate A. If A is true then stop: the whole expression is true. Since true || anything is true, there is no need to continue after the first true has been evaluated. This is short-circuit evaluation again. However, if A is false, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate !A\nFirst evaluate A. If A is true, the whole expression is false. If A is false, the whole expression is true.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the following code segment.\nboolean a = true, b = false;\nif (/ * missing code * /)\n    System.out.print(\"Nice job.\");\nelse\n    System.out.print(\"Nicer job.\");\n\nWhich of the following could be used to replace / * missing code * / so that the output of this block of code is \u201cNicer job.\u201d?\nI. a && !b\nII. !a || b\nIII. !a && b\nCorrect: II and III only\nIncorrect: I only\nIncorrect: I and II only\nIncorrect: I and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "Consider a situation in which you need a study break and decide to visit your local bakery for a snack. Your favorite dessert is typically Italian cannoli but you will also accept an apple turnover. But apple turnovers are somewhat dry, so you will buy one only if they are selling coffee that day.\nSince this example is relatively complicated, let\u2019s break it into chunks. We will use pseudocode for this example.\nLet\u2019s outline the conditions presented in this example, in order:\n    The bakery has cannoli.\n    The bakery has apple turnovers.\n    The bakery has coffee.\n\nThe complication here is that some of these decisions depend on others. For example, if the bakery DOES have cannoli, then it doesn\u2019t matter whether it has apple turnovers. Again, step by step: start with condition (1)\nif (bakery has cannoli) buy dessert;\n\nNow, another decision must be made, based on this decision; if the bakery DOES have cannoli, we get our desired dessert. If it does NOT have cannoli, we must try the apple turnover.\nif (bakery has cannoli)\n    buy dessert; // occurs only if bakery has cannoli\nelse if (bakery has apple turnovers) // occurs only if bakery has no cannoli\n    buy dessert; // occurs only if bakery has apple turnovers\n\nNote the else keyword used here. else is used if the programmer wants a statement to execute if the condition is false.\nIt\u2019s not that easy, though\u2026we must consider the coffee. Since you will buy an apple turnover only if there is ALSO coffee for sale, the && operator is appropriate here:\n1 if (bakery has cannoli)\n2 buy dessert; // bakery has cannoli\n3 else if (bakery has apple turnovers && bakery has coffee) // no cannoli\n4 buy dessert; // bakery has apple turnovers AND coffee\n\nThis pseudocode seems to work, but we must check for logical errors.\nUsing the numbered lines of pseudocode, let\u2019s trace the possibilities using a trace table.\nhas cannoli: line 1, condition is true -> line 2, buy dessert\nno cannoli, no turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, no turnovers, yes coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, yes coffee: line 1, false -> line 3, true -> line 4, buy dessert\n\nMoral of the story: This bakery had better get itself together.\n\nThere is a lot of pseudocode here! Controlling the flow of a program can be difficult and confusing, which is why it is a popular topic on the AP Exam. But it is also important because most programs, like most things we do in life, rely on conditions and react accordingly.\nIf we look at the bakery example one more time, the line\nbuy dessert;\n\noccurs twice. Good programming style attempts to repeat the same lines of code as little as possible, if ever. Therefore, we can rearrange the boolean operators in the following way, creating the same result:\nif (bakery has cannoli OR (bakery has apple turnovers AND bakery has coffee))\n    buy dessert;\n\nThat is a hefty boolean condition; however, it (1) eliminates the repetition of code and (2) provides a more \u201celegant\u201d programming solution. \u201cElegant\u201d is a relative term, of course, but the AP Exam often uses this subjective term to write code and to confuse you. Either way, you should be familiar with both ways.\nThe AP Exam free-response questions do not require you to write code with \u201celegance\u201d; in the free-response questions they will accept any code solution as long as it fulfills the specifications of the question.\nTo make things more complicated (or more life-like), consider a further idea. What if we want to execute several commands when a condition is true (or false) instead of just one? For example, using the bakery case, let\u2019s say that buying cannoli is so exciting that we must devour it right away. In other words, if the conditions are met for the bakery having cannoli, we want to buy it AND eat it. The pseudocode would look something like:\n1 if (bakery has cannoli)\n2 {\n3   buy dessert; // bakery has cannoli\n4   eat dessert;\n5 }\n6 else if (bakery has apple turnovers && bakery has coffee) // no cannoli\n7   buy dessert; // bakery has apple turnovers AND coffee\n\nThe { and } symbols in lines 2 and 5 indicate blocking, a technique used in flow control statements that allows the programmer to execute a series of commands (instead of just one) when a given condition is satisfied.\n\nHere is a summary for evaluating boolean expressions:\nAn && (and) expression is true if BOTH A and B are true. An || (or) expression is true if EITHER A or B is true, or if they are both true.\nThe ! (not) operator simply reverses the truth value of the variable.\nThe truth value of an expression is often abbreviated to a single letter. Thus, A may represent an expression such as x >= 0. The expression will either be true or false depending on the value of x, but for simplicity\u2019s sake we just refer to the whole expression as A.\nConsider the following three expressions:\nTo evaluate A && B\nFirst evaluate A. If A is false then stop: the whole expression is false. Since false && anything is false, there is no need to continue after the first false has been evaluated. This idea is called short-circuit evaluation. This idea is used (and tested) frequently. However, if A is true, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate A || B\nFirst evaluate A. If A is true then stop: the whole expression is true. Since true || anything is true, there is no need to continue after the first true has been evaluated. This is short-circuit evaluation again. However, if A is false, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate !A\nFirst evaluate A. If A is true, the whole expression is false. If A is false, the whole expression is true.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Suppose p and q are declared as boolean variables and have been initialized to unknown truth values.\nWhat does the following boolean expression evaluate to?\n(!p && !q) || !(p || q)\nCorrect: The expression evaluates to false whenever p and q have opposite truth values.\n\n\nIncorrect: The expression always evaluates to true.\nIncorrect: The expression always evaluates to false.\nIncorrect: The expression evaluates to true whenever p is false.\nIncorrect: The expression evaluates to true whenever q is false.END"}
{"prompt": "Now that we have some tools to make the computer accomplish a simple task, let\u2019s discuss how to make our programs a little more\u2026interesting.\nWhen you wake up in the morning, some tasks occur automatically, while others may depend on a decision. For example, if your alarm clock sounds at 6:00 a.m.\u2026wait, what if it doesn\u2019t? If it sounds at 6:00 a.m., you proceed with your morning rituals; if it does not sound, you wake up late and have to speed up, or change, your routine. When you sit down to eat your favorite breakfast cereal\u2026none is left! Now what?\nMost, if not all, of the actions we perform depend on decisions. These decisions affect whether or not we perform the actions, or even how we perform the actions. Programs possess this exact ability to make decisions and react accordingly. In this way, the programmer can control the flow of the program.\nIf you read the above examples closely, you will literally find the word if as a pivotal word in your decisions of what actions to perform next. The reserved word if is a conditional statement used in Java when programmers want to control the flow of the programs\u2014e.g., if they want Line 2 to occur ONLY if a condition in Line 1 is true. This is referred to as flow control.\nThe syntax of a simple if statement is\nif (condition) statement;\n\nSyntax statements in this book will be presented in pseudocode in order to illustrate the general form, and then further examples will be given. Pseudocode is not Java code that will compile, but it shows the format of the Java statements that we will write later.\nConsider an instance when you are asking a parent whether you can go out to the mall with a friend on Friday night. The (classic) parent response usually looks something like this: If you clean your room, you can go to the mall on Friday.\nIn pseudocode, the parent\u2019s response could be written as\nif (you clean your room) go to the mall;\n\nIn this example, \u201cyou clean your room\u201d is the condition of the if statement and \u201cgo to the mall\u201d is the statement. The condition in an if statement must have a boolean result. Note that if you do clean your room (true), you will go to the mall; however, if you do not clean your room (false), you will not go to the mall. The if statement is written in this way; the programmer is now controlling the flow of the program. Thus, \u201cgo to the mall\u201d will occur if the condition is true, but will be skipped if the condition is false. Another popular (pseudocode) way to write this statement is\nif (you clean your room)\n    go to the mall;\n\nThis construction simply uses white space to make the code more readable. The AP Exam may present an if statement in either of these formats.\nLet\u2019s try a code example. Consider the following lines from a Java program:\nint num1 = 4, num2 = 5;\nif (num1 == num2)\n    System.out.print(\"The numbers are the same.\");\n\nSince we have an if statement, one of two possibilities can occur, based on whether num1 has the same value as num2: (1) the program will display the string literal \"The numbers are the same.\" if the condition is true, or (2) the program will not display any output if the condition is false.\nNote the use, here, of the boolean operator == (also known as the equality operator); do not confuse this boolean operator with the assignment operator =. A boolean operator asks a question, while an assignment operator executes a command. num1 = 4 assigns the value 4 to the variable num1, while num1 == num2 determines whether the two values are equal. The assignment statement produces no other result, while the boolean statement returns a truth value based on the comparison.\nWouldn\u2019t it be nice if conditions in life depended on just one comparison, as our previous code example did? If we dig a bit deeper into our alarm clock example from before, there are probably a few more decisions that need to be made in order to begin your morning rituals; a few of these decisions might be, \u201cis it a school day?\u201d\u2026\u201cdo I feel healthy?\u201d\u2026\u201cis my blanket glued to my mattress, trapping me between them?\u201d Note that each of these questions, regardless of its plausibility, has a true or false (boolean) answer.\nIf (see how many times we use this word?) we want to incorporate a more complicated condition into our code, we must create a compound condition. Compound conditions include at least one boolean operator; all of these and their meanings are as follows:\n&& logical and\n|| logical or\n! logical not\n== is equal to\n!= is not equal to\n\nLet\u2019s explore how each of these can be incorporated into a program.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nfor (int i = 200; i > 0; i /= 3)\n{\n    if (i % 2 == 0)\n        System.out.print(i + \" \");\n}\n\nWhat is the output as a result of executing the code segment?\nCorrect: 200 66 22 2\nIncorrect: 200 66 22 7 2\nIncorrect: 66 22 7 2\nIncorrect: 200 66 22\nIncorrect: 7\n\nEND"}
{"prompt": "Consider a situation in which you need a study break and decide to visit your local bakery for a snack. Your favorite dessert is typically Italian cannoli but you will also accept an apple turnover. But apple turnovers are somewhat dry, so you will buy one only if they are selling coffee that day.\nSince this example is relatively complicated, let\u2019s break it into chunks. We will use pseudocode for this example.\nLet\u2019s outline the conditions presented in this example, in order:\n    The bakery has cannoli.\n    The bakery has apple turnovers.\n    The bakery has coffee.\n\nThe complication here is that some of these decisions depend on others. For example, if the bakery DOES have cannoli, then it doesn\u2019t matter whether it has apple turnovers. Again, step by step: start with condition (1)\nif (bakery has cannoli) buy dessert;\n\nNow, another decision must be made, based on this decision; if the bakery DOES have cannoli, we get our desired dessert. If it does NOT have cannoli, we must try the apple turnover.\nif (bakery has cannoli)\n    buy dessert; // occurs only if bakery has cannoli\nelse if (bakery has apple turnovers) // occurs only if bakery has no cannoli\n    buy dessert; // occurs only if bakery has apple turnovers\n\nNote the else keyword used here. else is used if the programmer wants a statement to execute if the condition is false.\nIt\u2019s not that easy, though\u2026we must consider the coffee. Since you will buy an apple turnover only if there is ALSO coffee for sale, the && operator is appropriate here:\n1 if (bakery has cannoli)\n2 buy dessert; // bakery has cannoli\n3 else if (bakery has apple turnovers && bakery has coffee) // no cannoli\n4 buy dessert; // bakery has apple turnovers AND coffee\n\nThis pseudocode seems to work, but we must check for logical errors.\nUsing the numbered lines of pseudocode, let\u2019s trace the possibilities using a trace table.\nhas cannoli: line 1, condition is true -> line 2, buy dessert\nno cannoli, no turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, no turnovers, yes coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, yes coffee: line 1, false -> line 3, true -> line 4, buy dessert\n\nMoral of the story: This bakery had better get itself together.\n\nThere is a lot of pseudocode here! Controlling the flow of a program can be difficult and confusing, which is why it is a popular topic on the AP Exam. But it is also important because most programs, like most things we do in life, rely on conditions and react accordingly.\nIf we look at the bakery example one more time, the line\nbuy dessert;\n\noccurs twice. Good programming style attempts to repeat the same lines of code as little as possible, if ever. Therefore, we can rearrange the boolean operators in the following way, creating the same result:\nif (bakery has cannoli OR (bakery has apple turnovers AND bakery has coffee))\n    buy dessert;\n\nThat is a hefty boolean condition; however, it (1) eliminates the repetition of code and (2) provides a more \u201celegant\u201d programming solution. \u201cElegant\u201d is a relative term, of course, but the AP Exam often uses this subjective term to write code and to confuse you. Either way, you should be familiar with both ways.\nThe AP Exam free-response questions do not require you to write code with \u201celegance\u201d; in the free-response questions they will accept any code solution as long as it fulfills the specifications of the question.\nTo make things more complicated (or more life-like), consider a further idea. What if we want to execute several commands when a condition is true (or false) instead of just one? For example, using the bakery case, let\u2019s say that buying cannoli is so exciting that we must devour it right away. In other words, if the conditions are met for the bakery having cannoli, we want to buy it AND eat it. The pseudocode would look something like:\n1 if (bakery has cannoli)\n2 {\n3   buy dessert; // bakery has cannoli\n4   eat dessert;\n5 }\n6 else if (bakery has apple turnovers && bakery has coffee) // no cannoli\n7   buy dessert; // bakery has apple turnovers AND coffee\n\nThe { and } symbols in lines 2 and 5 indicate blocking, a technique used in flow control statements that allows the programmer to execute a series of commands (instead of just one) when a given condition is satisfied.\n\nHere is a summary for evaluating boolean expressions:\nAn && (and) expression is true if BOTH A and B are true. An || (or) expression is true if EITHER A or B is true, or if they are both true.\nThe ! (not) operator simply reverses the truth value of the variable.\nThe truth value of an expression is often abbreviated to a single letter. Thus, A may represent an expression such as x >= 0. The expression will either be true or false depending on the value of x, but for simplicity\u2019s sake we just refer to the whole expression as A.\nConsider the following three expressions:\nTo evaluate A && B\nFirst evaluate A. If A is false then stop: the whole expression is false. Since false && anything is false, there is no need to continue after the first false has been evaluated. This idea is called short-circuit evaluation. This idea is used (and tested) frequently. However, if A is true, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate A || B\nFirst evaluate A. If A is true then stop: the whole expression is true. Since true || anything is true, there is no need to continue after the first true has been evaluated. This is short-circuit evaluation again. However, if A is false, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate !A\nFirst evaluate A. If A is true, the whole expression is false. If A is false, the whole expression is true.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Suppose p and q are declared as boolean variables and have been initialized to unknown truth values.\nWhat does the following boolean expression evaluate to? (p && !q) || (p && q)\nCorrect: The expression always evaluates to the same value as p.\nIncorrect: The expression always evaluates to the same value as q.\nIncorrect: The expression always evaluates to true.\nIncorrect: The expression always evaluates to false.\nIncorrect: The expression evaluates to true only if p and q have opposite truth values.END"}
{"prompt": "When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and \u201celegant\u201d).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty \u2014is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly \u201cfreeze\u201d in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) // ! means NOT wet\n2 {\n3   clean paintbrush; // is it COMPLETELY clean?\n4   dry paintbrush; // is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let\u2019s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment.\nint val1 = 2, val2 = 22, val3 = 78;\nwhile (val2 % val1 == 0 || val2 % 3 == 0)\n{\n    val3++;\n    val2--;\n}\n\nWhat will val3 contain after the code segment is executed?\nCorrect: None of the above\n\n\nIncorrect: 77\nIncorrect: 78\nIncorrect: 79\nIncorrect: 80END"}
{"prompt": "When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and \u201celegant\u201d).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty \u2014is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly \u201cfreeze\u201d in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) // ! means NOT wet\n2 {\n3   clean paintbrush; // is it COMPLETELY clean?\n4   dry paintbrush; // is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let\u2019s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: What will be the output when the following code is evaluated?\nfor (int k = 0; k < 3; k++)\n{\n    for (int j = 1; j < 4; j++)\n    {\n        System.out.print(j + \" \");\n    }\n    System.out.println();\n}\n\nCorrect: 1 2 3\n1 2 3\n1 2 3\nIncorrect: 1 2 3 4\n1 2 3 4\n1 2 3 4\nIncorrect: 0 1 2\n0 1 2\n0 1 2\n0 1 2\nIncorrect: 1 2 3\n1 2 3\n1 2 3\n1 2 3\nIncorrect: 1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n\nEND"}
{"prompt": "When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and \u201celegant\u201d).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty \u2014is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly \u201cfreeze\u201d in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) // ! means NOT wet\n2 {\n3   clean paintbrush; // is it COMPLETELY clean?\n4   dry paintbrush; // is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let\u2019s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\nThe following question asks about the properties or summary of a program with multiple options:\n\n###\n\n", "completion": "Question: Consider the following code fragments. Assume someNum has been correctly defined and initialized as a positive integer.\nI. for (int i; i = 0; i < someNum; i++)\n{\n    someNum--;\n}\nII. for (int i; i = 1; i < someNum - 1; i++)\n{\n    someNum -=1;\n}\nIII. int i = 0;\nwhile (i < someNum)\n{\n    i++;\n    someNum--;\n}\n\nAll of the following statements are true about these code fragments EXCEPT\nCorrect: The value of someNum after the execution of I and II is the same.\nIncorrect: The for loops in I and II have the same number of iterations.\nIncorrect: The value of i after execution of II and III is the same.\nIncorrect: The loops in I and III have the same number of iterations.\nIncorrect: I, II, and III do not produce identical results.\n\nEND"}
{"prompt": "When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and \u201celegant\u201d).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty \u2014is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly \u201cfreeze\u201d in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) // ! means NOT wet\n2 {\n3   clean paintbrush; // is it COMPLETELY clean?\n4   dry paintbrush; // is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let\u2019s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nfor (int i = 1; i < 100; i = i * 2)\n{\n    if (i / 50 == 0)\n        System.out.print(i + \" \");\n}\n\nWhat is printed as a result of executing the code segment?\nCorrect: 1 2 4 8 16 32\nIncorrect: 1 2 4 8 16 32 64\nIncorrect: 2 4 8 16 32 64\nIncorrect: 2 4 8 16 32\nIncorrect: 4 8 16 32 64\n\nEND"}
{"prompt": "When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and \u201celegant\u201d).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty \u2014is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly \u201cfreeze\u201d in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) // ! means NOT wet\n2 {\n3   clean paintbrush; // is it COMPLETELY clean?\n4   dry paintbrush; // is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let\u2019s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the following output:\n0 1\n0 2 4\n0 3 6 9\n0 4 8 12 16\nWhich of the following code segments will produce this output?\nCorrect: for (int x = 1; x < 5; x++)\n{\n    for (int z = 0; z <= x; z++)\n    {\n        System.out.print(x * z + \" \");\n    }\n    System.out.println(\" \");\n}\nIncorrect: for (int x = 1; x <= 5; x++)\n{\n    for (int z = 0; z < x; z++)\n    {\n        System.out.print(x * z + \" \");\n    }\n    System.out.println(\" \");\n}\nIncorrect: for (int x = 1; x < 5; x++)\n{\n    for (int z = 0; z <= 4; z++)\n    {\n        System.out.print(x * z + \" \");\n    }\n    System.out.println(\" \");\n}\nIncorrect: for (int x = 1; x < 5; x++)\n{\n    for (int z = 0; z <= 4; z += 2)\n    {\n        System.out.print(x * z + \" \");\n    }\n    System.out.println(\" \");\n}\nIncorrect: for (int x = 1; x <= 5; x++)\n{\n    for (int z = 0; z <= x; z++)\n    {\n        System.out.print(x * z + \" \");\n    }\n    System.out.println(\" \");\n}\n\nEND"}
{"prompt": "When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and \u201celegant\u201d).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty \u2014is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly \u201cfreeze\u201d in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) // ! means NOT wet\n2 {\n3   clean paintbrush; // is it COMPLETELY clean?\n4   dry paintbrush; // is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let\u2019s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: The speed limit of a stretch of highway is 55 miles per hour (mph). The highway patrol issues speeding tickets to anyone caught going faster than 55 miles per hour. The fine for speeding is based on the following scale:\nSpeed Fine:\ngreater than 55 mph but less than 65 mph $100\ngreater than or equal to 65 mph but less than 75 mph $150\ngreater than or equal to 75 mph $300\n\nIf the value of the int variable speed is the speed of a driver who was pulled over for going faster than 55 mph, which of the following code segments will assign the correct value to the int variable fine?\nI. if (speed >= 75)\n    fine = 300;\nif (speed >= 65 && speed < 75)\n    fine = 150;\nif (speed > 55 && speed < 65)\n    fine = 100;\nII. if (speed >= 75)\n    fine = 300;\nif (65 <= speed < 75)\n    fine = 150;\nif (55 < speed < 65)\n    fine = 100;\nIII. if (speed >= 75)\n    fine = 300;\nif (speed >= 65)\n    fine = 150;\nif (speed > 55)\n    fine = 100;\nCorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II\nIncorrect: I and III\n\nEND"}
{"prompt": "When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and \u201celegant\u201d).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty \u2014is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly \u201cfreeze\u201d in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) // ! means NOT wet\n2 {\n3   clean paintbrush; // is it COMPLETELY clean?\n4   dry paintbrush; // is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let\u2019s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint x = 10;\nint y = 3;\nboolean b = true;\nfor (int i = 0, i < 15; i += 5)\n{\n    x = x + y;\n    b = (x % y == 2);\n    if (!b)\n    {\n        y++;\n        i += 5;\n    }\n}\n\nWhat is the value of x after the code segment executes?\nCorrect: 17\nIncorrect: 10\nIncorrect: 15\nIncorrect: 22\nIncorrect: 25\n\nEND"}
{"prompt": "When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and \u201celegant\u201d).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty \u2014is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly \u201cfreeze\u201d in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) // ! means NOT wet\n2 {\n3   clean paintbrush; // is it COMPLETELY clean?\n4   dry paintbrush; // is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let\u2019s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: In the following statement, a and b are boolean variables: boolean c = (a && b) || !(a || b);\nUnder what conditions will the value of c be true?\nCorrect: Only when the value of a is the same as the value of b\nIncorrect: Only when the value of a is different than the value of b\nIncorrect: Only when a and b are both true\nIncorrect: Only when a and b are both false\nIncorrect: The value of c will be true for all values of a and b.\n\nEND"}
{"prompt": "When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and \u201celegant\u201d).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty \u2014is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly \u201cfreeze\u201d in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) // ! means NOT wet\n2 {\n3   clean paintbrush; // is it COMPLETELY clean?\n4   dry paintbrush; // is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let\u2019s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nwhile ((x > y) || y >= z)\n{\n    System.out.print(\u201c*\u201d);\n}\n\nIn the code segment above, x, y, and z are the variables of type int. Which of the following must be true after the code segment has executed?\nCorrect: x <= y && y < z\n\n\nIncorrect: x > y || y >= z\nIncorrect: x <= y || y > z\nIncorrect: x > y && y >= z\nIncorrect: x < y && y <= zEND"}
{"prompt": "When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and \u201celegant\u201d).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty \u2014is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly \u201cfreeze\u201d in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) // ! means NOT wet\n2 {\n3   clean paintbrush; // is it COMPLETELY clean?\n4   dry paintbrush; // is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let\u2019s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint a = 0;\nfor (int i = 0; i < 10; i++)\n{\n    for (int k = 0; k <= 5; k++)\n    {\n        for (int z = 1; z <= 16; z = z * 2)\n        {\n            a++;\n        }\n    }\n}\n\nWhat is the value of a after the code segment executes?\nCorrect: 300\nIncorrect: 31\nIncorrect: 180\nIncorrect: 200\nIncorrect: 400\n\nEND"}
{"prompt": "When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and \u201celegant\u201d).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty \u2014is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly \u201cfreeze\u201d in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) // ! means NOT wet\n2 {\n3   clean paintbrush; // is it COMPLETELY clean?\n4   dry paintbrush; // is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let\u2019s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint x = 10;\nint y = x / 3;\nint z = x % 2;\nx++;\nSystem.out.println(x)\n\nWhat is printed as a result of executing the code segment above?\nCorrect: 11\nIncorrect: 2\nIncorrect: 4\nIncorrect: 10\nIncorrect: 15\n\nEND"}
{"prompt": "When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and \u201celegant\u201d).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty \u2014is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly \u201cfreeze\u201d in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) // ! means NOT wet\n2 {\n3   clean paintbrush; // is it COMPLETELY clean?\n4   dry paintbrush; // is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let\u2019s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint a = 10;\ndouble b = 3.7;\nint c = 4;\nint x = (int) (a + b);\ndouble y = (double) a / c;\ndouble z = (double) (a / c);\ndouble w = x + y + z;\nSystem.out.println(w);\n\nWhat is printed as a result of evaluating the code above?\nCorrect: 17.5\n\n\nIncorrect: 10\nIncorrect: 15\nIncorrect: 15.5\nIncorrect: 17END"}
{"prompt": "When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and \u201celegant\u201d).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty \u2014is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly \u201cfreeze\u201d in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) // ! means NOT wet\n2 {\n3   clean paintbrush; // is it COMPLETELY clean?\n4   dry paintbrush; // is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let\u2019s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\nThe following question asks about the properties or summary of a program with multiple options:\n\n###\n\n", "completion": "Question: Consider the following code segments:\nI. int x = 10;\nint y = 20;\nint z = 0;\nif (x < y && 10 < y/z)\n{\n    System.out.println(\"Homer\");\n}\nelse\n{\n    System.out.println(\"Bart\");\n}\nII. int x = 10;\nint y = 20;\nint z = 0;\nif (x > y && 10 < y/z)\n    System.out.println(\"Homer\");\nelse\n    System.out.println(\"Bart\");\nIII. int x = 10;\nint y = 20;\nint z = 0;\nif (x < y || 10 < y/z)\n    System.out.println(\"Homer\");\nelse\n    System.out.println(\"Bart\");\n\nWhich of the code segments above will run without error?\nCorrect: II and III\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and IIIEND"}
{"prompt": "Inheritance is the quintessential way\u2014and the only way, for our purposes \u2014to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the \u201cparent\u201d class and all of its \u201cchild\u201d classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer/designer\u2014yes, there are programmers who focus solely on design\u2014is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet\u2019s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities\u2014would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable\u2014yet all viable\u2014results. \nIn this case, let\u2019s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let\u2019s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and/or conform to the given specifications. \nLet\u2019s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let\u2019s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization\u2014think: if I look around the room right now, what isn\u2019t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, \u201ceaters\u201d have to wipe their hands before continuing to eat. The desired eat() method\u2014possessing the identical name, parameters, and return type\u2014would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass\u2019s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it\u2019s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method\u2019s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: In order to write LawAcademy, a subclass of College, which of the following constructors is valid?\nI. public LawAcademy (String twn, double tuit)\n{\n    super.College(twn, tuit);\n}\nII. public LawAcademy (String twn, double tuit)\n{\n    super(twn, tuit);\n}\nIII. public LawAcademy (String twn, double tuit, String st) {\n    super(st, tuit);\n}\nCorrect: II and III only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: I and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "Inheritance is the quintessential way\u2014and the only way, for our purposes \u2014to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the \u201cparent\u201d class and all of its \u201cchild\u201d classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer/designer\u2014yes, there are programmers who focus solely on design\u2014is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet\u2019s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities\u2014would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable\u2014yet all viable\u2014results. \nIn this case, let\u2019s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let\u2019s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and/or conform to the given specifications. \nLet\u2019s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let\u2019s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization\u2014think: if I look around the room right now, what isn\u2019t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, \u201ceaters\u201d have to wipe their hands before continuing to eat. The desired eat() method\u2014possessing the identical name, parameters, and return type\u2014would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass\u2019s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it\u2019s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method\u2019s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider a class Recliner that extends a Chair class. Assuming both classes each have a no-parameter constructor, which of the following statements is NOT valid?\nCorrect: Recliner b = new Chair();\nIncorrect: Object a = new Recliner();\nIncorrect: Chair c = new Chair();\nIncorrect: Chair d = new Recliner();\nIncorrect: All of the above choices are valid.\n\nEND"}
{"prompt": "Inheritance is the quintessential way\u2014and the only way, for our purposes \u2014to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the \u201cparent\u201d class and all of its \u201cchild\u201d classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer/designer\u2014yes, there are programmers who focus solely on design\u2014is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet\u2019s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities\u2014would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable\u2014yet all viable\u2014results. \nIn this case, let\u2019s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let\u2019s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and/or conform to the given specifications. \nLet\u2019s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let\u2019s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization\u2014think: if I look around the room right now, what isn\u2019t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, \u201ceaters\u201d have to wipe their hands before continuing to eat. The desired eat() method\u2014possessing the identical name, parameters, and return type\u2014would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass\u2019s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it\u2019s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method\u2019s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the following two classes:\npublic class A\n{\n    public int method1(int x)\n    {\n        return 2;\n    }\n}\npublic class B extends A\n{ /* code not shown */ }\n\nWhich of the following could be the signature of a method in class B that correctly overloads method1 in class A?\nCorrect: public int method1(String x)\nIncorrect: public int method1(int y)\nIncorrect: private int method1(int x)\nIncorrect: public int method2(String x)\nIncorrect: public int method2(int y)\n\nEND"}
{"prompt": "Inheritance is the quintessential way\u2014and the only way, for our purposes \u2014to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the \u201cparent\u201d class and all of its \u201cchild\u201d classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer/designer\u2014yes, there are programmers who focus solely on design\u2014is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet\u2019s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities\u2014would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable\u2014yet all viable\u2014results. \nIn this case, let\u2019s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let\u2019s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and/or conform to the given specifications. \nLet\u2019s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let\u2019s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization\u2014think: if I look around the room right now, what isn\u2019t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, \u201ceaters\u201d have to wipe their hands before continuing to eat. The desired eat() method\u2014possessing the identical name, parameters, and return type\u2014would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass\u2019s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it\u2019s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method\u2019s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the following two classes:\npublic class Parent\n{\n    public void writeMe(String s)\n    {\n        System.out.println(\"Object\");\n    }\n}\npublic class Child extends Parent\n{\n    public void writeMe(String s)\n    {\n        System.out.println(\"Object\");\n    }\n}\n\nWhich of the following best describes the writeMe method of the Child class?\nCorrect: An overridden method\nIncorrect: An inherited method\nIncorrect: An overloaded method\nIncorrect: An interface method\nIncorrect: An abstract method\n\nEND"}
{"prompt": "Polymorphism is a technique that, in a way, breaks all of the rules we think would happen in inheritance\u2014and yet, it conforms to them at the same time. \nUsing our Snack example from above, including the overridden method in OnionChip, suppose several objects from various levels in the hierarchy reside in an untyped ArrayList. The programmer would like to, using a simple loop, simulate the user \u201ceating\u201d the chips in the list, regardless of their type. The loop will iterate through the list and automatically invoke the appropriate eat() method, including the overridden method for OnionChip objects, as desired. This is an example of polymorphism.\nThe word polymorphism, which means \u201cmany forms,\u201d can also apply to programs in a more profound manner. This process, directly or indirectly, involves virtually every technique we have learned in this book. \nSuppose an interface called Eatable is implemented by all of the classes in the Snack hierarchy. Every class has either overridden the abstract methods from the interface, as normally required, or passed the abstraction to a subclass. \nHave you ever seen those snack bags that have multiple forms of snacks (for example, potato chips AND pretzels AND nacho chips\u2026) in them? This example is similar; if you instantiated the \u201cbag\u201d as either a typed ArrayList or an array, you could fill the structure with instances of all of these classes by declaring the type as Eatable. Once the eat() method is invoked on all of the components of the list structure using a loop, each object will automatically invoke its corresponding eat method! Pretty awesome. \n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following class:\npublic class Cat\n{\n    private String name;\n    private int age;\n    public Cat(String name, int age)\n    {\n        this.name = name;\n        this.age = age;\n    }\n    public String toString()\n    {\n        return (name + \": \" + age);\n    }\n}\n\nSuppose another class were to include the following code segment:\nCat c = new Cat(\"Billi\", 5);\nSystem.out.println(c);\n\nWhich of the following will be the output of the code segment?\nCorrect: Billi: 5\nIncorrect: c\nIncorrect: 5\nIncorrect: Billi\nIncorrect: There would be no output.\n\nEND"}
{"prompt": "Inheritance is the quintessential way\u2014and the only way, for our purposes \u2014to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the \u201cparent\u201d class and all of its \u201cchild\u201d classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer/designer\u2014yes, there are programmers who focus solely on design\u2014is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet\u2019s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities\u2014would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable\u2014yet all viable\u2014results. \nIn this case, let\u2019s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let\u2019s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and/or conform to the given specifications. \nLet\u2019s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let\u2019s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization\u2014think: if I look around the room right now, what isn\u2019t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, \u201ceaters\u201d have to wipe their hands before continuing to eat. The desired eat() method\u2014possessing the identical name, parameters, and return type\u2014would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass\u2019s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it\u2019s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method\u2019s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the following two classes:\npublic class Parent\n{\n    public void writeMe(String s)\n    {\n        System.out.println(\"object\");\n    }\n}\npublic class Child extends Parent\n{\n    public void writeMe(String s)\n    {\n        System.out.println(\"object\");\n    }\n}\n\nWhich of the following best describes the writeMe method of the Child class?\nCorrect: An overridden method\nIncorrect: An inherited method\nIncorrect: An overloaded method\nIncorrect: An interface method\nIncorrect: An abstract method\n\nEND"}
{"prompt": "Inheritance is the quintessential way\u2014and the only way, for our purposes \u2014to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the \u201cparent\u201d class and all of its \u201cchild\u201d classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer/designer\u2014yes, there are programmers who focus solely on design\u2014is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet\u2019s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities\u2014would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable\u2014yet all viable\u2014results. \nIn this case, let\u2019s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let\u2019s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and/or conform to the given specifications. \nLet\u2019s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let\u2019s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization\u2014think: if I look around the room right now, what isn\u2019t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, \u201ceaters\u201d have to wipe their hands before continuing to eat. The desired eat() method\u2014possessing the identical name, parameters, and return type\u2014would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass\u2019s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it\u2019s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method\u2019s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\nThe following question asks about general programming knowledge:\n\n###\n\n", "completion": "Question: How many classes can a given class extend?\nCorrect: 1\nIncorrect: None\nIncorrect: 2\nIncorrect: 3\nIncorrect: As many as it needs to\n\nEND"}
{"prompt": "Inheritance is the quintessential way\u2014and the only way, for our purposes \u2014to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the \u201cparent\u201d class and all of its \u201cchild\u201d classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer/designer\u2014yes, there are programmers who focus solely on design\u2014is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet\u2019s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities\u2014would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable\u2014yet all viable\u2014results. \nIn this case, let\u2019s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let\u2019s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and/or conform to the given specifications. \nLet\u2019s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let\u2019s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization\u2014think: if I look around the room right now, what isn\u2019t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, \u201ceaters\u201d have to wipe their hands before continuing to eat. The desired eat() method\u2014possessing the identical name, parameters, and return type\u2014would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass\u2019s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it\u2019s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method\u2019s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the following classes.\npublic class Employee\n{\n    private String name;\n    private String department;\n    Employee ()\n    {\n        name = \"\";\n        department = \"\";\n    }\n    Employee (String iName)\n    {\n        name = iName;\n        department = \"\";\n    }\n    Employee (String iName, String iDepartment)  {\n        name = iName;\n        department = iDepartment;\n    }\n    public String toString()\n    {\n        return name + \" \" + department;\n    }\n}\n\npublic class Manager extends Employee {\n    private double salary;\n    Manager()\n    {\n        salary = 0;\n    }\n    Manager(double iSalary)\n    {\n        salary = iSalary;\n    }\n    Manager(String iName, String iDepartment, double iSalary)\n    {\n        super(iName, iDepartment);\n        salary = iSalary;\n    }\n    public void setSalary(double iSalary)\n    {\n        salary = iSalary;\n    }\n    public String toString()\n    {\n        String str = super.toString();\n        return str += \" \" + salary;\n    }\n}\n\nWhich of the following code combinations will NOT cause a compilation error?\nCorrect: Manager emp5 = new Employee(\"Jones\", \"Sales\");\n\n\nIncorrect: Employee emp1 = new Employee();\nIncorrect: Employee emp2 = new Employee(\"Jones\", \"Sales\");\nIncorrect: Employee emp3 = new Manager(\"Jones\", \"Sales\", 50000.0);\nIncorrect: Employee emp4 = new Manager(50000.0);END"}
{"prompt": "Inheritance is the quintessential way\u2014and the only way, for our purposes \u2014to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the \u201cparent\u201d class and all of its \u201cchild\u201d classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer/designer\u2014yes, there are programmers who focus solely on design\u2014is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet\u2019s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities\u2014would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable\u2014yet all viable\u2014results. \nIn this case, let\u2019s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let\u2019s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and/or conform to the given specifications. \nLet\u2019s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let\u2019s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization\u2014think: if I look around the room right now, what isn\u2019t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, \u201ceaters\u201d have to wipe their hands before continuing to eat. The desired eat() method\u2014possessing the identical name, parameters, and return type\u2014would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass\u2019s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it\u2019s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method\u2019s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: An apartment rental company has asked you to write a program to store information about the apartments that it has available for rent. For each apartment, the company wants to keep track of the following information: number of rooms, whether or not the apartment has a dishwasher, and whether or not pets are allowed. Which of the following is the best design?\nCorrect: Use one class, Apartment, which has three data fields: int rooms, boolean hasDishwasher, boolean allowsPets.\nIncorrect: Use four unrelated classes: Apartment, Rooms, Dishwasher, and Pets.\nIncorrect: Use one class, Apartment, which has three subclasses: Room, Dishwasher, and Pet.\nIncorrect: Use three classes\u2014Pets, Rooms, and Dishwasher\u2014each with a subclass Apartment.\nIncorrect: Use four classes: Apartment, Pets, Dishwasher, and Rooms. The class Apartment contains instances of the other classes as attributes.\n\nEND"}
{"prompt": "Polymorphism is a technique that, in a way, breaks all of the rules we think would happen in inheritance\u2014and yet, it conforms to them at the same time. \nUsing our Snack example from above, including the overridden method in OnionChip, suppose several objects from various levels in the hierarchy reside in an untyped ArrayList. The programmer would like to, using a simple loop, simulate the user \u201ceating\u201d the chips in the list, regardless of their type. The loop will iterate through the list and automatically invoke the appropriate eat() method, including the overridden method for OnionChip objects, as desired. This is an example of polymorphism.\nThe word polymorphism, which means \u201cmany forms,\u201d can also apply to programs in a more profound manner. This process, directly or indirectly, involves virtually every technique we have learned in this book. \nSuppose an interface called Eatable is implemented by all of the classes in the Snack hierarchy. Every class has either overridden the abstract methods from the interface, as normally required, or passed the abstraction to a subclass. \nHave you ever seen those snack bags that have multiple forms of snacks (for example, potato chips AND pretzels AND nacho chips\u2026) in them? This example is similar; if you instantiated the \u201cbag\u201d as either a typed ArrayList or an array, you could fill the structure with instances of all of these classes by declaring the type as Eatable. Once the eat() method is invoked on all of the components of the list structure using a loop, each object will automatically invoke its corresponding eat method! Pretty awesome. \n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the following class declarations:\npublic class Vehicle\n{\n    private int maxPassengers;\n    public Vehicle( )\n    {\n        maxPassengers = 1;\n    }\n    public Vehicle(int x)\n    {\n        maxPassengers = x;\n    }\n    public int maxPassengers( )\n    {\n        return maxPassengers;\n    }\n}\n\npublic class Motorcycle extends Vehicle\n{\n    public Motorcycle( )\n    {\n        super(2);\n    }\n}\n\nWhich of the following code segments will NOT cause a compilation error?\nCorrect: Vehicle v2 = new Motorcycle( );\nIncorrect: Motorcycle m1 = new Motorcycle(3);\nIncorrect: Vehicle v1 = new Motorcycle(4);\nIncorrect: Motorcycle m2 = new Vehicle( );\nIncorrect: Vehicle v3 = new Vehicle( );\nint max = v3.maxPassengers;END"}
{"prompt": "An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let\u2019s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) //x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) //x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those \u201csolve this problem\u201d memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n// returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); // returns -1 \nstr1.compareTo(\"cat\"); // returns 0 \nstr2.compareTo(str1); // returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() \u2013 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to \u2013 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 \u2013 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return \u20131, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet\u2019s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: A math teacher is writing a program that will correctly calculate the area of a circle. Recall that the area of a circle is pi times the radius squared (\u03c0r2). Assuming Math.PI returns an accurate decimal approximation of pi, which of the following statements WILL NOT calculate an accurate area of a circle with radius 22?\nCorrect: All of the above choices will calculate an accurate area.\n\n\nIncorrect: r*r*Math.PI; // r is the int 22\nIncorrect: r*r*Math.PI; // r is the double 22.0\nIncorrect: (double)r*r*Math.PI; // r is the int 22\nIncorrect: (double)(r*r)*Math.PI; // r is the int 22END"}
{"prompt": "An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let\u2019s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) //x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) //x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those \u201csolve this problem\u201d memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n// returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); // returns -1 \nstr1.compareTo(\"cat\"); // returns 0 \nstr2.compareTo(str1); // returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() \u2013 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to \u2013 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 \u2013 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return \u20131, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet\u2019s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nString s = \"This is the beginning\";\nString t = s.substring(5);\nint n = t.indexOf(\"the\");\nWhich of the following will be the value of n?\nCorrect: 3\nIncorrect: \u20131\nIncorrect: 7\nIncorrect: 9\nIncorrect: n will have no value because of a run-time error.\n\nEND"}
{"prompt": "An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let\u2019s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) //x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) //x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those \u201csolve this problem\u201d memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n// returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); // returns -1 \nstr1.compareTo(\"cat\"); // returns 0 \nstr2.compareTo(str1); // returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() \u2013 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to \u2013 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 \u2013 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return \u20131, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet\u2019s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Given the following code, what line will cause a compiler error?\nString word = \"Sunday Funday Celebration 1.0\"; 2 word.substring(7);\nword.substring(3, 6);\nword.indexOf(\"day\");\nword.indexOf(1.0);\nword.compareTo(\"day\");\nCorrect: line 5\nIncorrect: line 2\nIncorrect: line 3\nIncorrect: line 4\nIncorrect: line 6\n\nEND"}
{"prompt": "An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let\u2019s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) //x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) //x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those \u201csolve this problem\u201d memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n// returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); // returns -1 \nstr1.compareTo(\"cat\"); // returns 0 \nstr2.compareTo(str1); // returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() \u2013 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to \u2013 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 \u2013 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return \u20131, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet\u2019s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Given the following code, which of the following would cause a run time error?\nString s1 = \"pizza\";\nCorrect: String s2 = s1.substring(4, 6);\n\n\nIncorrect: String s2 = s1.substring(0, 2);\nIncorrect: String s2 = s1.substring(1, 3);\nIncorrect: String s2 = s1.substring(3, 3);\nIncorrect: String s2 = s1.substring(2, 3);END"}
{"prompt": "An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let\u2019s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) //x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) //x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those \u201csolve this problem\u201d memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n// returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); // returns -1 \nstr1.compareTo(\"cat\"); // returns 0 \nstr2.compareTo(str1); // returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() \u2013 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to \u2013 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 \u2013 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return \u20131, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet\u2019s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Given the following code, what is the final value stored in s3?\nString s1 = \"kangaroo\";\nString s3 = s1.substring(1, 2);\nCorrect: \"a\"\nIncorrect: \"k\"\nIncorrect: \"ka\"\nIncorrect: \"an\"\nIncorrect: \"kn\"\n\nEND"}
{"prompt": "An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let\u2019s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) //x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) //x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those \u201csolve this problem\u201d memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n// returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); // returns -1 \nstr1.compareTo(\"cat\"); // returns 0 \nstr2.compareTo(str1); // returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() \u2013 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to \u2013 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 \u2013 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return \u20131, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet\u2019s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Given the following code, what is the final value stored in s4?\nString s1 = \"tango\";\nString s4 = s1.substring(s1.length() - 2);\nCorrect: \"go\"\nIncorrect: \"g\"\nIncorrect: \"o\"\nIncorrect: \"og\"\nIncorrect: A compiler error will occur.\n\nEND"}
{"prompt": "An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let\u2019s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) //x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) //x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those \u201csolve this problem\u201d memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n// returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); // returns -1 \nstr1.compareTo(\"cat\"); // returns 0 \nstr2.compareTo(str1); // returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() \u2013 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to \u2013 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 \u2013 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return \u20131, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet\u2019s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Given that \u201cA\u201d comes before \u201ca\u201d in the dictionary and the following variables have been defined and initialized, which is true?\nString str1 = \"january\";\nString str2 = \"June\";\nString str3 = \"July\";\nCorrect: str1.compareTo(str2) > 0\nIncorrect: str1.compareTo(str3) < 0\nIncorrect: str3.compareTo(str2) > 0\nIncorrect: str1.compareTo(str2) < 0\nIncorrect: str2.compareTo(str3) < 0\n\nEND"}
{"prompt": "An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let\u2019s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) //x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) //x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those \u201csolve this problem\u201d memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n// returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); // returns -1 \nstr1.compareTo(\"cat\"); // returns 0 \nstr2.compareTo(str1); // returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() \u2013 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to \u2013 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 \u2013 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return \u20131, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet\u2019s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Given the following code, what is the final value stored in p?\nString word = \"boottool\";\nint p = word.indexOf(\"oo\");\nword.substring(p + 2);\np = word.indexOf(\"oo\");\nCorrect: 1\nIncorrect: 0\nIncorrect: 2\nIncorrect: 5\nIncorrect: 6END"}
{"prompt": "An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets\u2014these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it\u2019s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet\u2019s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet\u2019s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn\u2019t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array\u2019s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total / len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total / len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nfinal int[] a1 = {1, 2};\nint[] b1 = {3, 4};\na1 = b1;\nSystem.out.print(a1[1]);\n\nWhat is printed as a result of executing the code segment?\nCorrect: Nothing is printed due to a compile-time error.\nIncorrect: 2\nIncorrect: 3\nIncorrect: 4\nIncorrect: Nothing is printed due to a run-time error.\n\nEND"}
{"prompt": "An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets\u2014these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it\u2019s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet\u2019s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet\u2019s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn\u2019t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array\u2019s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total / len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total / len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint [] a = {1, 2, 3};\nint [] b = {4, 5, 6};\na = b;\nfor (int i = 0; i < b.length; i++)\n{\n    b[i] *= 2;\n}\nSystem.out.println(a[0]);\n\nWhat is printed as a result of executing the code segment?\nCorrect: 8\nIncorrect: 1\nIncorrect: 4\nIncorrect: Nothing is printed due to a compile-time error.\nIncorrect: Nothing is printed due to a run-time error.\n\nEND"}
{"prompt": "An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets\u2014these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it\u2019s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet\u2019s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet\u2019s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn\u2019t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array\u2019s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total / len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total / len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the following incomplete method:\npublic static int mod3(int[] a)\n{\n    int count = 0;\n    // code not shown\n    return count;\n}\n\nMethod Mod3 is intended to return the number of integers in the array that are evenly divisible by 3. Which of the following code segments could be used to replace // code not shown so that Mod3 will work as intended?\nI. for (int i = 0; i < a.length; i++)\n{\n    if (i % 3 == 0)\n    {\n        count++;\n    }\n}\nII. for (int i = 0; i < a.length; i++)\n{\n    if (a[i] % 3 == 0)\n    {\n        count++;\n    }\n}\nIII. int i = 0;\nwhile (a[i] % 3 == 0)\n{\n    count++;\n    i++;\n}\nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II\nIncorrect: II and III\n\nEND"}
{"prompt": "An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets\u2014these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it\u2019s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet\u2019s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet\u2019s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn\u2019t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array\u2019s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total / len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total / len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the following code:\npublic int[] someMethod (int[] array, int value) {\n    for (int i = 1, i < array.length \u2013 1; i++)\n        array[i - 1] += value;\n    return array;\n}\n\nWhich of the following statements is true about the method someMethod?\nCorrect: The method will not increment the last element of the array by value.\n\n\nIncorrect: The method will not return the first value in the array.\nIncorrect: The method will return the last value in the array.\nIncorrect: The method will cause a run-time error.\nIncorrect: The method will not increment the first element of the array by value.END"}
{"prompt": "An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets\u2014these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it\u2019s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet\u2019s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet\u2019s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn\u2019t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array\u2019s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total / len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total / len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the following code:\npublic int[] mystery (int[] array, int num)\n{\n    for(int i = 1, i < array.length - 1; i++)\n        array[i] = 0;\n    return array[0];\n}\n\nThere is an error in method mystery. Which of the following modifications is needed to correct the compiler error?\nCorrect: Change the return statement to return array;.\nIncorrect: Change int[] array in the method header parameter to int[] numbers.\nIncorrect: Change array.length - 1 to array.length in the loop statement.\nIncorrect: Change array[i] = 0; to array[i - 1] = 0;.\nIncorrect: None of these choices will make the method compile.\n\nEND"}
{"prompt": "Once data is stored in an array, a common task is to methodically search the array for given data. Consider a line of parked cars in the \u201cCurbside To Go\u201d section of your local chain restaurant. When the server is taking the food to a particular car, she must use a given attribute\u2014say, a license plate number \u2014to find the correct car. Once the correct car is found, the server can deliver the food and then go back inside for the next order, beginning the process all over again\u2026and again\u2026and again.\nThis same technique is used for searching an array. In APCS, we have two methods of searching arrays, the sequential search and the binary search. Since each of these search methods uses a distinct formula to search through the arrays, they are commonly referred to as search algorithms.\nThe chain restaurant example given above is an example of a sequential search. All of the cars are \u201clined up\u201d and the server begins with the first car, checking its license plate number against the one she is looking for. If it\u2019s correct, the server delivers the food and returns. If not, she moves on to the next car and repeats the process; this all ends when either (1) the correct car is found or (2) the correct car is not in the line at all. This sequential process works just fine, although it can be very tedious. The server would have to do much more work if the desired car were at the end of the line, as opposed to at the beginning. Remember, we are programming a computer; the server cannot simply \u201clook\u201d at all of the plates at once, as we might in real life. The computer does not know how to \u201clook,\u201d unless we know how to write the program that enables it!\nA code segment that performs a linear search for a number target in an array of integers nums might look like this:\nfor (int i = 0; i < nums.length; i++)\n\tif (nums[i] == target)\n\t\tSystem.out.print(\u201cFound at \" + i);\n\nThis segment will correctly traverse the array, searching for target, starting with index 0 and continuing to index length - 1, as desired. Remember that nums.length is the size of the array and therefore nums[length] would be out of bounds. When target is found, the print statement displays its index number. This process will continue until the end of the array is reached. Note that, if target is never found, there will be no output.\nWhen writing algorithms that traverse arrays, programmers often implement the enhanced-for loop, which is designed specifically for traversing entire arrays. In cases which traversing the entire array is not the intent or would cause a run-time error, the enhanced-for loop should not be used. Assuming nums from the previous example would not cause such a problem, the same code segment can be written as an enhanced-for loop structure like this:\nint loc = 0;\nfor (int num : nums)\n{\n\tif (num == target)\n\t\tSystem.out.print(\u201cfound at \u201d + loc);\n\ti++;\n}\n\nEach time the loop iterates, num will be assigned the value of the next element in the array. This structure automatically ensures that the loop does not go out of bounds. In this case, loc is the location or index in which the target is found.\nIt is important to note that the enhanced-for loop provides a variable that will hold each element of the array. It will NOT automatically provide the index of that element. You will have to add code to keep track of the index if you want to use it.\nA binary search is much more efficient; think of it as a \u201cdivide-and conquer\u201d mechanism. Instead of our restaurant server starting with the beginning of the line of cars, she will start with the middle car. Depending on whether the license plate is \u201cgreater\u201d or \u201cless\u201d than the car she is looking for, the server will move in the appropriate direction.\nThere is a huge obstacle with binary searches, however, or at least, for us with our current level of Java knowledge: these searches work only when there is an inherent order in the data. Suppose the top 21 students in the senior class are lined up in a row. You are looking for a student within that top 21 named Kathy, whom you have never met, but you are not sure where she is in the line. If the students are not lined up in a particular order, a sequential search is your only option, and you might need all 21 tries to find her if she is the last person in the lineup. If they are sorted in alphabetical order by first name, though, you can divide and conquer. Go to the middle person and find out her name\u2026if her name is Sara, you would move toward the front of the line and ignore the back. You then perform the same process, asking the name of the person halfway between the front of the line and Sara, and then ignore the appropriate side. Within a few tries, you will have Kathy.\nHere is a code example of how a binary search might look for array nums when searching for target, assuming nums is sorted:\nint front = 0, back = nums.length - 1, middle = 0; boolean isFound = false;\nwhile((front <= back) && (!isFound))\n{\n\tmiddle = (front + back) / 2;\n\tif (nums[middle] < target)\n\t{\n\t\tfront = middle + 1;\n\t}\n\telse if(nums[middle] > target)\n\t{\n\t\tback = middle - 1;\n\t}\n\telse\n\t{\n\t\tisFound = true;\n\t}\n}\nif (isFound)\n{\n System.out.println(\"Found at\" + middle);\n}\nelse\n{\n System.out.println(\"Target Not Found\");\n}\nOn the AP Exam, you will not be required to write a search algorithm; however, you will be required to recognize a search algorithm and trace it, which can be done the easy way if you understand the algorithm, or the hard way by actually tracing the code, step by step. Try to identify the key characteristics of each search; for example, the \u201csum divided by 2\u201d line is a good indicator of a binary search. The enhanced-for loop will traverse the entire array, which may indicate a sequential search.\n\n\nThe following question asks about general programming knowledge:\n\n###\n\n", "completion": "Question: Which of the following statements is true regarding search algorithms?\nCorrect: None of these\n\n\nIncorrect: Searching for a Twix in a row of unsorted candy is most efficient using a sequential search.\nIncorrect: Searching for a Twix in a row of unsorted candy is most efficient using a binary search.\nIncorrect: Searching for a Twix in a row of sorted candy is most efficient using a sequential search.\nIncorrect: Searching for a Twix in a row of sorted candy is most efficient using a binary search.END"}
{"prompt": "Once data is stored in an array, a common task is to methodically search the array for given data. Consider a line of parked cars in the \u201cCurbside To Go\u201d section of your local chain restaurant. When the server is taking the food to a particular car, she must use a given attribute\u2014say, a license plate number \u2014to find the correct car. Once the correct car is found, the server can deliver the food and then go back inside for the next order, beginning the process all over again\u2026and again\u2026and again.\nThis same technique is used for searching an array. In APCS, we have two methods of searching arrays, the sequential search and the binary search. Since each of these search methods uses a distinct formula to search through the arrays, they are commonly referred to as search algorithms.\nThe chain restaurant example given above is an example of a sequential search. All of the cars are \u201clined up\u201d and the server begins with the first car, checking its license plate number against the one she is looking for. If it\u2019s correct, the server delivers the food and returns. If not, she moves on to the next car and repeats the process; this all ends when either (1) the correct car is found or (2) the correct car is not in the line at all. This sequential process works just fine, although it can be very tedious. The server would have to do much more work if the desired car were at the end of the line, as opposed to at the beginning. Remember, we are programming a computer; the server cannot simply \u201clook\u201d at all of the plates at once, as we might in real life. The computer does not know how to \u201clook,\u201d unless we know how to write the program that enables it!\nA code segment that performs a linear search for a number target in an array of integers nums might look like this:\nfor (int i = 0; i < nums.length; i++)\n\tif (nums[i] == target)\n\t\tSystem.out.print(\u201cFound at \" + i);\n\nThis segment will correctly traverse the array, searching for target, starting with index 0 and continuing to index length - 1, as desired. Remember that nums.length is the size of the array and therefore nums[length] would be out of bounds. When target is found, the print statement displays its index number. This process will continue until the end of the array is reached. Note that, if target is never found, there will be no output.\nWhen writing algorithms that traverse arrays, programmers often implement the enhanced-for loop, which is designed specifically for traversing entire arrays. In cases which traversing the entire array is not the intent or would cause a run-time error, the enhanced-for loop should not be used. Assuming nums from the previous example would not cause such a problem, the same code segment can be written as an enhanced-for loop structure like this:\nint loc = 0;\nfor (int num : nums)\n{\n\tif (num == target)\n\t\tSystem.out.print(\u201cfound at \u201d + loc);\n\ti++;\n}\n\nEach time the loop iterates, num will be assigned the value of the next element in the array. This structure automatically ensures that the loop does not go out of bounds. In this case, loc is the location or index in which the target is found.\nIt is important to note that the enhanced-for loop provides a variable that will hold each element of the array. It will NOT automatically provide the index of that element. You will have to add code to keep track of the index if you want to use it.\nA binary search is much more efficient; think of it as a \u201cdivide-and conquer\u201d mechanism. Instead of our restaurant server starting with the beginning of the line of cars, she will start with the middle car. Depending on whether the license plate is \u201cgreater\u201d or \u201cless\u201d than the car she is looking for, the server will move in the appropriate direction.\nThere is a huge obstacle with binary searches, however, or at least, for us with our current level of Java knowledge: these searches work only when there is an inherent order in the data. Suppose the top 21 students in the senior class are lined up in a row. You are looking for a student within that top 21 named Kathy, whom you have never met, but you are not sure where she is in the line. If the students are not lined up in a particular order, a sequential search is your only option, and you might need all 21 tries to find her if she is the last person in the lineup. If they are sorted in alphabetical order by first name, though, you can divide and conquer. Go to the middle person and find out her name\u2026if her name is Sara, you would move toward the front of the line and ignore the back. You then perform the same process, asking the name of the person halfway between the front of the line and Sara, and then ignore the appropriate side. Within a few tries, you will have Kathy.\nHere is a code example of how a binary search might look for array nums when searching for target, assuming nums is sorted:\nint front = 0, back = nums.length - 1, middle = 0; boolean isFound = false;\nwhile((front <= back) && (!isFound))\n{\n\tmiddle = (front + back) / 2;\n\tif (nums[middle] < target)\n\t{\n\t\tfront = middle + 1;\n\t}\n\telse if(nums[middle] > target)\n\t{\n\t\tback = middle - 1;\n\t}\n\telse\n\t{\n\t\tisFound = true;\n\t}\n}\nif (isFound)\n{\n System.out.println(\"Found at\" + middle);\n}\nelse\n{\n System.out.println(\"Target Not Found\");\n}\nOn the AP Exam, you will not be required to write a search algorithm; however, you will be required to recognize a search algorithm and trace it, which can be done the easy way if you understand the algorithm, or the hard way by actually tracing the code, step by step. Try to identify the key characteristics of each search; for example, the \u201csum divided by 2\u201d line is a good indicator of a binary search. The enhanced-for loop will traverse the entire array, which may indicate a sequential search.\n\n\nThe following question asks about a hypothetical program or design choice with multiple options:\n\n###\n\n", "completion": "Question: Assuming target is in array a, which of the following methods will correctly return the index of target in sorted array a?\nI. public int findTarget(int[] a, int target)\n{\n    for (int x = 0; x < a.length; x++)\n        if (a[x] == target)\n    return x;\n}\nII. public int findTarget(int[] a, int target)\n{\n    int k = 0;\n    for (int x : a)\n    {\n        if (x == target)\n            return k;\n        k++;\n    }\n    return -1;\n}\nIII. public int findTarget(int[] a, int target)\n{\n    int f = 0, h = a.length, g = 0;\n    for (int i = 0; i < h; i++)\n    {\n        g = (f + h)/2;\n        if (a[g] < target)\n            f = g + 1;\n        else if (a[g] > target)\n            h = g \u2013 1;\n    }\n    if (a[g] == target)\n        return g;\n    return -1;\n}\nCorrect: II and III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets\u2014these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it\u2019s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet\u2019s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet\u2019s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn\u2019t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array\u2019s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total / len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total / len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: What is the length of the array numbers after the following code executes?\nString word = \"Bear\";\nint[] numbers = new int[word.length() - 1];\n\nCorrect: 3\nIncorrect: 1\nIncorrect: 4\nIncorrect: 6\nIncorrect: The array will not be created due to a compile-time error.\n\nEND"}
{"prompt": "An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets\u2014these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it\u2019s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet\u2019s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet\u2019s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn\u2019t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array\u2019s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total / len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total / len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nString[] s = new String[2];\nString[] t = {\"Michael\", \"Megan\", \"Chelsea\"};\ns = t;\nSystem.out.print(s.length);\n\nWhat is printed as a result of executing the code segment?\nCorrect: 3\nIncorrect: 1\nIncorrect: 2\nIncorrect: Nothing will be printed due to a compile-time error.\nIncorrect: Nothing will be printed due to a run-time error.\n\nEND"}
{"prompt": "An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets\u2014these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it\u2019s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet\u2019s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet\u2019s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn\u2019t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array\u2019s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total / len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total / len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nfinal int[] a1 = {1, 2};\nint[] b1 = {3, 4};\na1 = b1;\nSystem.out.print(a1[1]);\n\nWhat is printed as a result of executing the code segment?\nCorrect: Nothing will be printed due to a compile-time error.\nIncorrect: 2\nIncorrect: 3\nIncorrect: 4\nIncorrect: Nothing will be printed due to a run-time error.\n\nEND"}
{"prompt": "An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets\u2014these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it\u2019s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet\u2019s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet\u2019s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn\u2019t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array\u2019s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total / len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total / len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nfinal int[] myArray = {1, 2};\nmyArray[1] = 3;\nSystem.out.print(myArray[1]);\n\nWhat is printed as a result of executing the code segment?\nCorrect: 3\nIncorrect: 1\nIncorrect: 2\nIncorrect: Nothing will be printed due to a run-time error.\nIncorrect: Nothing will be printed due to a compile-time error.\n\nEND"}
{"prompt": "Once data is stored in an array, a common task is to methodically search the array for given data. Consider a line of parked cars in the \u201cCurbside To Go\u201d section of your local chain restaurant. When the server is taking the food to a particular car, she must use a given attribute\u2014say, a license plate number \u2014to find the correct car. Once the correct car is found, the server can deliver the food and then go back inside for the next order, beginning the process all over again\u2026and again\u2026and again.\nThis same technique is used for searching an array. In APCS, we have two methods of searching arrays, the sequential search and the binary search. Since each of these search methods uses a distinct formula to search through the arrays, they are commonly referred to as search algorithms.\nThe chain restaurant example given above is an example of a sequential search. All of the cars are \u201clined up\u201d and the server begins with the first car, checking its license plate number against the one she is looking for. If it\u2019s correct, the server delivers the food and returns. If not, she moves on to the next car and repeats the process; this all ends when either (1) the correct car is found or (2) the correct car is not in the line at all. This sequential process works just fine, although it can be very tedious. The server would have to do much more work if the desired car were at the end of the line, as opposed to at the beginning. Remember, we are programming a computer; the server cannot simply \u201clook\u201d at all of the plates at once, as we might in real life. The computer does not know how to \u201clook,\u201d unless we know how to write the program that enables it!\nA code segment that performs a linear search for a number target in an array of integers nums might look like this:\nfor (int i = 0; i < nums.length; i++)\n\tif (nums[i] == target)\n\t\tSystem.out.print(\u201cFound at \" + i);\n\nThis segment will correctly traverse the array, searching for target, starting with index 0 and continuing to index length - 1, as desired. Remember that nums.length is the size of the array and therefore nums[length] would be out of bounds. When target is found, the print statement displays its index number. This process will continue until the end of the array is reached. Note that, if target is never found, there will be no output.\nWhen writing algorithms that traverse arrays, programmers often implement the enhanced-for loop, which is designed specifically for traversing entire arrays. In cases which traversing the entire array is not the intent or would cause a run-time error, the enhanced-for loop should not be used. Assuming nums from the previous example would not cause such a problem, the same code segment can be written as an enhanced-for loop structure like this:\nint loc = 0;\nfor (int num : nums)\n{\n\tif (num == target)\n\t\tSystem.out.print(\u201cfound at \u201d + loc);\n\ti++;\n}\n\nEach time the loop iterates, num will be assigned the value of the next element in the array. This structure automatically ensures that the loop does not go out of bounds. In this case, loc is the location or index in which the target is found.\nIt is important to note that the enhanced-for loop provides a variable that will hold each element of the array. It will NOT automatically provide the index of that element. You will have to add code to keep track of the index if you want to use it.\nA binary search is much more efficient; think of it as a \u201cdivide-and conquer\u201d mechanism. Instead of our restaurant server starting with the beginning of the line of cars, she will start with the middle car. Depending on whether the license plate is \u201cgreater\u201d or \u201cless\u201d than the car she is looking for, the server will move in the appropriate direction.\nThere is a huge obstacle with binary searches, however, or at least, for us with our current level of Java knowledge: these searches work only when there is an inherent order in the data. Suppose the top 21 students in the senior class are lined up in a row. You are looking for a student within that top 21 named Kathy, whom you have never met, but you are not sure where she is in the line. If the students are not lined up in a particular order, a sequential search is your only option, and you might need all 21 tries to find her if she is the last person in the lineup. If they are sorted in alphabetical order by first name, though, you can divide and conquer. Go to the middle person and find out her name\u2026if her name is Sara, you would move toward the front of the line and ignore the back. You then perform the same process, asking the name of the person halfway between the front of the line and Sara, and then ignore the appropriate side. Within a few tries, you will have Kathy.\nHere is a code example of how a binary search might look for array nums when searching for target, assuming nums is sorted:\nint front = 0, back = nums.length - 1, middle = 0; boolean isFound = false;\nwhile((front <= back) && (!isFound))\n{\n\tmiddle = (front + back) / 2;\n\tif (nums[middle] < target)\n\t{\n\t\tfront = middle + 1;\n\t}\n\telse if(nums[middle] > target)\n\t{\n\t\tback = middle - 1;\n\t}\n\telse\n\t{\n\t\tisFound = true;\n\t}\n}\nif (isFound)\n{\n System.out.println(\"Found at\" + middle);\n}\nelse\n{\n System.out.println(\"Target Not Found\");\n}\nOn the AP Exam, you will not be required to write a search algorithm; however, you will be required to recognize a search algorithm and trace it, which can be done the easy way if you understand the algorithm, or the hard way by actually tracing the code, step by step. Try to identify the key characteristics of each search; for example, the \u201csum divided by 2\u201d line is a good indicator of a binary search. The enhanced-for loop will traverse the entire array, which may indicate a sequential search.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the following incomplete method:\npublic static int mod3(int[] numbers)\n{\n    int count = 0;\n    for (int i = 0; i < numbers.length; i++)  {\n        /* mystery code */\n    }\n    return count;\n}\n\nMethod mod3 is intended to return the number of integers in the array numbers that are evenly divisible by 3. Which of the following code segments could be used to replace / * mystery code * / so that mod3 will work as intended?\nI. if (i % 3 == 0)\n{\n    count++;\n}\nII. if (numbers[i] % 3 == 0)\n{\n    count++;\n}\nIII. while (numbers[i] % 3 == 0)\n{\n    count++;\n}\nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II\nIncorrect: II and III\n\nEND"}
{"prompt": "Probably the most useful algorithms you will learn in AP Computer Science A are sorting algorithms\u2014but they are also probably the most difficult to understand. If you\u2019ve been keeping up within this book so far, then you have a good start. \nAs the name implies, sorting algorithms will take data in an array and rearrange it into a particular order. We already know that this technique is useful if we want to search for data using the binary search algorithm. But imagine this automated process in real life: a process that automatically sorts the cups in your cabinet in height order, a process that automatically takes your homework assignments and arranges them in time order, and a process that sorts your to-do list in priority order. Needless to say: sorting algorithms are extremely powerful. \nThe selection sort is the first sorting algorithm we will discuss, and one of the three sorting algorithms you need to know for the AP Exam. This is a search-and-swap algorithm, so you should remember that the selection sort searches and swaps. Similar to a sequential search, the sort will first traverse the array for the lowest value. Once it finds the lowest value, it will swap its position in the array with the data at index 0. Now the first element is sorted. The process then repeats for index 1. The rest of the array will be searched for the lowest value and swapped with the data at index 1. Note that if the lowest value is already in position, it will stay there. \nConsider the array below. We would like to sort this array from least to greatest.\n8 6 10 2 4\n\nOur strategy will be to first find the smallest element in the array and put it in the first position. We will then find the smallest of the remaining elements and put that in the second position. We will continue to do this until the array is ordered. \nWe can start by looking at every element in the array (starting with the first element) and finding the smallest element. It\u2019s easy for a person to quickly glance through the array and see which element is smallest, but the sorting algorithm that we will implement can compare only two elements at once. So here\u2019s how we can find the smallest element: take the number in the first cell in the array and assign it to a variable called smallestSoFar. We\u2019ll also assign the position of that value to a variable called position. In this case, smallestSoFar will equal 8 and position will be 0. Note that even though we are assigning 8 to smallestSoFar, the first cell of the array will contain 8; we didn\u2019t actually remove it. \nsmallestSoFar = 8; \nposition = 0; \n\n8 6 10 2 4\n\nNext we\u2019ll walk through the array and compare the next value to smallestSoFar. The next value is 6, which is less than 8, so smallestSoFar becomes 6 and position becomes 1. \nsmallestSoFar = 6; \nposition = 1; \n\n8 6 10 2 4\n\nNow let\u2019s look at the next value in the array. 10 is larger than 6, so smallestSoFar remains 6.\nsmallestSoFar = 6; \nposition = 1; \n\n8 6 10 2 4\n\nThe next value in the array is 2: 2 is smaller than 6. \nsmallestSoFar = 2; \nposition = 3; \n\n8 6 10 2 4\n\nAnd finally, we look at the last element, 4. Because 4 is greater than 2, and we are at the end of the array, we know that 2 is the smallest element. \nsmallestSoFar = 2; \nposition = 3; \n\n8 6 10 2 4\n\nNow we know that 2 is the smallest element in the array. Because we want to order the array from least to greatest, we need to put 2 in the first cell in the array. We don\u2019t simply want to overwrite the 8 that is in the first cell, though. What we\u2019ll do is swap the 2 with the 8 to get \n\n2 6 10 8 4\n\nWe now have the smallest element in place. Next we\u2019ll need to find the second smallest element in the array. We can do this using the same approach we employed to find the smallest element. Because we know that 2 is the smallest element, we have to look at the elements only in positions 1 to 4 for the second smallest element. \nStart by assigning 6 to smallestSoFar and 1 to position and then compare 6 to 10. Six is the smaller element. Next, compare 6 to 8; 6 is still the smaller element. Finally, compare 6 to 4; 4 is smaller, and because we have no more elements in the array, 4 must be the second smallest element in the array. \nSwap 4 with the second element in the array to get \n\n2 4 10 8 6\n\nMake another pass through the array to find the third smallest element, and swap it into the third cell. The third smallest element is 6. \n\n2 4 6 8 10\n\nFinally, we look at the last two elements. Eight is smaller than 10, so we don\u2019t need to do anything. Our array is now sorted from least to greatest. \n\nHere is how a selection sort can be implemented in Java. The following implementation will sort the elements from least to greatest and will begin by sorting the smallest elements first. \n//precondition: numbers is an array of ints \n//postcondition: numbers is sorted in ascending order \n1 public static void selectionSort1(int[] numbers) 2 { \n3 for (int i = 0; i < numbers.length \u2013 1; i++) 4 { \n5 int position = i; \n6 for (int k = i + 1; k < numbers.length; k++) 7 { \n8 if (numbers[k] < numbers[position]) \n9 { \n10 position = k; \n11 } \n12 } \n13 int temp = numbers[i];\n14 numbers[i] = numbers[position]; \n15 numbers[position] = temp; \n16 } \n17 } \nHow could this be useful? Consider a case in which you have an unsorted array of 1,000 Student objects, and each Student object has a method that returns a grade point average for that Student. What if you would like to find the five students with the highest grade point average? In this case, it would be a waste of time to sort the entire array. Instead, we can just run through five cycles of the second implementation of the selection sort shown above, and the top five students will be sorted. \n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Assume that an array arr of integer values has been declared and initialized with random numbers.\nWhich of the following code segments correctly swaps the values stored in arr[0] and arr[3]?\nCorrect: int k = arr[3];\narr[3] = arr[0];\narr[0] = k;\nIncorrect: arr[0] = 3;\narr[3] = 0;\nIncorrect: arr[0] = arr[3];\narr[3] = arr[0];\nIncorrect: int k = arr[3];\narr[0] = arr[3];\narr[3] = k;\nIncorrect: int k = arr[0];\narr[3] = arr[0];\narr[0] = k;\n\nEND"}
{"prompt": "Once data is stored in an array, a common task is to methodically search the array for given data. Consider a line of parked cars in the \u201cCurbside To Go\u201d section of your local chain restaurant. When the server is taking the food to a particular car, she must use a given attribute\u2014say, a license plate number \u2014to find the correct car. Once the correct car is found, the server can deliver the food and then go back inside for the next order, beginning the process all over again\u2026and again\u2026and again.\nThis same technique is used for searching an array. In APCS, we have two methods of searching arrays, the sequential search and the binary search. Since each of these search methods uses a distinct formula to search through the arrays, they are commonly referred to as search algorithms.\nThe chain restaurant example given above is an example of a sequential search. All of the cars are \u201clined up\u201d and the server begins with the first car, checking its license plate number against the one she is looking for. If it\u2019s correct, the server delivers the food and returns. If not, she moves on to the next car and repeats the process; this all ends when either (1) the correct car is found or (2) the correct car is not in the line at all. This sequential process works just fine, although it can be very tedious. The server would have to do much more work if the desired car were at the end of the line, as opposed to at the beginning. Remember, we are programming a computer; the server cannot simply \u201clook\u201d at all of the plates at once, as we might in real life. The computer does not know how to \u201clook,\u201d unless we know how to write the program that enables it!\nA code segment that performs a linear search for a number target in an array of integers nums might look like this:\nfor (int i = 0; i < nums.length; i++)\n\tif (nums[i] == target)\n\t\tSystem.out.print(\u201cFound at \" + i);\n\nThis segment will correctly traverse the array, searching for target, starting with index 0 and continuing to index length - 1, as desired. Remember that nums.length is the size of the array and therefore nums[length] would be out of bounds. When target is found, the print statement displays its index number. This process will continue until the end of the array is reached. Note that, if target is never found, there will be no output.\nWhen writing algorithms that traverse arrays, programmers often implement the enhanced-for loop, which is designed specifically for traversing entire arrays. In cases which traversing the entire array is not the intent or would cause a run-time error, the enhanced-for loop should not be used. Assuming nums from the previous example would not cause such a problem, the same code segment can be written as an enhanced-for loop structure like this:\nint loc = 0;\nfor (int num : nums)\n{\n\tif (num == target)\n\t\tSystem.out.print(\u201cfound at \u201d + loc);\n\ti++;\n}\n\nEach time the loop iterates, num will be assigned the value of the next element in the array. This structure automatically ensures that the loop does not go out of bounds. In this case, loc is the location or index in which the target is found.\nIt is important to note that the enhanced-for loop provides a variable that will hold each element of the array. It will NOT automatically provide the index of that element. You will have to add code to keep track of the index if you want to use it.\nA binary search is much more efficient; think of it as a \u201cdivide-and conquer\u201d mechanism. Instead of our restaurant server starting with the beginning of the line of cars, she will start with the middle car. Depending on whether the license plate is \u201cgreater\u201d or \u201cless\u201d than the car she is looking for, the server will move in the appropriate direction.\nThere is a huge obstacle with binary searches, however, or at least, for us with our current level of Java knowledge: these searches work only when there is an inherent order in the data. Suppose the top 21 students in the senior class are lined up in a row. You are looking for a student within that top 21 named Kathy, whom you have never met, but you are not sure where she is in the line. If the students are not lined up in a particular order, a sequential search is your only option, and you might need all 21 tries to find her if she is the last person in the lineup. If they are sorted in alphabetical order by first name, though, you can divide and conquer. Go to the middle person and find out her name\u2026if her name is Sara, you would move toward the front of the line and ignore the back. You then perform the same process, asking the name of the person halfway between the front of the line and Sara, and then ignore the appropriate side. Within a few tries, you will have Kathy.\nHere is a code example of how a binary search might look for array nums when searching for target, assuming nums is sorted:\nint front = 0, back = nums.length - 1, middle = 0; boolean isFound = false;\nwhile((front <= back) && (!isFound))\n{\n\tmiddle = (front + back) / 2;\n\tif (nums[middle] < target)\n\t{\n\t\tfront = middle + 1;\n\t}\n\telse if(nums[middle] > target)\n\t{\n\t\tback = middle - 1;\n\t}\n\telse\n\t{\n\t\tisFound = true;\n\t}\n}\nif (isFound)\n{\n System.out.println(\"Found at\" + middle);\n}\nelse\n{\n System.out.println(\"Target Not Found\");\n}\nOn the AP Exam, you will not be required to write a search algorithm; however, you will be required to recognize a search algorithm and trace it, which can be done the easy way if you understand the algorithm, or the hard way by actually tracing the code, step by step. Try to identify the key characteristics of each search; for example, the \u201csum divided by 2\u201d line is a good indicator of a binary search. The enhanced-for loop will traverse the entire array, which may indicate a sequential search.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint [] scores = {75, 63, 52, 80};\nfor (int s : scores)\n{\n    if (s < 75)\n    {\n        s += 5;\n    }\n}\nfor (int s : scores)\n{\n    System.out.print(s + \" \");\n}\n\nWhat is printed as a result of executing the code segment?\nCorrect: 75 63 52 80\nIncorrect: 75 68 57 80\nIncorrect: 80 68 57 80\nIncorrect: 80 68 57 85\nIncorrect: Nothing will be printed due to a compile-time error.\n\nEND"}
{"prompt": "An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets\u2014these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it\u2019s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet\u2019s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet\u2019s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn\u2019t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array\u2019s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total / len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total / len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nString [] names = {\"Abi\", \"Brianna\", \"Jada\", \"Kiara\", \"Tiffany\", \"Vanessa\"};\nint middle = names.length/2 - 1;\nfor (int x = 0; x < middle; x++)\n{\n    String hold = names[x];\n    names[x] = names [names.length - x - 1];\n    names[names.length - x - 1] = hold;\n}\nfor (String n: names)\n{\n    System.out.print(n + \" \");\n}\nWhat is printed as a result of executing the code segment?\nCorrect: Vanessa Tiffany Jada Kiara Brianna Abi\nIncorrect: Abi Brianna Jada Kiara Tiffany Vanessa\nIncorrect: Abi Jada Brianna Vanessa Kiara Tiffany\nIncorrect: Vanessa Tiffany Kiara Jada Brianna Abi\nIncorrect: Vanessa Brianna Jada Kiara Tiffany Abi\nEND"}
{"prompt": "Computer Science (CS) is an official name used for many aspects of computing, usually on the developing end; its areas include computer programming, which is exactly what we will be doing in AP Computer Science A (APCS). APCS focuses on the language Java and its components, and in many cases, you will be the programmer. Although the person using your program (the user) will typically see only the end result of your program, CS gives you the tools to write statements (code) that will ideally make the user\u2019s experience both functional and enjoyable. \nComputer programming is similar to a foreign language; it has nouns, verbs, and other parts of speech, and it has different forms of style, just like speaking languages. Just as you might use different words and ways of speaking\u2014tone, expressions, etc.\u2014with your family versus your friends, CS has many different languages and, within each language, its own ways of getting the job done. In both the CS world and the APCS world, a particular programming style is expected in order to show fluency in the language. A company that might hire you for a CS job will likely expect you to conform to its own unique programming style; similarly, the College Board will expect you to conform to its accepted programming style based on its research of CS styles accepted at universities around the world. \nCommenting is an extremely vital style technique in the programming world. Comments do not actually cause the program to behave any differently, however, comments serve many purposes, including: allowing programmers to make \u201cnotes\u201d within the program that they may want to reference later allowing the person reading and/or using the program (\u201cthe reader\u201d and/or \u201cthe user\u201d) to understand the code in a less cryptic way, when applicablerevealing to the programmer/reader/user aspects of the program that are required to make the program operate as intended and/or are produced as a result of the program\u2019s execution \nThere are two types of commenting in Java. In-line, or short, comments appear after or near a statement and are preceded by two forward slashes (\u201c//\u201d) followed by the comment. Long comments that extend beyond a single line of code are surrounded by special characters; they begin with (\u201c/*\u201d) and end with (\u201c*/\u201d). \n\nFor example, \n// This is a short comment \n/* This is a \nlong comment */ \n\nIdentifiers are names that are given to represent data stored in the memory of the computer during the program\u2019s execution. Rather than using a nonsensical memory address code to reference data, Java allows the programmer to name an identifier to perform this job. When we name identifiers in Java, there are guidelines that we must use and guidelines that the College Board expects us to use: \nAn identifier may contain any combination of letters, numbers, and underscore (\u201c_\u201d), but must begin with a letter and may not contain any other characters than these, including spaces. An identifier should be a logical name that corresponds to the data it is associated with; for example, an identifier associated with the side of a triangle would be more useful as side1 instead of s. An identifier should begin with a lowercase letter and, if it is composed of several words, should denote each subsequent word with a capital letter. If we decided to create an identifier associated with our triangle\u2019s number of sides, numberOfSides or numOfSides would conform to this style; NumberOfSides and numofsides would not.\n\nWhite space is another element of style that does not affect the overall functionality of the program. Rather, it enhances the readability of the program by allowing the programmer to space out the code to separate specific statements or tasks from others. Much like a book may leave empty space at the end of a chapter and begin the next chapter on the next page without affecting the overall story, white space has a similar effect. \nWhen the programmer writes Java code, statements are written that are understood within a Java development environment. The computer, however, does not understand this language, much like you would likely not understand a foreign language that you have never studied, spoken in its native environment. Therefore, an interpreter is used within the developer environment, enabling the computer to understand the Java code. A computer operates using code written only in binary (zeroes and ones, literally!), and so the interpreter \u201ctranslates\u201d your Java code into binary. This process is called compiling. As a result, in most instances as well as on the AP Exam, modern computer programmers do not need to understand binary code directly. \nWhen an interactive development environment (\u201cIDE\u201d) is used to compile your code, the code will be automatically checked for basic programming errors. If an error is found within the code, the compiling is halted and an error message is produced (this feedback is where the \u201cinteractive\u201d part comes in); this situation is called a compile-time error. Although the error message/code is not always helpful in a direct way, it does allow the programmer to troubleshoot the issue in a more directed way. Unfortunately, since the AP Exam is a pencil-and-paper test, you will have access to neither a computer nor a compiler. Your code must be absent of errors in order to receive full credit for the response (or any credit if it\u2019s a multiple-choice question).\nA logical error is more difficult to troubleshoot, as opposed to a problem with the syntax of the Java code itself. A logical error lies in the desired output/purpose of the program. Similar to ordering dinner and receiving a perfectly prepared dessert instead, you are getting a good result, but it is not appropriate for the desired task. \nA run-time error is an error that is not caught by the compiler, yet produces an error during the execution of the program. In many ways, this is the worst (and most embarrassing) error for the programmer, because it is not realized until the task is supposedly \u201cdone.\u201d An example might be a crash that occurs when you are editing your favorite image in a graphics program. It\u2019s frustrating for the user and annoying for the programmer when you leave negative feedback on the company\u2019s website! \n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Assuming all other statements in the program are correct, each of the following statements will allow the program to compile EXCEPT\nCorrect: All of the above statements will compile.\n\n\nIncorrect: // This is a comment\nIncorrect: /* This is a comment */\nIncorrect: // myName is a good identifier name\nIncorrect: // myname is a good identifier nameEND"}
{"prompt": "Computer Science (CS) is an official name used for many aspects of computing, usually on the developing end; its areas include computer programming, which is exactly what we will be doing in AP Computer Science A (APCS). APCS focuses on the language Java and its components, and in many cases, you will be the programmer. Although the person using your program (the user) will typically see only the end result of your program, CS gives you the tools to write statements (code) that will ideally make the user\u2019s experience both functional and enjoyable. \nComputer programming is similar to a foreign language; it has nouns, verbs, and other parts of speech, and it has different forms of style, just like speaking languages. Just as you might use different words and ways of speaking\u2014tone, expressions, etc.\u2014with your family versus your friends, CS has many different languages and, within each language, its own ways of getting the job done. In both the CS world and the APCS world, a particular programming style is expected in order to show fluency in the language. A company that might hire you for a CS job will likely expect you to conform to its own unique programming style; similarly, the College Board will expect you to conform to its accepted programming style based on its research of CS styles accepted at universities around the world. \nCommenting is an extremely vital style technique in the programming world. Comments do not actually cause the program to behave any differently, however, comments serve many purposes, including: allowing programmers to make \u201cnotes\u201d within the program that they may want to reference later allowing the person reading and/or using the program (\u201cthe reader\u201d and/or \u201cthe user\u201d) to understand the code in a less cryptic way, when applicablerevealing to the programmer/reader/user aspects of the program that are required to make the program operate as intended and/or are produced as a result of the program\u2019s execution \nThere are two types of commenting in Java. In-line, or short, comments appear after or near a statement and are preceded by two forward slashes (\u201c//\u201d) followed by the comment. Long comments that extend beyond a single line of code are surrounded by special characters; they begin with (\u201c/*\u201d) and end with (\u201c*/\u201d). \n\nFor example, \n// This is a short comment \n/* This is a \nlong comment */ \n\nIdentifiers are names that are given to represent data stored in the memory of the computer during the program\u2019s execution. Rather than using a nonsensical memory address code to reference data, Java allows the programmer to name an identifier to perform this job. When we name identifiers in Java, there are guidelines that we must use and guidelines that the College Board expects us to use: \nAn identifier may contain any combination of letters, numbers, and underscore (\u201c_\u201d), but must begin with a letter and may not contain any other characters than these, including spaces. An identifier should be a logical name that corresponds to the data it is associated with; for example, an identifier associated with the side of a triangle would be more useful as side1 instead of s. An identifier should begin with a lowercase letter and, if it is composed of several words, should denote each subsequent word with a capital letter. If we decided to create an identifier associated with our triangle\u2019s number of sides, numberOfSides or numOfSides would conform to this style; NumberOfSides and numofsides would not.\n\nWhite space is another element of style that does not affect the overall functionality of the program. Rather, it enhances the readability of the program by allowing the programmer to space out the code to separate specific statements or tasks from others. Much like a book may leave empty space at the end of a chapter and begin the next chapter on the next page without affecting the overall story, white space has a similar effect. \nWhen the programmer writes Java code, statements are written that are understood within a Java development environment. The computer, however, does not understand this language, much like you would likely not understand a foreign language that you have never studied, spoken in its native environment. Therefore, an interpreter is used within the developer environment, enabling the computer to understand the Java code. A computer operates using code written only in binary (zeroes and ones, literally!), and so the interpreter \u201ctranslates\u201d your Java code into binary. This process is called compiling. As a result, in most instances as well as on the AP Exam, modern computer programmers do not need to understand binary code directly. \nWhen an interactive development environment (\u201cIDE\u201d) is used to compile your code, the code will be automatically checked for basic programming errors. If an error is found within the code, the compiling is halted and an error message is produced (this feedback is where the \u201cinteractive\u201d part comes in); this situation is called a compile-time error. Although the error message/code is not always helpful in a direct way, it does allow the programmer to troubleshoot the issue in a more directed way. Unfortunately, since the AP Exam is a pencil-and-paper test, you will have access to neither a computer nor a compiler. Your code must be absent of errors in order to receive full credit for the response (or any credit if it\u2019s a multiple-choice question).\nA logical error is more difficult to troubleshoot, as opposed to a problem with the syntax of the Java code itself. A logical error lies in the desired output/purpose of the program. Similar to ordering dinner and receiving a perfectly prepared dessert instead, you are getting a good result, but it is not appropriate for the desired task. \nA run-time error is an error that is not caught by the compiler, yet produces an error during the execution of the program. In many ways, this is the worst (and most embarrassing) error for the programmer, because it is not realized until the task is supposedly \u201cdone.\u201d An example might be a crash that occurs when you are editing your favorite image in a graphics program. It\u2019s frustrating for the user and annoying for the programmer when you leave negative feedback on the company\u2019s website! \n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Assuming all other statements in the program are correct, each of the following statements will allow the program to compile EXCEPT\nCorrect: System.out.print(side1);\nIncorrect: System.out.print(1);\nIncorrect: System.out.print(\"1\");\nIncorrect: System.out.print(\"side1\");\nIncorrect: All of the above statements will compile.\n\nEND"}
{"prompt": "In order for your program to \u201cdo anything\u201d from the user\u2019s perspective (at this level, anyway!), it must produce output to the screen. A program may produce output to many devices, including storage drives and printers, but APCS requires us to produce output only to the screen. \n\nThere are two similar statements that we use to produce output to the screen in this course: \nSystem.out.print(\u2026); \nSystem.out.println(\u2026); \n\nThe ellipses in these statements stand for the data and/or identifiers that will be displayed on the screen. We will see the difference between these statements in a minute. \nFor example, if a triangle has a side length of 2 stored in the memory using the identifier side1 and we wanted to output that information to the screen, we could use one of the following two commands: \nSystem.out.print(2); \nSystem.out.print(side1); \n\nSince both 2 and side1 represent numerical values, they can be outputted to the screen in this way. If we wanted to display non-numerical data, however, we would use a string literal (or simply a string) to accomplish this task. A string literal is simply one or more characters combined into a single unit. The previous sentence, and this sentence, can be considered string literals. In a Java program, string literals must be surrounded by double quotes (\u201c\u201d) to avoid a compile error. In our triangle example, we can use a string literal to make the output more user-friendly: \nSystem.out.println(\"The length of side 1 is:\"); \nSystem.out.print(side1); \n// side1 may be simply substituted with 2, in this case \n\nNote the usage of the println statement rather than the print statement. While print will display the next output on the same line, println will output the string literal and then put the cursor at the beginning of the next line for further output. Note, also, that the statement \nSystem.out.print(side1); \n\nwill display the value stored using the side1 identifier, 2. In contrast, the statement \nSystem.out.print(\"side1\"); \n\nwill literally display \nside1 \nbecause the double quotes create a string literal here. The College Board loves to ask multiple-choice questions that determine whether you understand these differences. \n\nIf quotation marks are how programmers signal the beginning and end of a string literal, how would they display quotation marks? For example, what if an instructional program was intended to display \nBe sure to display the value of side1, not \"side 1\".\n\nThe command below might seem like an appropriate solution but would actually cause a compile-time error. \nSystem.out.print(\"Be sure to display the value of side1, not \"side 1\".\"); \n\nThe complier will interpret the quotation mark in front of side1 as the close of the string and will not know what to do with the rest of it. To display a quotation mark, the programmer must use an escape sequence, a small piece of coding beginning with a backslash (\\) used to indicate specific characters. To successfully display the above live, use the command \nSystem.out.print(\u201cBe sure to print the value of side1, not \\\"side1\\\".\"); \n\nSimilarly, the escape sequence \\n can be used to create a line break in the middle of a string. For example the command \nSystem.out.print(\"The first line\\nThe second line\");\n\nwill display \nThe first line \nThe second line \n\nSo if a backslash indicates an escape sequence, how does a programmer print a backslash? This is done using another escape sequence, \\\\. The following command \nSystem.out.println(\"Use \\\\n to indicate a new line.\"); will display \n\nUse \\n to indicate a new line.\nThere are other escape sequences in Java, but only these three appear on the AP Computer Science A Exam. \n\nAs you might imagine, input is also important in programming. Although you may learn some techniques for getting user input (the Scanner class, for example), the AP Exam will not test any input methods or classes. Instead, the input will be assumed and given as a comment in the coding. It may be similar to this. \nint k = ..., //read user input \nYou will not be asked to prompt the user for input, unless there is pre-existing code in the task that does it for you. Nice.\nLet\u2019s put those identifiers to work. \nIn order to actually \u201ccreate\u201d an identifier, we need to assign a data value to that identifier. This task is done by writing an assignment statement. \nThe syntax of an assignment statement is \ntype identifier = data; \n\nContinuing with our triangle example, if we wanted to actually assign the data value of 2 to a new identifier called side1, we could use this statement: \nint side1 = 2; \n\nThis statement tells the compiler that (1) our identifier is called side1, (2) the data assigned to that identifier should be 2, and (3) our data is an integer (more on this in the next section). The equals sign (\u201c=\u201d) is called an assignment operator and is required by Java. The semicolon, which we also saw in the output statements above, denotes that the statement is finished. Note that an assignment statement does NOT produce any output to the screen. \nWhen data is associated with an identifier, the identifier is called a variable. The reason we use this term is that, as in math, the value of the variable can be changed; it can vary! Look at the following code: \n\nint myFavoriteNumber = 22; \nmyFavoriteNumber = 78; \nSystem.out.print(\"My favorite number is \" + myFavoriteNumber); \n\nCan you predict the output? The variable myFavoriteNumber is first assigned the value of 22, but it is then reassigned to the value 78. Therefore, the original value is no longer stored in the computer\u2019s memory and the 78 remains. The output would be\nMy favorite number is 78 \n\nA few items to note in this example: \nOnce a variable is given a type (again, more on this later), its type should not be restated. This fact explains why the second assignment statement is missing int. \nThe string literal is outputted as written, but the variable\u2019s value, not its name, is outputted. \nIn order to output a string literal and a numerical value using the same output statement, use the concatenation operator between the two items. Although this operator looks like a typical + sign, it does not \u201cadd\u201d the values in the traditional sense; instead, it simply outputs the two values next to each other. For example, two plus two equals four in the mathematical sense, but 2 concatenated with 2 produces 22. \n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Assuming all other statements in the program are correct, each of the following statements will allow the program to compile EXCEPT\nCorrect: System.out.print(1 + \"love\" + Java\");\nIncorrect: System.out.print(\"Ilove Java\");\nIncorrect: System.out.println(\"Ilove\" + \"Java\");\nIncorrect: System.out.println(1 + \"love\" + \"Java\");\nIncorrect: System.out.print(\"I love\" + \" \" + \"Java\");\n\nEND"}
{"prompt": "The most primitive uses for the first computers were to perform complex calculations. They were basically gigantic calculators. As a result, one of the most basic operations we use in Java involves arithmetic. \nThe symbols +, -, *, and / represent the operations addition, subtraction, multiplication, and division, respectively. The operator % is also used in Java: called the \u201cmodulus\u201d operator, this symbol will produce the numerical remainder of a division. For example, 3 % 2 would evaluate to 1, since 3 divided by 2 yields 1, with 1 as a remainder. These operations can be performed intuitively on numerical values; they can also be performed on variables that store numerical values.\nSpeaking of math, back to our triangle example\u2026 \nConsider the following statement in a program: \nint side2 = 2, side3 = 3; \n\n(Note that you can write multiple assignment statements in a single line, as long as the data types are the same.) \nIf we wanted to write a statement that found the sum of these data and assigned the result to another variable called sumOfSides, we could easily write \nsumOfSides = 2 + 3; // method 1 \n\nBut this statement is less useful than \nsumOfSides = side2 + side3; // method 2 \n\nSince the data is assigned to variables, for which values can vary, method 2 will reflect those changes while method 1 will not. \nThis same technique can be applied to all of the mathematical operators. Remember that a mixture of mathematical operations follows a specific order of precedence. Java will perform the multiplication and division operations (including modulus), from left to right, followed by the addition and subtraction operations in the same order. If programmers want to change the order of precedence of the operators, they can use parentheses. \nConsider these lines of code: \nSystem.out.print(3 - 4/5); // statement 3 \nSystem.out.print(3 -(4/5)); // statement 4 \nSystem.out.print((3 - 4)/5); // statement 5\n\nIn statement 3, the division occurs first, followed by the subtraction (3 minus the answer). \nIn statement 4, the same thing happens, so it is mathematically equivalent to statement 3. \nIn statement 5, the parentheses override the order of operations, so the subtraction occurs, and then the answer is divided by 5. \nOkay, here\u2019s where it gets crazy. Can you predict the output of these statements? Believe it or not, the output of statements 3 and 4 is 3; the output of statement 5 is 0. These results demonstrate the fact that data in Java is strongly typed. \nWhen you perform a mathematical operation on two integers, Java will return the answer as an integer, as well. Therefore, although 4/5 is actually 0.8, Java will return a value of 0. Likewise, Java will evaluate 5/4 to be 1. The decimal part is cut off (not rounded), so that the result will also be an integer. Negative numbers work the same way. Java will return \u20134/5 as 0 and \u20135/4 as \u20131. Strange, huh? \n\nAs is true with all computer science, there is a workaround for this called casting. Casting is a process through which data is forced to \u201clook like\u201d another type of data to the compiler. Think of someone who is cast in a show to play a part; although actors have personal identities, they assume new identities for the audience. The following modifications to statement 3 demonstrate different ways of casting: \nSystem.out.print(3 - (double)(4)/5); // statement 3.1\nSystem.out.print(3 - 4/(double)5); // statement 3.2 \n\nThese statements will cast 4 and 5, respectively, to be double values of 4.0 and 5.0. As a result, the division will be \u201cupgraded\u201d to a division between double values, not integers, and the desired result will be returned. The following statements, although they will compile without error, will not display the desired result of 2.2. \nSystem.out.print((double)3 - 4/5); // statement 3.3 \nSystem.out.print(3 - (double)(4/5)); // statement 3.4 \n\nCasting has a higher precedence than arithmetic operators, except parentheses, of course. Therefore, statement 3.3 will first convert 3 to 3.0, but will then perform integer division before completing the subtracting. The result is 3.0. In statement 3.4, the result of dividing the integers is cast to a double; since the integer division evaluates to 0, the cast will simply make the result 0.0, yielding an output of 3.0 once again. Very tricky! \nThe increment operator (++) is used to increase the value of a number by one. For example, if the value of a variable x is 3, then x++ will increment the value of x to 4. This has the exact same effect as writing x = x + 1, and is nothing more than convenient shorthand. \nConversely, the decrement operator (--) is used to quickly decrease the value of a number by one. For example, if the value of a variable named x is 3, then x-- decreases the value of x to 2. This has the exact same effect as writing x = x \u2013 1. \nOther shortcut operators include +=, -=, *=, /=, and %=. These shortcuts perform the indicated operation and assign the result to the original variable. For example, \na += b; \n\nis an equivalent command to \na = a + b;\nHumans are pretty smart when it comes to guessing intent For instance, you probably noticed that there\u2019s a missing period between this sentence and the one before it. (If not, slow down: AP Computer Science A Exam questions require close reading when looking for errors.) Computers, on the other hand, are literal\u2014more annoyingly so, probably, than those teachers who ask whether you\u2019re physically capable of going to the bathroom when you ask whether you can go. To that end, then, it\u2019s crucial that you end each complete statement (i.e., sentence) with a semicolon, which is our way of telling the Java compiler that it\u2019s reached the end of a step. This doesn\u2019t mean that you need to place a semicolon after every line\u2014 remember that line breaks exist only to make code more readable to humans \u2014but you must place one after any complete declaration or statement. \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint a = 3;\nint b = 6;\nint c = 8;\nint d = a / b;\nc /= d;\nSystem.out.print(c);\n\nWhich of the following will be output by the code segment?\nCorrect: There will be no output because of a run-time error.\n\n\nIncorrect: 4\nIncorrect: 8\nIncorrect: 12\nIncorrect: 16END"}
{"prompt": "The most primitive uses for the first computers were to perform complex calculations. They were basically gigantic calculators. As a result, one of the most basic operations we use in Java involves arithmetic. \nThe symbols +, -, *, and / represent the operations addition, subtraction, multiplication, and division, respectively. The operator % is also used in Java: called the \u201cmodulus\u201d operator, this symbol will produce the numerical remainder of a division. For example, 3 % 2 would evaluate to 1, since 3 divided by 2 yields 1, with 1 as a remainder. These operations can be performed intuitively on numerical values; they can also be performed on variables that store numerical values.\nSpeaking of math, back to our triangle example\u2026 \nConsider the following statement in a program: \nint side2 = 2, side3 = 3; \n\n(Note that you can write multiple assignment statements in a single line, as long as the data types are the same.) \nIf we wanted to write a statement that found the sum of these data and assigned the result to another variable called sumOfSides, we could easily write \nsumOfSides = 2 + 3; // method 1 \n\nBut this statement is less useful than \nsumOfSides = side2 + side3; // method 2 \n\nSince the data is assigned to variables, for which values can vary, method 2 will reflect those changes while method 1 will not. \nThis same technique can be applied to all of the mathematical operators. Remember that a mixture of mathematical operations follows a specific order of precedence. Java will perform the multiplication and division operations (including modulus), from left to right, followed by the addition and subtraction operations in the same order. If programmers want to change the order of precedence of the operators, they can use parentheses. \nConsider these lines of code: \nSystem.out.print(3 - 4/5); // statement 3 \nSystem.out.print(3 -(4/5)); // statement 4 \nSystem.out.print((3 - 4)/5); // statement 5\n\nIn statement 3, the division occurs first, followed by the subtraction (3 minus the answer). \nIn statement 4, the same thing happens, so it is mathematically equivalent to statement 3. \nIn statement 5, the parentheses override the order of operations, so the subtraction occurs, and then the answer is divided by 5. \nOkay, here\u2019s where it gets crazy. Can you predict the output of these statements? Believe it or not, the output of statements 3 and 4 is 3; the output of statement 5 is 0. These results demonstrate the fact that data in Java is strongly typed. \nWhen you perform a mathematical operation on two integers, Java will return the answer as an integer, as well. Therefore, although 4/5 is actually 0.8, Java will return a value of 0. Likewise, Java will evaluate 5/4 to be 1. The decimal part is cut off (not rounded), so that the result will also be an integer. Negative numbers work the same way. Java will return \u20134/5 as 0 and \u20135/4 as \u20131. Strange, huh? \n\nAs is true with all computer science, there is a workaround for this called casting. Casting is a process through which data is forced to \u201clook like\u201d another type of data to the compiler. Think of someone who is cast in a show to play a part; although actors have personal identities, they assume new identities for the audience. The following modifications to statement 3 demonstrate different ways of casting: \nSystem.out.print(3 - (double)(4)/5); // statement 3.1\nSystem.out.print(3 - 4/(double)5); // statement 3.2 \n\nThese statements will cast 4 and 5, respectively, to be double values of 4.0 and 5.0. As a result, the division will be \u201cupgraded\u201d to a division between double values, not integers, and the desired result will be returned. The following statements, although they will compile without error, will not display the desired result of 2.2. \nSystem.out.print((double)3 - 4/5); // statement 3.3 \nSystem.out.print(3 - (double)(4/5)); // statement 3.4 \n\nCasting has a higher precedence than arithmetic operators, except parentheses, of course. Therefore, statement 3.3 will first convert 3 to 3.0, but will then perform integer division before completing the subtracting. The result is 3.0. In statement 3.4, the result of dividing the integers is cast to a double; since the integer division evaluates to 0, the cast will simply make the result 0.0, yielding an output of 3.0 once again. Very tricky! \nThe increment operator (++) is used to increase the value of a number by one. For example, if the value of a variable x is 3, then x++ will increment the value of x to 4. This has the exact same effect as writing x = x + 1, and is nothing more than convenient shorthand. \nConversely, the decrement operator (--) is used to quickly decrease the value of a number by one. For example, if the value of a variable named x is 3, then x-- decreases the value of x to 2. This has the exact same effect as writing x = x \u2013 1. \nOther shortcut operators include +=, -=, *=, /=, and %=. These shortcuts perform the indicated operation and assign the result to the original variable. For example, \na += b; \n\nis an equivalent command to \na = a + b;\nHumans are pretty smart when it comes to guessing intent For instance, you probably noticed that there\u2019s a missing period between this sentence and the one before it. (If not, slow down: AP Computer Science A Exam questions require close reading when looking for errors.) Computers, on the other hand, are literal\u2014more annoyingly so, probably, than those teachers who ask whether you\u2019re physically capable of going to the bathroom when you ask whether you can go. To that end, then, it\u2019s crucial that you end each complete statement (i.e., sentence) with a semicolon, which is our way of telling the Java compiler that it\u2019s reached the end of a step. This doesn\u2019t mean that you need to place a semicolon after every line\u2014 remember that line breaks exist only to make code more readable to humans \u2014but you must place one after any complete declaration or statement. \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint a = 10;\ndouble b = 10.7;\ndouble c = a + b;\nint d = a + c;\nSystem.out.println(c + \" \" + d);\n\nWhat will be output as a result of executing the code segment?\nCorrect: Nothing will be printed because of a compile-time error.\n\n\nIncorrect: 20 20\nIncorrect: 20.0 30\nIncorrect: 20.7 31\nIncorrect: 20.730.7END"}
{"prompt": "The most primitive uses for the first computers were to perform complex calculations. They were basically gigantic calculators. As a result, one of the most basic operations we use in Java involves arithmetic. \nThe symbols +, -, *, and / represent the operations addition, subtraction, multiplication, and division, respectively. The operator % is also used in Java: called the \u201cmodulus\u201d operator, this symbol will produce the numerical remainder of a division. For example, 3 % 2 would evaluate to 1, since 3 divided by 2 yields 1, with 1 as a remainder. These operations can be performed intuitively on numerical values; they can also be performed on variables that store numerical values.\nSpeaking of math, back to our triangle example\u2026 \nConsider the following statement in a program: \nint side2 = 2, side3 = 3; \n\n(Note that you can write multiple assignment statements in a single line, as long as the data types are the same.) \nIf we wanted to write a statement that found the sum of these data and assigned the result to another variable called sumOfSides, we could easily write \nsumOfSides = 2 + 3; // method 1 \n\nBut this statement is less useful than \nsumOfSides = side2 + side3; // method 2 \n\nSince the data is assigned to variables, for which values can vary, method 2 will reflect those changes while method 1 will not. \nThis same technique can be applied to all of the mathematical operators. Remember that a mixture of mathematical operations follows a specific order of precedence. Java will perform the multiplication and division operations (including modulus), from left to right, followed by the addition and subtraction operations in the same order. If programmers want to change the order of precedence of the operators, they can use parentheses. \nConsider these lines of code: \nSystem.out.print(3 - 4/5); // statement 3 \nSystem.out.print(3 -(4/5)); // statement 4 \nSystem.out.print((3 - 4)/5); // statement 5\n\nIn statement 3, the division occurs first, followed by the subtraction (3 minus the answer). \nIn statement 4, the same thing happens, so it is mathematically equivalent to statement 3. \nIn statement 5, the parentheses override the order of operations, so the subtraction occurs, and then the answer is divided by 5. \nOkay, here\u2019s where it gets crazy. Can you predict the output of these statements? Believe it or not, the output of statements 3 and 4 is 3; the output of statement 5 is 0. These results demonstrate the fact that data in Java is strongly typed. \nWhen you perform a mathematical operation on two integers, Java will return the answer as an integer, as well. Therefore, although 4/5 is actually 0.8, Java will return a value of 0. Likewise, Java will evaluate 5/4 to be 1. The decimal part is cut off (not rounded), so that the result will also be an integer. Negative numbers work the same way. Java will return \u20134/5 as 0 and \u20135/4 as \u20131. Strange, huh? \n\nAs is true with all computer science, there is a workaround for this called casting. Casting is a process through which data is forced to \u201clook like\u201d another type of data to the compiler. Think of someone who is cast in a show to play a part; although actors have personal identities, they assume new identities for the audience. The following modifications to statement 3 demonstrate different ways of casting: \nSystem.out.print(3 - (double)(4)/5); // statement 3.1\nSystem.out.print(3 - 4/(double)5); // statement 3.2 \n\nThese statements will cast 4 and 5, respectively, to be double values of 4.0 and 5.0. As a result, the division will be \u201cupgraded\u201d to a division between double values, not integers, and the desired result will be returned. The following statements, although they will compile without error, will not display the desired result of 2.2. \nSystem.out.print((double)3 - 4/5); // statement 3.3 \nSystem.out.print(3 - (double)(4/5)); // statement 3.4 \n\nCasting has a higher precedence than arithmetic operators, except parentheses, of course. Therefore, statement 3.3 will first convert 3 to 3.0, but will then perform integer division before completing the subtracting. The result is 3.0. In statement 3.4, the result of dividing the integers is cast to a double; since the integer division evaluates to 0, the cast will simply make the result 0.0, yielding an output of 3.0 once again. Very tricky! \nThe increment operator (++) is used to increase the value of a number by one. For example, if the value of a variable x is 3, then x++ will increment the value of x to 4. This has the exact same effect as writing x = x + 1, and is nothing more than convenient shorthand. \nConversely, the decrement operator (--) is used to quickly decrease the value of a number by one. For example, if the value of a variable named x is 3, then x-- decreases the value of x to 2. This has the exact same effect as writing x = x \u2013 1. \nOther shortcut operators include +=, -=, *=, /=, and %=. These shortcuts perform the indicated operation and assign the result to the original variable. For example, \na += b; \n\nis an equivalent command to \na = a + b;\nHumans are pretty smart when it comes to guessing intent For instance, you probably noticed that there\u2019s a missing period between this sentence and the one before it. (If not, slow down: AP Computer Science A Exam questions require close reading when looking for errors.) Computers, on the other hand, are literal\u2014more annoyingly so, probably, than those teachers who ask whether you\u2019re physically capable of going to the bathroom when you ask whether you can go. To that end, then, it\u2019s crucial that you end each complete statement (i.e., sentence) with a semicolon, which is our way of telling the Java compiler that it\u2019s reached the end of a step. This doesn\u2019t mean that you need to place a semicolon after every line\u2014 remember that line breaks exist only to make code more readable to humans \u2014but you must place one after any complete declaration or statement. \n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the following code segment:\nint a = 10;\ndouble b = 10.7;\nint d = a + b;\n\nLine 3 will not compile in the code segment above. With which of the following statements could we replace this line so that it compiles?\nI. int d = (int) a + b;\nII. int d = (int) (a + b);\nIII. int d = a + (int) b;\nCorrect: II and III only\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and III onlyEND"}
{"prompt": "The most primitive uses for the first computers were to perform complex calculations. They were basically gigantic calculators. As a result, one of the most basic operations we use in Java involves arithmetic. \nThe symbols +, -, *, and / represent the operations addition, subtraction, multiplication, and division, respectively. The operator % is also used in Java: called the \u201cmodulus\u201d operator, this symbol will produce the numerical remainder of a division. For example, 3 % 2 would evaluate to 1, since 3 divided by 2 yields 1, with 1 as a remainder. These operations can be performed intuitively on numerical values; they can also be performed on variables that store numerical values.\nSpeaking of math, back to our triangle example\u2026 \nConsider the following statement in a program: \nint side2 = 2, side3 = 3; \n\n(Note that you can write multiple assignment statements in a single line, as long as the data types are the same.) \nIf we wanted to write a statement that found the sum of these data and assigned the result to another variable called sumOfSides, we could easily write \nsumOfSides = 2 + 3; // method 1 \n\nBut this statement is less useful than \nsumOfSides = side2 + side3; // method 2 \n\nSince the data is assigned to variables, for which values can vary, method 2 will reflect those changes while method 1 will not. \nThis same technique can be applied to all of the mathematical operators. Remember that a mixture of mathematical operations follows a specific order of precedence. Java will perform the multiplication and division operations (including modulus), from left to right, followed by the addition and subtraction operations in the same order. If programmers want to change the order of precedence of the operators, they can use parentheses. \nConsider these lines of code: \nSystem.out.print(3 - 4/5); // statement 3 \nSystem.out.print(3 -(4/5)); // statement 4 \nSystem.out.print((3 - 4)/5); // statement 5\n\nIn statement 3, the division occurs first, followed by the subtraction (3 minus the answer). \nIn statement 4, the same thing happens, so it is mathematically equivalent to statement 3. \nIn statement 5, the parentheses override the order of operations, so the subtraction occurs, and then the answer is divided by 5. \nOkay, here\u2019s where it gets crazy. Can you predict the output of these statements? Believe it or not, the output of statements 3 and 4 is 3; the output of statement 5 is 0. These results demonstrate the fact that data in Java is strongly typed. \nWhen you perform a mathematical operation on two integers, Java will return the answer as an integer, as well. Therefore, although 4/5 is actually 0.8, Java will return a value of 0. Likewise, Java will evaluate 5/4 to be 1. The decimal part is cut off (not rounded), so that the result will also be an integer. Negative numbers work the same way. Java will return \u20134/5 as 0 and \u20135/4 as \u20131. Strange, huh? \n\nAs is true with all computer science, there is a workaround for this called casting. Casting is a process through which data is forced to \u201clook like\u201d another type of data to the compiler. Think of someone who is cast in a show to play a part; although actors have personal identities, they assume new identities for the audience. The following modifications to statement 3 demonstrate different ways of casting: \nSystem.out.print(3 - (double)(4)/5); // statement 3.1\nSystem.out.print(3 - 4/(double)5); // statement 3.2 \n\nThese statements will cast 4 and 5, respectively, to be double values of 4.0 and 5.0. As a result, the division will be \u201cupgraded\u201d to a division between double values, not integers, and the desired result will be returned. The following statements, although they will compile without error, will not display the desired result of 2.2. \nSystem.out.print((double)3 - 4/5); // statement 3.3 \nSystem.out.print(3 - (double)(4/5)); // statement 3.4 \n\nCasting has a higher precedence than arithmetic operators, except parentheses, of course. Therefore, statement 3.3 will first convert 3 to 3.0, but will then perform integer division before completing the subtracting. The result is 3.0. In statement 3.4, the result of dividing the integers is cast to a double; since the integer division evaluates to 0, the cast will simply make the result 0.0, yielding an output of 3.0 once again. Very tricky! \nThe increment operator (++) is used to increase the value of a number by one. For example, if the value of a variable x is 3, then x++ will increment the value of x to 4. This has the exact same effect as writing x = x + 1, and is nothing more than convenient shorthand. \nConversely, the decrement operator (--) is used to quickly decrease the value of a number by one. For example, if the value of a variable named x is 3, then x-- decreases the value of x to 2. This has the exact same effect as writing x = x \u2013 1. \nOther shortcut operators include +=, -=, *=, /=, and %=. These shortcuts perform the indicated operation and assign the result to the original variable. For example, \na += b; \n\nis an equivalent command to \na = a + b;\nHumans are pretty smart when it comes to guessing intent For instance, you probably noticed that there\u2019s a missing period between this sentence and the one before it. (If not, slow down: AP Computer Science A Exam questions require close reading when looking for errors.) Computers, on the other hand, are literal\u2014more annoyingly so, probably, than those teachers who ask whether you\u2019re physically capable of going to the bathroom when you ask whether you can go. To that end, then, it\u2019s crucial that you end each complete statement (i.e., sentence) with a semicolon, which is our way of telling the Java compiler that it\u2019s reached the end of a step. This doesn\u2019t mean that you need to place a semicolon after every line\u2014 remember that line breaks exist only to make code more readable to humans \u2014but you must place one after any complete declaration or statement. \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment.\nint a = 11;\nint b = 4;\ndouble x = 11;\ndouble y = 4;\nSystem.out.print(a / b);\nSystem.out.print(\", \");\nSystem.out.print(x / y);\nSystem.out.print(\", \");\nSystem.out.print(a / y);\n\nWhat is printed as a result of executing the code segment?\nCorrect: 2, 2.75, 2.75\nIncorrect: 3, 2.75, 3\nIncorrect: 3, 2.75, 2.75\nIncorrect: 2, 3, 2\nIncorrect: Nothing will be printed because of a compile-time error.\n\nEND"}
{"prompt": "The most primitive uses for the first computers were to perform complex calculations. They were basically gigantic calculators. As a result, one of the most basic operations we use in Java involves arithmetic. \nThe symbols +, -, *, and / represent the operations addition, subtraction, multiplication, and division, respectively. The operator % is also used in Java: called the \u201cmodulus\u201d operator, this symbol will produce the numerical remainder of a division. For example, 3 % 2 would evaluate to 1, since 3 divided by 2 yields 1, with 1 as a remainder. These operations can be performed intuitively on numerical values; they can also be performed on variables that store numerical values.\nSpeaking of math, back to our triangle example\u2026 \nConsider the following statement in a program: \nint side2 = 2, side3 = 3; \n\n(Note that you can write multiple assignment statements in a single line, as long as the data types are the same.) \nIf we wanted to write a statement that found the sum of these data and assigned the result to another variable called sumOfSides, we could easily write \nsumOfSides = 2 + 3; // method 1 \n\nBut this statement is less useful than \nsumOfSides = side2 + side3; // method 2 \n\nSince the data is assigned to variables, for which values can vary, method 2 will reflect those changes while method 1 will not. \nThis same technique can be applied to all of the mathematical operators. Remember that a mixture of mathematical operations follows a specific order of precedence. Java will perform the multiplication and division operations (including modulus), from left to right, followed by the addition and subtraction operations in the same order. If programmers want to change the order of precedence of the operators, they can use parentheses. \nConsider these lines of code: \nSystem.out.print(3 - 4/5); // statement 3 \nSystem.out.print(3 -(4/5)); // statement 4 \nSystem.out.print((3 - 4)/5); // statement 5\n\nIn statement 3, the division occurs first, followed by the subtraction (3 minus the answer). \nIn statement 4, the same thing happens, so it is mathematically equivalent to statement 3. \nIn statement 5, the parentheses override the order of operations, so the subtraction occurs, and then the answer is divided by 5. \nOkay, here\u2019s where it gets crazy. Can you predict the output of these statements? Believe it or not, the output of statements 3 and 4 is 3; the output of statement 5 is 0. These results demonstrate the fact that data in Java is strongly typed. \nWhen you perform a mathematical operation on two integers, Java will return the answer as an integer, as well. Therefore, although 4/5 is actually 0.8, Java will return a value of 0. Likewise, Java will evaluate 5/4 to be 1. The decimal part is cut off (not rounded), so that the result will also be an integer. Negative numbers work the same way. Java will return \u20134/5 as 0 and \u20135/4 as \u20131. Strange, huh? \n\nAs is true with all computer science, there is a workaround for this called casting. Casting is a process through which data is forced to \u201clook like\u201d another type of data to the compiler. Think of someone who is cast in a show to play a part; although actors have personal identities, they assume new identities for the audience. The following modifications to statement 3 demonstrate different ways of casting: \nSystem.out.print(3 - (double)(4)/5); // statement 3.1\nSystem.out.print(3 - 4/(double)5); // statement 3.2 \n\nThese statements will cast 4 and 5, respectively, to be double values of 4.0 and 5.0. As a result, the division will be \u201cupgraded\u201d to a division between double values, not integers, and the desired result will be returned. The following statements, although they will compile without error, will not display the desired result of 2.2. \nSystem.out.print((double)3 - 4/5); // statement 3.3 \nSystem.out.print(3 - (double)(4/5)); // statement 3.4 \n\nCasting has a higher precedence than arithmetic operators, except parentheses, of course. Therefore, statement 3.3 will first convert 3 to 3.0, but will then perform integer division before completing the subtracting. The result is 3.0. In statement 3.4, the result of dividing the integers is cast to a double; since the integer division evaluates to 0, the cast will simply make the result 0.0, yielding an output of 3.0 once again. Very tricky! \nThe increment operator (++) is used to increase the value of a number by one. For example, if the value of a variable x is 3, then x++ will increment the value of x to 4. This has the exact same effect as writing x = x + 1, and is nothing more than convenient shorthand. \nConversely, the decrement operator (--) is used to quickly decrease the value of a number by one. For example, if the value of a variable named x is 3, then x-- decreases the value of x to 2. This has the exact same effect as writing x = x \u2013 1. \nOther shortcut operators include +=, -=, *=, /=, and %=. These shortcuts perform the indicated operation and assign the result to the original variable. For example, \na += b; \n\nis an equivalent command to \na = a + b;\nHumans are pretty smart when it comes to guessing intent For instance, you probably noticed that there\u2019s a missing period between this sentence and the one before it. (If not, slow down: AP Computer Science A Exam questions require close reading when looking for errors.) Computers, on the other hand, are literal\u2014more annoyingly so, probably, than those teachers who ask whether you\u2019re physically capable of going to the bathroom when you ask whether you can go. To that end, then, it\u2019s crucial that you end each complete statement (i.e., sentence) with a semicolon, which is our way of telling the Java compiler that it\u2019s reached the end of a step. This doesn\u2019t mean that you need to place a semicolon after every line\u2014 remember that line breaks exist only to make code more readable to humans \u2014but you must place one after any complete declaration or statement. \n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following statement:\nint i = x % 50;\n\nIf x is a positive integer, which of the following could NOT be the value of i after the statement above executes?\nCorrect: 50\nIncorrect: 0\nIncorrect: 10\nIncorrect: 25\nIncorrect: 40END"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about general programming knowledge with multiple options:\n\n###\n\n", "completion": "Question: Which of the following statements about recursion are true? \nI Every recursive algorithm can be written iteratively. \nII Tail recursion is always used in \u201cdivide-and-conquer\u201d algorithms. \nIII In a recursive definition, a process is defined in terms of a simpler case of itself. \nCorrect: I and III only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: II and III only\n\nEND"}
{"prompt": "A common technique in designing recursive algorithms is to have a public nonrecursive driver method that calls a private recursive helper method to carry out the task. The main reasons for doing this are\n\u2022 To hide the implementation details of the recursion from the user.\n\u2022 To enhance the efficiency of the program.\n\nExample 1\nConsider the simple example of recursively finding the sum of the first n positive integers.\n/** @param n a positive integer\n* @return 1 + 2 + 3 + ... + n\n*/\npublic static int sum(int n)\n{\n    if (n == 1)\n        return 1;\n    else\n        return n + sum(n - 1);\n}\n\nNotice that you get infinite recursion if n \u2264 0. Suppose you want to include a test for n > 0 before you execute the algorithm. Placing this test in the recursive method is inefficient because if n is initially positive, it will remain positive in subsequent recursive calls. You can avoid this problem by using a driver method called getSum, which does the test on n just once. The recursive method sum becomes a private helper method.\npublic class FindSum {\n    /**\n     * Private recursive helper method.\n     *\n     * @param n a positive integer\n     * @return 1 + 2 + 3 + ... + n\n     */\n    private static int sum(int n) {\n        if (n == 1)\n            return 1;\n        else\n            return n + sum(n - 1);\n    }\n\n    /* Driver method */\n    public static int getSum(int n) {\n        if (n > 0)\n            return sum(n);\n        else {\n            throw new IllegalArgumentException(\"Error: n must be positive\");\n        }\n    }\n}\n\nNOTE\nThis is a trivial method used to illustrate a private recursive helper method. In practice, you would never use recursion to find a simple sum!\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Which of the following, when used as the /* body */ of method sum, will enable that method to compute 1 + 2 + ... + n correctly for any n > 0? \n\n/** @param n a positive integer \n* @return 1 + 2 + ... + n \n*/ \npublic int sum(int n) \n{ \n    /* body */ \n} \n\nI return n + sum(n - 1); \nII if (n == 1) \n    return 1; \nelse \n    return n + sum(n - 1); \nIII if (n == 1) \n    return 1; \nelse \n    return sum(n) + sum(n - 1); \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "A recursive method is a method that calls itself. For example, here is a program that calls a recursive method stackWords.\npublic class WordPlay {\n    public static void stackWords() {\n        String word = IO.readString(); // read user input\n        if (word.equals(\".\"))\n            System.out.println();\n        else\n            stackWords();\n        System.out.println(word);\n    }\n\n    public static void main(String args[]) {\n        System.out.println(\"Enter list of words, one per line.\");\n        System.out.println(\"Final word should be a period (.)\");\n        stackWords();\n    }\n}\n\nHere is the output if you enter\nhold\nmy\nhand\n.\n\nYou get\n.\nhand\nmy\nhold\n\nThe program reads in a list of words terminated with a period, and prints the list in reverse order, starting with the period. How does this happen?\nEach time the recursive call to stackWords() is made, execution goes back to the start of a new method call. The computer must remember to complete all the pending calls to the method. It does this by stacking the statements that must still be executed as follows: The first time stackWords() is called, the word \"hold\" is read and tested for being a period. No it\u2019s not, so stackWords() is called again. The statement to output \"hold\" (which has not yet been executed) goes on a stack, and execution goes to the start of the method. The word \"my\" is read. No, it\u2019s not a period, so the command to output \"my\" goes on the stack. And so on. The stack looks something like this before the recursive call in which the period is read:\nSystem.out.println(\"hand\");\nSystem.out.println(\"my\");\nSystem.out.println(\"hold\");\n\nImagine that these statements are stacked like plates. In the final stackWords() call, word has the value \".\". Yes, it is a period, so the stackWords() line is skipped, the period is printed on the screen, and the method call terminates. The computer now completes each of the previous method calls in turn by \u201cpopping\u201d the statements off the top of the stack. It prints \"hand\", then \"my\", then \"hold\", and execution of method stackWords() is complete.1\n\nNOTE\n1. Each time stackWords() is called, a new local variable word is created.\n2. The first time the method actually terminates, the program returns to complete the most recently invoked previous call. That\u2019s why the words get reversed in this example.\nEvery recursive method has two distinct parts:\n\u2022 A base case or termination condition that causes the method to end.\n\u2022 A nonbase case whose actions move the algorithm toward the base case and termination.\n\nHere is the framework for a simple recursive method that has no specific return type.\npublic void recursiveMeth( ... )\n{\n    if (base case)\n        < Perform some action >\n    else\n    {\n        < Perform some other action >\n        recursiveMeth( ... ); //recursive method call\n    }\n}\n\nThe base case typically occurs for the simplest case of the problem, such as when an integer has a value of 0 or 1. Other examples of base cases are when some key is found, or an end-of-file is reached. A recursive algorithm can have more than one base case.\nIn the else or nonbase case of the framework shown, the code fragment < Perform some other action > and the method call recursiveMeth can sometimes be interchanged without altering the net effect of the algorithm. Be careful though, because what does change is the order of executing statements. This can sometimes be disastrous. (See the eraseBlob example on p. 299.)\n\nExample 1\npublic void drawLine(int n)\n{\n    if (n == 0)\n        System.out.println(\"That\u2019s all, folks!\");\n    else\n    {\n        for (int i = 1; i <= n; i++)\n            System.out.print(\"*\");\n        System.out.println();\n        drawLine(n - 1);\n    }\n}\n\nThe method call drawLine(3) produces this output:\n***\n**\n*\nThat\u2019s all, folks!\n\nNOTE\n1. A method that has no pending statements following the recursive call is an example of tail recursion. Method drawLine is such a case, but stackWords is not.\n2. The base case in the drawLine example is n == 0. Notice that each subsequent call, drawLine(n - 1), makes progress toward termination of the method. If your method has no base case, or if you never reach the base case, you will create infinite recursion. This is a catastrophic error that will cause your computer eventually to run out of memory and give you heart-stopping messages like java.lang.StackOverflowError\n\nExample 2\n//Illustrates infinite recursion.\npublic void catastrophe(int n)\n{\n    System.out.println(n);\n    catastrophe(n);\n}\n\nTry running the case catastrophe(1) if you have lots of time to waste! A recursive method must have a base case.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Refer to the method stringRecur: \n\npublic void stringRecur(String s) \n{ \n    if (s.length() < 15) \n        System.out.println(s); \n    stringRecur(s + \"*\"); \n} \n\nWhen will method stringRecur terminate without error? \nCorrect: For no string inputs\n\n\nIncorrect: Only when the length of the input string is less than 15\nIncorrect: Only when the length of the input string is greater than or equal to 15\nIncorrect: Only when an empty string is input\nIncorrect: For all string inputsEND"}
{"prompt": "A recursive method is a method that calls itself. For example, here is a program that calls a recursive method stackWords.\npublic class WordPlay {\n    public static void stackWords() {\n        String word = IO.readString(); // read user input\n        if (word.equals(\".\"))\n            System.out.println();\n        else\n            stackWords();\n        System.out.println(word);\n    }\n\n    public static void main(String args[]) {\n        System.out.println(\"Enter list of words, one per line.\");\n        System.out.println(\"Final word should be a period (.)\");\n        stackWords();\n    }\n}\n\nHere is the output if you enter\nhold\nmy\nhand\n.\n\nYou get\n.\nhand\nmy\nhold\n\nThe program reads in a list of words terminated with a period, and prints the list in reverse order, starting with the period. How does this happen?\nEach time the recursive call to stackWords() is made, execution goes back to the start of a new method call. The computer must remember to complete all the pending calls to the method. It does this by stacking the statements that must still be executed as follows: The first time stackWords() is called, the word \"hold\" is read and tested for being a period. No it\u2019s not, so stackWords() is called again. The statement to output \"hold\" (which has not yet been executed) goes on a stack, and execution goes to the start of the method. The word \"my\" is read. No, it\u2019s not a period, so the command to output \"my\" goes on the stack. And so on. The stack looks something like this before the recursive call in which the period is read:\nSystem.out.println(\"hand\");\nSystem.out.println(\"my\");\nSystem.out.println(\"hold\");\n\nImagine that these statements are stacked like plates. In the final stackWords() call, word has the value \".\". Yes, it is a period, so the stackWords() line is skipped, the period is printed on the screen, and the method call terminates. The computer now completes each of the previous method calls in turn by \u201cpopping\u201d the statements off the top of the stack. It prints \"hand\", then \"my\", then \"hold\", and execution of method stackWords() is complete.1\n\nNOTE\n1. Each time stackWords() is called, a new local variable word is created.\n2. The first time the method actually terminates, the program returns to complete the most recently invoked previous call. That\u2019s why the words get reversed in this example.\nEvery recursive method has two distinct parts:\n\u2022 A base case or termination condition that causes the method to end.\n\u2022 A nonbase case whose actions move the algorithm toward the base case and termination.\n\nHere is the framework for a simple recursive method that has no specific return type.\npublic void recursiveMeth( ... )\n{\n    if (base case)\n        < Perform some action >\n    else\n    {\n        < Perform some other action >\n        recursiveMeth( ... ); //recursive method call\n    }\n}\n\nThe base case typically occurs for the simplest case of the problem, such as when an integer has a value of 0 or 1. Other examples of base cases are when some key is found, or an end-of-file is reached. A recursive algorithm can have more than one base case.\nIn the else or nonbase case of the framework shown, the code fragment < Perform some other action > and the method call recursiveMeth can sometimes be interchanged without altering the net effect of the algorithm. Be careful though, because what does change is the order of executing statements. This can sometimes be disastrous. (See the eraseBlob example on p. 299.)\n\nExample 1\npublic void drawLine(int n)\n{\n    if (n == 0)\n        System.out.println(\"That\u2019s all, folks!\");\n    else\n    {\n        for (int i = 1; i <= n; i++)\n            System.out.print(\"*\");\n        System.out.println();\n        drawLine(n - 1);\n    }\n}\n\nThe method call drawLine(3) produces this output:\n***\n**\n*\nThat\u2019s all, folks!\n\nNOTE\n1. A method that has no pending statements following the recursive call is an example of tail recursion. Method drawLine is such a case, but stackWords is not.\n2. The base case in the drawLine example is n == 0. Notice that each subsequent call, drawLine(n - 1), makes progress toward termination of the method. If your method has no base case, or if you never reach the base case, you will create infinite recursion. This is a catastrophic error that will cause your computer eventually to run out of memory and give you heart-stopping messages like java.lang.StackOverflowError\n\nExample 2\n//Illustrates infinite recursion.\npublic void catastrophe(int n)\n{\n    System.out.println(n);\n    catastrophe(n);\n}\n\nTry running the case catastrophe(1) if you have lots of time to waste! A recursive method must have a base case.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Refer to method strRecur: \n\npublic void strRecur(String s) \n{ \n    if (s.length() < 15) \n    { \n        System.out.println(s); \n        strRecur(s + \"*\"); \n    } \n} \n\nWhen will method strRecur terminate without error? \nCorrect: For all string inputs\nIncorrect: Only when the length of the input string is less than 15\nIncorrect: Only when the length of the input string is greater than or equal to 15\nIncorrect: Only when an empty string is input\nIncorrect: For no string inputs\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Refer to method result:\n\npublic int result(int n) \n{ \n    if (n == 1) \n        return 2; \n    else \n        return 2 * result(n - 1); \n} \n\nWhat value does result(5) return? \nCorrect: 32\nIncorrect: 64\nIncorrect: 16\nIncorrect: 8\nIncorrect: 2\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Refer to method result:\n\npublic int result(int n) \n{ \n    if (n == 1) \n        return 2; \n    else \n        return 2 * result(n - 1); \n} \n\nIf n > 0, how many times will result be called to evaluate result(n) (including the initial call)? \nCorrect: n\nIncorrect: 2\nIncorrect: 2n\nIncorrect: 2n\nIncorrect: n2\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Refer to method mystery: \n\npublic int mystery(int n, int a, int d) \n{ \n    if (n == 1) \n        return a; \n    else \n        return d + mystery(n - 1, a, d); \n} \n\nWhat value is returned by the call mystery(3, 2, 6)? \nCorrect: 14\nIncorrect: 20\nIncorrect: 10\nIncorrect: 8\nIncorrect: 2\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Refer to method f: \n\npublic int f(int k, int n) \n{ \n    if (n == k) \n        return k; \n    else \n        if (n > k) \n            return f(k, n - k); \n    else \n        return f(k - n, n); \n} \n\nWhat value is returned by the call f(6, 8)? \nCorrect: 2\nIncorrect: 8\nIncorrect: 4\nIncorrect: 3\nIncorrect: 1\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: What does method recur do? \n\n/** @param x an array of n integers \n* @param n a positive integer \n*/ \npublic int recur(int[] x, int n) \n{ \n    int t; \n    if (n == 1) \n        return x[0]; \n    else \n    { \n        t = recur(x, n - 1); \n        if (x[n-1] > t) \n            return x[n-1]; \n        else \n            return t; \n    } \n} \n\nCorrect: It finds the largest value in x and leaves x unchanged.\nIncorrect: It finds the smallest value in x and leaves x unchanged.\nIncorrect: It sorts x in ascending order and returns the largest value in x.\nIncorrect: It sorts x in descending order and returns the largest value in x.\nIncorrect: It returns x[0] or x[n-1], whichever is larger.\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Which best describes what the printString method below does? \n\npublic void printString(String s) \n{ \n    if (s.length() > 0) \n    { \n        printString(s.substring(1)); \n        System.out.print(s.substring(0, 1)); \n    } \n} \n\nCorrect: It prints string s in reverse order.\nIncorrect: It prints string s.\nIncorrect: It prints only the first character of string s.\nIncorrect: It prints only the first two characters of string s.\nIncorrect: It prints only the last character of string s.\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Refer to the method power: \n\n/** @param base a nonzero real number \n* @param expo an integer \n* @return base raised to the expo power \n*/ \npublic double power(double base, int expo) \n{ \n    if (expo == 0) \n        return 1; \n    else if (expo > 0) \n        return base * power(base, expo - 1); \n    else \n        return /* code */; \n} \n\nWhich /* code */ correctly completes method power? (Recall that a^\u2212n = 1/a^n, a != 0; for example, 2^\u22123 = 1/2^3 = 1/8.) \nCorrect: (1 / base) * power(base, expo + 1)\nIncorrect: (1 / base) * power(base, expo - 1)\nIncorrect: base * power(base, expo + 1)\nIncorrect: base * power(base, expo - 1)\nIncorrect: (1 / base) * power(base, expo)\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following method: \n\npublic void doSomething(int n) \n{ \n    if (n > 0) \n    { \n        doSomething(n - 1); \n        System.out.print(n); \n        doSomething(n - 1); \n    } \n} \n\nWhat would be output following the call doSomething(3)? \nCorrect: 1213121\nIncorrect: 3211211\nIncorrect: 1121213\nIncorrect: 1211213\nIncorrect: 1123211\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: A user enters several positive integers at the keyboard and terminates the list with a sentinel (-999). A writeEven method reads those integers and outputs the even integers only, in the reverse order that they are read. Thus, if the user enters \n3 5 14 6 1 8 -999 \nthe output for the writeEven method will be \n8 6 14 \n\nAssume that the user enters at least one positive integer and terminates the list with \u2212999. Here is the method: \n\n/** Postcondition: All even integers in the list are output in \n* reverse order. \n*/ \npublic static void writeEven() \n{ \n    int num = IO.readInt(); //read user input \n    if (num != -999) \n    { \n        /* code */ \n    } \n} \n\nWhich /* code */ satisfies the postcondition of method writeEven? \nI if (num % 2 == 0) \n    System.out.print(num + \" \"); \nwriteEven(); \nII if (num % 2 == 0) \n    writeEven(); \nSystem.out.print(num + \" \"); \nIII writeEven(); \nif (num % 2 == 0) \n    System.out.print(num + \" \"); \nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Refer to the following recursive method. \n\npublic int mystery(int n) \n{ \n    if (n < 0) \n        return 2; \n    else \n        return mystery(n - 1) + mystery(n - 3); \n} \n\nWhat value is returned by the call mystery(3)? \nCorrect: 12\nIncorrect: 10\nIncorrect: 8\nIncorrect: 6\nIncorrect: 4\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the method t:\n\n/** @param n a positive integer */ \npublic int t(int n) \n{ \n    if (n == 1 || n == 2) \n        return 2 * n; \n    else \n        return t(n - 1) - t(n - 2); \n} \n\nWhat will be returned by t(5)? \nCorrect: \u22124\n\n\nIncorrect: 4\nIncorrect: 2\nIncorrect: 0\nIncorrect: \u22122END"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the method t:\n\n/** @param n a positive integer */ \npublic int t(int n) \n{ \n    if (n == 1 || n == 2) \n        return 2 * n; \n    else \n        return t(n - 1) - t(n - 2); \n} \n\nFor the method call t(6), how many calls to t will be made, including the original call? \nCorrect: 15\nIncorrect: 6\nIncorrect: 7\nIncorrect: 11\nIncorrect: 25\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: This question refers to methods f1 and f2 that are in the same class: \npublic int f1(int a, int b) \n{ \n    if (a == b) \n        return b; \n    else \n        return a + f2(a - 1, b); \n} \n\npublic int f2(int p, int q) \n{ \n    if (p < q) \n        return p + q; \n    else \n        return p + f1(p - 2, q); \n} \n\nWhat value will be returned by a call to f1(5, 3)? \nCorrect: 15\n\n\nIncorrect: 5\nIncorrect: 6\nIncorrect: 7\nIncorrect: 12END"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider method foo: \n\npublic int foo(int x) \n{ \n    if (x == 1 || x == 3) \n        return x; \n    else \n        return x * foo(x - 1); \n} \n\nAssuming no possibility of integer overflow, what will be the value of z after execution of the following statement? \nint z = foo(foo(3) + foo(4)); \nCorrect: (15!)/(2!)\nIncorrect: 3! + 4!\nIncorrect: (7!)!\nIncorrect: (3! + 4!)!\nIncorrect: 15\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the IntFormatter class defined below:\n\npublic class IntFormatter {\n    /**\n     * Write 3 digits adjacent to each other.\n     * \n     * @param n a nonnegative integer\n     */\n    public static void writeThreeDigits(int n) {\n        System.out.print(n / 100);\n        System.out.print((n / 10) % 10);\n        System.out.print(n % 10);\n    }\n\n    /**\n     * Insert commas in n, every 3 digits starting at the right.\n     * \n     * @param n a nonnegative integer\n     */\n    public static void writeWithCommas(int n) {\n        if (n < 1000)\n            System.out.print(n);\n        else {\n            writeThreeDigits(n % 1000);\n            System.out.print(\",\");\n            writeWithCommas(n / 1000);\n        }\n    }\n}\n\nThe method writeWithCommas is supposed to print its nonnegative int argument with commas properly inserted (every three digits, starting at the right). For example, the integer 27048621 should be printed as 27,048,621. Method writeWithCommas does not always work as intended, however. Assuming no integer overflow, which of the following integer arguments will not be printed correctly? \nCorrect: 365051\nIncorrect: 896\nIncorrect: 251462251\nIncorrect: 278278\nIncorrect: 4\n\nEND"}
{"prompt": "To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*/\npublic static int factorial(int n)\n{\n    if (n == 0) //base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n/10, reverse its digits. Repeat this until n/10 is 0. Here is the method:\n/** @param n a nonnegative integer\n* @return n with its digits reversed\n*/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); //rightmost digit\n    if (n / 10 != 0) //base case\n        revDigs(n / 10);\n}\n\nNOTE\nOn the AP exam, you are expected to \u201cunderstand and evaluate\u201d recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n \u2265 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n \u2212 1) + Fib(n \u2212 2): n \u2265 3)\n\nHere is the method:\n/** @param n a positive integer\n* @return the nth Fibonacci number\n*/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays\u2014too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n\u2022 Branching processes like traversing trees or directories.\n\u2022 Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the IntFormatter class defined below:\n\npublic class IntFormatter {\n    /**\n     * Write 3 digits adjacent to each other.\n     * \n     * @param n a nonnegative integer\n     */\n    public static void writeThreeDigits(int n) {\n        System.out.print(n / 100);\n        System.out.print((n / 10) % 10);\n        System.out.print(n % 10);\n    }\n\n    /**\n     * Insert commas in n, every 3 digits starting at the right.\n     * \n     * @param n a nonnegative integer\n     */\n    public static void writeWithCommas(int n) {\n        if (n < 1000)\n            System.out.print(n);\n        else {\n            writeThreeDigits(n % 1000);\n            System.out.print(\",\");\n            writeWithCommas(n / 1000);\n        }\n    }\n}\n\nWhich change in the code of the given methods will cause method writeWithCommas to work as intended? \nCorrect: Interchange the lines writeThreeDigits(n % 1000) and writeWithCommas(n / 1000) in method writeWithCommas.\nIncorrect: Interchange the lines System.out.print(n / 100) and System.out.print(n % 10) in method writeThreeDigits.\nIncorrect: Change the test in writeWithCommas to if (n > 1000).\nIncorrect: In the method writeWithCommas, change the line writeThreeDigits(n % 1000) to writeThreeDigits(n / 1000).\nIncorrect: In the method writeWithCommas, change the recursive call writeWithCommas(n / 1000) to writeWithCommas(n % 1000).END"}
{"prompt": "An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (\u201csubscripts\u201d) go from 0 to N \u2212 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k \u2265 N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java\u2019s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; //declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; //reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n//loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); //assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n/** @return the number of even integers in array arr of integers */ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) //num is even\n            count++;\n    return count;\n}\nExample 2\n/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Which of the following correctly initializes an array arr to contain four elements each with value 0? \nI int[] arr = {0, 0, 0, 0}; \nII int[] arr = new int[4]; \nIII int[] arr = new int[4]; \nfor (int i = 0; i < arr.length; i++) \n    arr[i] = 0; \nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and III only\nIncorrect: II and III onlyEND"}
{"prompt": "An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (\u201csubscripts\u201d) go from 0 to N \u2212 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k \u2265 N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java\u2019s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; //declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; //reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n//loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); //assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n/** @return the number of even integers in array arr of integers */ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) //num is even\n            count++;\n    return count;\n}\nExample 2\n/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: The following program segment is intended to find the index of the first negative integer in arr[0] . . . arr[N-1], where arr is an array of N integers. \n\nint i = 0; \nwhile (arr[i] >= 0) \n{ \n    i++; \n} \nlocation = i; \n\nThis segment will work as intended \nCorrect: whenever arr contains at least one negative integer.\nIncorrect: always.\nIncorrect: never.\nIncorrect: whenever arr contains at least one nonnegative integer.\nIncorrect: whenever arr contains no negative integers.\n\nEND"}
{"prompt": "An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (\u201csubscripts\u201d) go from 0 to N \u2212 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k \u2265 N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java\u2019s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; //declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; //reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n//loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); //assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n/** @return the number of even integers in array arr of integers */ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) //num is even\n            count++;\n    return count;\n}\nExample 2\n/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Refer to the following code segment. You may assume that arr is an array of int values. \n\nint sum = arr[0], i = 0; \nwhile (i < arr.length) \n{ \n    i++; \n    sum += arr[i]; \n} \n\nWhich of the following will be the result of executing the segment? \nCorrect: A run-time error will occur.\n\n\nIncorrect: Sum of arr[0], arr[1], . . . , arr[arr.length-1] will be stored in sum.\nIncorrect: Sum of arr[1], arr[2], . . . , arr[arr.length-1] will be stored in sum.\nIncorrect: Sum of arr[0], arr[1], . . . , arr[arr.length] will be stored in sum.\nIncorrect: An infinite loop will occur.END"}
{"prompt": "An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (\u201csubscripts\u201d) go from 0 to N \u2212 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k \u2265 N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java\u2019s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; //declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; //reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n//loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); //assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n/** @return the number of even integers in array arr of integers */ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) //num is even\n            count++;\n    return count;\n}\nExample 2\n/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Refer to the following code segment. You may assume that array arr1 contains elements arr1[0], arr1[1], . . . , arr1[N-1], where N = arr1.length. \n\nint count = 0; \nfor (int i = 0; i < N; i++) \n    if (arr1[i] != 0) \n    { \n        arr1[count] = arr1[i]; \n        count++; \n    } \n\nint[] arr2 = new int[count]; \nfor (int i = 0; i < count; i++) \n    arr2[i] = arr1[i]; \n\nIf array arr1 initially contains the elements 0, 6, 0, 4, 0, 0, 2 in this order, what will arr2 contain after execution of the code segment? \nCorrect: 6, 4, 2\nIncorrect: 0, 0, 0, 0, 6, 4, 2\nIncorrect: 6, 4, 2, 4, 0, 0, 2\nIncorrect: 0, 6, 0, 4, 0, 0, 2\nIncorrect: 6, 4, 2, 0, 0, 0, 0\n\nEND"}
{"prompt": "An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (\u201csubscripts\u201d) go from 0 to N \u2212 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k \u2265 N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java\u2019s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; //declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; //reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n//loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); //assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n/** @return the number of even integers in array arr of integers */ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) //num is even\n            count++;\n    return count;\n}\nExample 2\n/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider this program segment: \n\nfor (int i = 2; i <= k; i++) \n    if (arr[i] < someValue) \n        System.out.print(\"SMALL\"); \n\nWhat is the maximum number of times that SMALL can be printed? \nCorrect: k - 1\nIncorrect: 0\nIncorrect: 1\nIncorrect: k - 2\nIncorrect: k\n\nEND"}
{"prompt": "An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (\u201csubscripts\u201d) go from 0 to N \u2212 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k \u2265 N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java\u2019s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; //declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; //reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n//loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); //assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n/** @return the number of even integers in array arr of integers */ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) //num is even\n            count++;\n    return count;\n}\nExample 2\n/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: What will be output from the following code segment, assuming it is in the same class as the doSomething method? \n\nint[] arr = {1, 2, 3, 4}; \ndoSomething(arr); \nSystem.out.print(arr[1] + \" \"); \nSystem.out.print(arr[3]); \n... \npublic void doSomething(int[] list) \n{ \n    int[] b = list; \n    for (int i = 0; i < b.length; i++) \n        b[i] = i; \n}\nCorrect: 1 3\nIncorrect: 0 0\nIncorrect: 2 4\nIncorrect: 0 2\nIncorrect: 0 3\n\nEND"}
{"prompt": "Example 1\nDiscuss the efficiency of the countNegs method below. What are the best and worst case configurations of the data?\n/** Precondition: arr[0],...,arr[arr.length-1] contain integers.\n* @return the number of negative values in arr\n*/\npublic static int countNegs(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if (num < 0)\n            count++;\n    return count;\n}\n\nSolution:\nThis algorithm sequentially examines each element in the array. In the best case, there are no negative elements, and count++ is never executed. In the worst case, all the elements are negative, and count++ is executed in each pass of the for loop.\n\nExample 2\nThe code fragment below inserts a value, num, into its correct position in a sorted array of integers. Discuss the efficiency of the algorithm.\n\n/** Precondition:\n* - arr[0],...,arr[n-1] contain integers sorted in increasing order.\n* - n < arr.length.\n* Postcondition: num has been inserted in its correct position.\n*/\n{\n    //find insertion point\n    int i = 0;\n    while (i < n && num > arr[i])\n    i++;\n    //if necessary, move elements arr[i]...arr[n-1] up 1 slot\n    for (int j = n; j >= i + 1; j--)\n    arr[j] = arr[j-1];\n    //insert num in i-th slot and update n\n    arr[i] = num;\n    n++;\n}\n\nSolution:\nIn the best case, num is greater than all the elements in the array: Because it gets inserted at the end of the list, no elements must be moved to create a slot for it. The worst case has num less than all the elements in the array. In this case, num must be inserted in the first slot, arr[0], and every element in the array must be moved up one position to create a slot.\nThis algorithm illustrates a disadvantage of arrays: Insertion and deletion of an ele ment in an ordered list is inefficient, since, in the worst case, it may involve moving all the elements in the list.\nAn ArrayList provides an alternative way of storing a list of objects and has the fol lowing advantages over an array:\n\u2022 An ArrayList shrinks and grows as needed in a program, whereas an array has a fixed length that is set when the array is created.\n\u2022 In an ArrayList list, the last slot is always list.size()-1, whereas in a partially filled array, you, the programmer, must keep track of the last slot currently in use.\n\u2022 For an ArrayList, you can do insertion or deletion with just a single statement. Any shifting of elements is handled automatically. In an array, however, insertion or deletion requires you to write the code that shifts the elements.\n\nThe Collections API\nThe ArrayList class is in the Collections API (Application Programming Interface), which is a library provided by Java. Most of the API is in java.util. This library gives the programmer access to prepackaged data structures and the methods to manipulate them. The implementations of these container classes are invisible and should not be of concern to the programmer. The code works. And it is reusable.\nAll of the collections classes, including ArrayList, have the following features in common:\n\u2022 They are designed to be both memory and run-time efficient.\n\u2022 They provide methods for insertion and removal of items (i.e., they can grow and shrink).\n\u2022 They provide for iteration over the entire collection.\n\nInheritance is a defining feature of the Collections API. The interfaces that are used to manipulate the collections specify the operations that must be defined for any con tainer class that implements that interface.\n\nCollections and Generics\nThe collections classes are generic, with type parameters. Thus, List<E> and ArrayList<E> contain elements of type E. When a generic class is declared, the type parameter is replaced by an actual object type. For example,\nprivate ArrayList<Clown> clowns;\n\nNOTE\n1. The clowns list must contain only Clown objects. An attempt to add an Acrobat to the list, for example, will cause a compile-time error.\n2. Since the type of objects in a generic class is restricted, the elements can be accessed without casting.\n3. All of the type information in a program with generic classes is examined at compile time. After compilation the type information is erased. This feature of generic classes is known as erasure. During execution of the program, any attempt at incorrect casting will lead to a ClassCastException.\nThere are no primitive types in collections classes. An ArrayList must contain objects, not types like double and int. Numbers must therefore be boxed\u2014placed in wrapper classes like Integer and Double\u2014before insertion into an ArrayList.\nAuto-boxing is the automatic wrapping of primitive types in their wrapper classes.\nTo retrieve the numerical value of an Integer (or Double) stored in an ArrayList, the intValue() (or doubleValue()) method must be invoked (unwrapping). Auto unboxing is the automatic conversion of a wrapper class to its corresponding primitive type. This means that you don\u2019t need to explicitly call the intValue() or doubleValue() methods. Be aware that if a program tries to auto-unbox null, the method will throw a NullPointerException.\nNote that while auto-boxing and -unboxing cut down on code clutter, these oper ations must still be performed behind the scenes, leading to decreased run-time effi ciency. It is much more efficient to assign and access primitive types in an array than an ArrayList. You should therefore consider using an array for a program that manip ulates sequences of numbers and does not need to use objects.\n\nNOTE\nAuto-boxing and -unboxing is a feature in Java 5.0 and later versions and will not be tested on the AP exam. It is OK, however, to use this convenient feature in code that you write in the free-response questions.\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: Consider writing a program that reads the lines of any text file into a sequential list of lines. Which of the following is a good reason to implement the list with an ArrayList of String objects rather than an array of String objects? \nCorrect: If any particular text file is unexpectedly long, the ArrayList will automatically be resized. The array, by contrast, may go out of bounds.\nIncorrect: The get and set methods of ArrayList are more convenient than the [] notation for arrays.\nIncorrect: The size method of ArrayList provides instant access to the length of the list.\nIncorrect: An ArrayList can contain objects of any type, which leads to greater generality.\nIncorrect: The String methods are easier to use with an ArrayList than with an array.\n\nEND"}
{"prompt": "Example 1\nDiscuss the efficiency of the countNegs method below. What are the best and worst case configurations of the data?\n/** Precondition: arr[0],...,arr[arr.length-1] contain integers.\n* @return the number of negative values in arr\n*/\npublic static int countNegs(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if (num < 0)\n            count++;\n    return count;\n}\n\nSolution:\nThis algorithm sequentially examines each element in the array. In the best case, there are no negative elements, and count++ is never executed. In the worst case, all the elements are negative, and count++ is executed in each pass of the for loop.\n\nExample 2\nThe code fragment below inserts a value, num, into its correct position in a sorted array of integers. Discuss the efficiency of the algorithm.\n\n/** Precondition:\n* - arr[0],...,arr[n-1] contain integers sorted in increasing order.\n* - n < arr.length.\n* Postcondition: num has been inserted in its correct position.\n*/\n{\n    //find insertion point\n    int i = 0;\n    while (i < n && num > arr[i])\n    i++;\n    //if necessary, move elements arr[i]...arr[n-1] up 1 slot\n    for (int j = n; j >= i + 1; j--)\n    arr[j] = arr[j-1];\n    //insert num in i-th slot and update n\n    arr[i] = num;\n    n++;\n}\n\nSolution:\nIn the best case, num is greater than all the elements in the array: Because it gets inserted at the end of the list, no elements must be moved to create a slot for it. The worst case has num less than all the elements in the array. In this case, num must be inserted in the first slot, arr[0], and every element in the array must be moved up one position to create a slot.\nThis algorithm illustrates a disadvantage of arrays: Insertion and deletion of an ele ment in an ordered list is inefficient, since, in the worst case, it may involve moving all the elements in the list.\nAn ArrayList provides an alternative way of storing a list of objects and has the fol lowing advantages over an array:\n\u2022 An ArrayList shrinks and grows as needed in a program, whereas an array has a fixed length that is set when the array is created.\n\u2022 In an ArrayList list, the last slot is always list.size()-1, whereas in a partially filled array, you, the programmer, must keep track of the last slot currently in use.\n\u2022 For an ArrayList, you can do insertion or deletion with just a single statement. Any shifting of elements is handled automatically. In an array, however, insertion or deletion requires you to write the code that shifts the elements.\n\nThe Collections API\nThe ArrayList class is in the Collections API (Application Programming Interface), which is a library provided by Java. Most of the API is in java.util. This library gives the programmer access to prepackaged data structures and the methods to manipulate them. The implementations of these container classes are invisible and should not be of concern to the programmer. The code works. And it is reusable.\nAll of the collections classes, including ArrayList, have the following features in common:\n\u2022 They are designed to be both memory and run-time efficient.\n\u2022 They provide methods for insertion and removal of items (i.e., they can grow and shrink).\n\u2022 They provide for iteration over the entire collection.\n\nInheritance is a defining feature of the Collections API. The interfaces that are used to manipulate the collections specify the operations that must be defined for any con tainer class that implements that interface.\n\nCollections and Generics\nThe collections classes are generic, with type parameters. Thus, List<E> and ArrayList<E> contain elements of type E. When a generic class is declared, the type parameter is replaced by an actual object type. For example,\nprivate ArrayList<Clown> clowns;\n\nNOTE\n1. The clowns list must contain only Clown objects. An attempt to add an Acrobat to the list, for example, will cause a compile-time error.\n2. Since the type of objects in a generic class is restricted, the elements can be accessed without casting.\n3. All of the type information in a program with generic classes is examined at compile time. After compilation the type information is erased. This feature of generic classes is known as erasure. During execution of the program, any attempt at incorrect casting will lead to a ClassCastException.\nThere are no primitive types in collections classes. An ArrayList must contain objects, not types like double and int. Numbers must therefore be boxed\u2014placed in wrapper classes like Integer and Double\u2014before insertion into an ArrayList.\nAuto-boxing is the automatic wrapping of primitive types in their wrapper classes.\nTo retrieve the numerical value of an Integer (or Double) stored in an ArrayList, the intValue() (or doubleValue()) method must be invoked (unwrapping). Auto unboxing is the automatic conversion of a wrapper class to its corresponding primitive type. This means that you don\u2019t need to explicitly call the intValue() or doubleValue() methods. Be aware that if a program tries to auto-unbox null, the method will throw a NullPointerException.\nNote that while auto-boxing and -unboxing cut down on code clutter, these oper ations must still be performed behind the scenes, leading to decreased run-time effi ciency. It is much more efficient to assign and access primitive types in an array than an ArrayList. You should therefore consider using an array for a program that manip ulates sequences of numbers and does not need to use objects.\n\nNOTE\nAuto-boxing and -unboxing is a feature in Java 5.0 and later versions and will not be tested on the AP exam. It is OK, however, to use this convenient feature in code that you write in the free-response questions.\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: Consider writing a program that produces statistics for long lists of numerical data. Which of the following is the best reason to implement each list with an array of int (or double), rather than an ArrayList of Integer (or Double) objects? \nCorrect: An array of primitive number types is more efficient to manipulate than an ArrayList of wrapper objects that contain numbers.\nIncorrect: Insertion of new elements into a list is easier to code for an array than for an ArrayList.\nIncorrect: Removal of elements from a list is easier to code for an array than for an ArrayList.\nIncorrect: Accessing individual elements in the middle of a list is easier for an array than for an ArrayList.\nIncorrect: Accessing all the elements is more efficient in an array than in an ArrayList.\n\nEND"}
{"prompt": "Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    /** constructor */\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    /** Write contents of Deck. */\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    /** Swap arr[i] and arr[j] in array arr. */\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    /**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     */\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            // generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards\u2014deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    /** constructor */\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    /** Shuffle the Decks. */\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    /** Write contents of all the Decks. */\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it\u2019s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the following classes:\n\npublic class Address {\n    private String name;\n    private String street;\n    private String city;\n    private String state;\n    private String zip;\n    // constructors\n    ...\n\n    // accessors\n    public String getName() { return name; }\n\n    public String getStreet() { return street; }\n\n    public String getCity() { return city; }\n\n    public String getState() { return state; }\n\n    public String getZip() { return zip; }\n}\n\npublic class Student {\n    private int idNum;\n    private double gpa;\n    private Address address;\n    // constructors\n    ...\n\n    // accessors\n    public Address getAddress() { return address; }\n\n    public int getIdNum() { return idNum; }\n\n    public double getGpa() { return gpa; }\n}\n\nA client method has this declaration, followed by code to initialize the list: \nAddress[] list = new Address[100]; \n\nHere is a code segment to generate a list of names only. \nfor (Address a : list) \n    /* line of code */ \n\nWhich is a correct /* line of code */? \nCorrect: System.out.println(a.getName());\nIncorrect: System.out.println(Address[i].getName());\nIncorrect: System.out.println(list[i].getName());\nIncorrect: System.out.println(a[i].getName());\nIncorrect: System.out.println(list.getName());\n\nEND"}
{"prompt": "Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    /** constructor */\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    /** Write contents of Deck. */\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    /** Swap arr[i] and arr[j] in array arr. */\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    /**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     */\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            // generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards\u2014deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    /** constructor */\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    /** Shuffle the Decks. */\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    /** Write contents of all the Decks. */\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it\u2019s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the following classes:\n\npublic class Address {\n    private String name;\n    private String street;\n    private String city;\n    private String state;\n    private String zip;\n    // constructors\n    ...\n\n    // accessors\n    public String getName() { return name; }\n\n    public String getStreet() { return street; }\n\n    public String getCity() { return city; }\n\n    public String getState() { return state; }\n\n    public String getZip() { return zip; }\n}\n\npublic class Student {\n    private int idNum;\n    private double gpa;\n    private Address address;\n    // constructors\n    ...\n\n    // accessors\n    public Address getAddress() { return address; }\n\n    public int getIdNum() { return idNum; }\n\n    public double getGpa() { return gpa; }\n}\n\nThe following code segment is to print out a list of addresses: \nfor (Address addr : list) \n{ \n    /* more code */ \n} \n\nWhich is a correct replacement for /* more code */? \nI System.out.println(list[i].getName()); \nSystem.out.println(list[i].getStreet()); \nSystem.out.print(list[i].getCity() + \", \"); \nSystem.out.print(list[i].getState() + \" \"); \nSystem.out.println(list[i].getZip()); \nII System.out.println(addr.getName()); \nSystem.out.println(addr.getStreet()); \nSystem.out.print(addr.getCity() + \", \"); \nSystem.out.print(addr.getState() + \" \"); \nSystem.out.println(addr.getZip()); \nIII System.out.println(addr); \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    /** constructor */\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    /** Write contents of Deck. */\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    /** Swap arr[i] and arr[j] in array arr. */\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    /**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     */\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            // generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards\u2014deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    /** constructor */\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    /** Shuffle the Decks. */\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    /** Write contents of all the Decks. */\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it\u2019s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the following classes:\n\npublic class Address {\n    private String name;\n    private String street;\n    private String city;\n    private String state;\n    private String zip;\n    // constructors\n    ...\n\n    // accessors\n    public String getName() { return name; }\n\n    public String getStreet() { return street; }\n\n    public String getCity() { return city; }\n\n    public String getState() { return state; }\n\n    public String getZip() { return zip; }\n}\n\npublic class Student {\n    private int idNum;\n    private double gpa;\n    private Address address;\n    // constructors\n    ...\n\n    // accessors\n    public Address getAddress() { return address; }\n\n    public int getIdNum() { return idNum; }\n\n    public double getGpa() { return gpa; }\n}\n\nA client method has this declaration: \n\nStudent[] allStudents = new Student[NUM_STUDS]; //NUM_STUDS is an int constant \n\nHere is a code segment to generate a list of Student names only. (You may assume that allStudents has been initialized.) \n\nfor (Student student : allStudents) \n    /* code to print list of names */ \n\nWhich is a correct replacement for /* code to print list of names */? \nCorrect: System.out.println(student.getAddress().getName());\nIncorrect: System.out.println(allStudents.getName());\nIncorrect: System.out.println(student.getName());\nIncorrect: System.out.println(allStudents.getAddress().getName());\nIncorrect: System.out.println(student[i].getAddress().getName());\n\nEND"}
{"prompt": "Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    /** constructor */\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    /** Write contents of Deck. */\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    /** Swap arr[i] and arr[j] in array arr. */\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    /**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     */\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            // generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards\u2014deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    /** constructor */\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    /** Shuffle the Decks. */\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    /** Write contents of all the Decks. */\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it\u2019s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the following classes:\n\npublic class Address {\n    private String name;\n    private String street;\n    private String city;\n    private String state;\n    private String zip;\n    // constructors\n    ...\n\n    // accessors\n    public String getName() { return name; }\n\n    public String getStreet() { return street; }\n\n    public String getCity() { return city; }\n\n    public String getState() { return state; }\n\n    public String getZip() { return zip; }\n}\n\npublic class Student {\n    private int idNum;\n    private double gpa;\n    private Address address;\n    // constructors\n    ...\n\n    // accessors\n    public Address getAddress() { return address; }\n\n    public int getIdNum() { return idNum; }\n\n    public double getGpa() { return gpa; }\n}\n\nHere is a method that locates the Student with the highest idNum: \n\n/** Precondition: Array stuArr of Student is initialized. \n* @return Student with highest idNum \n*/ \npublic static Student locate(Student[] stuArr) \n{ \n    /* method body */ \n} \n\nWhich of the following could replace /* method body */ so that the method works as intended? \nI int max = stuArr[0].getIdNum(); \nfor (Student student : stuArr) \n    if (student.getIdNum() > max) \n    { \n        max = student.getIdNum(); \n        return student; \n    } \nreturn stuArr[0]; \nII Student highestSoFar = stuArr[0]; \nint max = stuArr[0].getIdNum(); \nfor (Student student : stuArr) \n    if(student.getIdNum() > max) \n    { \n        max = student.getIdNum(); \n        highestSoFar = student; \n    } \nreturn highestSoFar; \nIII int maxPos = 0; \nfor(int i = 1; i < stuArr.length; i++) \n    if(stuArr[i].getIdNum() > stuArr[maxPos].getIdNum()) \n        maxPos = i; \nreturn stuArr[maxPos]; \nCorrect: II and III only\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and III onlyEND"}
{"prompt": "Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    /** constructor */\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    /** Write contents of Deck. */\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    /** Swap arr[i] and arr[j] in array arr. */\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    /**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     */\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            // generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards\u2014deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    /** constructor */\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    /** Shuffle the Decks. */\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    /** Write contents of all the Decks. */\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it\u2019s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the Ticket and Transaction classes defined below:\n\npublic class Ticket \n{ \n    private String row; \n    private int seat; \n    private double price; \n\n    //constructor \n    public Ticket(String aRow, int aSeat, double aPrice) \n    { \n        row = aRow; \n        seat = aSeat; \n        price = aPrice; \n    } \n\n    //accessors getRow(), getSeat(), and getPrice() \n    ... \n}\n\npublic class Transaction {\n    private int numTickets;\n    private Ticket[] tickList;\n\n    // constructor\n    public Transaction(int numTicks) \n    { \n        numTickets = numTicks; \n        tickList = new Ticket[numTicks]; \n        String theRow; \n        int theSeat; \n        double thePrice; \n        for (int i = 0; i < numTicks; i++) \n        { \n            < read user input for theRow, theSeat, and thePrice > \n            ... \n            /* more code */ \n        } \n    }\n\n    /** @return total amount paid for this transaction */\n    public double totalPaid() {\n        double total = 0.0;\n        /* code to calculate amount */\n        return total;\n    }\n}\n\nWhich of the following correctly replaces /* more code */ in the Transaction constructor to initialize the tickList array? \nCorrect: tickList[i] = new Ticket(theRow, theSeat, thePrice);\nIncorrect: tickList[i] = new Ticket(getRow(), getSeat(), getPrice());\nIncorrect: tickList[i] = new tickList(getRow(), getSeat(), getPrice());\nIncorrect: tickList[i] = new tickList(theRow, theSeat, thePrice);\nIncorrect: tickList[i] = new tickList(numTicks);\n\nEND"}
{"prompt": "Example 1\nDiscuss the efficiency of the countNegs method below. What are the best and worst case configurations of the data?\n/** Precondition: arr[0],...,arr[arr.length-1] contain integers.\n* @return the number of negative values in arr\n*/\npublic static int countNegs(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if (num < 0)\n            count++;\n    return count;\n}\n\nSolution:\nThis algorithm sequentially examines each element in the array. In the best case, there are no negative elements, and count++ is never executed. In the worst case, all the elements are negative, and count++ is executed in each pass of the for loop.\n\nExample 2\nThe code fragment below inserts a value, num, into its correct position in a sorted array of integers. Discuss the efficiency of the algorithm.\n\n/** Precondition:\n* - arr[0],...,arr[n-1] contain integers sorted in increasing order.\n* - n < arr.length.\n* Postcondition: num has been inserted in its correct position.\n*/\n{\n    //find insertion point\n    int i = 0;\n    while (i < n && num > arr[i])\n    i++;\n    //if necessary, move elements arr[i]...arr[n-1] up 1 slot\n    for (int j = n; j >= i + 1; j--)\n    arr[j] = arr[j-1];\n    //insert num in i-th slot and update n\n    arr[i] = num;\n    n++;\n}\n\nSolution:\nIn the best case, num is greater than all the elements in the array: Because it gets inserted at the end of the list, no elements must be moved to create a slot for it. The worst case has num less than all the elements in the array. In this case, num must be inserted in the first slot, arr[0], and every element in the array must be moved up one position to create a slot.\nThis algorithm illustrates a disadvantage of arrays: Insertion and deletion of an ele ment in an ordered list is inefficient, since, in the worst case, it may involve moving all the elements in the list.\nAn ArrayList provides an alternative way of storing a list of objects and has the fol lowing advantages over an array:\n\u2022 An ArrayList shrinks and grows as needed in a program, whereas an array has a fixed length that is set when the array is created.\n\u2022 In an ArrayList list, the last slot is always list.size()-1, whereas in a partially filled array, you, the programmer, must keep track of the last slot currently in use.\n\u2022 For an ArrayList, you can do insertion or deletion with just a single statement. Any shifting of elements is handled automatically. In an array, however, insertion or deletion requires you to write the code that shifts the elements.\n\nThe Collections API\nThe ArrayList class is in the Collections API (Application Programming Interface), which is a library provided by Java. Most of the API is in java.util. This library gives the programmer access to prepackaged data structures and the methods to manipulate them. The implementations of these container classes are invisible and should not be of concern to the programmer. The code works. And it is reusable.\nAll of the collections classes, including ArrayList, have the following features in common:\n\u2022 They are designed to be both memory and run-time efficient.\n\u2022 They provide methods for insertion and removal of items (i.e., they can grow and shrink).\n\u2022 They provide for iteration over the entire collection.\n\nInheritance is a defining feature of the Collections API. The interfaces that are used to manipulate the collections specify the operations that must be defined for any con tainer class that implements that interface.\n\nCollections and Generics\nThe collections classes are generic, with type parameters. Thus, List<E> and ArrayList<E> contain elements of type E. When a generic class is declared, the type parameter is replaced by an actual object type. For example,\nprivate ArrayList<Clown> clowns;\n\nNOTE\n1. The clowns list must contain only Clown objects. An attempt to add an Acrobat to the list, for example, will cause a compile-time error.\n2. Since the type of objects in a generic class is restricted, the elements can be accessed without casting.\n3. All of the type information in a program with generic classes is examined at compile time. After compilation the type information is erased. This feature of generic classes is known as erasure. During execution of the program, any attempt at incorrect casting will lead to a ClassCastException.\nThere are no primitive types in collections classes. An ArrayList must contain objects, not types like double and int. Numbers must therefore be boxed\u2014placed in wrapper classes like Integer and Double\u2014before insertion into an ArrayList.\nAuto-boxing is the automatic wrapping of primitive types in their wrapper classes.\nTo retrieve the numerical value of an Integer (or Double) stored in an ArrayList, the intValue() (or doubleValue()) method must be invoked (unwrapping). Auto unboxing is the automatic conversion of a wrapper class to its corresponding primitive type. This means that you don\u2019t need to explicitly call the intValue() or doubleValue() methods. Be aware that if a program tries to auto-unbox null, the method will throw a NullPointerException.\nNote that while auto-boxing and -unboxing cut down on code clutter, these oper ations must still be performed behind the scenes, leading to decreased run-time effi ciency. It is much more efficient to assign and access primitive types in an array than an ArrayList. You should therefore consider using an array for a program that manip ulates sequences of numbers and does not need to use objects.\n\nNOTE\nAuto-boxing and -unboxing is a feature in Java 5.0 and later versions and will not be tested on the AP exam. It is OK, however, to use this convenient feature in code that you write in the free-response questions.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the Ticket and Transaction classes defined below:\n\npublic class Ticket \n{ \n    private String row; \n    private int seat; \n    private double price; \n\n    //constructor \n    public Ticket(String aRow, int aSeat, double aPrice) \n    { \n        row = aRow; \n        seat = aSeat; \n        price = aPrice; \n    } \n\n    //accessors getRow(), getSeat(), and getPrice() \n    ... \n}\n\npublic class Transaction {\n    private int numTickets;\n    private Ticket[] tickList;\n\n    // constructor\n    public Transaction(int numTicks) \n    { \n        numTickets = numTicks; \n        tickList = new Ticket[numTicks]; \n        String theRow; \n        int theSeat; \n        double thePrice; \n        for (int i = 0; i < numTicks; i++) \n        { \n            < read user input for theRow, theSeat, and thePrice > \n            ... \n            /* more code */ \n        } \n    }\n\n    /** @return total amount paid for this transaction */\n    public double totalPaid() {\n        double total = 0.0;\n        /* code to calculate amount */\n        return total;\n    }\n}\n\nWhich represents correct /* code to calculate amount */ in the totalPaid method? \nCorrect: for (Ticket t : tickList)\n    total += t.getPrice(); \nIncorrect: for (Ticket t : tickList)\n    total += t.price; \nIncorrect: for (Ticket t : tickList)\n    total += tickList.getPrice(); \nIncorrect: Transaction T;\nfor (Ticket t : T) \n    total += t.getPrice(); \nIncorrect: Transaction T;\nfor (Ticket t : T) \n    total += t.price; \n\nEND"}
{"prompt": "Example 1\nDiscuss the efficiency of the countNegs method below. What are the best and worst case configurations of the data?\n/** Precondition: arr[0],...,arr[arr.length-1] contain integers.\n* @return the number of negative values in arr\n*/\npublic static int countNegs(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if (num < 0)\n            count++;\n    return count;\n}\n\nSolution:\nThis algorithm sequentially examines each element in the array. In the best case, there are no negative elements, and count++ is never executed. In the worst case, all the elements are negative, and count++ is executed in each pass of the for loop.\n\nExample 2\nThe code fragment below inserts a value, num, into its correct position in a sorted array of integers. Discuss the efficiency of the algorithm.\n\n/** Precondition:\n* - arr[0],...,arr[n-1] contain integers sorted in increasing order.\n* - n < arr.length.\n* Postcondition: num has been inserted in its correct position.\n*/\n{\n    //find insertion point\n    int i = 0;\n    while (i < n && num > arr[i])\n    i++;\n    //if necessary, move elements arr[i]...arr[n-1] up 1 slot\n    for (int j = n; j >= i + 1; j--)\n    arr[j] = arr[j-1];\n    //insert num in i-th slot and update n\n    arr[i] = num;\n    n++;\n}\n\nSolution:\nIn the best case, num is greater than all the elements in the array: Because it gets inserted at the end of the list, no elements must be moved to create a slot for it. The worst case has num less than all the elements in the array. In this case, num must be inserted in the first slot, arr[0], and every element in the array must be moved up one position to create a slot.\nThis algorithm illustrates a disadvantage of arrays: Insertion and deletion of an ele ment in an ordered list is inefficient, since, in the worst case, it may involve moving all the elements in the list.\nAn ArrayList provides an alternative way of storing a list of objects and has the fol lowing advantages over an array:\n\u2022 An ArrayList shrinks and grows as needed in a program, whereas an array has a fixed length that is set when the array is created.\n\u2022 In an ArrayList list, the last slot is always list.size()-1, whereas in a partially filled array, you, the programmer, must keep track of the last slot currently in use.\n\u2022 For an ArrayList, you can do insertion or deletion with just a single statement. Any shifting of elements is handled automatically. In an array, however, insertion or deletion requires you to write the code that shifts the elements.\n\nThe Collections API\nThe ArrayList class is in the Collections API (Application Programming Interface), which is a library provided by Java. Most of the API is in java.util. This library gives the programmer access to prepackaged data structures and the methods to manipulate them. The implementations of these container classes are invisible and should not be of concern to the programmer. The code works. And it is reusable.\nAll of the collections classes, including ArrayList, have the following features in common:\n\u2022 They are designed to be both memory and run-time efficient.\n\u2022 They provide methods for insertion and removal of items (i.e., they can grow and shrink).\n\u2022 They provide for iteration over the entire collection.\n\nInheritance is a defining feature of the Collections API. The interfaces that are used to manipulate the collections specify the operations that must be defined for any con tainer class that implements that interface.\n\nCollections and Generics\nThe collections classes are generic, with type parameters. Thus, List<E> and ArrayList<E> contain elements of type E. When a generic class is declared, the type parameter is replaced by an actual object type. For example,\nprivate ArrayList<Clown> clowns;\n\nNOTE\n1. The clowns list must contain only Clown objects. An attempt to add an Acrobat to the list, for example, will cause a compile-time error.\n2. Since the type of objects in a generic class is restricted, the elements can be accessed without casting.\n3. All of the type information in a program with generic classes is examined at compile time. After compilation the type information is erased. This feature of generic classes is known as erasure. During execution of the program, any attempt at incorrect casting will lead to a ClassCastException.\nThere are no primitive types in collections classes. An ArrayList must contain objects, not types like double and int. Numbers must therefore be boxed\u2014placed in wrapper classes like Integer and Double\u2014before insertion into an ArrayList.\nAuto-boxing is the automatic wrapping of primitive types in their wrapper classes.\nTo retrieve the numerical value of an Integer (or Double) stored in an ArrayList, the intValue() (or doubleValue()) method must be invoked (unwrapping). Auto unboxing is the automatic conversion of a wrapper class to its corresponding primitive type. This means that you don\u2019t need to explicitly call the intValue() or doubleValue() methods. Be aware that if a program tries to auto-unbox null, the method will throw a NullPointerException.\nNote that while auto-boxing and -unboxing cut down on code clutter, these oper ations must still be performed behind the scenes, leading to decreased run-time effi ciency. It is much more efficient to assign and access primitive types in an array than an ArrayList. You should therefore consider using an array for a program that manip ulates sequences of numbers and does not need to use objects.\n\nNOTE\nAuto-boxing and -unboxing is a feature in Java 5.0 and later versions and will not be tested on the AP exam. It is OK, however, to use this convenient feature in code that you write in the free-response questions.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the Ticket and Transaction classes defined below:\n\npublic class Ticket \n{ \n    private String row; \n    private int seat; \n    private double price; \n\n    //constructor \n    public Ticket(String aRow, int aSeat, double aPrice) \n    { \n        row = aRow; \n        seat = aSeat; \n        price = aPrice; \n    } \n\n    //accessors getRow(), getSeat(), and getPrice() \n    ... \n}\n\npublic class Transaction {\n    private int numTickets;\n    private Ticket[] tickList;\n\n    // constructor\n    public Transaction(int numTicks) \n    { \n        numTickets = numTicks; \n        tickList = new Ticket[numTicks]; \n        String theRow; \n        int theSeat; \n        double thePrice; \n        for (int i = 0; i < numTicks; i++) \n        { \n            < read user input for theRow, theSeat, and thePrice > \n            ... \n            /* more code */ \n        } \n    }\n\n    /** @return total amount paid for this transaction */\n    public double totalPaid() {\n        double total = 0.0;\n        /* code to calculate amount */\n        return total;\n    }\n}\n\nSuppose it is necessary to keep a list of all ticket transactions. Assuming that there are NUMSALES transactions, a suitable declaration would be \nCorrect: Transaction[] listOfSales = new Transaction[NUMSALES];\nIncorrect: Transaction[] listOfSales = new Ticket[NUMSALES];\nIncorrect: Ticket[] listOfSales = new Transaction[NUMSALES];\nIncorrect: Ticket[] listOfSales = new Ticket[NUMSALES];\nIncorrect: Transaction[] Ticket = new listOfSales[NUMSALES];\n\nEND"}
{"prompt": "An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (\u201csubscripts\u201d) go from 0 to N \u2212 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k \u2265 N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java\u2019s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; //declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; //reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n//loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); //assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n/** @return the number of even integers in array arr of integers */ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) //num is even\n            count++;\n    return count;\n}\nExample 2\n/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: The following code fragment is intended to find the smallest value in arr[0] . . . arr[n-1]. \n\n/** Precondition: \n* - arr is an array, arr.length = n. \n* - arr[0]...arr[n-1] initialized with integers. \n* Postcondition: min = smallest value in arr[0]...arr[n-1]. \n*/ \nint min = arr[0]; \nint i = 1; \nwhile (i < n) \n{ \n    i++; \n    if (arr[i] < min) \n    min = arr[i]; \n} \n\nThis code is incorrect. For the segment to work as intended, which of the following modifications could be made? \nI Change the line \nint i = 1; \nto \nint i = 0; \nMake no other changes. \nII Change the body of the while loop to \n{ \n    if (arr[i] < min) \n    min = arr[i]; \n    i++; \n} \nMake no other changes. \nIII Change the test for the while loop as follows: \nwhile (i <= n) \nMake no other changes. \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (\u201csubscripts\u201d) go from 0 to N \u2212 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k \u2265 N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java\u2019s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; //declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; //reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n//loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); //assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n/** @return the number of even integers in array arr of integers */ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) //num is even\n            count++;\n    return count;\n}\nExample 2\n/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Refer to method match below: \n\n/** @param v an array of int sorted in increasing order \n* @param w an array of int sorted in increasing order \n* @param N the number of elements in array v \n* @param M the number of elements in array w \n* @return true if there is an integer k that occurs \n* in both arrays; otherwise returns false \n* Precondition: \n* v[0]..v[N-1] and w[0]..w[M-1] initialized with integers. \n* v[0] < v[1] < .. < v[N-1] and w[0] < w[1] < .. < w[M-1]. \n*/ \npublic static boolean match(int[] v, int[] w, int N, int M) \n{ \n    int vIndex = 0, wIndex = 0; \n    while (vIndex < N && wIndex < M) \n    { \n        if (v[vIndex] == w[wIndex]) \n            return true; \n        else if (v[vIndex] < w[wIndex]) \n            vIndex++; \n        else \n            wIndex++; \n    } \n    return false; \n} \n\nAssuming that the method has not been exited, which assertion is true at the end of every execution of the while loop? \nCorrect: v[0]..v[vIndex-1] and w[0]..w[wIndex-1] contain no common value,\nvIndex \u2264 N and wIndex \u2264 M. \nIncorrect: v[0]..v[vIndex] and w[0]..w[wIndex] contain no common value,\nvIndex \u2264 N and wIndex \u2264 M. \nIncorrect: v[0]..v[vIndex-1] and w[0]..w[wIndex-1] contain no common value,\nvIndex \u2264 N-1 and wIndex \u2264 M-1. \nIncorrect: v[0]..v[vIndex] and w[0]..w[wIndex] contain no common value,\nvIndex \u2264 N-1 and wIndex \u2264 M-1. \nIncorrect: v[0]..v[N-1] and w[0]..w[M-1] contain no common value,\nvIndex \u2264 N and wIndex \u2264 M.\n\nEND"}
{"prompt": "Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    /** constructor */\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    /** Write contents of Deck. */\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    /** Swap arr[i] and arr[j] in array arr. */\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    /**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     */\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            // generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards\u2014deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    /** constructor */\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    /** Shuffle the Decks. */\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    /** Write contents of all the Decks. */\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it\u2019s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider this class: \n\npublic class Book {\n    private String title;\n    private String author;\n    private boolean checkoutStatus;\n\n    public Book(String bookTitle, String bookAuthor) {\n        title = bookTitle;\n        author = bookAuthor;\n        checkoutStatus = false;\n    }\n\n    /** Change checkout status. */\n    public void changeStatus() {\n        checkoutStatus = !checkoutStatus;\n    }\n    \n    // Other methods are not shown.\n}\n\nA client program has this declaration: \n\nBook[] bookList = new Book[SOME_NUMBER]; \n\nSuppose bookList is initialized so that each Book in the list has a title, author, and checkout status. The following piece of code is written, whose intent is to change the checkout status of each book in bookList. \n\nfor (Book b : bookList) \n    b.changeStatus(); \n\nWhich is true about this code? \nCorrect: Each book in the bookList array will have its checkout status changed, as intended.\nIncorrect: The bookList array will remain unchanged after execution.\nIncorrect: A NullPointerException may occur.\nIncorrect: A run-time error will occur because it is not possible to modify objects using the for-each loop.\nIncorrect: A logic error will occur because it is not possible to modify objects in an array without accessing the indexes of the objects.\n\nEND"}
{"prompt": "Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    /** constructor */\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    /** Write contents of Deck. */\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    /** Swap arr[i] and arr[j] in array arr. */\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    /**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     */\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            // generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards\u2014deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    /** constructor */\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    /** Shuffle the Decks. */\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    /** Write contents of all the Decks. */\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it\u2019s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the BingoCard class defined below:\n\npublic class BingoCard {\n    private int[] card;\n\n    /**\n     * Default constructor: Creates BingoCard with\n     * 20 random digits in the range 1 - 90.\n     */\n    public BingoCard() { /* implementation not shown */ }\n\n    /* Display BingoCard. */\n    public void display() { /* implementation not shown */ }\n    \n    ...\n}\n\nA program that simulates a bingo game declares an array of BingoCard. The array has NUMPLAYERS elements, where each element represents the card of a different player. Here is a code segment that creates all the bingo cards in the game: \n/* declare array of BingoCard */ \n/* construct each BingoCard */ \n\nWhich of the following is a correct replacement for \n/* declare array of BingoCard */? \nCorrect: BingoCard[] players = new BingoCard[NUMPLAYERS];\nIncorrect: int[] BingoCard = new BingoCard[NUMPLAYERS];\nIncorrect: BingoCard[] players = new int[NUMPLAYERS];\nIncorrect: BingoCard[] players = new BingoCard[20];\nIncorrect: int[] players = new BingoCard[NUMPLAYERS];\n\nEND"}
{"prompt": "Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    /** constructor */\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    /** Write contents of Deck. */\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    /** Swap arr[i] and arr[j] in array arr. */\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    /**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     */\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            // generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards\u2014deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    /** constructor */\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    /** Shuffle the Decks. */\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    /** Write contents of all the Decks. */\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it\u2019s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the BingoCard class defined below:\n\npublic class BingoCard {\n    private int[] card;\n\n    /**\n     * Default constructor: Creates BingoCard with\n     * 20 random digits in the range 1 - 90.\n     */\n    public BingoCard() { /* implementation not shown */ }\n\n    /* Display BingoCard. */\n    public void display() { /* implementation not shown */ }\n    \n    ...\n}\n\nA program that simulates a bingo game declares an array of BingoCard. The array has NUMPLAYERS elements, where each element represents the card of a different player. Here is a code segment that creates all the bingo cards in the game: \n/* declare array of BingoCard */ \n/* construct each BingoCard */ \n\nAssuming that players has been declared as an array of BingoCard, which of the following is a correct replacement for \n/* construct each BingoCard */ \nI for (BingoCard card : players) \n    card = new BingoCard(); \nII for (BingoCard card : players) \n    players[card] = new BingoCard(); \nIII for (int i = 0; i < players.length; i++) \n    players[i] = new BingoCard(); \nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "A class that implements the List<E> interface\u2014ArrayList<E>, for example\u2014is a list of elements of type E. In a list, duplicate elements are allowed. The elements of the list are indexed, with 0 being the index of the first element.\nA list allows you to\n\u2022 Access an element at any position in the list using its integer index.\n\u2022 Insert an element anywhere in the list.\n\u2022 Iterate over all elements using ListIterator or Iterator (not in the AP subset).\n\nHere are the methods you should know.\nboolean add(E obj)\nAppends obj to the end of the list. Always returns true. If the specified element is not of type E, throws a ClassCastException.\nint size()\nReturns the number of elements in the list.\nE get(int index)\nReturns the element at the specified index in the list.\nE set(int index, E element)\nReplaces item at specified index in the list with specified element. Returns the element that was previously at index. Throws a ClassCastException if the specified element is not of type E.\nvoid add(int index, E element)\nInserts element at specified index. Elements from position index and higher have 1 added to their indices. Size of list is incremented by 1.\nE remove(int index)\nRemoves and returns the element at the specified index. Elements to the right of position index have 1 subtracted from their indices. Size of list is decreased by 1.\nIterator<E> iterator()\nReturns an iterator over the elements in the list, in proper sequence, starting at the first element.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Which declaration will cause an error? \nI List<String> stringList = new ArrayList<String>(); \nII List<int> intList = new ArrayList<int>(); \nIII ArrayList<String> compList = new ArrayList<String>(); \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and III only\nIncorrect: II and III only\n\nEND"}
{"prompt": "A class that implements the List<E> interface\u2014ArrayList<E>, for example\u2014is a list of elements of type E. In a list, duplicate elements are allowed. The elements of the list are indexed, with 0 being the index of the first element.\nA list allows you to\n\u2022 Access an element at any position in the list using its integer index.\n\u2022 Insert an element anywhere in the list.\n\u2022 Iterate over all elements using ListIterator or Iterator (not in the AP subset).\n\nHere are the methods you should know.\nboolean add(E obj)\nAppends obj to the end of the list. Always returns true. If the specified element is not of type E, throws a ClassCastException.\nint size()\nReturns the number of elements in the list.\nE get(int index)\nReturns the element at the specified index in the list.\nE set(int index, E element)\nReplaces item at specified index in the list with specified element. Returns the element that was previously at index. Throws a ClassCastException if the specified element is not of type E.\nvoid add(int index, E element)\nInserts element at specified index. Elements from position index and higher have 1 added to their indices. Size of list is incremented by 1.\nE remove(int index)\nRemoves and returns the element at the specified index. Elements to the right of position index have 1 subtracted from their indices. Size of list is decreased by 1.\nIterator<E> iterator()\nReturns an iterator over the elements in the list, in proper sequence, starting at the first element.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider these declarations: \n\nList<String> strList = new ArrayList<String>(); \nString ch = \" \"; \nInteger intOb = new Integer(5); \n\nWhich statement will cause an error? \nCorrect: strList.add(intOb + 8);\n\n\nIncorrect: strList.add(ch);\nIncorrect: strList.add(new String(\"handy andy\"));\nIncorrect: strList.add(intOb.toString());\nIncorrect: strList.add(ch + 8);END"}
{"prompt": "This is an array implementation of the List<E> interface. The main difference between an array and an ArrayList is that an ArrayList is resizable during run time, whereas an array has a fixed size at construction.\nShifting of elements, if any, caused by insertion or deletion, is handled automatically by ArrayList. Operations to insert or delete at the end of the list are very efficient. Be aware, however, that at some point there will be a resizing; but, on average, over time, an insertion at the end of the list is a single, quick operation. In general, insertion or deletion in the middle of an ArrayList requires elements to be shifted to accommodate a new element (add), or to close a \u201chole\u201d (remove).\n\nTHE METHODS OF ArrayList<E>\nIn addition to the two add methods, and size, get, set, and remove, you must know the following constructor.\nArrayList()\nConstructs an empty list.\n\nNOTE\nEach method above that has an index parameter\u2014add, get, remove, and set\u2014throws an IndexOutOfBoundsException if index is out of range. For get, remove, and set, index is out of range if\nindex < 0 || index >= size()\nFor add, however, it is OK to add an element at the end of the list. Therefore index is out of range if\nindex < 0 || index > size()\n\nUsing ArrayList<E>\nExample 1\n//Create an ArrayList containing 0 1 4 9.\nList<Integer> list = new ArrayList<Integer>(); //An ArrayList is-a List\nfor (int i = 0; i < 4; i++)\n    list.add(i * i); //example of auto-boxing\n//i*i wrapped in an Integer before insertion\nInteger intOb = list.get(2); //assigns Integer with value 4 to intOb.\n//Leaves list unchanged.\nint n = list.get(3); //example of auto-unboxing\n//Integer is retrieved and converted to int\n//n contains 9\nInteger x = list.set(3, 5); //list is 0 1 4 5\n//x contains Integer with value 9\nx = list.remove(2);\n//list is 0 1 5\n//x contains Integer with value 4\nlist.add(1, 7);\n//list is 0 7 1 5\nlist.add(2, 8);\n//list is 0 7 8 1 5\n\nExample 2\n//Traversing an ArrayList of Integer.\n//Print the elements of list, one per line.\nfor (Integer num : list)\n    System.out.println(num);\n\nExample 3\n/** Precondition: List list is an ArrayList that contains Integer\n* values sorted in increasing order.\n* Postcondition: value inserted in its correct position in list.\n*/\npublic static void insert(List<Integer> list, Integer value)\n{\n    int index = 0;\n    //find insertion point\n    while (index < list.size() &&\n        value.compareTo(list.get(index)) > 0)\n        index++;\n    //insert value\n    list.add(index, value);\n}\n\nNOTE\nSuppose value is larger than all the elements in list. Then the insert method will throw an IndexOutOfBoundsException if the first part of the test is omitted, namely index < list.size().\n\nExample 4\n/** @return an ArrayList of random integers from 0 to 100 */\npublic static List<Integer> getRandomIntList()\n{\n    List<Integer> list = new ArrayList<Integer>();\n    System.out.print(\"How many integers? \");\n    int length = IO.readInt(); //read user input\n    for (int i = 0; i < length; i++)\n    {\n        int newNum = (int) (Math.random() * 101);\n        list.add(new Integer(newNum));\n    }\n    return list;\n}\n\nNOTE\n1. The variable list is declared to be of type List<Integer> (the interface) but is instantiated as type ArrayList<Integer> (the implementation).\n2. The add method in getRandomIntList is the List method that appends its parameter to the end of the list.\n\nExample 5\n/** Swap two values in list, indexed at i and j. */\npublic static void swap(List<E> list, int i, int j)\n{\n    E temp = list.get(i);\n    list.set(i, list.get(j));\n    list.set(j, temp);\n}\n\nExample 6\n/** Print all negatives in list a.\n* Precondition: a contains Integer values.\n*/\npublic static void printNegs(List<Integer> a)\n{\n    System.out.println(\"The negative values in the list are: \");\n    for (Integer i : a)\n        if (i.intValue() < 0)\n            System.out.println(i);\n}\n\nExample 7\n/** Change every even-indexed element of strList to the empty string.\n* Precondition: strList contains String values.\n*/\npublic static void changeEvenToEmpty(List<String> strList)\n{\n    boolean even = true;\n    int index = 0;\n    while (index < strList.size())\n    {\n        if (even)\n            strList.set(index, \"\");\n        index++;\n        even = !even;\n    }\n}\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Let list be an ArrayList<Integer> containing these elements: \n2 5 7 6 0 1 \nWhich of the following statements would not cause an error to occur? Assume that each statement applies to the given list, independent of the other statements. \nCorrect: list.add(6, 9);\nIncorrect: Object ob = list.get(6);\nIncorrect: Integer intOb = list.add(3.4);\nIncorrect: Object x = list.remove(6);\nIncorrect: Object y = list.set(6, 8);\n\nEND"}
{"prompt": "A class that implements the List<E> interface\u2014ArrayList<E>, for example\u2014is a list of elements of type E. In a list, duplicate elements are allowed. The elements of the list are indexed, with 0 being the index of the first element.\nA list allows you to\n\u2022 Access an element at any position in the list using its integer index.\n\u2022 Insert an element anywhere in the list.\n\u2022 Iterate over all elements using ListIterator or Iterator (not in the AP subset).\n\nHere are the methods you should know.\nboolean add(E obj)\nAppends obj to the end of the list. Always returns true. If the specified element is not of type E, throws a ClassCastException.\nint size()\nReturns the number of elements in the list.\nE get(int index)\nReturns the element at the specified index in the list.\nE set(int index, E element)\nReplaces item at specified index in the list with specified element. Returns the element that was previously at index. Throws a ClassCastException if the specified element is not of type E.\nvoid add(int index, E element)\nInserts element at specified index. Elements from position index and higher have 1 added to their indices. Size of list is incremented by 1.\nE remove(int index)\nRemoves and returns the element at the specified index. Elements to the right of position index have 1 subtracted from their indices. Size of list is decreased by 1.\nIterator<E> iterator()\nReturns an iterator over the elements in the list, in proper sequence, starting at the first element.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Refer to method insert below: \n\n/** @param list an ArrayList of String objects \n* @param element a String object \n* Precondition: list contains String values sorted \n* in decreasing order. \n* Postcondition: element inserted in its correct position in list. \n*/ \npublic void insert(List<String> list, String element) \n{ \n    int index = 0; \n    while (element.compareTo(list.get(index)) < 0) \n        index++; \n    list.add(index, element); \n} \n\nAssuming that the type of element is compatible with the objects in the list, which is a true statement about the insert method? \nCorrect: It fails if element is smaller than the last item in list and works in all other cases.\nIncorrect: It works as intended for all values of element.\nIncorrect: It fails for all values of element.\nIncorrect: It fails if element is greater than the first item in list and works in all other cases.\nIncorrect: It fails if element is either greater than the first item or smaller than the last item in list and works in all other cases.\n\nEND"}
{"prompt": "This is an array implementation of the List<E> interface. The main difference between an array and an ArrayList is that an ArrayList is resizable during run time, whereas an array has a fixed size at construction.\nShifting of elements, if any, caused by insertion or deletion, is handled automatically by ArrayList. Operations to insert or delete at the end of the list are very efficient. Be aware, however, that at some point there will be a resizing; but, on average, over time, an insertion at the end of the list is a single, quick operation. In general, insertion or deletion in the middle of an ArrayList requires elements to be shifted to accommodate a new element (add), or to close a \u201chole\u201d (remove).\n\nTHE METHODS OF ArrayList<E>\nIn addition to the two add methods, and size, get, set, and remove, you must know the following constructor.\nArrayList()\nConstructs an empty list.\n\nNOTE\nEach method above that has an index parameter\u2014add, get, remove, and set\u2014throws an IndexOutOfBoundsException if index is out of range. For get, remove, and set, index is out of range if\nindex < 0 || index >= size()\nFor add, however, it is OK to add an element at the end of the list. Therefore index is out of range if\nindex < 0 || index > size()\n\nUsing ArrayList<E>\nExample 1\n//Create an ArrayList containing 0 1 4 9.\nList<Integer> list = new ArrayList<Integer>(); //An ArrayList is-a List\nfor (int i = 0; i < 4; i++)\n    list.add(i * i); //example of auto-boxing\n//i*i wrapped in an Integer before insertion\nInteger intOb = list.get(2); //assigns Integer with value 4 to intOb.\n//Leaves list unchanged.\nint n = list.get(3); //example of auto-unboxing\n//Integer is retrieved and converted to int\n//n contains 9\nInteger x = list.set(3, 5); //list is 0 1 4 5\n//x contains Integer with value 9\nx = list.remove(2);\n//list is 0 1 5\n//x contains Integer with value 4\nlist.add(1, 7);\n//list is 0 7 1 5\nlist.add(2, 8);\n//list is 0 7 8 1 5\n\nExample 2\n//Traversing an ArrayList of Integer.\n//Print the elements of list, one per line.\nfor (Integer num : list)\n    System.out.println(num);\n\nExample 3\n/** Precondition: List list is an ArrayList that contains Integer\n* values sorted in increasing order.\n* Postcondition: value inserted in its correct position in list.\n*/\npublic static void insert(List<Integer> list, Integer value)\n{\n    int index = 0;\n    //find insertion point\n    while (index < list.size() &&\n        value.compareTo(list.get(index)) > 0)\n        index++;\n    //insert value\n    list.add(index, value);\n}\n\nNOTE\nSuppose value is larger than all the elements in list. Then the insert method will throw an IndexOutOfBoundsException if the first part of the test is omitted, namely index < list.size().\n\nExample 4\n/** @return an ArrayList of random integers from 0 to 100 */\npublic static List<Integer> getRandomIntList()\n{\n    List<Integer> list = new ArrayList<Integer>();\n    System.out.print(\"How many integers? \");\n    int length = IO.readInt(); //read user input\n    for (int i = 0; i < length; i++)\n    {\n        int newNum = (int) (Math.random() * 101);\n        list.add(new Integer(newNum));\n    }\n    return list;\n}\n\nNOTE\n1. The variable list is declared to be of type List<Integer> (the interface) but is instantiated as type ArrayList<Integer> (the implementation).\n2. The add method in getRandomIntList is the List method that appends its parameter to the end of the list.\n\nExample 5\n/** Swap two values in list, indexed at i and j. */\npublic static void swap(List<E> list, int i, int j)\n{\n    E temp = list.get(i);\n    list.set(i, list.get(j));\n    list.set(j, temp);\n}\n\nExample 6\n/** Print all negatives in list a.\n* Precondition: a contains Integer values.\n*/\npublic static void printNegs(List<Integer> a)\n{\n    System.out.println(\"The negative values in the list are: \");\n    for (Integer i : a)\n        if (i.intValue() < 0)\n            System.out.println(i);\n}\n\nExample 7\n/** Change every even-indexed element of strList to the empty string.\n* Precondition: strList contains String values.\n*/\npublic static void changeEvenToEmpty(List<String> strList)\n{\n    boolean even = true;\n    int index = 0;\n    while (index < strList.size())\n    {\n        if (even)\n            strList.set(index, \"\");\n        index++;\n        even = !even;\n    }\n}\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following code segment, applied to list, an ArrayList of Integer values. \n\nint len = list.size(); \nfor (int i = 0; i < len; i++) \n{ \n    list.add(i + 1, new Integer(i)); \n    Object x = list.set(i, new Integer(i + 2)); \n} \n\nIf list is initially 6 1 8, what will it be following execution of the code segment? \nCorrect: 2 3 4 2 1 8\nIncorrect: 2 3 4 6 2 2 0 1 8\nIncorrect: 2 3 4 0 1 2\nIncorrect: 2 3 4 6 1 8\nIncorrect: 2 3 3 2\n\nEND"}
{"prompt": "This is an array implementation of the List<E> interface. The main difference between an array and an ArrayList is that an ArrayList is resizable during run time, whereas an array has a fixed size at construction.\nShifting of elements, if any, caused by insertion or deletion, is handled automatically by ArrayList. Operations to insert or delete at the end of the list are very efficient. Be aware, however, that at some point there will be a resizing; but, on average, over time, an insertion at the end of the list is a single, quick operation. In general, insertion or deletion in the middle of an ArrayList requires elements to be shifted to accommodate a new element (add), or to close a \u201chole\u201d (remove).\n\nTHE METHODS OF ArrayList<E>\nIn addition to the two add methods, and size, get, set, and remove, you must know the following constructor.\nArrayList()\nConstructs an empty list.\n\nNOTE\nEach method above that has an index parameter\u2014add, get, remove, and set\u2014throws an IndexOutOfBoundsException if index is out of range. For get, remove, and set, index is out of range if\nindex < 0 || index >= size()\nFor add, however, it is OK to add an element at the end of the list. Therefore index is out of range if\nindex < 0 || index > size()\n\nUsing ArrayList<E>\nExample 1\n//Create an ArrayList containing 0 1 4 9.\nList<Integer> list = new ArrayList<Integer>(); //An ArrayList is-a List\nfor (int i = 0; i < 4; i++)\n    list.add(i * i); //example of auto-boxing\n//i*i wrapped in an Integer before insertion\nInteger intOb = list.get(2); //assigns Integer with value 4 to intOb.\n//Leaves list unchanged.\nint n = list.get(3); //example of auto-unboxing\n//Integer is retrieved and converted to int\n//n contains 9\nInteger x = list.set(3, 5); //list is 0 1 4 5\n//x contains Integer with value 9\nx = list.remove(2);\n//list is 0 1 5\n//x contains Integer with value 4\nlist.add(1, 7);\n//list is 0 7 1 5\nlist.add(2, 8);\n//list is 0 7 8 1 5\n\nExample 2\n//Traversing an ArrayList of Integer.\n//Print the elements of list, one per line.\nfor (Integer num : list)\n    System.out.println(num);\n\nExample 3\n/** Precondition: List list is an ArrayList that contains Integer\n* values sorted in increasing order.\n* Postcondition: value inserted in its correct position in list.\n*/\npublic static void insert(List<Integer> list, Integer value)\n{\n    int index = 0;\n    //find insertion point\n    while (index < list.size() &&\n        value.compareTo(list.get(index)) > 0)\n        index++;\n    //insert value\n    list.add(index, value);\n}\n\nNOTE\nSuppose value is larger than all the elements in list. Then the insert method will throw an IndexOutOfBoundsException if the first part of the test is omitted, namely index < list.size().\n\nExample 4\n/** @return an ArrayList of random integers from 0 to 100 */\npublic static List<Integer> getRandomIntList()\n{\n    List<Integer> list = new ArrayList<Integer>();\n    System.out.print(\"How many integers? \");\n    int length = IO.readInt(); //read user input\n    for (int i = 0; i < length; i++)\n    {\n        int newNum = (int) (Math.random() * 101);\n        list.add(new Integer(newNum));\n    }\n    return list;\n}\n\nNOTE\n1. The variable list is declared to be of type List<Integer> (the interface) but is instantiated as type ArrayList<Integer> (the implementation).\n2. The add method in getRandomIntList is the List method that appends its parameter to the end of the list.\n\nExample 5\n/** Swap two values in list, indexed at i and j. */\npublic static void swap(List<E> list, int i, int j)\n{\n    E temp = list.get(i);\n    list.set(i, list.get(j));\n    list.set(j, temp);\n}\n\nExample 6\n/** Print all negatives in list a.\n* Precondition: a contains Integer values.\n*/\npublic static void printNegs(List<Integer> a)\n{\n    System.out.println(\"The negative values in the list are: \");\n    for (Integer i : a)\n        if (i.intValue() < 0)\n            System.out.println(i);\n}\n\nExample 7\n/** Change every even-indexed element of strList to the empty string.\n* Precondition: strList contains String values.\n*/\npublic static void changeEvenToEmpty(List<String> strList)\n{\n    boolean even = true;\n    int index = 0;\n    while (index < strList.size())\n    {\n        if (even)\n            strList.set(index, \"\");\n        index++;\n        even = !even;\n    }\n}\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the Coin and Purse classes defined below:\n\n/* A simple coin class */\npublic class Coin {\n    private double value;\n    private String name;\n\n    // constructor\n    public Coin(double coinValue, String coinName) {\n        value = coinValue;\n        name = coinName;\n    }\n\n    /** @return the value of this coin */\n    public double getValue() { return value; }\n\n    /** @return the name of this coin */\n    public String getName() { return name; }\n\n    /**\n     * @param obj a Coin object\n     * @return true if this coin equals obj; otherwise false\n     */\n    public boolean equals(Object obj) { return name.equals(((Coin) obj).name); }\n    \n    // Other methods are not shown.\n}\n\n/* A purse holds a collection of coins */\npublic class Purse {\n    private List<Coin> coins;\n\n    /** Creates an empty purse. */\n    public Purse() { coins = new ArrayList<Coin>(); }\n\n    /**\n     * Adds aCoin to the purse.\n     * \n     * @param aCoin the coin to be added to the purse\n     */\n    public void add(Coin aCoin) { coins.add(aCoin); }\n\n    /** @return the total value of coins in purse */\n    public double getTotal() { /* implementation not shown */ }\n}\n\nHere is the getTotal method from the Purse class: \n\n/** @return the total value of coins in purse */ \npublic double getTotal() \n    { \n    double total = 0; \n    /* more code */ \n    return total; \n} \n\nWhich of the following is a correct replacement for /* more code */? \nCorrect: for (Coin c : coins)\n{ \n    total += c.getValue(); \n}\n\n\nIncorrect: for (Coin c : coins)\n{ \n    c = coins.get(i); \n    total += c.getValue(); \n} \nIncorrect: for (Coin c : coins)\n{ \n    Coin value = c.getValue(); \n    total += value; \n} \nIncorrect: for (Coin c : coins)\n{ \n    Coin c = coins.get(i); \n    total += c.getValue(); \n} \nIncorrect: for (Coin c : coins)\n{ \n    total += coins.getValue(); \n} END"}
{"prompt": "This is an array implementation of the List<E> interface. The main difference between an array and an ArrayList is that an ArrayList is resizable during run time, whereas an array has a fixed size at construction.\nShifting of elements, if any, caused by insertion or deletion, is handled automatically by ArrayList. Operations to insert or delete at the end of the list are very efficient. Be aware, however, that at some point there will be a resizing; but, on average, over time, an insertion at the end of the list is a single, quick operation. In general, insertion or deletion in the middle of an ArrayList requires elements to be shifted to accommodate a new element (add), or to close a \u201chole\u201d (remove).\n\nTHE METHODS OF ArrayList<E>\nIn addition to the two add methods, and size, get, set, and remove, you must know the following constructor.\nArrayList()\nConstructs an empty list.\n\nNOTE\nEach method above that has an index parameter\u2014add, get, remove, and set\u2014throws an IndexOutOfBoundsException if index is out of range. For get, remove, and set, index is out of range if\nindex < 0 || index >= size()\nFor add, however, it is OK to add an element at the end of the list. Therefore index is out of range if\nindex < 0 || index > size()\n\nUsing ArrayList<E>\nExample 1\n//Create an ArrayList containing 0 1 4 9.\nList<Integer> list = new ArrayList<Integer>(); //An ArrayList is-a List\nfor (int i = 0; i < 4; i++)\n    list.add(i * i); //example of auto-boxing\n//i*i wrapped in an Integer before insertion\nInteger intOb = list.get(2); //assigns Integer with value 4 to intOb.\n//Leaves list unchanged.\nint n = list.get(3); //example of auto-unboxing\n//Integer is retrieved and converted to int\n//n contains 9\nInteger x = list.set(3, 5); //list is 0 1 4 5\n//x contains Integer with value 9\nx = list.remove(2);\n//list is 0 1 5\n//x contains Integer with value 4\nlist.add(1, 7);\n//list is 0 7 1 5\nlist.add(2, 8);\n//list is 0 7 8 1 5\n\nExample 2\n//Traversing an ArrayList of Integer.\n//Print the elements of list, one per line.\nfor (Integer num : list)\n    System.out.println(num);\n\nExample 3\n/** Precondition: List list is an ArrayList that contains Integer\n* values sorted in increasing order.\n* Postcondition: value inserted in its correct position in list.\n*/\npublic static void insert(List<Integer> list, Integer value)\n{\n    int index = 0;\n    //find insertion point\n    while (index < list.size() &&\n        value.compareTo(list.get(index)) > 0)\n        index++;\n    //insert value\n    list.add(index, value);\n}\n\nNOTE\nSuppose value is larger than all the elements in list. Then the insert method will throw an IndexOutOfBoundsException if the first part of the test is omitted, namely index < list.size().\n\nExample 4\n/** @return an ArrayList of random integers from 0 to 100 */\npublic static List<Integer> getRandomIntList()\n{\n    List<Integer> list = new ArrayList<Integer>();\n    System.out.print(\"How many integers? \");\n    int length = IO.readInt(); //read user input\n    for (int i = 0; i < length; i++)\n    {\n        int newNum = (int) (Math.random() * 101);\n        list.add(new Integer(newNum));\n    }\n    return list;\n}\n\nNOTE\n1. The variable list is declared to be of type List<Integer> (the interface) but is instantiated as type ArrayList<Integer> (the implementation).\n2. The add method in getRandomIntList is the List method that appends its parameter to the end of the list.\n\nExample 5\n/** Swap two values in list, indexed at i and j. */\npublic static void swap(List<E> list, int i, int j)\n{\n    E temp = list.get(i);\n    list.set(i, list.get(j));\n    list.set(j, temp);\n}\n\nExample 6\n/** Print all negatives in list a.\n* Precondition: a contains Integer values.\n*/\npublic static void printNegs(List<Integer> a)\n{\n    System.out.println(\"The negative values in the list are: \");\n    for (Integer i : a)\n        if (i.intValue() < 0)\n            System.out.println(i);\n}\n\nExample 7\n/** Change every even-indexed element of strList to the empty string.\n* Precondition: strList contains String values.\n*/\npublic static void changeEvenToEmpty(List<String> strList)\n{\n    boolean even = true;\n    int index = 0;\n    while (index < strList.size())\n    {\n        if (even)\n            strList.set(index, \"\");\n        index++;\n        even = !even;\n    }\n}\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the Coin and Purse classes defined below:\n\n/* A simple coin class */\npublic class Coin {\n    private double value;\n    private String name;\n\n    // constructor\n    public Coin(double coinValue, String coinName) {\n        value = coinValue;\n        name = coinName;\n    }\n\n    /** @return the value of this coin */\n    public double getValue() { return value; }\n\n    /** @return the name of this coin */\n    public String getName() { return name; }\n\n    /**\n     * @param obj a Coin object\n     * @return true if this coin equals obj; otherwise false\n     */\n    public boolean equals(Object obj) { return name.equals(((Coin) obj).name); }\n    \n    // Other methods are not shown.\n}\n\n/* A purse holds a collection of coins */\npublic class Purse {\n    private List<Coin> coins;\n\n    /** Creates an empty purse. */\n    public Purse() { coins = new ArrayList<Coin>(); }\n\n    /**\n     * Adds aCoin to the purse.\n     * \n     * @param aCoin the coin to be added to the purse\n     */\n    public void add(Coin aCoin) { coins.add(aCoin); }\n\n    /** @return the total value of coins in purse */\n    public double getTotal() { /* implementation not shown */ }\n}\n\nTwo coins are said to match each other if they have the same name or the same value. You may assume that coins with the same name have the same value and coins with the same value have the same name. A boolean method find is added to the Purse class: \n\n/** @return true if the purse has a coin that matches aCoin, \n* false otherwise \n*/ \npublic boolean find(Coin aCoin) \n{ \n    for (Coin c : coins) \n    { \n        /* code to find match */ \n    } \n    return false; \n} \n\nWhich is a correct replacement for /* code to find match */? \nI if (c.equals(aCoin)) \n    return true; \nII if ((c.getName()).equals(aCoin.getName())) \n    return true; \nIII if ((c.getValue()).equals(aCoin.getValue())) \n    return true; \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "A two-dimensional array (matrix) is often the data structure of choice for objects like board games, tables of values, theater seats, and mazes.\nLook at the following 3 \u00d7 4 matrix:\n2 6 8 7\n1 5 4 0\n9 3 2 8\n\nIf mat is the matrix variable, the row subscripts go from 0 to 2 and the column sub scripts go from 0 to 3. The element mat[1][2] is 4, whereas mat[0][2] and mat[2][3] are both 8. As with one-dimensional arrays, if the subscripts are out of range, an ArrayIndexOutOfBoundsException is thrown.\n\nEach of the following declares a two-dimensional array:\nint[][] table; //table can reference a 2-D array of integers\n//table is currently a null reference\ndouble[][] matrix = new double[3][4]; //matrix references a 3 \u00d7 4\n//array of real numbers.\n//Each element has value 0.0\nString[][] strs = new String[2][5]; //strs references a 2 \u00d7 5\n//array of String objects.\n//Each element is null\nAn initializer list can be used to specify a two-dimensional array:\nint[][] mat = { {3, 4, 5}, //row 0\n{6, 7, 8} }; //row 1\nThis defines a 2\u00d73 rectangular array (i.e., one in which each row has the same number of elements).\nThe initializer list is a list of lists in which each inside list represents a row of the matrix.\nA matrix is implemented as an array of rows, where each row is a one-dimensional array of elements. Suppose mat is the 3 \u00d7 4 matrix\n2 6 8 7\n1 5 4 0\n9 3 2 8\nThen mat is an array of three arrays:\nmat[0] contains {2, 6, 8, 7}\nmat[1] contains {1, 5, 4, 0}\nmat[2] contains {9, 3, 2, 8}\nThe quantity mat.length represents the number of rows. In this case it equals 3 because there are three row-arrays in mat. For any given row k, where 0 \u2264 k < mat.length, the quantity mat[k].length represents the number of elements in that row, namely the number of columns. ( Java allows a variable number of elements in each row. Since these \u201cjagged arrays\u201d are not part of the AP Java subset, you can assume that mat[k].length is the same for all rows k of the matrix, i.e., that the matrix is rectangular.)\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Which of the following initializes an 8 \u00d7 10 matrix with integer values that are perfect squares? (0 is a perfect square.) \nI int[][] mat = new int[8][10]; \nII int[][] mat = new int[8][10]; \nfor (int r = 0; r < mat.length; r++) \n    for (int c = 0; c < mat[r].length; c++) \n        mat[r][c] = r * r; \nIII int[][] mat = new int[8][10]; \nfor (int c = 0; c < mat[r].length; c++) \n    for (int r = 0; r < mat.length; r++) \n        mat[r][c] = c * c; \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "There are three common ways to traverse a two-dimensional array:\n\u2022 row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n\u2022 for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n\u2022 row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n/** Precondition: mat is initialized with integer values. */\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) //for each row array in mat\n    for (int element : row) //for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n/** @return the sum of integers in arr */\npublic int sumArray(int[] arr)\n{ /* implementation not shown */ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) //for each row in mat,\n    sum += sumArray(mat[row]); //add that row\u2019s total to sum\n\nNote how, since mat[row] is an array of int for 0 \u2264 row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 \u2264 k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n/** Add 10 to each int in arr */\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) //for each row array in cardMatrix,\n    for (Card c : row) //for each Card in that row,\n        c.changeValue(v); //change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can\u2019t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; //SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; //major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; //minor diagonal\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider a class that has this private instance variable: \nprivate int[][] mat; \n\nThe class has the following method, alter. \npublic void alter(int c) \n{ \n    for (int i = 0; i < mat.length; i++) \n        for (int j = c + 1; j < mat[0].length; j++) \n            mat[i][j-1] = mat[i][j]; \n} \n\nIf a 3 \u00d7 4 matrix mat is \n1 3 5 7 \n2 4 6 8 \n3 5 7 9 \n\nthen alter(1) will change mat to \nCorrect: 1 5 7 7\n2 6 8 8 \n3 7 9 9 \nIncorrect: 1 5 7\n2 6 8 \n3 7 9 \nIncorrect: 1 3 5 7\n3 5 7 9 \nIncorrect: 1 3 5 7\n3 5 7 9 \n3 5 7 9 \nIncorrect: 1 7 7 7\n2 8 8 8 \n3 9 9 9\n\nEND"}
{"prompt": "There are three common ways to traverse a two-dimensional array:\n\u2022 row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n\u2022 for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n\u2022 row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n/** Precondition: mat is initialized with integer values. */\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) //for each row array in mat\n    for (int element : row) //for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n/** @return the sum of integers in arr */\npublic int sumArray(int[] arr)\n{ /* implementation not shown */ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) //for each row in mat,\n    sum += sumArray(mat[row]); //add that row\u2019s total to sum\n\nNote how, since mat[row] is an array of int for 0 \u2264 row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 \u2264 k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n/** Add 10 to each int in arr */\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) //for each row array in cardMatrix,\n    for (Card c : row) //for each Card in that row,\n        c.changeValue(v); //change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can\u2019t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; //SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; //major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; //minor diagonal\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following method that will alter the matrix mat:\n\n/** @param mat the initialized matrix \n* @param row the row number \n*/ \npublic static void matStuff(int[][] mat, int row) \n{ \n    int numCols = mat[0].length; \n    for (int col = 0; col < numCols; col++) \n        mat[row][col] = row; \n} \n\nSuppose mat is originally \n1 4 9 0 \n2 7 8 6 \n5 1 4 3 \n\nAfter the method call matStuff(mat,2), matrix mat will be \nCorrect: 1 4 9 0\n2 7 8 6 \n2 2 2 2 \nIncorrect: 1 4 9 0\n2 2 2 2 \n5 1 4 3 \nIncorrect: 2 2 2 2\n2 2 2 2 \n2 2 2 2 \nIncorrect: 1 4 2 0\n2 7 2 6 \n5 1 2 3 \nIncorrect: 1 2 9 0\n2 2 8 6 \n5 2 4 3\n\nEND"}
{"prompt": "There are three common ways to traverse a two-dimensional array:\n\u2022 row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n\u2022 for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n\u2022 row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n/** Precondition: mat is initialized with integer values. */\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) //for each row array in mat\n    for (int element : row) //for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n/** @return the sum of integers in arr */\npublic int sumArray(int[] arr)\n{ /* implementation not shown */ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) //for each row in mat,\n    sum += sumArray(mat[row]); //add that row\u2019s total to sum\n\nNote how, since mat[row] is an array of int for 0 \u2264 row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 \u2264 k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n/** Add 10 to each int in arr */\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) //for each row array in cardMatrix,\n    for (Card c : row) //for each Card in that row,\n        c.changeValue(v); //change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can\u2019t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; //SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; //major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; //minor diagonal\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Assume that a square matrix mat is defined by \n\nint[][] mat = new int[SIZE][SIZE]; \n//SIZE is an integer constant >= 2 \n\nWhat does the following code segment do? \n\nfor (int i = 0; i < SIZE - 1; i++) \n    for (int j = 0; j < SIZE - i - 1; j++) \n        swap(mat, i, j, SIZE - j - 1, SIZE - i - 1); \n\nYou may assume the existence of this swap method: \n\n/** Interchange mat[a][b] and mat[c][d]. */ \npublic void swap(int[][] mat, int a, int b, int c, int d) \n\nCorrect: Reflects mat through its minor diagonal. For example,\n2 6 3 6 \u2192 4 3 4 2 \nIncorrect: Reflects mat through its major diagonal. For example,\n2 6 2 4 \u2192 4 3 6 3 \nIncorrect: Reflects mat through a horizontal line of symmetry. For example,\n2 6 4 3 \u2192 4 3 2 6 \nIncorrect: Reflects mat through a vertical line of symmetry. For example,\n2 6 6 2 \u2192 4 3 3 4 \nIncorrect: Leaves mat unchanged\n\nEND"}
{"prompt": "There are three common ways to traverse a two-dimensional array:\n\u2022 row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n\u2022 for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n\u2022 row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n/** Precondition: mat is initialized with integer values. */\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) //for each row array in mat\n    for (int element : row) //for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n/** @return the sum of integers in arr */\npublic int sumArray(int[] arr)\n{ /* implementation not shown */ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) //for each row in mat,\n    sum += sumArray(mat[row]); //add that row\u2019s total to sum\n\nNote how, since mat[row] is an array of int for 0 \u2264 row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 \u2264 k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n/** Add 10 to each int in arr */\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) //for each row array in cardMatrix,\n    for (Card c : row) //for each Card in that row,\n        c.changeValue(v); //change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can\u2019t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; //SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; //major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; //minor diagonal\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider a class MatrixStuff that has a private instance variable: \nprivate int[][] mat; \n\nRefer to method alter below that occurs in the MatrixStuff class. (The lines are numbered for reference.) \nLine 1: /** @param mat the matrix initialized with integers \nLine 2: * @param c the column to be removed \nLine 3: * Postcondition: \nLine 4: * - Column c has been removed. \nLine 5: * - The last column is filled with zeros. \nLine 6: */ \nLine 7: public void alter(int[][] mat, int c) \nLine 8: { \nLine 9:     for (int i = 0; i < mat.length; i++) \nLine 10:        for (int j = c; j < mat[0].length; j++) \nLine 11:            mat[i][j] = mat[i][j+1]; \nLine 12:    //code to insert zeros in rightmost column \nLine 13:    ... \nLine 14: } \n\nThe intent of the method alter is to remove column c. Thus, if the input matrix mat is \n2 6 8 9 \n1 5 4 3 \n0 7 3 2 \n\nthe method call alter(mat, 1) should change mat to \n2 8 9 0 \n1 4 3 0 \n0 3 2 0 \n\nThe method does not work as intended. Which of the following changes will correct the problem? \nI Change line 10 to \nfor (int j = c; j < mat[0].length - 1; j++) \nand make no other changes. \nII Change lines 10 and 11 to \nfor (int j = c + 1; j < mat[0].length; j++) \n    mat[i][j-1] = mat[i][j]; \nand make no other changes. \nIII Change lines 10 and 11 to \nfor (int j = mat[0].length - 1; j > c; j--) \n    mat[i][j-1] = mat[i][j]; \nand make no other changes. \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "There are three common ways to traverse a two-dimensional array:\n\u2022 row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n\u2022 for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n\u2022 row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n/** Precondition: mat is initialized with integer values. */\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) //for each row array in mat\n    for (int element : row) //for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n/** @return the sum of integers in arr */\npublic int sumArray(int[] arr)\n{ /* implementation not shown */ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) //for each row in mat,\n    sum += sumArray(mat[row]); //add that row\u2019s total to sum\n\nNote how, since mat[row] is an array of int for 0 \u2264 row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 \u2264 k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n/** Add 10 to each int in arr */\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) //for each row array in cardMatrix,\n    for (Card c : row) //for each Card in that row,\n        c.changeValue(v); //change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can\u2019t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; //SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; //major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; //minor diagonal\n\n\nThe following question asks about the properties or summary of a program with multiple options:\n\n###\n\n", "completion": "Question: This question refers to the following method: \n\npublic static boolean isThere(String[][] mat, int row, int col, String symbol) \n{ \n    boolean yes; \n    int i, count = 0; \n    for (i = 0; i < SIZE; i++) \n        if (mat[i][col].equals(symbol)) \n            count++; \n    yes = (count == SIZE); \n    count = 0; \n    for (i = 0; i < SIZE; i++) \n        if (mat[row][i].equals(symbol)) \n            count++; \n    return (yes || count == SIZE); \n} \n\nNow consider this code segment:\n\npublic final int SIZE = 8; \nString[][] mat = new String[SIZE][SIZE]; \n\nWhich of the following conditions on a matrix mat of the type declared in the code segment will by itself guarantee that \nisThere(mat, 2, 2, \"$\") \nwill have the value true when evaluated? \nI The element in row 2 and column 2 is \"$\" \nII All elements in both diagonals are \"$\" \nIII All elements in column 2 are \"$\" \nCorrect: III only\nIncorrect: I only\nIncorrect: I and II only\nIncorrect: I and III only\nIncorrect: II and III only\n\nEND"}
{"prompt": "There are three common ways to traverse a two-dimensional array:\n\u2022 row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n\u2022 for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n\u2022 row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n/** Precondition: mat is initialized with integer values. */\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) //for each row array in mat\n    for (int element : row) //for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n/** @return the sum of integers in arr */\npublic int sumArray(int[] arr)\n{ /* implementation not shown */ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) //for each row in mat,\n    sum += sumArray(mat[row]); //add that row\u2019s total to sum\n\nNote how, since mat[row] is an array of int for 0 \u2264 row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 \u2264 k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n/** Add 10 to each int in arr */\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) //for each row array in cardMatrix,\n    for (Card c : row) //for each Card in that row,\n        c.changeValue(v); //change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can\u2019t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; //SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; //major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; //minor diagonal\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: The method changeNegs below should replace every occurrence of a negative integer in its matrix parameter with 0. \n\n/** @param mat the matrix \n* Precondition: mat is initialized with integers. \n* Postcondition: All negative values in mat replaced with 0. \n*/ \npublic static void changeNegs(int[][] mat) \n{ \n    /* code */ \n} \n\nWhich is correct replacement for /* code */? \nI for (int r = 0; r < mat.length; r++) \n    for (int c = 0; c < mat[r].length; c++) \n        if (mat[r][c] < 0) \n            mat[r][c] = 0; \nII for (int c = 0; c < mat[0].length; c++) \n    for (int r = 0; r < mat.length; r++) \n        if (mat[r][c] < 0) \n            mat[r][c] = 0; \nIII for (int[] row : mat) \n    for (int element : row) \n        if (element < 0) \n            element = 0; \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "There are three common ways to traverse a two-dimensional array:\n\u2022 row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n\u2022 for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n\u2022 row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n/** Precondition: mat is initialized with integer values. */\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) //for each row array in mat\n    for (int element : row) //for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n/** @return the sum of integers in arr */\npublic int sumArray(int[] arr)\n{ /* implementation not shown */ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) //for each row in mat,\n    sum += sumArray(mat[row]); //add that row\u2019s total to sum\n\nNote how, since mat[row] is an array of int for 0 \u2264 row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 \u2264 k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n/** Add 10 to each int in arr */\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) //for each row array in cardMatrix,\n    for (Card c : row) //for each Card in that row,\n        c.changeValue(v); //change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can\u2019t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; //SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; //major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; //minor diagonal\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: A two-dimensional array of double, rainfall, will be used to represent the daily rainfall for a given year. In this scheme, rainfall[month][day] represents the amount of rain on the given day and month. For example, \nrainfall[1][15] is the amount of rain on Jan. 15 \nrainfall[12][25] is the amount of rain on Dec. 25 \n\nThe array can be declared as follows: \ndouble[][] rainfall = new double[13][32]; \n\nThis creates 13 rows indexed from 0 to 12 and 32 columns indexed from 0 to 31, all initialized to 0.0. Row 0 and column 0 will be ignored. Column 31 in row 4 will be ignored, since April 31 is not a valid day. In years that are not leap years, columns 29, 30, and 31 in row 2 will be ignored since Feb. 29, 30, and 31 are not valid days. \nConsider the method averageRainfall below: \n\n/** Precondition: \n* - rainfall is initialized with values representing amounts \n* of rain on all valid days. \n* - Invalid days are initialized to 0.0. \n* - Feb 29 is not a valid day. \n* Postcondition: Returns average rainfall for the year. \n*/ \npublic double averageRainfall(double rainfall[][]) \n{ \n    double total = 0.0; \n    /* more code */ \n} \n\nWhich of the following is a correct replacement for /* more code */ so that the postcondition for the method is satisfied? \nI for (int month = 1; month < rainfall.length; month++) \n    for (int day = 1; day < rainfall[month].length; day++) \n        total += rainfall[month][day]; \nreturn total / (13 * 32); \nII for (int month = 1; month < rainfall.length; month++) \n    for (int day = 1; day < rainfall[month].length; day++) \n        total += rainfall[month][day]; \nreturn total / 365; \nIII for (double[] month : rainfall) \n    for (double rainAmt : month) \n        total += rainAmt; \nreturn total / 365; \nCorrect: II and III only\n\n\nIncorrect: None\nIncorrect: I only\nIncorrect: II only\nIncorrect: III onlyEND"}
{"prompt": "There are three common ways to traverse a two-dimensional array:\n\u2022 row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n\u2022 for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n\u2022 row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n/** Precondition: mat is initialized with integer values. */\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) //for each row array in mat\n    for (int element : row) //for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n/** @return the sum of integers in arr */\npublic int sumArray(int[] arr)\n{ /* implementation not shown */ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) //for each row in mat,\n    sum += sumArray(mat[row]); //add that row\u2019s total to sum\n\nNote how, since mat[row] is an array of int for 0 \u2264 row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 \u2264 k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n/** Add 10 to each int in arr */\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) //for each row array in cardMatrix,\n    for (Card c : row) //for each Card in that row,\n        c.changeValue(v); //change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can\u2019t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; //SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; //major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; //minor diagonal\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: This question is based on the Point class below: \n\npublic class Point {\n    /** The coordinates. */\n    private int x;\n    private int y;\n\n    public Point(int xValue, int yValue) {\n        x = xValue;\n        y = yValue;\n    }\n\n    /** @return the x-coordinate of this point */\n    public int getx() { return x; }\n\n    /** @return the y-coordinate of this point */\n    public int gety() { return y; }\n\n    /** Set x and y to new_x and new_y. */\n    public void setPoint(int new_x, int new_y) {\n        x = new_x;\n        y = new_y;\n    }\n\n    // Other methods are not shown.\n}\n\nThe method changeNegs below takes a matrix of Point objects as parameter and replaces every Point that has as least one negative coordinate with the Point (0,0). \n\n/** @param pointMat the matrix of points \n* Precondition: pointMat is initialized with Point objects. \n* Postcondition: Every point with at least one negative coordinate \n* has been changed to have both coordinates \n* equal to zero. \n*/ \npublic static void changeNegs (Point [][] pointMat) \n{ \n    /* code */ \n}\n\nWhich is a correct replacement for /* code */? \nI for (int r = 0; r < pointMat.length; r++) \n    for (int c = 0; c < pointMat[r].length; c++) \n        if (pointMat[r][c].getx() < 0 || pointMat[r][c].gety() < 0) \n            pointMat[r][c].setPoint(0, 0); \nII for (int c = 0; c < pointMat[0].length; c++) \n    for (int r = 0; r < pointMat.length; r++) \n        if (pointMat[r][c].getx() < 0 || pointMat[r][c].gety() < 0) \n            pointMat[r][c].setPoint(0, 0); \nIII for (Point[] row : pointMat) \n    for (Point p : row) \n        if (p.getx() < 0 || p.gety() < 0) \n            p.setPoint(0, 0); \nCorrect: I, II, and III\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II onlyEND"}
{"prompt": "This class implements standard mathematical functions such as absolute value, square root, trigonometric functions, the log function, the power function, and so on. It also contains mathematical constants such as \u03c0 and e.\n\nHere are the functions you should know for the AP exam:\nstatic int abs(int x)\nReturns the absolute value of integer x.\nstatic double abs(double x)\nReturns the absolute value of real number x.\nstatic double pow(double base, double exp)\nReturns base^exp. Assumes base > 0, or base = 0 and exp > 0, or base < 0 and exp is an integer.\nstatic double sqrt(double x)\nReturns sqrt(x), x \u2265 0.\nstatic double random()\nReturns a random number r, where 0.0 \u2264 r < 1.0. (See the next section, Random Numbers.)\nAll of the functions and constants are implemented as static methods and variables, which means that there are no instances of Math objects. The methods are invoked using the class name, Math, followed by the dot operator.\n\nHere are some examples of mathematical formulas and the equivalent Java statements.\n1. The relationship between the radius and area of a circle:\nradius = Math.sqrt(area / Math.PI);\n2. The amount of money A in an account after ten years, given an original deposit of P and an interest rate of 5% compounded annually, is\nA= P(1.05)10\nIn code:\na = p * Math.pow(1.05, 10);\n3. The distance D between two points P(xP, y) and Q(xQ, y) on the same hori zontal line is\nD = |xP \u2212 xQ|\nIn code:\nd = Math.abs(xp - xq);\n\nNOTE\nThe static import construct allows you to use the static members of a class without the class name prefix. For example, the statement\nimport static java.lang.Math.*;\nallows use of all Math methods and constants without the Math prefix. Thus, the statement in formula 1 above could be written\nradius = sqrt(area / PI);\nStatic imports are not part of the AP subset.\n\nThe statement\ndouble r = Math.random();\nproduces a random real number in the range 0.0 to 1.0, where 0.0 is included and 1.0 is not.\nThis range can be scaled and shifted. On the AP exam you will be expected to write algebraic expressions involving Math.random() that represent linear transformations of the original interval 0.0 \u2264 x < 1.0.\n\nExample 1\nProduce a random real value x in the range 0.0 \u2264 x < 6.0.\ndouble x = 6 * Math.random();\nExample 2\nProduce a random real value x in the range 2.0 \u2264 x < 3.0.\ndouble x = Math.random() + 2;\nExample 3\nProduce a random real value x in the range 4.0 \u2264 x < 6.0.\ndouble x = 2 * Math.random() + 4;\nIn general, to produce a random real value in the range lowValue \u2264 x < highValue: double x = (highValue - lowValue) * Math.random() + lowValue;\n\nUsing a cast to int, a scaling factor, and a shifting value, Math.random() can be used to produce random integers in any range.\nExample 1\nProduce a random integer, from 0 to 99.\nint num = (int) (Math.random() * 100);\nIn general, the expression\n(int) (Math.random() * k)\nproduces a random int in the range 0,1,..., k \u2212 1, where k is called the scaling factor. Note that the cast to int truncates the real number Math.random() * k.\nExample 2\nProduce a random integer, from 1 to 100.\nint num = (int) (Math.random() * 100) + 1;\nIn general, if k is a scaling factor, and p is a shifting value, the statement\nint n = (int) (Math.random() * k) + p;\nproduces a random integer n in the range p, p + 1,..., p + (k \u2212 1).\nExample 3\nProduce a random integer from 5 to 24.\nint num = (int) (Math.random() * 20) + 5;\nNote that there are 20 possible integers from 5 to 24, inclusive.\nNOTE\nThere is further discussion of strings and random numbers, plus additional questions, in Chapter 9 (The AP Computer Science Labs).\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Here is a program segment to find the quantity base^exp. Both base and exp are entered at the keyboard. \n\nSystem.out.println(\"Enter base and exponent: \"); \ndouble base = IO.readDouble(); //read user input \ndouble exp = IO.readDouble(); //read user input \n/* code to find power, which equals baseexp */ \nSystem.out.print(base + \" raised to the power \" + exp); \nSystem.out.println(\" equals \" + power); \n\nWhich is a correct replacement for \n/* code to find power, which equals base^exp */? \nI double power; \nMath m = new Math(); \npower = m.pow(base, exp); \nII double power; \npower = Math.pow(base, exp); \nIII int power; \npower = Math.pow(base, exp); \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I and III only\n\nEND"}
{"prompt": "This class implements standard mathematical functions such as absolute value, square root, trigonometric functions, the log function, the power function, and so on. It also contains mathematical constants such as \u03c0 and e.\n\nHere are the functions you should know for the AP exam:\nstatic int abs(int x)\nReturns the absolute value of integer x.\nstatic double abs(double x)\nReturns the absolute value of real number x.\nstatic double pow(double base, double exp)\nReturns base^exp. Assumes base > 0, or base = 0 and exp > 0, or base < 0 and exp is an integer.\nstatic double sqrt(double x)\nReturns sqrt(x), x \u2265 0.\nstatic double random()\nReturns a random number r, where 0.0 \u2264 r < 1.0. (See the next section, Random Numbers.)\nAll of the functions and constants are implemented as static methods and variables, which means that there are no instances of Math objects. The methods are invoked using the class name, Math, followed by the dot operator.\n\nHere are some examples of mathematical formulas and the equivalent Java statements.\n1. The relationship between the radius and area of a circle:\nradius = Math.sqrt(area / Math.PI);\n2. The amount of money A in an account after ten years, given an original deposit of P and an interest rate of 5% compounded annually, is\nA= P(1.05)10\nIn code:\na = p * Math.pow(1.05, 10);\n3. The distance D between two points P(xP, y) and Q(xQ, y) on the same hori zontal line is\nD = |xP \u2212 xQ|\nIn code:\nd = Math.abs(xp - xq);\n\nNOTE\nThe static import construct allows you to use the static members of a class without the class name prefix. For example, the statement\nimport static java.lang.Math.*;\nallows use of all Math methods and constants without the Math prefix. Thus, the statement in formula 1 above could be written\nradius = sqrt(area / PI);\nStatic imports are not part of the AP subset.\n\nThe statement\ndouble r = Math.random();\nproduces a random real number in the range 0.0 to 1.0, where 0.0 is included and 1.0 is not.\nThis range can be scaled and shifted. On the AP exam you will be expected to write algebraic expressions involving Math.random() that represent linear transformations of the original interval 0.0 \u2264 x < 1.0.\n\nExample 1\nProduce a random real value x in the range 0.0 \u2264 x < 6.0.\ndouble x = 6 * Math.random();\nExample 2\nProduce a random real value x in the range 2.0 \u2264 x < 3.0.\ndouble x = Math.random() + 2;\nExample 3\nProduce a random real value x in the range 4.0 \u2264 x < 6.0.\ndouble x = 2 * Math.random() + 4;\nIn general, to produce a random real value in the range lowValue \u2264 x < highValue: double x = (highValue - lowValue) * Math.random() + lowValue;\n\nUsing a cast to int, a scaling factor, and a shifting value, Math.random() can be used to produce random integers in any range.\nExample 1\nProduce a random integer, from 0 to 99.\nint num = (int) (Math.random() * 100);\nIn general, the expression\n(int) (Math.random() * k)\nproduces a random int in the range 0,1,..., k \u2212 1, where k is called the scaling factor. Note that the cast to int truncates the real number Math.random() * k.\nExample 2\nProduce a random integer, from 1 to 100.\nint num = (int) (Math.random() * 100) + 1;\nIn general, if k is a scaling factor, and p is a shifting value, the statement\nint n = (int) (Math.random() * k) + p;\nproduces a random integer n in the range p, p + 1,..., p + (k \u2212 1).\nExample 3\nProduce a random integer from 5 to 24.\nint num = (int) (Math.random() * 20) + 5;\nNote that there are 20 possible integers from 5 to 24, inclusive.\nNOTE\nThere is further discussion of strings and random numbers, plus additional questions, in Chapter 9 (The AP Computer Science Labs).\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the squareRoot method defined below: \n\n/** @param d a real number such that d >= 0 \n* Postcondition: Returns a Double whose value is the square \n* root of the value represented by d. \n*/ \npublic Double squareRoot(Double d) \n{ \n    /* implementation code */ \n} \n\nWhich /* implementation code */ satisfies the postcondition? \nI double x = d.doubleValue(); \nx = Math.sqrt(x); \nreturn new Double(x); \nII return new Double(Math.sqrt(d.doubleValue())); \nIII return (Double) Math.sqrt(d.doubleValue()); \nCorrect: I and II only\nIncorrect: I only\nIncorrect: I and III only\nIncorrect: II and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "This class implements standard mathematical functions such as absolute value, square root, trigonometric functions, the log function, the power function, and so on. It also contains mathematical constants such as \u03c0 and e.\n\nHere are the functions you should know for the AP exam:\nstatic int abs(int x)\nReturns the absolute value of integer x.\nstatic double abs(double x)\nReturns the absolute value of real number x.\nstatic double pow(double base, double exp)\nReturns base^exp. Assumes base > 0, or base = 0 and exp > 0, or base < 0 and exp is an integer.\nstatic double sqrt(double x)\nReturns sqrt(x), x \u2265 0.\nstatic double random()\nReturns a random number r, where 0.0 \u2264 r < 1.0. (See the next section, Random Numbers.)\nAll of the functions and constants are implemented as static methods and variables, which means that there are no instances of Math objects. The methods are invoked using the class name, Math, followed by the dot operator.\n\nHere are some examples of mathematical formulas and the equivalent Java statements.\n1. The relationship between the radius and area of a circle:\nradius = Math.sqrt(area / Math.PI);\n2. The amount of money A in an account after ten years, given an original deposit of P and an interest rate of 5% compounded annually, is\nA= P(1.05)10\nIn code:\na = p * Math.pow(1.05, 10);\n3. The distance D between two points P(xP, y) and Q(xQ, y) on the same hori zontal line is\nD = |xP \u2212 xQ|\nIn code:\nd = Math.abs(xp - xq);\n\nNOTE\nThe static import construct allows you to use the static members of a class without the class name prefix. For example, the statement\nimport static java.lang.Math.*;\nallows use of all Math methods and constants without the Math prefix. Thus, the statement in formula 1 above could be written\nradius = sqrt(area / PI);\nStatic imports are not part of the AP subset.\n\nThe statement\ndouble r = Math.random();\nproduces a random real number in the range 0.0 to 1.0, where 0.0 is included and 1.0 is not.\nThis range can be scaled and shifted. On the AP exam you will be expected to write algebraic expressions involving Math.random() that represent linear transformations of the original interval 0.0 \u2264 x < 1.0.\n\nExample 1\nProduce a random real value x in the range 0.0 \u2264 x < 6.0.\ndouble x = 6 * Math.random();\nExample 2\nProduce a random real value x in the range 2.0 \u2264 x < 3.0.\ndouble x = Math.random() + 2;\nExample 3\nProduce a random real value x in the range 4.0 \u2264 x < 6.0.\ndouble x = 2 * Math.random() + 4;\nIn general, to produce a random real value in the range lowValue \u2264 x < highValue: double x = (highValue - lowValue) * Math.random() + lowValue;\n\nUsing a cast to int, a scaling factor, and a shifting value, Math.random() can be used to produce random integers in any range.\nExample 1\nProduce a random integer, from 0 to 99.\nint num = (int) (Math.random() * 100);\nIn general, the expression\n(int) (Math.random() * k)\nproduces a random int in the range 0,1,..., k \u2212 1, where k is called the scaling factor. Note that the cast to int truncates the real number Math.random() * k.\nExample 2\nProduce a random integer, from 1 to 100.\nint num = (int) (Math.random() * 100) + 1;\nIn general, if k is a scaling factor, and p is a shifting value, the statement\nint n = (int) (Math.random() * k) + p;\nproduces a random integer n in the range p, p + 1,..., p + (k \u2212 1).\nExample 3\nProduce a random integer from 5 to 24.\nint num = (int) (Math.random() * 20) + 5;\nNote that there are 20 possible integers from 5 to 24, inclusive.\nNOTE\nThere is further discussion of strings and random numbers, plus additional questions, in Chapter 9 (The AP Computer Science Labs).\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Here are some examples of negative numbers rounded to the nearest integer. \n\n\u22123.5 -> \u22124 \n\u22128.97 -> \u22129 \n\u22125.0 -> \u22125 \n\u22122.487 -> \u22122 \n\u22120.2 -> 0 \n\nRefer to the declaration \ndouble d = -4.67; \nWhich of the following correctly rounds d to the nearest integer? \nCorrect: int rounded = (int) (d - 0.5);\nIncorrect: int rounded = Math.abs(d);\nIncorrect: int rounded = (int) (Math.random() * d);\nIncorrect: int rounded = (int) (d + 0.5);\nIncorrect: int rounded = Math.abs((int) (d - 0.5));\n\nEND"}
{"prompt": "This class implements standard mathematical functions such as absolute value, square root, trigonometric functions, the log function, the power function, and so on. It also contains mathematical constants such as \u03c0 and e.\n\nHere are the functions you should know for the AP exam:\nstatic int abs(int x)\nReturns the absolute value of integer x.\nstatic double abs(double x)\nReturns the absolute value of real number x.\nstatic double pow(double base, double exp)\nReturns base^exp. Assumes base > 0, or base = 0 and exp > 0, or base < 0 and exp is an integer.\nstatic double sqrt(double x)\nReturns sqrt(x), x \u2265 0.\nstatic double random()\nReturns a random number r, where 0.0 \u2264 r < 1.0. (See the next section, Random Numbers.)\nAll of the functions and constants are implemented as static methods and variables, which means that there are no instances of Math objects. The methods are invoked using the class name, Math, followed by the dot operator.\n\nHere are some examples of mathematical formulas and the equivalent Java statements.\n1. The relationship between the radius and area of a circle:\nradius = Math.sqrt(area / Math.PI);\n2. The amount of money A in an account after ten years, given an original deposit of P and an interest rate of 5% compounded annually, is\nA= P(1.05)10\nIn code:\na = p * Math.pow(1.05, 10);\n3. The distance D between two points P(xP, y) and Q(xQ, y) on the same hori zontal line is\nD = |xP \u2212 xQ|\nIn code:\nd = Math.abs(xp - xq);\n\nNOTE\nThe static import construct allows you to use the static members of a class without the class name prefix. For example, the statement\nimport static java.lang.Math.*;\nallows use of all Math methods and constants without the Math prefix. Thus, the statement in formula 1 above could be written\nradius = sqrt(area / PI);\nStatic imports are not part of the AP subset.\n\nThe statement\ndouble r = Math.random();\nproduces a random real number in the range 0.0 to 1.0, where 0.0 is included and 1.0 is not.\nThis range can be scaled and shifted. On the AP exam you will be expected to write algebraic expressions involving Math.random() that represent linear transformations of the original interval 0.0 \u2264 x < 1.0.\n\nExample 1\nProduce a random real value x in the range 0.0 \u2264 x < 6.0.\ndouble x = 6 * Math.random();\nExample 2\nProduce a random real value x in the range 2.0 \u2264 x < 3.0.\ndouble x = Math.random() + 2;\nExample 3\nProduce a random real value x in the range 4.0 \u2264 x < 6.0.\ndouble x = 2 * Math.random() + 4;\nIn general, to produce a random real value in the range lowValue \u2264 x < highValue: double x = (highValue - lowValue) * Math.random() + lowValue;\n\nUsing a cast to int, a scaling factor, and a shifting value, Math.random() can be used to produce random integers in any range.\nExample 1\nProduce a random integer, from 0 to 99.\nint num = (int) (Math.random() * 100);\nIn general, the expression\n(int) (Math.random() * k)\nproduces a random int in the range 0,1,..., k \u2212 1, where k is called the scaling factor. Note that the cast to int truncates the real number Math.random() * k.\nExample 2\nProduce a random integer, from 1 to 100.\nint num = (int) (Math.random() * 100) + 1;\nIn general, if k is a scaling factor, and p is a shifting value, the statement\nint n = (int) (Math.random() * k) + p;\nproduces a random integer n in the range p, p + 1,..., p + (k \u2212 1).\nExample 3\nProduce a random integer from 5 to 24.\nint num = (int) (Math.random() * 20) + 5;\nNote that there are 20 possible integers from 5 to 24, inclusive.\nNOTE\nThere is further discussion of strings and random numbers, plus additional questions, in Chapter 9 (The AP Computer Science Labs).\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: A program is to simulate plant life under harsh conditions. In the program, plants die randomly according to some probability. Here is part of a Plant class defined in the program. \n\npublic class Plant {\n    /** probability that plant dies, a real number between 0 and 1 */\n    private double probDeath;\n\n    public Plant(double plantProbDeath, < other parameters >) \n    { \n        probDeath = plantProbDeath; \n        < initialization of other instance variables > \n    }\n\n    /** Plant lives or dies. */ \n    public void liveOrDie() \n    { \n        /* statement to generate random number */ \n        if (/* test to determine if plant dies */) \n            < code to implement plant\u2019s death > \n        else \n            < code to make plant continue living > \n    }\n    // Other variables and methods are not shown.\n}\n\nWhich of the following are correct replacements for \n(1) /* statement to generate random number */ and \n(2) /* test to determine if plant dies */? \nCorrect: (1) double x = Math.random();\n(2) x < probDeath \nIncorrect: (1) double x = Math.random();\n(2) x == probDeath \nIncorrect: (1) double x = (int) (Math.random());\n(2) x > probDeath \nIncorrect: (1) int x = (int) (Math.random() * 100);\n(2) x < (int) probDeath \nIncorrect: (1) int x = (int) (Math.random() * 100) + 1;\n(2) x == (int) probDeath \n\nEND"}
{"prompt": "This class implements standard mathematical functions such as absolute value, square root, trigonometric functions, the log function, the power function, and so on. It also contains mathematical constants such as \u03c0 and e.\n\nHere are the functions you should know for the AP exam:\nstatic int abs(int x)\nReturns the absolute value of integer x.\nstatic double abs(double x)\nReturns the absolute value of real number x.\nstatic double pow(double base, double exp)\nReturns base^exp. Assumes base > 0, or base = 0 and exp > 0, or base < 0 and exp is an integer.\nstatic double sqrt(double x)\nReturns sqrt(x), x \u2265 0.\nstatic double random()\nReturns a random number r, where 0.0 \u2264 r < 1.0. (See the next section, Random Numbers.)\nAll of the functions and constants are implemented as static methods and variables, which means that there are no instances of Math objects. The methods are invoked using the class name, Math, followed by the dot operator.\n\nHere are some examples of mathematical formulas and the equivalent Java statements.\n1. The relationship between the radius and area of a circle:\nradius = Math.sqrt(area / Math.PI);\n2. The amount of money A in an account after ten years, given an original deposit of P and an interest rate of 5% compounded annually, is\nA= P(1.05)10\nIn code:\na = p * Math.pow(1.05, 10);\n3. The distance D between two points P(xP, y) and Q(xQ, y) on the same hori zontal line is\nD = |xP \u2212 xQ|\nIn code:\nd = Math.abs(xp - xq);\n\nNOTE\nThe static import construct allows you to use the static members of a class without the class name prefix. For example, the statement\nimport static java.lang.Math.*;\nallows use of all Math methods and constants without the Math prefix. Thus, the statement in formula 1 above could be written\nradius = sqrt(area / PI);\nStatic imports are not part of the AP subset.\n\nThe statement\ndouble r = Math.random();\nproduces a random real number in the range 0.0 to 1.0, where 0.0 is included and 1.0 is not.\nThis range can be scaled and shifted. On the AP exam you will be expected to write algebraic expressions involving Math.random() that represent linear transformations of the original interval 0.0 \u2264 x < 1.0.\n\nExample 1\nProduce a random real value x in the range 0.0 \u2264 x < 6.0.\ndouble x = 6 * Math.random();\nExample 2\nProduce a random real value x in the range 2.0 \u2264 x < 3.0.\ndouble x = Math.random() + 2;\nExample 3\nProduce a random real value x in the range 4.0 \u2264 x < 6.0.\ndouble x = 2 * Math.random() + 4;\nIn general, to produce a random real value in the range lowValue \u2264 x < highValue: double x = (highValue - lowValue) * Math.random() + lowValue;\n\nUsing a cast to int, a scaling factor, and a shifting value, Math.random() can be used to produce random integers in any range.\nExample 1\nProduce a random integer, from 0 to 99.\nint num = (int) (Math.random() * 100);\nIn general, the expression\n(int) (Math.random() * k)\nproduces a random int in the range 0,1,..., k \u2212 1, where k is called the scaling factor. Note that the cast to int truncates the real number Math.random() * k.\nExample 2\nProduce a random integer, from 1 to 100.\nint num = (int) (Math.random() * 100) + 1;\nIn general, if k is a scaling factor, and p is a shifting value, the statement\nint n = (int) (Math.random() * k) + p;\nproduces a random integer n in the range p, p + 1,..., p + (k \u2212 1).\nExample 3\nProduce a random integer from 5 to 24.\nint num = (int) (Math.random() * 20) + 5;\nNote that there are 20 possible integers from 5 to 24, inclusive.\nNOTE\nThere is further discussion of strings and random numbers, plus additional questions, in Chapter 9 (The AP Computer Science Labs).\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: A program simulates fifty slips of paper, numbered 1 through 50, placed in a bowl for a raffle drawing. Which of the following statements stores in winner a random integer from 1 to 50? \nCorrect: int winner = (int) (Math.random() * 50) + 1;\nIncorrect: int winner = (int) (Math.random() * 50);\nIncorrect: int winner = (int) (Math.random() * 51);\nIncorrect: int winner = (int) (Math.random() * 51) + 1;\nIncorrect: int winner = (int) (1 + Math.random() * 49);\n\nEND"}
{"prompt": "A wrapper class takes either an existing object or a value of primitive type, \u201cwraps\u201d or \u201cboxes\u201d it in an object, and provides a new set of methods for that type. The point of a wrapper class is to provide extended capabilities for the boxed quantity:\n\u2022 It can be used in generic Java methods that require objects as parameters.\n\u2022 It can be used in Java container classes that require the items be objects (see p. 242).\n\nIn each case, the wrapper class allows\n1. Construction of an object from a single value (wrapping or boxing the primitive in a wrapper object).\n2. Retrieval of the primitive value (unwrapping or unboxing from the wrapper object).\nJava provides a wrapper class for each of its primitive types. The two that you should know for the AP exam are the Integer and Double classes.\n\nThe Integer class wraps a value of type int in an object. An object of type Integer contains just one instance variable whose type is int.\nHere are the Integer methods you should know for the AP exam:\nInteger(int value)\nConstructs an Integer object from an int. (Boxing.)\nint compareTo(Integer other)\nReturns 0 if the value of this Integer is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nint intValue()\nReturns the value of this Integer as an int. (Unboxing.)\nboolean equals(Object obj)\nReturns true if and only if this Integer has the same int value as obj.\nNOTE\n1. This method overrides equals in class Object.\n2. This method throws a ClassCastException if obj is not an Integer.\nString toString()\nReturns a String representing the value of this Integer.\nHere are some examples to illustrate the Integer methods:\nInteger intObj = new Integer(6); //boxes 6 in Integer object\nint j = intObj.intValue(); //unboxes 6 from Integer object\nSystem.out.println(\"Integer value is \" + intObj);\n//calls toString() for intObj\n//output is\n//Integer value is 6\nObject object = new Integer(5); //Integer is a subclass of Object\nInteger intObj2 = new Integer(3);\nint k = intObj2.intValue();\nif (intObj.equals(intObj2)) //OK, evaluates to false\n...\nif (intObj.intValue() == intObj2.intValue())\n... //OK, since comparing primitive types\nif (k.equals(j)) //error, k and j not objects\n...\nif ((intObj.intValue()).compareTo(intObj2.intValue()) < 0)\n... //error, can\u2019t use compareTo on primitive types\nif (intObj.compareTo(object) < 0) //Error. Parameter needs Integer cast if (intObj.compareTo((Integer) object) < 0) //OK\n...\nif (object.compareTo(intObj) < 0) //error, no compareTo in Object\n...\nif (((Integer) object).compareTo(intObj) < 0) //OK\n...\n\nThe Double class wraps a value of type double in an object. An object of type Double contains just one instance variable whose type is double.\nThe methods you should know for the AP exam are analogous to those for type\nInteger.\nDouble(double value)\nConstructs a Double object from a double. (Boxing.)\ndouble doubleValue()\nReturns the value of this Double as a double. (Unboxing.)\nint compareTo(Double other)\nReturns 0 if the value of this Double is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nboolean equals(Object obj)\nThis method overrides equals in class Object and throws a ClassCastException if obj is not a Double. Otherwise it returns true if and only if this Double has the same double value as obj.\nString toString()\nReturns a String representing the value of this Double.\n\nHere are some examples:\nDouble dObj = new Double(2.5); //boxes 2.5 in Double object\ndouble d = dObj.doubleValue(); //unboxes 2.5 from Double object\nObject object = new Double(7.3); //Double is a subclass of Object\nObject intObj = new Integer(4);\nif (dObj.compareTo(object) > 0) //Error. Parameter needs cast to Double\nif (dObj.compareTo((Double) object) > 0) //OK\n...\nif (dObj.compareTo(intObj) > 0) //ClassCastException\n... //can\u2019t compare Integer to Double\n\nNOTE\n1. Integer and Double objects are immutable: There are no mutator methods in the classes.\n2. See p. 242 for a discussion of auto-boxing and -unboxing. This useful feature will not be tested on the AP exam.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the code segment \n\nInteger i = new Integer(20); \n/* more code */ \n\nWhich of the following replacements for /* more code */ correctly sets i to have an integer value of 25? \nI i = new Integer(25); \nII i.intValue() = 25; \nIII Integer j = new Integer(25); \ni = j; \nCorrect: I and III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: II and III only\n\nEND"}
{"prompt": "A wrapper class takes either an existing object or a value of primitive type, \u201cwraps\u201d or \u201cboxes\u201d it in an object, and provides a new set of methods for that type. The point of a wrapper class is to provide extended capabilities for the boxed quantity:\n\u2022 It can be used in generic Java methods that require objects as parameters.\n\u2022 It can be used in Java container classes that require the items be objects (see p. 242).\n\nIn each case, the wrapper class allows\n1. Construction of an object from a single value (wrapping or boxing the primitive in a wrapper object).\n2. Retrieval of the primitive value (unwrapping or unboxing from the wrapper object).\nJava provides a wrapper class for each of its primitive types. The two that you should know for the AP exam are the Integer and Double classes.\n\nThe Integer class wraps a value of type int in an object. An object of type Integer contains just one instance variable whose type is int.\nHere are the Integer methods you should know for the AP exam:\nInteger(int value)\nConstructs an Integer object from an int. (Boxing.)\nint compareTo(Integer other)\nReturns 0 if the value of this Integer is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nint intValue()\nReturns the value of this Integer as an int. (Unboxing.)\nboolean equals(Object obj)\nReturns true if and only if this Integer has the same int value as obj.\nNOTE\n1. This method overrides equals in class Object.\n2. This method throws a ClassCastException if obj is not an Integer.\nString toString()\nReturns a String representing the value of this Integer.\nHere are some examples to illustrate the Integer methods:\nInteger intObj = new Integer(6); //boxes 6 in Integer object\nint j = intObj.intValue(); //unboxes 6 from Integer object\nSystem.out.println(\"Integer value is \" + intObj);\n//calls toString() for intObj\n//output is\n//Integer value is 6\nObject object = new Integer(5); //Integer is a subclass of Object\nInteger intObj2 = new Integer(3);\nint k = intObj2.intValue();\nif (intObj.equals(intObj2)) //OK, evaluates to false\n...\nif (intObj.intValue() == intObj2.intValue())\n... //OK, since comparing primitive types\nif (k.equals(j)) //error, k and j not objects\n...\nif ((intObj.intValue()).compareTo(intObj2.intValue()) < 0)\n... //error, can\u2019t use compareTo on primitive types\nif (intObj.compareTo(object) < 0) //Error. Parameter needs Integer cast if (intObj.compareTo((Integer) object) < 0) //OK\n...\nif (object.compareTo(intObj) < 0) //error, no compareTo in Object\n...\nif (((Integer) object).compareTo(intObj) < 0) //OK\n...\n\nThe Double class wraps a value of type double in an object. An object of type Double contains just one instance variable whose type is double.\nThe methods you should know for the AP exam are analogous to those for type\nInteger.\nDouble(double value)\nConstructs a Double object from a double. (Boxing.)\ndouble doubleValue()\nReturns the value of this Double as a double. (Unboxing.)\nint compareTo(Double other)\nReturns 0 if the value of this Double is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nboolean equals(Object obj)\nThis method overrides equals in class Object and throws a ClassCastException if obj is not a Double. Otherwise it returns true if and only if this Double has the same double value as obj.\nString toString()\nReturns a String representing the value of this Double.\n\nHere are some examples:\nDouble dObj = new Double(2.5); //boxes 2.5 in Double object\ndouble d = dObj.doubleValue(); //unboxes 2.5 from Double object\nObject object = new Double(7.3); //Double is a subclass of Object\nObject intObj = new Integer(4);\nif (dObj.compareTo(object) > 0) //Error. Parameter needs cast to Double\nif (dObj.compareTo((Double) object) > 0) //OK\n...\nif (dObj.compareTo(intObj) > 0) //ClassCastException\n... //can\u2019t compare Integer to Double\n\nNOTE\n1. Integer and Double objects are immutable: There are no mutator methods in the classes.\n2. See p. 242 for a discussion of auto-boxing and -unboxing. This useful feature will not be tested on the AP exam.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider these declarations:\n\nInteger intOb = new Integer(3); \nObject ob = new Integer(4); \nDouble doubOb = new Double(3.0); \n\nWhich of the following will not cause an error? \nCorrect: if (intOb.compareTo((Integer) ob) < 0) ...\n\n\nIncorrect: if ((Integer) ob.compareTo(intOb) < 0) ...\nIncorrect: if (ob.compareTo(intOb) < 0) ...\nIncorrect: if (intOb.compareTo(doubOb) < 0) ...\nIncorrect: if (intOb.compareTo(ob) < 0) ...END"}
{"prompt": "A wrapper class takes either an existing object or a value of primitive type, \u201cwraps\u201d or \u201cboxes\u201d it in an object, and provides a new set of methods for that type. The point of a wrapper class is to provide extended capabilities for the boxed quantity:\n\u2022 It can be used in generic Java methods that require objects as parameters.\n\u2022 It can be used in Java container classes that require the items be objects (see p. 242).\n\nIn each case, the wrapper class allows\n1. Construction of an object from a single value (wrapping or boxing the primitive in a wrapper object).\n2. Retrieval of the primitive value (unwrapping or unboxing from the wrapper object).\nJava provides a wrapper class for each of its primitive types. The two that you should know for the AP exam are the Integer and Double classes.\n\nThe Integer class wraps a value of type int in an object. An object of type Integer contains just one instance variable whose type is int.\nHere are the Integer methods you should know for the AP exam:\nInteger(int value)\nConstructs an Integer object from an int. (Boxing.)\nint compareTo(Integer other)\nReturns 0 if the value of this Integer is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nint intValue()\nReturns the value of this Integer as an int. (Unboxing.)\nboolean equals(Object obj)\nReturns true if and only if this Integer has the same int value as obj.\nNOTE\n1. This method overrides equals in class Object.\n2. This method throws a ClassCastException if obj is not an Integer.\nString toString()\nReturns a String representing the value of this Integer.\nHere are some examples to illustrate the Integer methods:\nInteger intObj = new Integer(6); //boxes 6 in Integer object\nint j = intObj.intValue(); //unboxes 6 from Integer object\nSystem.out.println(\"Integer value is \" + intObj);\n//calls toString() for intObj\n//output is\n//Integer value is 6\nObject object = new Integer(5); //Integer is a subclass of Object\nInteger intObj2 = new Integer(3);\nint k = intObj2.intValue();\nif (intObj.equals(intObj2)) //OK, evaluates to false\n...\nif (intObj.intValue() == intObj2.intValue())\n... //OK, since comparing primitive types\nif (k.equals(j)) //error, k and j not objects\n...\nif ((intObj.intValue()).compareTo(intObj2.intValue()) < 0)\n... //error, can\u2019t use compareTo on primitive types\nif (intObj.compareTo(object) < 0) //Error. Parameter needs Integer cast if (intObj.compareTo((Integer) object) < 0) //OK\n...\nif (object.compareTo(intObj) < 0) //error, no compareTo in Object\n...\nif (((Integer) object).compareTo(intObj) < 0) //OK\n...\n\nThe Double class wraps a value of type double in an object. An object of type Double contains just one instance variable whose type is double.\nThe methods you should know for the AP exam are analogous to those for type\nInteger.\nDouble(double value)\nConstructs a Double object from a double. (Boxing.)\ndouble doubleValue()\nReturns the value of this Double as a double. (Unboxing.)\nint compareTo(Double other)\nReturns 0 if the value of this Double is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nboolean equals(Object obj)\nThis method overrides equals in class Object and throws a ClassCastException if obj is not a Double. Otherwise it returns true if and only if this Double has the same double value as obj.\nString toString()\nReturns a String representing the value of this Double.\n\nHere are some examples:\nDouble dObj = new Double(2.5); //boxes 2.5 in Double object\ndouble d = dObj.doubleValue(); //unboxes 2.5 from Double object\nObject object = new Double(7.3); //Double is a subclass of Object\nObject intObj = new Integer(4);\nif (dObj.compareTo(object) > 0) //Error. Parameter needs cast to Double\nif (dObj.compareTo((Double) object) > 0) //OK\n...\nif (dObj.compareTo(intObj) > 0) //ClassCastException\n... //can\u2019t compare Integer to Double\n\nNOTE\n1. Integer and Double objects are immutable: There are no mutator methods in the classes.\n2. See p. 242 for a discussion of auto-boxing and -unboxing. This useful feature will not be tested on the AP exam.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Refer to these declarations: \n\nInteger k = new Integer(8); \nInteger m = new Integer(4); \n\nWhich test will not generate an error? \nI if (k.intValue() == m.intValue())... \nII if ((k.intValue()).equals(m.intValue()))... \nIII if ((k.toString()).equals(m.toString()))... \nCorrect: I and III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "A wrapper class takes either an existing object or a value of primitive type, \u201cwraps\u201d or \u201cboxes\u201d it in an object, and provides a new set of methods for that type. The point of a wrapper class is to provide extended capabilities for the boxed quantity:\n\u2022 It can be used in generic Java methods that require objects as parameters.\n\u2022 It can be used in Java container classes that require the items be objects (see p. 242).\n\nIn each case, the wrapper class allows\n1. Construction of an object from a single value (wrapping or boxing the primitive in a wrapper object).\n2. Retrieval of the primitive value (unwrapping or unboxing from the wrapper object).\nJava provides a wrapper class for each of its primitive types. The two that you should know for the AP exam are the Integer and Double classes.\n\nThe Integer class wraps a value of type int in an object. An object of type Integer contains just one instance variable whose type is int.\nHere are the Integer methods you should know for the AP exam:\nInteger(int value)\nConstructs an Integer object from an int. (Boxing.)\nint compareTo(Integer other)\nReturns 0 if the value of this Integer is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nint intValue()\nReturns the value of this Integer as an int. (Unboxing.)\nboolean equals(Object obj)\nReturns true if and only if this Integer has the same int value as obj.\nNOTE\n1. This method overrides equals in class Object.\n2. This method throws a ClassCastException if obj is not an Integer.\nString toString()\nReturns a String representing the value of this Integer.\nHere are some examples to illustrate the Integer methods:\nInteger intObj = new Integer(6); //boxes 6 in Integer object\nint j = intObj.intValue(); //unboxes 6 from Integer object\nSystem.out.println(\"Integer value is \" + intObj);\n//calls toString() for intObj\n//output is\n//Integer value is 6\nObject object = new Integer(5); //Integer is a subclass of Object\nInteger intObj2 = new Integer(3);\nint k = intObj2.intValue();\nif (intObj.equals(intObj2)) //OK, evaluates to false\n...\nif (intObj.intValue() == intObj2.intValue())\n... //OK, since comparing primitive types\nif (k.equals(j)) //error, k and j not objects\n...\nif ((intObj.intValue()).compareTo(intObj2.intValue()) < 0)\n... //error, can\u2019t use compareTo on primitive types\nif (intObj.compareTo(object) < 0) //Error. Parameter needs Integer cast if (intObj.compareTo((Integer) object) < 0) //OK\n...\nif (object.compareTo(intObj) < 0) //error, no compareTo in Object\n...\nif (((Integer) object).compareTo(intObj) < 0) //OK\n...\n\nThe Double class wraps a value of type double in an object. An object of type Double contains just one instance variable whose type is double.\nThe methods you should know for the AP exam are analogous to those for type\nInteger.\nDouble(double value)\nConstructs a Double object from a double. (Boxing.)\ndouble doubleValue()\nReturns the value of this Double as a double. (Unboxing.)\nint compareTo(Double other)\nReturns 0 if the value of this Double is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nboolean equals(Object obj)\nThis method overrides equals in class Object and throws a ClassCastException if obj is not a Double. Otherwise it returns true if and only if this Double has the same double value as obj.\nString toString()\nReturns a String representing the value of this Double.\n\nHere are some examples:\nDouble dObj = new Double(2.5); //boxes 2.5 in Double object\ndouble d = dObj.doubleValue(); //unboxes 2.5 from Double object\nObject object = new Double(7.3); //Double is a subclass of Object\nObject intObj = new Integer(4);\nif (dObj.compareTo(object) > 0) //Error. Parameter needs cast to Double\nif (dObj.compareTo((Double) object) > 0) //OK\n...\nif (dObj.compareTo(intObj) > 0) //ClassCastException\n... //can\u2019t compare Integer to Double\n\nNOTE\n1. Integer and Double objects are immutable: There are no mutator methods in the classes.\n2. See p. 242 for a discussion of auto-boxing and -unboxing. This useful feature will not be tested on the AP exam.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the code fragment \n\nObject intObj = new Integer(9); \nSystem.out.println((String) intObj); \n\nWhat will be output as a result of running the fragment? \nCorrect: No output. A ClassCastException will be thrown.\nIncorrect: No output. An ArithmeticException will be thrown.\nIncorrect: 9\nIncorrect: \"9\"\nIncorrect: nine\n\nEND"}
{"prompt": "There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n\u2022 If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n\u2022 If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n\u2022 If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) //true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) //false, \"H\" comes before \"d\"\nDon\u2019t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you\u2019re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don\u2019t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) //returns \"happy\"\n\"cold\".substring(4) //returns \"\" (empty string)\n\"cold\".substring(5) //StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) //returns \"be\"\n\"crayfish\".substring(4,8) //returns \"fish\"\n\"crayfish\".substring(4,9) //StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) //StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); //x has value 5\nx = s.indexOf(\"farmer\"); //x has value -1\nint y = s.length(); //y has value 9\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider these declarations: \n\nString s1 = \"crab\"; \nString s2 = new String(\"crab\"); \nString s3 = s1; \n\nWhich expression involving these strings evaluates to true? \nI s1 == s2 \nII s1.equals(s2) \nIII s3.equals(s2) \nCorrect: II and III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n\u2022 If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n\u2022 If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n\u2022 If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) //true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) //false, \"H\" comes before \"d\"\nDon\u2019t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you\u2019re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don\u2019t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) //returns \"happy\"\n\"cold\".substring(4) //returns \"\" (empty string)\n\"cold\".substring(5) //StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) //returns \"be\"\n\"crayfish\".substring(4,8) //returns \"fish\"\n\"crayfish\".substring(4,9) //StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) //StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); //x has value 5\nx = s.indexOf(\"farmer\"); //x has value -1\nint y = s.length(); //y has value 9\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Suppose that strA = \"TOMATO\", strB = \"tomato\", and strC = \"tom\". Given that \"A\" comes before \"a\" in dictionary order, which is true? \nCorrect: !(strA.equals(strB)) && strC.compareTo(strB) < 0\nIncorrect: strA.compareTo(strB) < 0 && strB.compareTo(strC) < 0\nIncorrect: strB.compareTo(strA) < 0 || strC.compareTo(strA) < 0\nIncorrect: strC.compareTo(strA) < 0 && strA.compareTo(strB) < 0\nIncorrect: !(strA.equals(strB)) && strC.compareTo(strA) < 0\n\nEND"}
{"prompt": "There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n\u2022 If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n\u2022 If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n\u2022 If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) //true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) //false, \"H\" comes before \"d\"\nDon\u2019t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you\u2019re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don\u2019t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) //returns \"happy\"\n\"cold\".substring(4) //returns \"\" (empty string)\n\"cold\".substring(5) //StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) //returns \"be\"\n\"crayfish\".substring(4,8) //returns \"fish\"\n\"crayfish\".substring(4,9) //StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) //StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); //x has value 5\nx = s.indexOf(\"farmer\"); //x has value -1\nint y = s.length(); //y has value 9\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: This question refers to the following declaration: \n\nString line = \"Some more silly stuff on strings!\"; \n//the words are separated by a single space \n\nWhat string will str refer to after execution of the following? \n\nint x = line.indexOf(\"m\"); \nString str = line.substring(10, 15) + line.substring(25, 25 + x); \n\nCorrect: \"sillyst\"\nIncorrect: \"sillystr\"\nIncorrect: \"silly st\"\nIncorrect: \"silly str\"\nIncorrect: \"sillystrin\"\n\nEND"}
{"prompt": "There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n\u2022 If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n\u2022 If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n\u2022 If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) //true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) //false, \"H\" comes before \"d\"\nDon\u2019t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you\u2019re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don\u2019t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) //returns \"happy\"\n\"cold\".substring(4) //returns \"\" (empty string)\n\"cold\".substring(5) //StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) //returns \"be\"\n\"crayfish\".substring(4,8) //returns \"fish\"\n\"crayfish\".substring(4,9) //StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) //StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); //x has value 5\nx = s.indexOf(\"farmer\"); //x has value -1\nint y = s.length(); //y has value 9\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: A program has a String variable fullName that stores a first name, followed by a space, followed by a last name. There are no spaces in either the first or last names. Here are some examples of fullName values: \"Anthony Coppola\", \"Jimmy Carroll\", and \"Tom DeWire\". Consider this code segment that extracts the last name from a fullName variable, and stores it in lastName with no surrounding blanks: \n\nint k = fullName.indexOf(\" \"); //find index of blank \nString lastName = /* expression */ \n\nWhich is a correct replacement for /* expression */? \nI fullName.substring(k); \nII fullName.substring(k + 1); \nIII fullName.substring(k + 1, fullName.length()); \nCorrect: II and III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and III only\n\nEND"}
{"prompt": "There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n\u2022 If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n\u2022 If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n\u2022 If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) //true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) //false, \"H\" comes before \"d\"\nDon\u2019t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you\u2019re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don\u2019t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) //returns \"happy\"\n\"cold\".substring(4) //returns \"\" (empty string)\n\"cold\".substring(5) //StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) //returns \"be\"\n\"crayfish\".substring(4,8) //returns \"fish\"\n\"crayfish\".substring(4,9) //StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) //StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); //x has value 5\nx = s.indexOf(\"farmer\"); //x has value -1\nint y = s.length(); //y has value 9\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: One of the rules for converting English to Pig Latin states: If a word begins with a consonant, move the consonant to the end of the word and add \u201cay\u201d. Thus \u201cdog\u201d becomes \u201cogday,\u201d and \u201ccrisp\u201d becomes \u201crispcay\u201d. Suppose s is a String containing an English word that begins with a consonant. Which of the following creates the correct corresponding word in Pig Latin? Assume the declarations \n\nString ayString = \"ay\"; \nString pigString; \n\nCorrect: pigString = s.substring(1, s.length()) + s.substring(0,1) + ayString;\n\n\nIncorrect: pigString = s.substring(0, s.length()) + s.substring(0,1) + ayString;\nIncorrect: pigString = s.substring(1, s.length()) + s.substring(0,0) + ayString;\nIncorrect: pigString = s.substring(0, s.length()-1) + s.substring(0,1) + ayString;\nIncorrect: pigString = s.substring(1, s.length()-1) + s.substring(0,0) + ayString;END"}
{"prompt": "There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n\u2022 If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n\u2022 If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n\u2022 If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) //true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) //false, \"H\" comes before \"d\"\nDon\u2019t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you\u2019re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don\u2019t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) //returns \"happy\"\n\"cold\".substring(4) //returns \"\" (empty string)\n\"cold\".substring(5) //StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) //returns \"be\"\n\"crayfish\".substring(4,8) //returns \"fish\"\n\"crayfish\".substring(4,9) //StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) //StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); //x has value 5\nx = s.indexOf(\"farmer\"); //x has value -1\nint y = s.length(); //y has value 9\n\n\nThe following question asks about the properties or summary of a program with multiple options:\n\n###\n\n", "completion": "Question: This question refers to the getString method shown below: \n\npublic static String getString(String s1, String s2) \n{ \n    int index = s1.indexOf(s2); \n    return s1.substring(index, index + s2.length()); \n} \n\nWhich is true about getString? It may return a string that \nI Is equal to s2. \nII Has no characters in common with s2. \nIII Is equal to s1. \nCorrect: I and III only\nIncorrect: II and III only\nIncorrect: I and II only\nIncorrect: I, II, and III\nIncorrect: None is true.\n\nEND"}
{"prompt": "There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n\u2022 If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n\u2022 If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n\u2022 If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) //true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) //false, \"H\" comes before \"d\"\nDon\u2019t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you\u2019re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don\u2019t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) //returns \"happy\"\n\"cold\".substring(4) //returns \"\" (empty string)\n\"cold\".substring(5) //StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) //returns \"be\"\n\"crayfish\".substring(4,8) //returns \"fish\"\n\"crayfish\".substring(4,9) //StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) //StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); //x has value 5\nx = s.indexOf(\"farmer\"); //x has value -1\nint y = s.length(); //y has value 9\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider this method: \n\npublic static String doSomething(String s) \n{ \n    final String BLANK = \" \"; //BLANK contains a single space \n    String str = \"\"; //empty string \n    String temp; \n    for (int i = 0; i < s.length(); i++) \n    { \n        temp = s.substring(i, i + 1); \n        if (!(temp.equals(BLANK))) \n            str += temp; \n    } \n    return str; \n} \n\nWhich of the following is the most precise description of what doSomething does? \nCorrect: It returns a String that is equivalent to s with all its blanks removed.\nIncorrect: It returns s unchanged.\nIncorrect: It returns s with all its blanks removed.\nIncorrect: It returns a String that is an exact copy of s.\nIncorrect: It returns a String that contains s.length() blanks.\n\nEND"}
{"prompt": "A wrapper class takes either an existing object or a value of primitive type, \u201cwraps\u201d or \u201cboxes\u201d it in an object, and provides a new set of methods for that type. The point of a wrapper class is to provide extended capabilities for the boxed quantity:\n\u2022 It can be used in generic Java methods that require objects as parameters.\n\u2022 It can be used in Java container classes that require the items be objects (see p. 242).\n\nIn each case, the wrapper class allows\n1. Construction of an object from a single value (wrapping or boxing the primitive in a wrapper object).\n2. Retrieval of the primitive value (unwrapping or unboxing from the wrapper object).\nJava provides a wrapper class for each of its primitive types. The two that you should know for the AP exam are the Integer and Double classes.\n\nThe Integer class wraps a value of type int in an object. An object of type Integer contains just one instance variable whose type is int.\nHere are the Integer methods you should know for the AP exam:\nInteger(int value)\nConstructs an Integer object from an int. (Boxing.)\nint compareTo(Integer other)\nReturns 0 if the value of this Integer is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nint intValue()\nReturns the value of this Integer as an int. (Unboxing.)\nboolean equals(Object obj)\nReturns true if and only if this Integer has the same int value as obj.\nNOTE\n1. This method overrides equals in class Object.\n2. This method throws a ClassCastException if obj is not an Integer.\nString toString()\nReturns a String representing the value of this Integer.\nHere are some examples to illustrate the Integer methods:\nInteger intObj = new Integer(6); //boxes 6 in Integer object\nint j = intObj.intValue(); //unboxes 6 from Integer object\nSystem.out.println(\"Integer value is \" + intObj);\n//calls toString() for intObj\n//output is\n//Integer value is 6\nObject object = new Integer(5); //Integer is a subclass of Object\nInteger intObj2 = new Integer(3);\nint k = intObj2.intValue();\nif (intObj.equals(intObj2)) //OK, evaluates to false\n...\nif (intObj.intValue() == intObj2.intValue())\n... //OK, since comparing primitive types\nif (k.equals(j)) //error, k and j not objects\n...\nif ((intObj.intValue()).compareTo(intObj2.intValue()) < 0)\n... //error, can\u2019t use compareTo on primitive types\nif (intObj.compareTo(object) < 0) //Error. Parameter needs Integer cast if (intObj.compareTo((Integer) object) < 0) //OK\n...\nif (object.compareTo(intObj) < 0) //error, no compareTo in Object\n...\nif (((Integer) object).compareTo(intObj) < 0) //OK\n...\n\nThe Double class wraps a value of type double in an object. An object of type Double contains just one instance variable whose type is double.\nThe methods you should know for the AP exam are analogous to those for type\nInteger.\nDouble(double value)\nConstructs a Double object from a double. (Boxing.)\ndouble doubleValue()\nReturns the value of this Double as a double. (Unboxing.)\nint compareTo(Double other)\nReturns 0 if the value of this Double is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nboolean equals(Object obj)\nThis method overrides equals in class Object and throws a ClassCastException if obj is not a Double. Otherwise it returns true if and only if this Double has the same double value as obj.\nString toString()\nReturns a String representing the value of this Double.\n\nHere are some examples:\nDouble dObj = new Double(2.5); //boxes 2.5 in Double object\ndouble d = dObj.doubleValue(); //unboxes 2.5 from Double object\nObject object = new Double(7.3); //Double is a subclass of Object\nObject intObj = new Integer(4);\nif (dObj.compareTo(object) > 0) //Error. Parameter needs cast to Double\nif (dObj.compareTo((Double) object) > 0) //OK\n...\nif (dObj.compareTo(intObj) > 0) //ClassCastException\n... //can\u2019t compare Integer to Double\n\nNOTE\n1. Integer and Double objects are immutable: There are no mutator methods in the classes.\n2. See p. 242 for a discussion of auto-boxing and -unboxing. This useful feature will not be tested on the AP exam.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: The following question deals with the problem of swapping two integer values. Three methods are proposed to solve the problem, using primitive int types, Integer objects, and IntPair objects, where IntPair is defined as follows: \n\npublic class IntPair {\n    private int firstValue;\n    private int secondValue;\n\n    public IntPair(int first, int second) {\n        firstValue = first;\n        secondValue = second;\n    }\n\n    public int getFirst() {\n        return firstValue;\n    }\n\n    public int getSecond() {\n        return secondValue;\n    }\n\n    public void setFirst(int a) {\n        firstValue = a;\n    }\n\n    public void setSecond(int b) {\n        secondValue = b;\n    }\n}\n\nHere are three different swap methods, each intended for use in a client program.\nI public static void swap(int a, int b) \n{ \n    int temp = a; \n    a = b; \n    b = temp; \n} \nII public static void swap(Integer obj_a, Integer obj_b) \n{ \n    Integer temp = new Integer(obj_a.intValue()); \n    obj_a = obj_b; \n    obj_b = temp; \n} \nIII public static void swap(IntPair pair) \n{ \n    int temp = pair.getFirst(); \n    pair.setFirst(pair.getSecond()); \n    pair.setSecond(temp); \n} \nWhen correctly used in a client program with appropriate parameters, which method will swap two integers, as intended? \nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: II and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n\u2022 If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n\u2022 If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n\u2022 If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) //true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) //false, \"H\" comes before \"d\"\nDon\u2019t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you\u2019re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don\u2019t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) //returns \"happy\"\n\"cold\".substring(4) //returns \"\" (empty string)\n\"cold\".substring(5) //StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) //returns \"be\"\n\"crayfish\".substring(4,8) //returns \"fish\"\n\"crayfish\".substring(4,9) //StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) //StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); //x has value 5\nx = s.indexOf(\"farmer\"); //x has value -1\nint y = s.length(); //y has value 9\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the Name class defined below:\n\npublic class Name {\n    private String firstName;\n    private String lastName;\n\n    public Name(String first, String last) // constructor\n    {\n        firstName = first;\n        lastName = last;\n    }\n\n    public String toString() {\n        return firstName + \" \" + lastName;\n    }\n\n    public boolean equals(Object obj) {\n        Name n = (Name) obj;\n        return n.firstName.equals(firstName) && n.lastName.equals(lastName);\n    }\n\n    public int hashCode() { /* implementation not shown */ }\n\n    public int compareTo(Name n) { /* more code */ }\n}\n\nThe compareTo method implements the standard name-ordering algorithm where last names take precedence over first names. Lexicographic or dictionary ordering of Strings is used. For example, the name Scott Dentes comes before Nick Elser, and Adam Cooper comes before Sara Cooper. \nWhich of the following is a correct replacement for /* more code */? \nI int lastComp = lastName.compareTo(n.lastName); \nif (lastComp != 0) \n    return lastComp; \nelse \n    return firstName.compareTo(n.firstName); \nII if (lastName.equals(n.lastName)) \n    return firstName.compareTo(n.firstName); \nelse \n    return 0; \nIII if (!(lastName.equals(n.lastName))) \n    return firstName.compareTo(n.firstName); \nelse \n    return lastName.compareTo(n.lastName); \nCorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n\u2022 If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n\u2022 If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n\u2022 If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) //true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) //false, \"H\" comes before \"d\"\nDon\u2019t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you\u2019re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don\u2019t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) //returns \"happy\"\n\"cold\".substring(4) //returns \"\" (empty string)\n\"cold\".substring(5) //StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) //returns \"be\"\n\"crayfish\".substring(4,8) //returns \"fish\"\n\"crayfish\".substring(4,9) //StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) //StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); //x has value 5\nx = s.indexOf(\"farmer\"); //x has value -1\nint y = s.length(); //y has value 9\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the Name class defined below:\n\npublic class Name {\n    private String firstName;\n    private String lastName;\n\n    public Name(String first, String last) // constructor\n    {\n        firstName = first;\n        lastName = last;\n    }\n\n    public String toString() {\n        return firstName + \" \" + lastName;\n    }\n\n    public boolean equals(Object obj) {\n        Name n = (Name) obj;\n        return n.firstName.equals(firstName) && n.lastName.equals(lastName);\n    }\n\n    public int hashCode() { /* implementation not shown */ }\n\n    public int compareTo(Name n) { /* more code */ }\n}\n\nWhich statement about the Name class is false? \nCorrect: Since the Name class has a compareTo method, it must provide an implementation for an equals method.\n\nIncorrect: Name objects are immutable.\nIncorrect: It is possible for the methods in Name to throw a NullPointerException.\nIncorrect: If n1 and n2 are Name objects in a client class, then the expressions\nn1.equals(n2) and n1.compareTo(n2) == 0 must have the same value. \nIncorrect: The compareTo method throws a run-time exception if the parameter is null.END"}
{"prompt": "The header of a method defines the parameters of that method. For example, consider the withdraw method of the BankAccount class:\npublic class BankAccount\n{ ...\n    public void withdraw(String acctPassword, double amount) ...\n\nThis method has two explicit parameters, acctPassword and amount. These are dummy or formal parameters. Think of them as placeholders for the pair of actual parameters or arguments that will be supplied by a particular method call in a client program. For example,\nDo not make a method call with an object whose value is null.\n\nBankAccount b = new BankAccount(\"TimB\", 1000);\nb.withdraw(\"TimB\", 250);\n\nHere \"TimB\" and 250 are the actual parameters that match up with acctPassword and amount for the withdraw method.\n\n1. The number of arguments in the method call must equal the number of param eters in the method header, and the type of each argument must be compatible with the type of each corresponding parameter.\n2. In addition to its explicit parameters, the withdraw method has an implicit parameter, this, the BankAccount from which money will be withdrawn. In the method call\nb.withdraw(\"TimB\", 250);\nthe actual parameter that matches up with this is the object reference b.\n\nParameters are passed by value. For primitive types this means that when a method is called, a new memory slot is allocated for each parameter. The value of each argument is copied into the newly created memory slot corresponding to each parameter.\nDuring execution of the method, the parameters are local to that method. Any changes made to the parameters will not affect the values of the arguments in the calling program. When the method is exited, the local memory slots for the parameters are erased.\nHere\u2019s an example: What will the output be?\n\npublic class ParamTest {\n    public static void foo(int x, double y) {\n        x = 3;\n        y = 2.5;\n    }\n\n    public static void main(String[] args) {\n        int a = 7;\n        double b = 6.5;\n        foo(a, b);\n        System.out.println(a + \" \" + b);\n    }\n}\n\nThe output will be\n7 6.5\nThe arguments a and b remain unchanged, despite the method call!\nThis can be understood by picturing the state of the memory slots during execution of the program.\n\n\nThe following question asks about general programming knowledge:\n\n###\n\n", "completion": "Question: Which statement about parameters is false?\nCorrect: Two overloaded methods in the same class must have parameters with different names.\nIncorrect: The scope of parameters is the method in which they are defined.\nIncorrect: Static methods have no implicit parameter this.\nIncorrect: All parameters in Java are passed by value.\nIncorrect: Two different constructors in a given class can have the same number of parameters.\n\nEND"}
{"prompt": "A constructor creates an object of the class. You can recognize a constructor by its name\u2014always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n/** Default constructor.\n* Constructs a bank account with default values. */\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address\u2014we say \u201cb is a reference to the object.\u201d\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n/** Constructor. Constructs a bank account with\n* specified password and balance. */\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n/** @return the balance of this account */\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n        balance += amount;\n}\n/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n    {\n        balance -= amount; //allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the Time class defined below:\n\npublic class Time\n{\n\tprivate int hrs;\n\tprivate int mins;\n\tprivate int secs;\n\n\tpublic Time()\n\t{ /* implementation not shown */ }\n\n\tpublic Time(int h, int m, int s)\n\t{ /* implementation not shown */ }\n\n\t/** Resets time to hrs = h, mins = m, secs = s. */\n\tpublic void resetTime(int h, int m, int s)\n\t{ /* implementation not shown */ }\n\n\t/** Advances time by one second. */\n\tpublic void increment()\n\t{ /* implementation not shown */ }\n\n\t/** @return true if this time equals t, false otherwise */\n\tpublic boolean equals(Time t)\n\t{ /* implementation not shown */ }\n\n\t/** @return true if this time is earlier than t, false otherwise */\n\tpublic boolean lessThan(Time t)\n\t{ /* implementation not shown */ }\n\n\t/** @return a String with the time in the form hrs:mins:secs */\n\tpublic String toString()\n\t{ /* implementation not shown */ }\n}\n\nWhich of the following is a false statement about the methods?\nCorrect: The Time class has three constructors.\nIncorrect: equals, lessThan, and toString are all accessor methods.\nIncorrect: increment is a mutator method.\nIncorrect: Time() is the default constructor.\nIncorrect: There are no static methods in this class.\n\nEND"}
{"prompt": "Every program that you write involves at least one thing that is being created or manipulated by the program. This thing, together with the operations that manipulate it, is called an object.\nConsider, for example, a program that must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. Rules for validity are provided. The object is a four-digit code number. Some of the operations to manipulate the object could be readNumber, getSeparateDigits, testValidity, and writeNumber.\nAny given program can have several different types of objects. For example, a pro gram that maintains a database of all books in a library has at least two objects:\n1. A Book object, with operations like getTitle, isOnShelf, isFiction, and goOutOfPrint.\n2. A ListOfBooks object, with operations like search, addBook, removeBook, and sortByAuthor.\nAn object is characterized by its state and behavior. For example, a book has a state described by its title, author, whether it\u2019s on the shelf, and so on. It also has behavior, like going out of print.\nNotice that an object is an idea, separate from the concrete details of a programming language. It corresponds to some real-world object that is being represented by the program.\nAll object-oriented programming languages have a way to represent an object as a variable in a program. In Java, a variable that represents an object is called an object reference.\nA class is a software blueprint for implementing objects of a given type. An object is a single instance of the class. In a program there will often be several different instances of a given class type.\nThe current state of a given object is maintained in its data fields orinstance variables, provided by the class. The methods of the class provide both the behaviors exhibited by the object and the operations that manipulate the object. Combining an object\u2019s data and methods into a single unit called a class is known as encapsulation.\nHere is the framework for a simple bank account class:\n\npublic class BankAccount {\n    private String password;\n    private double balance;\n    public static final double OVERDRAWN_PENALTY = 20.00;\n\n    // constructors\n    /**\n     * Default constructor.\n     * Constructs bank account with default values.\n     */\n    public BankAccount() {\n        /* implementation code */ }\n\n    /** Constructs bank account with specified password and balance. */\n    public BankAccount(String acctPassword, double acctBalance) {\n        /* implementation code */ }\n\n    // accessor\n    /** @return balance of this account */\n    public double getBalance() {\n        /* implementation code */ }\n\n    // mutators\n    /**\n     * Deposits amount in bank account with given password.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be deposited\n     */\n    public void deposit(String acctPassword, double amount) {\n        /* implementation code */ }\n\n    /**\n     * Withdraws amount from bank account with given password.\n     * Assesses penalty if balance is less than amount.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be withdrawn\n     */\n    public void withdraw(String acctPassword, double amount) {\n        /* implementation code */ }\n}\nThe keyword public preceding the class declaration signals that the class is usable by all client programs. If a class is not public, it can be used only by classes in its own package. In the AP Java subset, all classes are public.\nSimilarly, public methods are accessible to all client programs. Clients, however, are not privy to the class implementation and may not access the private instance variables and private methods of the class. Restriction of access is known as information hiding. In Java, this is implemented by using the keyword private. Private methods and vari ables in a class can be accessed only by methods of that class. Even though Java allows public instance variables, in the AP Java subset all instance variables are private.\nA static variable (class variable) contains a value that is shared by all instances of the class. \u201cStatic\u201d means that memory allocation happens once.\nTypical uses of a static variable are to\n\u2022 keep track of statistics for objects of the class.\n\u2022 accumulate a total.\n\u2022 provide a new identity number for each new object of the class.\nFor example:\n\npublic class Employee\n{\n    private String name;\n    private static int employeeCount = 0; //number of employees\n    public Employee( < parameter list > )\n    {\n        < initialization of private instance variables >\n        employeeCount++; //increment count of all employees\n    }\n\n    ...\n}\n\nNotice that the static variable was initialized outside the constructor and that its value can be changed.\nStatic final variables (constants) in a class cannot be changed. They are often de clared public (see some examples of Math class constants on p. 183). The variable OVERDRAWN_PENALTY is an example in the BankAccount class. Since the variable is public, it can be used in any client method. The keyword static indicates that there is a single value of the variable that applies to the whole class, rather than a new instance for each object of the class. A client method would refer to the vari able as BankAccount.OVERDRAWN_PENALTY. In its own class it is referred to as simply OVERDRAWN_PENALTY.\nSee p. 97 for static methods.\nAll method headers, with the exception of constructors (see below) and static methods (p. 97), look like this:\naccess specifier, return type, method name, parameter list\n\n1. The access specifier tells which other methods can call this method (see Public, Private, and Static on the previous page).\n2. A return type of void signals that the method does not return a value. 3. Items in the parameter list are separated by commas.\nThe implementation of the method directly follows the header, enclosed in a {} block.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the Time class defined below:\n\npublic class Time\n{\n\tprivate int hrs;\n\tprivate int mins;\n\tprivate int secs;\n\n\tpublic Time()\n\t{ /* implementation not shown */ }\n\n\tpublic Time(int h, int m, int s)\n\t{ /* implementation not shown */ }\n\n\t/** Resets time to hrs = h, mins = m, secs = s. */\n\tpublic void resetTime(int h, int m, int s)\n\t{ /* implementation not shown */ }\n\n\t/** Advances time by one second. */\n\tpublic void increment()\n\t{ /* implementation not shown */ }\n\n\t/** @return true if this time equals t, false otherwise */\n\tpublic boolean equals(Time t)\n\t{ /* implementation not shown */ }\n\n\t/** @return true if this time is earlier than t, false otherwise */\n\tpublic boolean lessThan(Time t)\n\t{ /* implementation not shown */ }\n\n\t/** @return a String with the time in the form hrs:mins:secs */\n\tpublic String toString()\n\t{ /* implementation not shown */ }\n}\n\nWhich of the following represents correct implementation code for the constructor with parameters?\nCorrect: hrs = h;\nmins = m;\nsecs = s;\nIncorrect: hrs = 0;\nmins = 0;\nsecs = 0;\nIncorrect: resetTime(hrs, mins, secs);\nIncorrect: h = hrs;\nm = mins;\ns = secs;\nIncorrect: Time = new Time(h, m, s);\n\nEND"}
{"prompt": "Every program that you write involves at least one thing that is being created or manipulated by the program. This thing, together with the operations that manipulate it, is called an object.\nConsider, for example, a program that must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. Rules for validity are provided. The object is a four-digit code number. Some of the operations to manipulate the object could be readNumber, getSeparateDigits, testValidity, and writeNumber.\nAny given program can have several different types of objects. For example, a pro gram that maintains a database of all books in a library has at least two objects:\n1. A Book object, with operations like getTitle, isOnShelf, isFiction, and goOutOfPrint.\n2. A ListOfBooks object, with operations like search, addBook, removeBook, and sortByAuthor.\nAn object is characterized by its state and behavior. For example, a book has a state described by its title, author, whether it\u2019s on the shelf, and so on. It also has behavior, like going out of print.\nNotice that an object is an idea, separate from the concrete details of a programming language. It corresponds to some real-world object that is being represented by the program.\nAll object-oriented programming languages have a way to represent an object as a variable in a program. In Java, a variable that represents an object is called an object reference.\nA class is a software blueprint for implementing objects of a given type. An object is a single instance of the class. In a program there will often be several different instances of a given class type.\nThe current state of a given object is maintained in its data fields orinstance variables, provided by the class. The methods of the class provide both the behaviors exhibited by the object and the operations that manipulate the object. Combining an object\u2019s data and methods into a single unit called a class is known as encapsulation.\nHere is the framework for a simple bank account class:\n\npublic class BankAccount {\n    private String password;\n    private double balance;\n    public static final double OVERDRAWN_PENALTY = 20.00;\n\n    // constructors\n    /**\n     * Default constructor.\n     * Constructs bank account with default values.\n     */\n    public BankAccount() {\n        /* implementation code */ }\n\n    /** Constructs bank account with specified password and balance. */\n    public BankAccount(String acctPassword, double acctBalance) {\n        /* implementation code */ }\n\n    // accessor\n    /** @return balance of this account */\n    public double getBalance() {\n        /* implementation code */ }\n\n    // mutators\n    /**\n     * Deposits amount in bank account with given password.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be deposited\n     */\n    public void deposit(String acctPassword, double amount) {\n        /* implementation code */ }\n\n    /**\n     * Withdraws amount from bank account with given password.\n     * Assesses penalty if balance is less than amount.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be withdrawn\n     */\n    public void withdraw(String acctPassword, double amount) {\n        /* implementation code */ }\n}\nThe keyword public preceding the class declaration signals that the class is usable by all client programs. If a class is not public, it can be used only by classes in its own package. In the AP Java subset, all classes are public.\nSimilarly, public methods are accessible to all client programs. Clients, however, are not privy to the class implementation and may not access the private instance variables and private methods of the class. Restriction of access is known as information hiding. In Java, this is implemented by using the keyword private. Private methods and vari ables in a class can be accessed only by methods of that class. Even though Java allows public instance variables, in the AP Java subset all instance variables are private.\nA static variable (class variable) contains a value that is shared by all instances of the class. \u201cStatic\u201d means that memory allocation happens once.\nTypical uses of a static variable are to\n\u2022 keep track of statistics for objects of the class.\n\u2022 accumulate a total.\n\u2022 provide a new identity number for each new object of the class.\nFor example:\n\npublic class Employee\n{\n    private String name;\n    private static int employeeCount = 0; //number of employees\n    public Employee( < parameter list > )\n    {\n        < initialization of private instance variables >\n        employeeCount++; //increment count of all employees\n    }\n\n    ...\n}\n\nNotice that the static variable was initialized outside the constructor and that its value can be changed.\nStatic final variables (constants) in a class cannot be changed. They are often de clared public (see some examples of Math class constants on p. 183). The variable OVERDRAWN_PENALTY is an example in the BankAccount class. Since the variable is public, it can be used in any client method. The keyword static indicates that there is a single value of the variable that applies to the whole class, rather than a new instance for each object of the class. A client method would refer to the vari able as BankAccount.OVERDRAWN_PENALTY. In its own class it is referred to as simply OVERDRAWN_PENALTY.\nSee p. 97 for static methods.\nAll method headers, with the exception of constructors (see below) and static methods (p. 97), look like this:\naccess specifier, return type, method name, parameter list\n\n1. The access specifier tells which other methods can call this method (see Public, Private, and Static on the previous page).\n2. A return type of void signals that the method does not return a value. 3. Items in the parameter list are separated by commas.\nThe implementation of the method directly follows the header, enclosed in a {} block.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the Time class defined below:\n\npublic class Time\n{\n\tprivate int hrs;\n\tprivate int mins;\n\tprivate int secs;\n\n\tpublic Time()\n\t{ /* implementation not shown */ }\n\n\tpublic Time(int h, int m, int s)\n\t{ /* implementation not shown */ }\n\n\t/** Resets time to hrs = h, mins = m, secs = s. */\n\tpublic void resetTime(int h, int m, int s)\n\t{ /* implementation not shown */ }\n\n\t/** Advances time by one second. */\n\tpublic void increment()\n\t{ /* implementation not shown */ }\n\n\t/** @return true if this time equals t, false otherwise */\n\tpublic boolean equals(Time t)\n\t{ /* implementation not shown */ }\n\n\t/** @return true if this time is earlier than t, false otherwise */\n\tpublic boolean lessThan(Time t)\n\t{ /* implementation not shown */ }\n\n\t/** @return a String with the time in the form hrs:mins:secs */\n\tpublic String toString()\n\t{ /* implementation not shown */ }\n}\n\nA client class has a display method that writes the time represented by its parameter:\n/** Outputs time t in the form hrs:mins:secs.\n* @param t the time\n*/\npublic void display (Time t)\n{\n\t/* method body */\n}\nWhich of the following are correct replacements for /* method body */?\nI Time T = new Time(h, m, s);\nSystem.out.println(T);\nII System.out.println(t.hrs + \":\" + t.mins + \":\" + t.secs);\nIII System.out.println(t);\nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: II and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "A constructor creates an object of the class. You can recognize a constructor by its name\u2014always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n/** Default constructor.\n* Constructs a bank account with default values. */\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address\u2014we say \u201cb is a reference to the object.\u201d\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n/** Constructor. Constructs a bank account with\n* specified password and balance. */\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n/** @return the balance of this account */\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n        balance += amount;\n}\n/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n    {\n        balance -= amount; //allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() //default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) //constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() //returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() //returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() //returns year of Date\n\t{\n\t\t...\n\t}\n\n\t\t// Returns String representation of Date as \"m/d/y\", e.g. 4/18/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nWhich of the following correctly constructs a Date object in a client class?\nCorrect: Date d = new Date(2, 13, 1947);\nIncorrect: Date d = new (2, 13, 1947);\nIncorrect: Date d;\nd = new (2, 13, 1947);\nIncorrect: Date d;\nd = Date(2, 13, 1947);\nIncorrect: Date d = Date(2, 13, 1947);\n\nEND"}
{"prompt": "The scope of a variable or method is the region in which that variable or method is visible and can be accessed.\nThe instance variables, static variables, and methods of a class belong to that class\u2019s scope, which extends from the opening brace to the closing brace of the class definition. Within the class all instance variables and methods are accessible and can be referred to simply by name (no dot operator!).\nA local variable is defined inside a method. It can even be defined inside a statement. Its scope extends from the point where it is declared to the end of the block in which its declaration occurs. A block is a piece of code enclosed in a {} pair. When a block is exited, the memory for a local variable is automatically recycled.\nLocal variables take precedence over instance variables with the same name. (Using the same name, however, creates ambiguity for the programmer, leading to errors. You should avoid the practice.)\n\nAn instance method is always called for a particular object. This object is an implicit parameter for the method and is referred to with the keyword this. You are expected to know this vocabulary for the exam.\nIn the implementation of instance methods, all instance variables can be written with the prefix this followed by the dot operator.\n\nExample 1\nIn the method call obj.doSomething(\"Mary\",num), where obj is some class object and doSomething is a method of that class, \"Mary\" and num, the parameters in parentheses, are explicit parameters, whereas obj is an implicit parameter.\nExample 2\nHere\u2019s an example where this is used as a parameter.\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person(String aName, int anAge) {\n        name = aName;\n        age = anAge;\n    }\n\n    /** @return the String form of this person */\n    public String toString() {\n        return name + \" \" + age;\n    }\n\n    public void printPerson() {\n        System.out.println(this);\n    }\n    // Other variables and methods are not shown.\n}\n\nSuppose a client class has these lines of code:\nPerson p = new Person(\"Dan\", 10);\np.printPerson();\nThe statement\nSystem.out.println(this);\nin the printPerson method means \u201cprint the current Person object.\u201d The output should be: Dan 10. Note that System.out.println invokes the toString method of the Person class.\n\nThe deposit method of the BankAccount class can refer to balance as follows:\npublic void deposit(String acctPassword, double amount)\n{\n    this.balance += amount;\n}\nThe use of this is unnecessary in the above example.\n\nConsider a rational number class called Rational, which has two private instance variables:\nprivate int num; //numerator\nprivate int denom; //denominator\nNow consider a constructor for the Rational class:\npublic Rational(int num, int denom)\n{\n    this.num = num;\n    this.denom = denom;\n}\nIt is definitely not a good idea to use the same name for the explicit parameters and the private instance variables. But if you do, you can avoid errors by referring to this.num and this.denom for the current object that is being constructed. (This particular use of this will not be tested on the exam.)\nAll of the numerical data types, like double and int, as well as types char and boolean, are primitive data types. All objects are reference data types. The difference lies in the way they are stored.\nConsider the statements\nint num1 = 3;\nint num2 = num1;\n\nThe variables num1 and num2 can be thought of as memory slots, labeled num1 and num2, respectively\nIf either of the above variables is now changed, the other is not affected. Each has its own memory slot.\nContrast this with the declaration of a reference data type. Recall that an object is created using new:\nDate d = new Date(2, 17, 1948);\nThis declaration creates a reference variable d that refers to a Date object. The value of d is the address in memory of that object\n\nSuppose the following declaration is now made:\nDate birthday = d;\nThis statement creates the reference variable birthday, which contains the same address as d\n\nHaving two references for the same object is known as aliasing. Aliasing can cause unintended problems for the programmer. The statement\nd.changeDate();\nwill automatically change the object referred to by birthday as well. What the programmer probably intended was to create a second object called birthday whose attributes exactly matched those of d. This cannot be accomplished without using new. For example,\nDate birthday = new Date(d.getMonth(), d.getDay(), d.getYear()); The statement d.changeDate() will now leave the birthday object unchanged.\nThe declaration\nBankAccount b;\ndefines a reference b that is uninitialized. (To construct the object that b refers to requires the new operator and a BankAccount constructor.) An uninitialized object variable is called a null reference or null pointer. You can test whether a variable refers to an object or is uninitialized by using the keyword null:\nif (b == null)\nIf a reference is not null, it can be set to null with the statement\nb = null;\nAn attempt to invoke an instance method with a null reference may cause your program to terminate with a NullPointerException. For example,\n\npublic class PersonalFinances\n{\n    BankAccount b; //b is a null reference\n    ...\n    b.withdraw(acctPassword, amt); //throws a NullPointerException\n    ... //if b not constructed with new\n\nIf you fail to initialize a local variable in a method before you use it, you will get a compile-time error. If you make the same mistake with an instance variable of a class, the compiler provides reasonable default values for primitive variables (0 for numbers,\n\nfalse for booleans), and the code may run without error. However, if you don\u2019t initialize reference instance variables in a class, as in the above example, the compiler will set them to null. Any method call for an object of the class that tries to access the null reference will cause a run-time error: The program will terminate with a NullPointerException.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() //default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) //constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() //returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() //returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() //returns year of Date\n\t{\n\t\t...\n\t}\n\n\t\t// Returns String representation of Date as \"m/d/y\", e.g. 4/18/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nWhich of the following will cause an error message?\nI Date d1 = new Date(8, 2, 1947);\nDate d2 = d1;\nII Date d1 = null;\nDate d2 = d1;\nIII Date d = null;\nint x = d.year();\nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: II and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "Every program that you write involves at least one thing that is being created or manipulated by the program. This thing, together with the operations that manipulate it, is called an object.\nConsider, for example, a program that must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. Rules for validity are provided. The object is a four-digit code number. Some of the operations to manipulate the object could be readNumber, getSeparateDigits, testValidity, and writeNumber.\nAny given program can have several different types of objects. For example, a pro gram that maintains a database of all books in a library has at least two objects:\n1. A Book object, with operations like getTitle, isOnShelf, isFiction, and goOutOfPrint.\n2. A ListOfBooks object, with operations like search, addBook, removeBook, and sortByAuthor.\nAn object is characterized by its state and behavior. For example, a book has a state described by its title, author, whether it\u2019s on the shelf, and so on. It also has behavior, like going out of print.\nNotice that an object is an idea, separate from the concrete details of a programming language. It corresponds to some real-world object that is being represented by the program.\nAll object-oriented programming languages have a way to represent an object as a variable in a program. In Java, a variable that represents an object is called an object reference.\nA class is a software blueprint for implementing objects of a given type. An object is a single instance of the class. In a program there will often be several different instances of a given class type.\nThe current state of a given object is maintained in its data fields orinstance variables, provided by the class. The methods of the class provide both the behaviors exhibited by the object and the operations that manipulate the object. Combining an object\u2019s data and methods into a single unit called a class is known as encapsulation.\nHere is the framework for a simple bank account class:\n\npublic class BankAccount {\n    private String password;\n    private double balance;\n    public static final double OVERDRAWN_PENALTY = 20.00;\n\n    // constructors\n    /**\n     * Default constructor.\n     * Constructs bank account with default values.\n     */\n    public BankAccount() {\n        /* implementation code */ }\n\n    /** Constructs bank account with specified password and balance. */\n    public BankAccount(String acctPassword, double acctBalance) {\n        /* implementation code */ }\n\n    // accessor\n    /** @return balance of this account */\n    public double getBalance() {\n        /* implementation code */ }\n\n    // mutators\n    /**\n     * Deposits amount in bank account with given password.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be deposited\n     */\n    public void deposit(String acctPassword, double amount) {\n        /* implementation code */ }\n\n    /**\n     * Withdraws amount from bank account with given password.\n     * Assesses penalty if balance is less than amount.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be withdrawn\n     */\n    public void withdraw(String acctPassword, double amount) {\n        /* implementation code */ }\n}\nThe keyword public preceding the class declaration signals that the class is usable by all client programs. If a class is not public, it can be used only by classes in its own package. In the AP Java subset, all classes are public.\nSimilarly, public methods are accessible to all client programs. Clients, however, are not privy to the class implementation and may not access the private instance variables and private methods of the class. Restriction of access is known as information hiding. In Java, this is implemented by using the keyword private. Private methods and vari ables in a class can be accessed only by methods of that class. Even though Java allows public instance variables, in the AP Java subset all instance variables are private.\nA static variable (class variable) contains a value that is shared by all instances of the class. \u201cStatic\u201d means that memory allocation happens once.\nTypical uses of a static variable are to\n\u2022 keep track of statistics for objects of the class.\n\u2022 accumulate a total.\n\u2022 provide a new identity number for each new object of the class.\nFor example:\n\npublic class Employee\n{\n    private String name;\n    private static int employeeCount = 0; //number of employees\n    public Employee( < parameter list > )\n    {\n        < initialization of private instance variables >\n        employeeCount++; //increment count of all employees\n    }\n\n    ...\n}\n\nNotice that the static variable was initialized outside the constructor and that its value can be changed.\nStatic final variables (constants) in a class cannot be changed. They are often de clared public (see some examples of Math class constants on p. 183). The variable OVERDRAWN_PENALTY is an example in the BankAccount class. Since the variable is public, it can be used in any client method. The keyword static indicates that there is a single value of the variable that applies to the whole class, rather than a new instance for each object of the class. A client method would refer to the vari able as BankAccount.OVERDRAWN_PENALTY. In its own class it is referred to as simply OVERDRAWN_PENALTY.\nSee p. 97 for static methods.\nAll method headers, with the exception of constructors (see below) and static methods (p. 97), look like this:\naccess specifier, return type, method name, parameter list\n\n1. The access specifier tells which other methods can call this method (see Public, Private, and Static on the previous page).\n2. A return type of void signals that the method does not return a value. 3. Items in the parameter list are separated by commas.\nThe implementation of the method directly follows the header, enclosed in a {} block.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() //default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) //constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() //returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() //returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() //returns year of Date\n\t{\n\t\t...\n\t}\n\n\t// Returns String representation of Date as \"m/d/y\", e.g. 4/18/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nA client program creates a Date object as follows:\nDate d = new Date(1, 13, 2002);\nWhich of the following subsequent code segments will cause an error?\nCorrect: int y = d.year;\n\n\nIncorrect: String s = d.toString();\nIncorrect: int x = d.day();\nIncorrect: Date e = d;\nIncorrect: Date e = new Date(1, 13, 2002);END"}
{"prompt": "Every program that you write involves at least one thing that is being created or manipulated by the program. This thing, together with the operations that manipulate it, is called an object.\nConsider, for example, a program that must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. Rules for validity are provided. The object is a four-digit code number. Some of the operations to manipulate the object could be readNumber, getSeparateDigits, testValidity, and writeNumber.\nAny given program can have several different types of objects. For example, a pro gram that maintains a database of all books in a library has at least two objects:\n1. A Book object, with operations like getTitle, isOnShelf, isFiction, and goOutOfPrint.\n2. A ListOfBooks object, with operations like search, addBook, removeBook, and sortByAuthor.\nAn object is characterized by its state and behavior. For example, a book has a state described by its title, author, whether it\u2019s on the shelf, and so on. It also has behavior, like going out of print.\nNotice that an object is an idea, separate from the concrete details of a programming language. It corresponds to some real-world object that is being represented by the program.\nAll object-oriented programming languages have a way to represent an object as a variable in a program. In Java, a variable that represents an object is called an object reference.\nA class is a software blueprint for implementing objects of a given type. An object is a single instance of the class. In a program there will often be several different instances of a given class type.\nThe current state of a given object is maintained in its data fields orinstance variables, provided by the class. The methods of the class provide both the behaviors exhibited by the object and the operations that manipulate the object. Combining an object\u2019s data and methods into a single unit called a class is known as encapsulation.\nHere is the framework for a simple bank account class:\n\npublic class BankAccount {\n    private String password;\n    private double balance;\n    public static final double OVERDRAWN_PENALTY = 20.00;\n\n    // constructors\n    /**\n     * Default constructor.\n     * Constructs bank account with default values.\n     */\n    public BankAccount() {\n        /* implementation code */ }\n\n    /** Constructs bank account with specified password and balance. */\n    public BankAccount(String acctPassword, double acctBalance) {\n        /* implementation code */ }\n\n    // accessor\n    /** @return balance of this account */\n    public double getBalance() {\n        /* implementation code */ }\n\n    // mutators\n    /**\n     * Deposits amount in bank account with given password.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be deposited\n     */\n    public void deposit(String acctPassword, double amount) {\n        /* implementation code */ }\n\n    /**\n     * Withdraws amount from bank account with given password.\n     * Assesses penalty if balance is less than amount.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be withdrawn\n     */\n    public void withdraw(String acctPassword, double amount) {\n        /* implementation code */ }\n}\nThe keyword public preceding the class declaration signals that the class is usable by all client programs. If a class is not public, it can be used only by classes in its own package. In the AP Java subset, all classes are public.\nSimilarly, public methods are accessible to all client programs. Clients, however, are not privy to the class implementation and may not access the private instance variables and private methods of the class. Restriction of access is known as information hiding. In Java, this is implemented by using the keyword private. Private methods and vari ables in a class can be accessed only by methods of that class. Even though Java allows public instance variables, in the AP Java subset all instance variables are private.\nA static variable (class variable) contains a value that is shared by all instances of the class. \u201cStatic\u201d means that memory allocation happens once.\nTypical uses of a static variable are to\n\u2022 keep track of statistics for objects of the class.\n\u2022 accumulate a total.\n\u2022 provide a new identity number for each new object of the class.\nFor example:\n\npublic class Employee\n{\n    private String name;\n    private static int employeeCount = 0; //number of employees\n    public Employee( < parameter list > )\n    {\n        < initialization of private instance variables >\n        employeeCount++; //increment count of all employees\n    }\n\n    ...\n}\n\nNotice that the static variable was initialized outside the constructor and that its value can be changed.\nStatic final variables (constants) in a class cannot be changed. They are often de clared public (see some examples of Math class constants on p. 183). The variable OVERDRAWN_PENALTY is an example in the BankAccount class. Since the variable is public, it can be used in any client method. The keyword static indicates that there is a single value of the variable that applies to the whole class, rather than a new instance for each object of the class. A client method would refer to the vari able as BankAccount.OVERDRAWN_PENALTY. In its own class it is referred to as simply OVERDRAWN_PENALTY.\nSee p. 97 for static methods.\nAll method headers, with the exception of constructors (see below) and static methods (p. 97), look like this:\naccess specifier, return type, method name, parameter list\n\n1. The access specifier tells which other methods can call this method (see Public, Private, and Static on the previous page).\n2. A return type of void signals that the method does not return a value. 3. Items in the parameter list are separated by commas.\nThe implementation of the method directly follows the header, enclosed in a {} block.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() //default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) //constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() //returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() //returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() //returns year of Date\n\t{\n\t\t...\n\t}\n\n\t// Returns String representation of Date as \"m/d/y\", e.g. 4/18/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nConsider the implementation of a write() method that is added to the Date class:\n\n/** Write the date in the form m/d/y, for example 2/17/1948. */\npublic void write()\n{\n\t/* implementation code */\n}\nWhich of the following could be used as /* implementation code */?\nI System.out.println(month + \"/\" + day + \"/\" + year);\nII System.out.println(month() + \"/\" + day() + \"/\" + year());\nIII System.out.println(this);\nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: II and III onlyEND"}
{"prompt": "A constructor creates an object of the class. You can recognize a constructor by its name\u2014always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n/** Default constructor.\n* Constructs a bank account with default values. */\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address\u2014we say \u201cb is a reference to the object.\u201d\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n/** Constructor. Constructs a bank account with\n* specified password and balance. */\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n/** @return the balance of this account */\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n        balance += amount;\n}\n/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n    {\n        balance -= amount; //allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() //default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) //constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() //returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() //returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() //returns year of Date\n\t{\n\t\t...\n\t}\n\n\t\t// Returns String representation of Date as \"m/d/y\", e.g. 4/18/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nHere is a client program that uses Date objects:\n\npublic class BirthdayStuff\n{\n\tpublic static Date findBirthdate()\n\t{\n\t\t/* code to get birthDate */\n\t\treturn birthDate;\n\t}\n\tpublic static void main(String[] args)\n\t{\n\t\tDate d = findBirthdate();\n\t\t...\n\t}\n}\n\nWhich of the following is a correct replacement for\n/* code to get birthDate */?\nI System.out.println(\"Enter birthdate: mo, day, yr: \");\nint m = IO.readInt(); //read user input\nint d = IO.readInt(); //read user input\nint y = IO.readInt(); //read user input\nDate birthDate = new Date(m, d, y);\nII System.out.println(\"Enter birthdate: mo, day, yr: \");\nint birthDate.month() = IO.readInt(); //read user input\nint birthDate.day() = IO.readInt(); //read user input\nint birthDate.year() = IO.readInt(); //read user input\nDate birthDate = new Date(birthDate.month(), birthDate.day(), birthDate.year());\nIII System.out.println(\"Enter birthdate: mo, day, yr: \");\nint birthDate.month = IO.readInt(); //read user input\nint birthDate.day = IO.readInt(); //read user input\nint birthDate.year = IO.readInt(); //read user input\nDate birthDate = new Date(birthDate.month, birthDate.day, birthDate.year);\nCorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I and III only\n\nEND"}
{"prompt": "The scope of a variable or method is the region in which that variable or method is visible and can be accessed.\nThe instance variables, static variables, and methods of a class belong to that class\u2019s scope, which extends from the opening brace to the closing brace of the class definition. Within the class all instance variables and methods are accessible and can be referred to simply by name (no dot operator!).\nA local variable is defined inside a method. It can even be defined inside a statement. Its scope extends from the point where it is declared to the end of the block in which its declaration occurs. A block is a piece of code enclosed in a {} pair. When a block is exited, the memory for a local variable is automatically recycled.\nLocal variables take precedence over instance variables with the same name. (Using the same name, however, creates ambiguity for the programmer, leading to errors. You should avoid the practice.)\n\nAn instance method is always called for a particular object. This object is an implicit parameter for the method and is referred to with the keyword this. You are expected to know this vocabulary for the exam.\nIn the implementation of instance methods, all instance variables can be written with the prefix this followed by the dot operator.\n\nExample 1\nIn the method call obj.doSomething(\"Mary\",num), where obj is some class object and doSomething is a method of that class, \"Mary\" and num, the parameters in parentheses, are explicit parameters, whereas obj is an implicit parameter.\nExample 2\nHere\u2019s an example where this is used as a parameter.\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person(String aName, int anAge) {\n        name = aName;\n        age = anAge;\n    }\n\n    /** @return the String form of this person */\n    public String toString() {\n        return name + \" \" + age;\n    }\n\n    public void printPerson() {\n        System.out.println(this);\n    }\n    // Other variables and methods are not shown.\n}\n\nSuppose a client class has these lines of code:\nPerson p = new Person(\"Dan\", 10);\np.printPerson();\nThe statement\nSystem.out.println(this);\nin the printPerson method means \u201cprint the current Person object.\u201d The output should be: Dan 10. Note that System.out.println invokes the toString method of the Person class.\n\nThe deposit method of the BankAccount class can refer to balance as follows:\npublic void deposit(String acctPassword, double amount)\n{\n    this.balance += amount;\n}\nThe use of this is unnecessary in the above example.\n\nConsider a rational number class called Rational, which has two private instance variables:\nprivate int num; //numerator\nprivate int denom; //denominator\nNow consider a constructor for the Rational class:\npublic Rational(int num, int denom)\n{\n    this.num = num;\n    this.denom = denom;\n}\nIt is definitely not a good idea to use the same name for the explicit parameters and the private instance variables. But if you do, you can avoid errors by referring to this.num and this.denom for the current object that is being constructed. (This particular use of this will not be tested on the exam.)\nAll of the numerical data types, like double and int, as well as types char and boolean, are primitive data types. All objects are reference data types. The difference lies in the way they are stored.\nConsider the statements\nint num1 = 3;\nint num2 = num1;\n\nThe variables num1 and num2 can be thought of as memory slots, labeled num1 and num2, respectively\nIf either of the above variables is now changed, the other is not affected. Each has its own memory slot.\nContrast this with the declaration of a reference data type. Recall that an object is created using new:\nDate d = new Date(2, 17, 1948);\nThis declaration creates a reference variable d that refers to a Date object. The value of d is the address in memory of that object\n\nSuppose the following declaration is now made:\nDate birthday = d;\nThis statement creates the reference variable birthday, which contains the same address as d\n\nHaving two references for the same object is known as aliasing. Aliasing can cause unintended problems for the programmer. The statement\nd.changeDate();\nwill automatically change the object referred to by birthday as well. What the programmer probably intended was to create a second object called birthday whose attributes exactly matched those of d. This cannot be accomplished without using new. For example,\nDate birthday = new Date(d.getMonth(), d.getDay(), d.getYear()); The statement d.changeDate() will now leave the birthday object unchanged.\nThe declaration\nBankAccount b;\ndefines a reference b that is uninitialized. (To construct the object that b refers to requires the new operator and a BankAccount constructor.) An uninitialized object variable is called a null reference or null pointer. You can test whether a variable refers to an object or is uninitialized by using the keyword null:\nif (b == null)\nIf a reference is not null, it can be set to null with the statement\nb = null;\nAn attempt to invoke an instance method with a null reference may cause your program to terminate with a NullPointerException. For example,\n\npublic class PersonalFinances\n{\n    BankAccount b; //b is a null reference\n    ...\n    b.withdraw(acctPassword, amt); //throws a NullPointerException\n    ... //if b not constructed with new\n\nIf you fail to initialize a local variable in a method before you use it, you will get a compile-time error. If you make the same mistake with an instance variable of a class, the compiler provides reasonable default values for primitive variables (0 for numbers,\n\nfalse for booleans), and the code may run without error. However, if you don\u2019t initialize reference instance variables in a class, as in the above example, the compiler will set them to null. Any method call for an object of the class that tries to access the null reference will cause a run-time error: The program will terminate with a NullPointerException.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() //default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) //constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() //returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() //returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() //returns year of Date\n\t{\n\t\t...\n\t}\n\n\t\t// Returns String representation of Date as \"m/d/y\", e.g. 4/18/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nA method in a client program for the Date class has this declaration:\n\nDate d1 = new Date(mo, da, yr);\n\nwhere mo, da, and yr are previously defined integer variables. The same method now creates a second Date object d2 that is an exact copy of the object d1 refers to. Which of the following code segments will not do this correctly?\nI Date d2 = d1;\nII Date d2 = new Date(mo, da, yr);\nIII Date d2 = new Date(d1.month(), d1.day(), d1.year());\nCorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: II and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "A constructor creates an object of the class. You can recognize a constructor by its name\u2014always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n/** Default constructor.\n* Constructs a bank account with default values. */\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address\u2014we say \u201cb is a reference to the object.\u201d\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n/** Constructor. Constructs a bank account with\n* specified password and balance. */\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n/** @return the balance of this account */\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n        balance += amount;\n}\n/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n    {\n        balance -= amount; //allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() //default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) //constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() //returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() //returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() //returns year of Date\n\t{\n\t\t...\n\t}\n\n\t\t// Returns String representation of Date as \"m/d/y\", e.g. 4/18/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nThe Date class is modified by adding the following mutator method:\n\npublic void addYears(int n) //add n years to date\n\nHere is part of a poorly coded client program that uses the Date class:\n\npublic static void addCentury(Date recent, Date old)\n{\n\told.addYears(100);\n\trecent = old;\n}\n\npublic static void main(String[] args)\n{\n\tDate oldDate = new Date(1, 13, 1900);\n\tDate recentDate = null;\n\taddCentury(recentDate, oldDate);\n\t...\n}\n\nWhich will be true after executing this code?\nCorrect: recentDate is a null reference.\nIncorrect: A NullPointerException is thrown.\nIncorrect: The oldDate object remains unchanged.\nIncorrect: recentDate refers to the same object as oldDate.\nIncorrect: recentDate refers to a separate object whose contents are the same as those of oldDate.\n\nEND"}
{"prompt": "The methods discussed in the preceding sections\u2014constructors, accessors, and mutators\u2014all operate on individual objects of a class. They are called instance methods. A method that performs an operation for the entire class, not its individual objects, is called a static method (sometimes called a class method).\nThe implementation of a static method uses the keyword static in its header. There is no implied object in the code (as there is in an instance method). Thus, if the code tries to call an instance method or invoke a private instance variable for this nonexistent object, a syntax error will occur. A static method can, however, use a static variable in its code. For example, in the Employee example on p. 94, you could add a static method that returns the employeeCount:\n\npublic static int getEmployeeCount()\n{ return employeeCount; }\n\nHere\u2019s an example of a static method that might be used in the BankAccount class. Suppose the class has a static variable intRate, declared as follows:\n\nprivate static double intRate;\n\nThe static method getInterestRate may be as follows:\n\npublic static double getInterestRate()\n{\n    System.out.println(\"Enter interest rate for bank account\");\n    System.out.println(\"Enter in decimal form:\");\n    intRate = IO.readDouble(); // read user input\n    return intRate;\n}\n\nSince the rate that\u2019s read in by this method applies to all bank accounts in the class, not to any particular BankAccount object, it\u2019s appropriate that the method should be static.\nRecall that an instance method is invoked in a client program by using an object variable followed by the dot operator followed by the method name:\n\nBankAccount b = new BankAccount(); //invokes the deposit method for\nb.deposit(acctPassword, amount); //BankAccount object b\n\nA static method, by contrast, is invoked by using the class name with the dot operator: double interestRate = BankAccount.getInterestRate();\nOften a class that contains the main() method is used as a driver program to test other classes. Usually such a class creates no objects of the class. So all the methods in the class must be static. Note that at the start of program execution, no objects exist yet. So the main() method must always be static.\nFor example, here is a program that tests a class for reading integers entered at the keyboard.\n\nimport java.util.*;\n\npublic class GetListTest {\n    /** @return a list of integers from the keyboard */\n    public static List<Integer> getList()\n    {\n        List<Integer> a = new ArrayList<Integer>();\n        < code to read integers into a>\n        return a;\n    }\n\n    /**\n     * Write contents of List a.\n     *\n     * @param a the list\n     */\n    public static void writeList(List<Integer> a) {\n        System.out.println(\"List is : \" + a);\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list = getList();\n        writeList(list);\n    }\n}\n\n1. The calls to writeList(list) and getList() do not need to be preceded by\nGetListTest plus a dot because main is not a client program: It is in the same\nclass as getList and writeList.\n2. If you omit the keyword static from the getList or writeList header, you\nget an error message like the following:\nCan\u2019t make static reference to method getList()\nin class GetListTest\n\nThe compiler has recognized that there was no object variable preceding the\nmethod call, which means that the methods were static and should have been\ndeclared as such.\nOverloaded methods are two or more methods in the same class that have the same name but different parameter lists. For example,\n\npublic class DoOperations\n{\n    public int product(int n) { return n * n; }\n    public double product(double x) { return x * x; }\n    public double product(int x, int y) { return x * y; }\n    ...\n\nThe compiler figures out which method to call by examining the method\u2019s signature. The signature of a method consists of the method\u2019s name and a list of the parameter types. Thus, the signatures of the overloaded product methods are\nproduct(int)\nproduct(double)\nproduct(int, int)\nNote that for overloading purposes, the return type of the method is irrelevant. You can\u2019t have two methods with identical signatures but different return types. The compiler will complain that the method call is ambiguous.\nHaving more than one constructor in the same class is an example of overloading. Overloaded constructors provide a choice of ways to initialize objects of the class.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Here are the private instance variables for a Frog object:\n\npublic class Frog\n{\n\tprivate String species;\n\tprivate int age;\n\tprivate double weight;\n\tprivate Position position; //position (x,y) in pond\n\tprivate boolean amAlive;\n\t...\n\nWhich of the following methods in the Frog class is the best candidate for being a static method?\nCorrect: getPondTemperature //returns temperature of pond\nIncorrect: swim //frog swims to new position in pond\nIncorrect: eat //frog eats and gains weight\nIncorrect: getWeight //returns weight of frog\nIncorrect: die //frog dies with some probability based\n//on frog\u2019s age and pond temperature\n\nEND"}
{"prompt": "The header of a method defines the parameters of that method. For example, consider the withdraw method of the BankAccount class:\npublic class BankAccount\n{ ...\n    public void withdraw(String acctPassword, double amount) ...\n\nThis method has two explicit parameters, acctPassword and amount. These are dummy or formal parameters. Think of them as placeholders for the pair of actual parameters or arguments that will be supplied by a particular method call in a client program. For example,\nDo not make a method call with an object whose value is null.\n\nBankAccount b = new BankAccount(\"TimB\", 1000);\nb.withdraw(\"TimB\", 250);\n\nHere \"TimB\" and 250 are the actual parameters that match up with acctPassword and amount for the withdraw method.\n\n1. The number of arguments in the method call must equal the number of param eters in the method header, and the type of each argument must be compatible with the type of each corresponding parameter.\n2. In addition to its explicit parameters, the withdraw method has an implicit parameter, this, the BankAccount from which money will be withdrawn. In the method call\nb.withdraw(\"TimB\", 250);\nthe actual parameter that matches up with this is the object reference b.\n\nParameters are passed by value. For primitive types this means that when a method is called, a new memory slot is allocated for each parameter. The value of each argument is copied into the newly created memory slot corresponding to each parameter.\nDuring execution of the method, the parameters are local to that method. Any changes made to the parameters will not affect the values of the arguments in the calling program. When the method is exited, the local memory slots for the parameters are erased.\nHere\u2019s an example: What will the output be?\n\npublic class ParamTest {\n    public static void foo(int x, double y) {\n        x = 3;\n        y = 2.5;\n    }\n\n    public static void main(String[] args) {\n        int a = 7;\n        double b = 6.5;\n        foo(a, b);\n        System.out.println(a + \" \" + b);\n    }\n}\n\nThe output will be\n7 6.5\nThe arguments a and b remain unchanged, despite the method call!\nThis can be understood by picturing the state of the memory slots during execution of the program.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: What output will be produced by this program?\n\npublic class Mystery\n{\n\tpublic static void strangeMethod(int x, int y)\n\t{\n\t\tx += y;\n\t\ty *= x;\n\t\tSystem.out.println(x + \" \" + y);\n\t}\n\n\tpublic static void main(String[] args)\n\t{\n\t\tint a = 6, b = 3;\n\t\tstrangeMethod(a, b);\n\t\tSystem.out.println(a + \" \" + b);\n\t}\n}\n\nCorrect: 9 27\n6 3\n\n\nIncorrect: 36\n9\nIncorrect: 3 6\n9\nIncorrect: 9 27\n9 27\nIncorrect: 6 3\n9 27END"}
{"prompt": "Every program that you write involves at least one thing that is being created or manipulated by the program. This thing, together with the operations that manipulate it, is called an object.\nConsider, for example, a program that must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. Rules for validity are provided. The object is a four-digit code number. Some of the operations to manipulate the object could be readNumber, getSeparateDigits, testValidity, and writeNumber.\nAny given program can have several different types of objects. For example, a pro gram that maintains a database of all books in a library has at least two objects:\n1. A Book object, with operations like getTitle, isOnShelf, isFiction, and goOutOfPrint.\n2. A ListOfBooks object, with operations like search, addBook, removeBook, and sortByAuthor.\nAn object is characterized by its state and behavior. For example, a book has a state described by its title, author, whether it\u2019s on the shelf, and so on. It also has behavior, like going out of print.\nNotice that an object is an idea, separate from the concrete details of a programming language. It corresponds to some real-world object that is being represented by the program.\nAll object-oriented programming languages have a way to represent an object as a variable in a program. In Java, a variable that represents an object is called an object reference.\nA class is a software blueprint for implementing objects of a given type. An object is a single instance of the class. In a program there will often be several different instances of a given class type.\nThe current state of a given object is maintained in its data fields orinstance variables, provided by the class. The methods of the class provide both the behaviors exhibited by the object and the operations that manipulate the object. Combining an object\u2019s data and methods into a single unit called a class is known as encapsulation.\nHere is the framework for a simple bank account class:\n\npublic class BankAccount {\n    private String password;\n    private double balance;\n    public static final double OVERDRAWN_PENALTY = 20.00;\n\n    // constructors\n    /**\n     * Default constructor.\n     * Constructs bank account with default values.\n     */\n    public BankAccount() {\n        /* implementation code */ }\n\n    /** Constructs bank account with specified password and balance. */\n    public BankAccount(String acctPassword, double acctBalance) {\n        /* implementation code */ }\n\n    // accessor\n    /** @return balance of this account */\n    public double getBalance() {\n        /* implementation code */ }\n\n    // mutators\n    /**\n     * Deposits amount in bank account with given password.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be deposited\n     */\n    public void deposit(String acctPassword, double amount) {\n        /* implementation code */ }\n\n    /**\n     * Withdraws amount from bank account with given password.\n     * Assesses penalty if balance is less than amount.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be withdrawn\n     */\n    public void withdraw(String acctPassword, double amount) {\n        /* implementation code */ }\n}\nThe keyword public preceding the class declaration signals that the class is usable by all client programs. If a class is not public, it can be used only by classes in its own package. In the AP Java subset, all classes are public.\nSimilarly, public methods are accessible to all client programs. Clients, however, are not privy to the class implementation and may not access the private instance variables and private methods of the class. Restriction of access is known as information hiding. In Java, this is implemented by using the keyword private. Private methods and vari ables in a class can be accessed only by methods of that class. Even though Java allows public instance variables, in the AP Java subset all instance variables are private.\nA static variable (class variable) contains a value that is shared by all instances of the class. \u201cStatic\u201d means that memory allocation happens once.\nTypical uses of a static variable are to\n\u2022 keep track of statistics for objects of the class.\n\u2022 accumulate a total.\n\u2022 provide a new identity number for each new object of the class.\nFor example:\n\npublic class Employee\n{\n    private String name;\n    private static int employeeCount = 0; //number of employees\n    public Employee( < parameter list > )\n    {\n        < initialization of private instance variables >\n        employeeCount++; //increment count of all employees\n    }\n\n    ...\n}\n\nNotice that the static variable was initialized outside the constructor and that its value can be changed.\nStatic final variables (constants) in a class cannot be changed. They are often de clared public (see some examples of Math class constants on p. 183). The variable OVERDRAWN_PENALTY is an example in the BankAccount class. Since the variable is public, it can be used in any client method. The keyword static indicates that there is a single value of the variable that applies to the whole class, rather than a new instance for each object of the class. A client method would refer to the vari able as BankAccount.OVERDRAWN_PENALTY. In its own class it is referred to as simply OVERDRAWN_PENALTY.\nSee p. 97 for static methods.\nAll method headers, with the exception of constructors (see below) and static methods (p. 97), look like this:\naccess specifier, return type, method name, parameter list\n\n1. The access specifier tells which other methods can call this method (see Public, Private, and Static on the previous page).\n2. A return type of void signals that the method does not return a value. 3. Items in the parameter list are separated by commas.\nThe implementation of the method directly follows the header, enclosed in a {} block.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the Rational class defined below:\n\npublic class Rational {\n\tprivate int numerator;\n\tprivate int denominator;\n\n\t/** default constructor */\n\tRational() { /* implementation not shown */ }\n\n\t/**\n\t * Constructs a Rational with numerator n and\n\t * denominator 1.\n\t */\n\tRational(int n) { /* implementation not shown */ }\n\n\t/**\n\t * Constructs a Rational with specified numerator and\n\t * denominator.\n\t */\n\tRational(int numer, int denom) { /* implementation not shown */ }\n\n\t/** @return numerator */\n\tint numerator() { /* implementation not shown */ }\n\n\t/** @return denominator */\n\tint denominator() { /* implementation not shown */ }\n\n\t/**\n\t * Returns (this + r). Leaves this unchanged.\n\t *\n\t * @return this rational number plus r\n\t * @param r a rational number to be added to this Rational\n\t */\n\tpublic Rational plus(Rational r) { /* implementation not shown */ }\n\n\t// Similarly for times, minus, divide ...\n\t/** Ensures denominator > 0. */\n\tprivate void fixSigns() { /* implementation not shown */ }\n\n\t/** Ensures lowest terms. */\n\tprivate void reduce() { /* implementation not shown */ }\n}\n\nThe method reduce() is not a public method because\nCorrect: the reduce() method is not intended for use by clients of the Rational class.\nIncorrect: methods whose return type is void cannot be public.\nIncorrect: methods that change this cannot be public.\nIncorrect: the reduce() method is intended for use only by clients of the Rational class.\nIncorrect: the reduce() method uses only the private data fields of the Rational class.\n\nEND"}
{"prompt": "A constructor creates an object of the class. You can recognize a constructor by its name\u2014always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n/** Default constructor.\n* Constructs a bank account with default values. */\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address\u2014we say \u201cb is a reference to the object.\u201d\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n/** Constructor. Constructs a bank account with\n* specified password and balance. */\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n/** @return the balance of this account */\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n        balance += amount;\n}\n/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n    {\n        balance -= amount; //allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the Rational class defined below:\n\npublic class Rational {\n\tprivate int numerator;\n\tprivate int denominator;\n\n\t/** default constructor */\n\tRational() { /* implementation not shown */ }\n\n\t/**\n\t * Constructs a Rational with numerator n and\n\t * denominator 1.\n\t */\n\tRational(int n) { /* implementation not shown */ }\n\n\t/**\n\t * Constructs a Rational with specified numerator and\n\t * denominator.\n\t */\n\tRational(int numer, int denom) { /* implementation not shown */ }\n\n\t/** @return numerator */\n\tint numerator() { /* implementation not shown */ }\n\n\t/** @return denominator */\n\tint denominator() { /* implementation not shown */ }\n\n\t/**\n\t * Returns (this + r). Leaves this unchanged.\n\t *\n\t * @return this rational number plus r\n\t * @param r a rational number to be added to this Rational\n\t */\n\tpublic Rational plus(Rational r) { /* implementation not shown */ }\n\n\t// Similarly for times, minus, divide ...\n\t/** Ensures denominator > 0. */\n\tprivate void fixSigns() { /* implementation not shown */ }\n\n\t/** Ensures lowest terms. */\n\tprivate void reduce() { /* implementation not shown */ }\n}\n\nThe constructors in the Rational class allow initialization of Rational objects in several different ways. Which of the following will cause an error? \nCorrect: Rational r4 = new Rational(3.5);\nIncorrect: Rational r1 = new Rational();\nIncorrect: Rational r2 = r1;\nIncorrect: Rational r3 = new Rational(2,-3);\nIncorrect: Rational r5 = new Rational(10);\n\nEND"}
{"prompt": "A constructor creates an object of the class. You can recognize a constructor by its name\u2014always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n/** Default constructor.\n* Constructs a bank account with default values. */\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address\u2014we say \u201cb is a reference to the object.\u201d\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n/** Constructor. Constructs a bank account with\n* specified password and balance. */\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n/** @return the balance of this account */\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n        balance += amount;\n}\n/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n    {\n        balance -= amount; //allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the Rational class defined below:\n\npublic class Rational {\n\tprivate int numerator;\n\tprivate int denominator;\n\n\t/** default constructor */\n\tRational() { /* implementation not shown */ }\n\n\t/**\n\t * Constructs a Rational with numerator n and\n\t * denominator 1.\n\t */\n\tRational(int n) { /* implementation not shown */ }\n\n\t/**\n\t * Constructs a Rational with specified numerator and\n\t * denominator.\n\t */\n\tRational(int numer, int denom) { /* implementation not shown */ }\n\n\t/** @return numerator */\n\tint numerator() { /* implementation not shown */ }\n\n\t/** @return denominator */\n\tint denominator() { /* implementation not shown */ }\n\n\t/**\n\t * Returns (this + r). Leaves this unchanged.\n\t *\n\t * @return this rational number plus r\n\t * @param r a rational number to be added to this Rational\n\t */\n\tpublic Rational plus(Rational r) { /* implementation not shown */ }\n\n\t// Similarly for times, minus, divide ...\n\t/** Ensures denominator > 0. */\n\tprivate void fixSigns() { /* implementation not shown */ }\n\n\t/** Ensures lowest terms. */\n\tprivate void reduce() { /* implementation not shown */ }\n}\n\nHere is the implementation code for the plus method: \n\n/** Returns (this + r). Leaves this unchanged. \n* @return this rational number plus r \n* @param r a rational number to be added to this Rational \n*/ \npublic Rational plus(Rational r) \n{ \n\tfixSigns(); \n\tr.fixSigns(); \n\tint denom = denominator * r.denominator; \n\tint numer = numerator * r.denominator + r.numerator * denominator; \n\t/* more code */ \n} \n\nWhich of the following is a correct replacement for /* more code */? \nCorrect: Rational rat = new Rational(numer, denom);\nrat.reduce(); \nreturn rat; \n\n\nIncorrect: Rational rat(numer, denom);\nrat.reduce(); \nreturn rat; \nIncorrect: return new Rational(numer, denom);\nIncorrect: reduce();\nRational rat = new Rational(numer, denom); \nreturn rat; \nIncorrect: Rational rat = new Rational(numer, denom);\nRational.reduce(); \nreturn rat; END"}
{"prompt": "A constructor creates an object of the class. You can recognize a constructor by its name\u2014always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n/** Default constructor.\n* Constructs a bank account with default values. */\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address\u2014we say \u201cb is a reference to the object.\u201d\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n/** Constructor. Constructs a bank account with\n* specified password and balance. */\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n/** @return the balance of this account */\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n        balance += amount;\n}\n/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n    {\n        balance -= amount; //allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the Rational class defined below:\n\npublic class Rational {\n\tprivate int numerator;\n\tprivate int denominator;\n\n\t/** default constructor */\n\tRational() { /* implementation not shown */ }\n\n\t/**\n\t * Constructs a Rational with numerator n and\n\t * denominator 1.\n\t */\n\tRational(int n) { /* implementation not shown */ }\n\n\t/**\n\t * Constructs a Rational with specified numerator and\n\t * denominator.\n\t */\n\tRational(int numer, int denom) { /* implementation not shown */ }\n\n\t/** @return numerator */\n\tint numerator() { /* implementation not shown */ }\n\n\t/** @return denominator */\n\tint denominator() { /* implementation not shown */ }\n\n\t/**\n\t * Returns (this + r). Leaves this unchanged.\n\t *\n\t * @return this rational number plus r\n\t * @param r a rational number to be added to this Rational\n\t */\n\tpublic Rational plus(Rational r) { /* implementation not shown */ }\n\n\t// Similarly for times, minus, divide ...\n\t/** Ensures denominator > 0. */\n\tprivate void fixSigns() { /* implementation not shown */ }\n\n\t/** Ensures lowest terms. */\n\tprivate void reduce() { /* implementation not shown */ }\n}\n\nAssume these declarations: \n\nRational a = new Rational(); \nRational r = new Rational(numer, denom); \nint n = value; \n//numer, denom, and value are valid integer values \n\nWhich of the following will cause a compile-time error? \nCorrect: a = n.plus(r);\nIncorrect: r = a.plus(r);\nIncorrect: a = r.plus(new Rational(n));\nIncorrect: r = r.plus(r);\nIncorrect: r = r.plus(new Rational(n));\n\nEND"}
{"prompt": "The scope of a variable or method is the region in which that variable or method is visible and can be accessed.\nThe instance variables, static variables, and methods of a class belong to that class\u2019s scope, which extends from the opening brace to the closing brace of the class definition. Within the class all instance variables and methods are accessible and can be referred to simply by name (no dot operator!).\nA local variable is defined inside a method. It can even be defined inside a statement. Its scope extends from the point where it is declared to the end of the block in which its declaration occurs. A block is a piece of code enclosed in a {} pair. When a block is exited, the memory for a local variable is automatically recycled.\nLocal variables take precedence over instance variables with the same name. (Using the same name, however, creates ambiguity for the programmer, leading to errors. You should avoid the practice.)\n\nAn instance method is always called for a particular object. This object is an implicit parameter for the method and is referred to with the keyword this. You are expected to know this vocabulary for the exam.\nIn the implementation of instance methods, all instance variables can be written with the prefix this followed by the dot operator.\n\nExample 1\nIn the method call obj.doSomething(\"Mary\",num), where obj is some class object and doSomething is a method of that class, \"Mary\" and num, the parameters in parentheses, are explicit parameters, whereas obj is an implicit parameter.\nExample 2\nHere\u2019s an example where this is used as a parameter.\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person(String aName, int anAge) {\n        name = aName;\n        age = anAge;\n    }\n\n    /** @return the String form of this person */\n    public String toString() {\n        return name + \" \" + age;\n    }\n\n    public void printPerson() {\n        System.out.println(this);\n    }\n    // Other variables and methods are not shown.\n}\n\nSuppose a client class has these lines of code:\nPerson p = new Person(\"Dan\", 10);\np.printPerson();\nThe statement\nSystem.out.println(this);\nin the printPerson method means \u201cprint the current Person object.\u201d The output should be: Dan 10. Note that System.out.println invokes the toString method of the Person class.\n\nThe deposit method of the BankAccount class can refer to balance as follows:\npublic void deposit(String acctPassword, double amount)\n{\n    this.balance += amount;\n}\nThe use of this is unnecessary in the above example.\n\nConsider a rational number class called Rational, which has two private instance variables:\nprivate int num; //numerator\nprivate int denom; //denominator\nNow consider a constructor for the Rational class:\npublic Rational(int num, int denom)\n{\n    this.num = num;\n    this.denom = denom;\n}\nIt is definitely not a good idea to use the same name for the explicit parameters and the private instance variables. But if you do, you can avoid errors by referring to this.num and this.denom for the current object that is being constructed. (This particular use of this will not be tested on the exam.)\nAll of the numerical data types, like double and int, as well as types char and boolean, are primitive data types. All objects are reference data types. The difference lies in the way they are stored.\nConsider the statements\nint num1 = 3;\nint num2 = num1;\n\nThe variables num1 and num2 can be thought of as memory slots, labeled num1 and num2, respectively\nIf either of the above variables is now changed, the other is not affected. Each has its own memory slot.\nContrast this with the declaration of a reference data type. Recall that an object is created using new:\nDate d = new Date(2, 17, 1948);\nThis declaration creates a reference variable d that refers to a Date object. The value of d is the address in memory of that object\n\nSuppose the following declaration is now made:\nDate birthday = d;\nThis statement creates the reference variable birthday, which contains the same address as d\n\nHaving two references for the same object is known as aliasing. Aliasing can cause unintended problems for the programmer. The statement\nd.changeDate();\nwill automatically change the object referred to by birthday as well. What the programmer probably intended was to create a second object called birthday whose attributes exactly matched those of d. This cannot be accomplished without using new. For example,\nDate birthday = new Date(d.getMonth(), d.getDay(), d.getYear()); The statement d.changeDate() will now leave the birthday object unchanged.\nThe declaration\nBankAccount b;\ndefines a reference b that is uninitialized. (To construct the object that b refers to requires the new operator and a BankAccount constructor.) An uninitialized object variable is called a null reference or null pointer. You can test whether a variable refers to an object or is uninitialized by using the keyword null:\nif (b == null)\nIf a reference is not null, it can be set to null with the statement\nb = null;\nAn attempt to invoke an instance method with a null reference may cause your program to terminate with a NullPointerException. For example,\n\npublic class PersonalFinances\n{\n    BankAccount b; //b is a null reference\n    ...\n    b.withdraw(acctPassword, amt); //throws a NullPointerException\n    ... //if b not constructed with new\n\nIf you fail to initialize a local variable in a method before you use it, you will get a compile-time error. If you make the same mistake with an instance variable of a class, the compiler provides reasonable default values for primitive variables (0 for numbers,\n\nfalse for booleans), and the code may run without error. However, if you don\u2019t initialize reference instance variables in a class, as in the above example, the compiler will set them to null. Any method call for an object of the class that tries to access the null reference will cause a run-time error: The program will terminate with a NullPointerException.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the Temperature class defined below:\n\npublic class Temperature {\n\tprivate String scale; // valid values are \"F\" or \"C\"\n\tprivate double degrees;\n\n\t/** constructor with specified degrees and scale */\n\tpublic Temperature(double tempDegrees, String tempScale) { /* implementation not shown */ }\n\n\t/**\n\t * Mutator. Converts this Temperature to degrees Fahrenheit.\n\t * Precondition: Temperature is a valid temperature\n\t * in degrees Celsius.\n\t * \n\t * @return this temperature in degrees Fahrenheit\n\t */\n\tpublic Temperature toFahrenheit() { /* implementation not shown */ }\n\n\t/**\n\t * Mutator. Converts this Temperature to degrees Celsius.\n\t * Precondition: Temperature is a valid temperature\n\t * in degrees Fahrenheit.\n\t * \n\t * @return this temperature in degrees Celsius\n\t */\n\tpublic Temperature toCelsius() { /* implementation not shown */ }\n\n\t/**\n\t * Mutator.\n\t * \n\t * @param amt the number of degrees to raise this temperature\n\t * @return this temperature raised by amt degrees\n\t */\n\tpublic Temperature raise(double amt) { /* implementation not shown */ }\n\n\t/**\n\t * Mutator.\n\t * \n\t * @param amt the number of degrees to lower this temperature\n\t * @return this temperature lowered by amt degrees\n\t */\n\tpublic Temperature lower(double amt) { /* implementation not shown */ }\n\n\t/**\n\t * @param tempDegrees the number of degrees\n\t * @param tempScale   the temperature scale\n\t * @return true if tempDegrees is a valid temperature\n\t *         in the given temperature scale, false otherwise\n\t */\n\tpublic static boolean isValidTemp(double tempDegrees,\n\t\t\tString tempScale) { /* implementation not shown */ }\n\t// Other methods are not shown.\n}\n\nA client method contains this code segment: \n\nTemperature t1 = new Temperature(40, \"C\"); \nTemperature t2 = t1; \nTemperature t3 = t2.lower(20); \nTemperature t4 = t1.toFahrenheit(); \n\nWhich statement is true following execution of this segment? \nCorrect: t1, t2, t3, and t4 all represent the identical temperature, in degrees Fahrenheit.\nIncorrect: t1, t2, t3, and t4 all represent the identical temperature, in degrees Celsius.\nIncorrect: t4 represents a Fahrenheit temperature, while t1, t2, and t3 all represent degrees Celsius.\nIncorrect: t1 and t2 refer to the same Temperature object; t3 refers to a Temperature object that is 20 degrees lower than t1 and t2, while t4 refers to an object that is t1 converted to Fahrenheit.\nIncorrect: A NullPointerException was thrown.\n\nEND"}
{"prompt": "A constructor creates an object of the class. You can recognize a constructor by its name\u2014always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n/** Default constructor.\n* Constructs a bank account with default values. */\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address\u2014we say \u201cb is a reference to the object.\u201d\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n/** Constructor. Constructs a bank account with\n* specified password and balance. */\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n/** @return the balance of this account */\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n        balance += amount;\n}\n/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        /* throw an exception */\n    else\n    {\n        balance -= amount; //allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the Temperature class defined below:\n\npublic class Temperature {\n\tprivate String scale; // valid values are \"F\" or \"C\"\n\tprivate double degrees;\n\n\t/** constructor with specified degrees and scale */\n\tpublic Temperature(double tempDegrees, String tempScale) { /* implementation not shown */ }\n\n\t/**\n\t * Mutator. Converts this Temperature to degrees Fahrenheit.\n\t * Precondition: Temperature is a valid temperature\n\t * in degrees Celsius.\n\t * \n\t * @return this temperature in degrees Fahrenheit\n\t */\n\tpublic Temperature toFahrenheit() { /* implementation not shown */ }\n\n\t/**\n\t * Mutator. Converts this Temperature to degrees Celsius.\n\t * Precondition: Temperature is a valid temperature\n\t * in degrees Fahrenheit.\n\t * \n\t * @return this temperature in degrees Celsius\n\t */\n\tpublic Temperature toCelsius() { /* implementation not shown */ }\n\n\t/**\n\t * Mutator.\n\t * \n\t * @param amt the number of degrees to raise this temperature\n\t * @return this temperature raised by amt degrees\n\t */\n\tpublic Temperature raise(double amt) { /* implementation not shown */ }\n\n\t/**\n\t * Mutator.\n\t * \n\t * @param amt the number of degrees to lower this temperature\n\t * @return this temperature lowered by amt degrees\n\t */\n\tpublic Temperature lower(double amt) { /* implementation not shown */ }\n\n\t/**\n\t * @param tempDegrees the number of degrees\n\t * @param tempScale   the temperature scale\n\t * @return true if tempDegrees is a valid temperature\n\t *         in the given temperature scale, false otherwise\n\t */\n\tpublic static boolean isValidTemp(double tempDegrees,\n\t\t\tString tempScale) { /* implementation not shown */ }\n\t// Other methods are not shown.\n}\n\nConsider the following code: \n\npublic class TempTest \n{ \n\tpublic static void main(String[] args) \n\t{ \n\t\tSystem.out.println(\"Enter temperature scale: \"); \n\t\tString tempScale = IO.readString(); //read user input \n\t\tSystem.out.println(\"Enter number of degrees: \"); \n\t\tdouble tempDegrees = IO.readDouble(); //read user input \n\t\t/* code to construct a valid temperature from user input */ \n\t} \n} \n\nWhich is a correct replacement for /* code to construct. . . */? \nI Temperature t = new Temperature(tempDegrees, tempScale); \nif (!t.isValidTemp(tempDegrees,tempScale)) \n/* error message and exit program */ \nII if (isValidTemp(tempDegrees,tempScale)) \nTemperature t = new Temperature(tempDegrees, tempScale); \nelse \n/* error message and exit program */ \nIII if (Temperature.isValidTemp(tempDegrees,tempScale)) \nTemperature t = new Temperature(tempDegrees, tempScale); \nelse \n/* error message and exit program */ \nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: I and III only\n\nEND"}
{"prompt": "The methods discussed in the preceding sections\u2014constructors, accessors, and mutators\u2014all operate on individual objects of a class. They are called instance methods. A method that performs an operation for the entire class, not its individual objects, is called a static method (sometimes called a class method).\nThe implementation of a static method uses the keyword static in its header. There is no implied object in the code (as there is in an instance method). Thus, if the code tries to call an instance method or invoke a private instance variable for this nonexistent object, a syntax error will occur. A static method can, however, use a static variable in its code. For example, in the Employee example on p. 94, you could add a static method that returns the employeeCount:\n\npublic static int getEmployeeCount()\n{ return employeeCount; }\n\nHere\u2019s an example of a static method that might be used in the BankAccount class. Suppose the class has a static variable intRate, declared as follows:\n\nprivate static double intRate;\n\nThe static method getInterestRate may be as follows:\n\npublic static double getInterestRate()\n{\n    System.out.println(\"Enter interest rate for bank account\");\n    System.out.println(\"Enter in decimal form:\");\n    intRate = IO.readDouble(); // read user input\n    return intRate;\n}\n\nSince the rate that\u2019s read in by this method applies to all bank accounts in the class, not to any particular BankAccount object, it\u2019s appropriate that the method should be static.\nRecall that an instance method is invoked in a client program by using an object variable followed by the dot operator followed by the method name:\n\nBankAccount b = new BankAccount(); //invokes the deposit method for\nb.deposit(acctPassword, amount); //BankAccount object b\n\nA static method, by contrast, is invoked by using the class name with the dot operator: double interestRate = BankAccount.getInterestRate();\nOften a class that contains the main() method is used as a driver program to test other classes. Usually such a class creates no objects of the class. So all the methods in the class must be static. Note that at the start of program execution, no objects exist yet. So the main() method must always be static.\nFor example, here is a program that tests a class for reading integers entered at the keyboard.\n\nimport java.util.*;\n\npublic class GetListTest {\n    /** @return a list of integers from the keyboard */\n    public static List<Integer> getList()\n    {\n        List<Integer> a = new ArrayList<Integer>();\n        < code to read integers into a>\n        return a;\n    }\n\n    /**\n     * Write contents of List a.\n     *\n     * @param a the list\n     */\n    public static void writeList(List<Integer> a) {\n        System.out.println(\"List is : \" + a);\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list = getList();\n        writeList(list);\n    }\n}\n\n1. The calls to writeList(list) and getList() do not need to be preceded by\nGetListTest plus a dot because main is not a client program: It is in the same\nclass as getList and writeList.\n2. If you omit the keyword static from the getList or writeList header, you\nget an error message like the following:\nCan\u2019t make static reference to method getList()\nin class GetListTest\n\nThe compiler has recognized that there was no object variable preceding the\nmethod call, which means that the methods were static and should have been\ndeclared as such.\nOverloaded methods are two or more methods in the same class that have the same name but different parameter lists. For example,\n\npublic class DoOperations\n{\n    public int product(int n) { return n * n; }\n    public double product(double x) { return x * x; }\n    public double product(int x, int y) { return x * y; }\n    ...\n\nThe compiler figures out which method to call by examining the method\u2019s signature. The signature of a method consists of the method\u2019s name and a list of the parameter types. Thus, the signatures of the overloaded product methods are\nproduct(int)\nproduct(double)\nproduct(int, int)\nNote that for overloading purposes, the return type of the method is irrelevant. You can\u2019t have two methods with identical signatures but different return types. The compiler will complain that the method call is ambiguous.\nHaving more than one constructor in the same class is an example of overloading. Overloaded constructors provide a choice of ways to initialize objects of the class.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the Temperature class defined below:\n\npublic class Temperature {\n\tprivate String scale; // valid values are \"F\" or \"C\"\n\tprivate double degrees;\n\n\t/** constructor with specified degrees and scale */\n\tpublic Temperature(double tempDegrees, String tempScale) { /* implementation not shown */ }\n\n\t/**\n\t * Mutator. Converts this Temperature to degrees Fahrenheit.\n\t * Precondition: Temperature is a valid temperature\n\t * in degrees Celsius.\n\t * \n\t * @return this temperature in degrees Fahrenheit\n\t */\n\tpublic Temperature toFahrenheit() { /* implementation not shown */ }\n\n\t/**\n\t * Mutator. Converts this Temperature to degrees Celsius.\n\t * Precondition: Temperature is a valid temperature\n\t * in degrees Fahrenheit.\n\t * \n\t * @return this temperature in degrees Celsius\n\t */\n\tpublic Temperature toCelsius() { /* implementation not shown */ }\n\n\t/**\n\t * Mutator.\n\t * \n\t * @param amt the number of degrees to raise this temperature\n\t * @return this temperature raised by amt degrees\n\t */\n\tpublic Temperature raise(double amt) { /* implementation not shown */ }\n\n\t/**\n\t * Mutator.\n\t * \n\t * @param amt the number of degrees to lower this temperature\n\t * @return this temperature lowered by amt degrees\n\t */\n\tpublic Temperature lower(double amt) { /* implementation not shown */ }\n\n\t/**\n\t * @param tempDegrees the number of degrees\n\t * @param tempScale   the temperature scale\n\t * @return true if tempDegrees is a valid temperature\n\t *         in the given temperature scale, false otherwise\n\t */\n\tpublic static boolean isValidTemp(double tempDegrees,\n\t\t\tString tempScale) { /* implementation not shown */ }\n\t// Other methods are not shown.\n}\n\nThe formula to convert degrees Celsius C to Fahrenheit F is F = 1.8C + 32. For example, 30\u25e6 C is equivalent to 86\u25e6 F. An inFahrenheit() accessor method is added to the Temperature class. Here is its implementation: \n/** Precondition: The temperature is a valid temperature \n* in degrees Celsius. \n* Postcondition: \n* - An equivalent temperature in degrees Fahrenheit has been \n* returned. \n* - Original temperature remains unchanged. \n* @return an equivalent temperature in degrees Fahrenheit \n*/ \npublic Temperature inFahrenheit() \n{ \n\tTemperature result; \n\t/* more code */ \n\treturn result; \n} \n\nWhich of the following correctly replaces /* more code */ so that the postcondition is achieved? \nI result = new Temperature(degrees * 1.8 + 32, \"F\"); \nII result = new Temperature(degrees * 1.8, \"F\"); \nresult = result.raise(32); \nIII degrees *= 1.8; \nthis = this.raise(32); \nresult = new Temperature(degrees, \"F\"); \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "The scope of a variable or method is the region in which that variable or method is visible and can be accessed.\nThe instance variables, static variables, and methods of a class belong to that class\u2019s scope, which extends from the opening brace to the closing brace of the class definition. Within the class all instance variables and methods are accessible and can be referred to simply by name (no dot operator!).\nA local variable is defined inside a method. It can even be defined inside a statement. Its scope extends from the point where it is declared to the end of the block in which its declaration occurs. A block is a piece of code enclosed in a {} pair. When a block is exited, the memory for a local variable is automatically recycled.\nLocal variables take precedence over instance variables with the same name. (Using the same name, however, creates ambiguity for the programmer, leading to errors. You should avoid the practice.)\n\nAn instance method is always called for a particular object. This object is an implicit parameter for the method and is referred to with the keyword this. You are expected to know this vocabulary for the exam.\nIn the implementation of instance methods, all instance variables can be written with the prefix this followed by the dot operator.\n\nExample 1\nIn the method call obj.doSomething(\"Mary\",num), where obj is some class object and doSomething is a method of that class, \"Mary\" and num, the parameters in parentheses, are explicit parameters, whereas obj is an implicit parameter.\nExample 2\nHere\u2019s an example where this is used as a parameter.\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person(String aName, int anAge) {\n        name = aName;\n        age = anAge;\n    }\n\n    /** @return the String form of this person */\n    public String toString() {\n        return name + \" \" + age;\n    }\n\n    public void printPerson() {\n        System.out.println(this);\n    }\n    // Other variables and methods are not shown.\n}\n\nSuppose a client class has these lines of code:\nPerson p = new Person(\"Dan\", 10);\np.printPerson();\nThe statement\nSystem.out.println(this);\nin the printPerson method means \u201cprint the current Person object.\u201d The output should be: Dan 10. Note that System.out.println invokes the toString method of the Person class.\n\nThe deposit method of the BankAccount class can refer to balance as follows:\npublic void deposit(String acctPassword, double amount)\n{\n    this.balance += amount;\n}\nThe use of this is unnecessary in the above example.\n\nConsider a rational number class called Rational, which has two private instance variables:\nprivate int num; //numerator\nprivate int denom; //denominator\nNow consider a constructor for the Rational class:\npublic Rational(int num, int denom)\n{\n    this.num = num;\n    this.denom = denom;\n}\nIt is definitely not a good idea to use the same name for the explicit parameters and the private instance variables. But if you do, you can avoid errors by referring to this.num and this.denom for the current object that is being constructed. (This particular use of this will not be tested on the exam.)\nAll of the numerical data types, like double and int, as well as types char and boolean, are primitive data types. All objects are reference data types. The difference lies in the way they are stored.\nConsider the statements\nint num1 = 3;\nint num2 = num1;\n\nThe variables num1 and num2 can be thought of as memory slots, labeled num1 and num2, respectively\nIf either of the above variables is now changed, the other is not affected. Each has its own memory slot.\nContrast this with the declaration of a reference data type. Recall that an object is created using new:\nDate d = new Date(2, 17, 1948);\nThis declaration creates a reference variable d that refers to a Date object. The value of d is the address in memory of that object\n\nSuppose the following declaration is now made:\nDate birthday = d;\nThis statement creates the reference variable birthday, which contains the same address as d\n\nHaving two references for the same object is known as aliasing. Aliasing can cause unintended problems for the programmer. The statement\nd.changeDate();\nwill automatically change the object referred to by birthday as well. What the programmer probably intended was to create a second object called birthday whose attributes exactly matched those of d. This cannot be accomplished without using new. For example,\nDate birthday = new Date(d.getMonth(), d.getDay(), d.getYear()); The statement d.changeDate() will now leave the birthday object unchanged.\nThe declaration\nBankAccount b;\ndefines a reference b that is uninitialized. (To construct the object that b refers to requires the new operator and a BankAccount constructor.) An uninitialized object variable is called a null reference or null pointer. You can test whether a variable refers to an object or is uninitialized by using the keyword null:\nif (b == null)\nIf a reference is not null, it can be set to null with the statement\nb = null;\nAn attempt to invoke an instance method with a null reference may cause your program to terminate with a NullPointerException. For example,\n\npublic class PersonalFinances\n{\n    BankAccount b; //b is a null reference\n    ...\n    b.withdraw(acctPassword, amt); //throws a NullPointerException\n    ... //if b not constructed with new\n\nIf you fail to initialize a local variable in a method before you use it, you will get a compile-time error. If you make the same mistake with an instance variable of a class, the compiler provides reasonable default values for primitive variables (0 for numbers,\n\nfalse for booleans), and the code may run without error. However, if you don\u2019t initialize reference instance variables in a class, as in the above example, the compiler will set them to null. Any method call for an object of the class that tries to access the null reference will cause a run-time error: The program will terminate with a NullPointerException.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider this program: \n\npublic class CountStuff \n{ \n\tpublic static void doSomething() \n\t{ \n\t\tint count = 0; \n\t\t... \n\t\t//code to do something - no screen output produced \n\t\tcount++; \n\t} \n\n\tpublic static void main(String[] args) \n\t{ \n\t\tint count = 0; \n\t\tSystem.out.println(\"How many iterations?\"); \n\t\tint n = IO.readInt(); //read user input \n\t\tfor (int i = 1; i <= n; i++) \n\t\t{ \n\t\t\tdoSomething(); \n\t\t\tSystem.out.println(count); \n\t\t} \n\t} \n} \n\nIf the input value for n is 3, what screen output will this program subsequently produce? \nCorrect: 0\n0 \n0 \nIncorrect: 1\n2 \n3 \nIncorrect: 3\n3 \n3 \nIncorrect: ?\n? \n?where ? is some undefined value. \nIncorrect: No output will be produced.\n\nEND"}
{"prompt": "The scope of a variable or method is the region in which that variable or method is visible and can be accessed.\nThe instance variables, static variables, and methods of a class belong to that class\u2019s scope, which extends from the opening brace to the closing brace of the class definition. Within the class all instance variables and methods are accessible and can be referred to simply by name (no dot operator!).\nA local variable is defined inside a method. It can even be defined inside a statement. Its scope extends from the point where it is declared to the end of the block in which its declaration occurs. A block is a piece of code enclosed in a {} pair. When a block is exited, the memory for a local variable is automatically recycled.\nLocal variables take precedence over instance variables with the same name. (Using the same name, however, creates ambiguity for the programmer, leading to errors. You should avoid the practice.)\n\nAn instance method is always called for a particular object. This object is an implicit parameter for the method and is referred to with the keyword this. You are expected to know this vocabulary for the exam.\nIn the implementation of instance methods, all instance variables can be written with the prefix this followed by the dot operator.\n\nExample 1\nIn the method call obj.doSomething(\"Mary\",num), where obj is some class object and doSomething is a method of that class, \"Mary\" and num, the parameters in parentheses, are explicit parameters, whereas obj is an implicit parameter.\nExample 2\nHere\u2019s an example where this is used as a parameter.\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person(String aName, int anAge) {\n        name = aName;\n        age = anAge;\n    }\n\n    /** @return the String form of this person */\n    public String toString() {\n        return name + \" \" + age;\n    }\n\n    public void printPerson() {\n        System.out.println(this);\n    }\n    // Other variables and methods are not shown.\n}\n\nSuppose a client class has these lines of code:\nPerson p = new Person(\"Dan\", 10);\np.printPerson();\nThe statement\nSystem.out.println(this);\nin the printPerson method means \u201cprint the current Person object.\u201d The output should be: Dan 10. Note that System.out.println invokes the toString method of the Person class.\n\nThe deposit method of the BankAccount class can refer to balance as follows:\npublic void deposit(String acctPassword, double amount)\n{\n    this.balance += amount;\n}\nThe use of this is unnecessary in the above example.\n\nConsider a rational number class called Rational, which has two private instance variables:\nprivate int num; //numerator\nprivate int denom; //denominator\nNow consider a constructor for the Rational class:\npublic Rational(int num, int denom)\n{\n    this.num = num;\n    this.denom = denom;\n}\nIt is definitely not a good idea to use the same name for the explicit parameters and the private instance variables. But if you do, you can avoid errors by referring to this.num and this.denom for the current object that is being constructed. (This particular use of this will not be tested on the exam.)\nAll of the numerical data types, like double and int, as well as types char and boolean, are primitive data types. All objects are reference data types. The difference lies in the way they are stored.\nConsider the statements\nint num1 = 3;\nint num2 = num1;\n\nThe variables num1 and num2 can be thought of as memory slots, labeled num1 and num2, respectively\nIf either of the above variables is now changed, the other is not affected. Each has its own memory slot.\nContrast this with the declaration of a reference data type. Recall that an object is created using new:\nDate d = new Date(2, 17, 1948);\nThis declaration creates a reference variable d that refers to a Date object. The value of d is the address in memory of that object\n\nSuppose the following declaration is now made:\nDate birthday = d;\nThis statement creates the reference variable birthday, which contains the same address as d\n\nHaving two references for the same object is known as aliasing. Aliasing can cause unintended problems for the programmer. The statement\nd.changeDate();\nwill automatically change the object referred to by birthday as well. What the programmer probably intended was to create a second object called birthday whose attributes exactly matched those of d. This cannot be accomplished without using new. For example,\nDate birthday = new Date(d.getMonth(), d.getDay(), d.getYear()); The statement d.changeDate() will now leave the birthday object unchanged.\nThe declaration\nBankAccount b;\ndefines a reference b that is uninitialized. (To construct the object that b refers to requires the new operator and a BankAccount constructor.) An uninitialized object variable is called a null reference or null pointer. You can test whether a variable refers to an object or is uninitialized by using the keyword null:\nif (b == null)\nIf a reference is not null, it can be set to null with the statement\nb = null;\nAn attempt to invoke an instance method with a null reference may cause your program to terminate with a NullPointerException. For example,\n\npublic class PersonalFinances\n{\n    BankAccount b; //b is a null reference\n    ...\n    b.withdraw(acctPassword, amt); //throws a NullPointerException\n    ... //if b not constructed with new\n\nIf you fail to initialize a local variable in a method before you use it, you will get a compile-time error. If you make the same mistake with an instance variable of a class, the compiler provides reasonable default values for primitive variables (0 for numbers,\n\nfalse for booleans), and the code may run without error. However, if you don\u2019t initialize reference instance variables in a class, as in the above example, the compiler will set them to null. Any method call for an object of the class that tries to access the null reference will cause a run-time error: The program will terminate with a NullPointerException.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: This question refers to the following class: \n\npublic class IntObject \n{ \n\tprivate int num; \n\n\tpublic IntObject() //default constructor \n\t{ num = 0; } \n\n\tpublic IntObject(int n) //constructor \n\t{ num = n; } \n\n\tpublic void increment() //increment by 1 \n\t{ num++; } \n} \n\nHere is a client program that uses this class: \n\npublic class IntObjectTest \n{ \n\tpublic static IntObject someMethod(IntObject obj) \n\t{ \n\t\tIntObject ans = obj; \n\t\tans.increment(); \n\t\treturn ans; \n\t} \n\n\tpublic static void main(String[] args) \n\t{ \n\t\tIntObject x = new IntObject(2); \n\t\tIntObject y = new IntObject(7); \n\t\tIntObject a = y; \n\t\tx = someMethod(y); \n\t\ta = someMethod(x); \n\t} \n} \n\nJust before exiting this program, what are the object values of x, y, and a, respectively? \nCorrect: 9, 9, 9\nIncorrect: 2, 9, 9\nIncorrect: 2, 8, 9\nIncorrect: 3, 8, 9\nIncorrect: 7, 8, 9\n\nEND"}
{"prompt": "The scope of a variable or method is the region in which that variable or method is visible and can be accessed.\nThe instance variables, static variables, and methods of a class belong to that class\u2019s scope, which extends from the opening brace to the closing brace of the class definition. Within the class all instance variables and methods are accessible and can be referred to simply by name (no dot operator!).\nA local variable is defined inside a method. It can even be defined inside a statement. Its scope extends from the point where it is declared to the end of the block in which its declaration occurs. A block is a piece of code enclosed in a {} pair. When a block is exited, the memory for a local variable is automatically recycled.\nLocal variables take precedence over instance variables with the same name. (Using the same name, however, creates ambiguity for the programmer, leading to errors. You should avoid the practice.)\n\nAn instance method is always called for a particular object. This object is an implicit parameter for the method and is referred to with the keyword this. You are expected to know this vocabulary for the exam.\nIn the implementation of instance methods, all instance variables can be written with the prefix this followed by the dot operator.\n\nExample 1\nIn the method call obj.doSomething(\"Mary\",num), where obj is some class object and doSomething is a method of that class, \"Mary\" and num, the parameters in parentheses, are explicit parameters, whereas obj is an implicit parameter.\nExample 2\nHere\u2019s an example where this is used as a parameter.\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person(String aName, int anAge) {\n        name = aName;\n        age = anAge;\n    }\n\n    /** @return the String form of this person */\n    public String toString() {\n        return name + \" \" + age;\n    }\n\n    public void printPerson() {\n        System.out.println(this);\n    }\n    // Other variables and methods are not shown.\n}\n\nSuppose a client class has these lines of code:\nPerson p = new Person(\"Dan\", 10);\np.printPerson();\nThe statement\nSystem.out.println(this);\nin the printPerson method means \u201cprint the current Person object.\u201d The output should be: Dan 10. Note that System.out.println invokes the toString method of the Person class.\n\nThe deposit method of the BankAccount class can refer to balance as follows:\npublic void deposit(String acctPassword, double amount)\n{\n    this.balance += amount;\n}\nThe use of this is unnecessary in the above example.\n\nConsider a rational number class called Rational, which has two private instance variables:\nprivate int num; //numerator\nprivate int denom; //denominator\nNow consider a constructor for the Rational class:\npublic Rational(int num, int denom)\n{\n    this.num = num;\n    this.denom = denom;\n}\nIt is definitely not a good idea to use the same name for the explicit parameters and the private instance variables. But if you do, you can avoid errors by referring to this.num and this.denom for the current object that is being constructed. (This particular use of this will not be tested on the exam.)\nAll of the numerical data types, like double and int, as well as types char and boolean, are primitive data types. All objects are reference data types. The difference lies in the way they are stored.\nConsider the statements\nint num1 = 3;\nint num2 = num1;\n\nThe variables num1 and num2 can be thought of as memory slots, labeled num1 and num2, respectively\nIf either of the above variables is now changed, the other is not affected. Each has its own memory slot.\nContrast this with the declaration of a reference data type. Recall that an object is created using new:\nDate d = new Date(2, 17, 1948);\nThis declaration creates a reference variable d that refers to a Date object. The value of d is the address in memory of that object\n\nSuppose the following declaration is now made:\nDate birthday = d;\nThis statement creates the reference variable birthday, which contains the same address as d\n\nHaving two references for the same object is known as aliasing. Aliasing can cause unintended problems for the programmer. The statement\nd.changeDate();\nwill automatically change the object referred to by birthday as well. What the programmer probably intended was to create a second object called birthday whose attributes exactly matched those of d. This cannot be accomplished without using new. For example,\nDate birthday = new Date(d.getMonth(), d.getDay(), d.getYear()); The statement d.changeDate() will now leave the birthday object unchanged.\nThe declaration\nBankAccount b;\ndefines a reference b that is uninitialized. (To construct the object that b refers to requires the new operator and a BankAccount constructor.) An uninitialized object variable is called a null reference or null pointer. You can test whether a variable refers to an object or is uninitialized by using the keyword null:\nif (b == null)\nIf a reference is not null, it can be set to null with the statement\nb = null;\nAn attempt to invoke an instance method with a null reference may cause your program to terminate with a NullPointerException. For example,\n\npublic class PersonalFinances\n{\n    BankAccount b; //b is a null reference\n    ...\n    b.withdraw(acctPassword, amt); //throws a NullPointerException\n    ... //if b not constructed with new\n\nIf you fail to initialize a local variable in a method before you use it, you will get a compile-time error. If you make the same mistake with an instance variable of a class, the compiler provides reasonable default values for primitive variables (0 for numbers,\n\nfalse for booleans), and the code may run without error. However, if you don\u2019t initialize reference instance variables in a class, as in the above example, the compiler will set them to null. Any method call for an object of the class that tries to access the null reference will cause a run-time error: The program will terminate with a NullPointerException.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the following program: \n\npublic class Tester \n{ \n\tpublic void someMethod(int a, int b) \n\t{ \n\t\tint temp = a; \n\t\ta = b; \n\t\tb = temp; \n\t} \n} \n\npublic class TesterMain \n{ \n\tpublic static void main(String[] args) \n\t{ \n\t\tint x = 6, y = 8; \n\t\tTester tester = new Tester(); \n\t\ttester.someMethod(x, y); \n\t} \n} \n\nJust before the end of execution of this program, what are the values of x, y, and temp, respectively? \nCorrect: 6, 8, ?, where ? means undefined\nIncorrect: 6, 8, 6\nIncorrect: 8, 6, 6\nIncorrect: 8, 6, ?, where ? means undefined\nIncorrect: 8, 6, 8END"}
{"prompt": "Students of introductory computer science typically see themselves as programmers. They no sooner have a new programming project in their heads than they\u2019re at the computer, typing madly to get some code up and running. (Is this you?) To succeed as a programmer, however, you have to combine the practical skills of a software engineer with the analytical mindset of a computer scientist. A software engineer oversees the life cycle of software development: initiation of the project, analysis of the specification, and design of the program, as well as implementation, testing, and maintenance of the final product. A computer scientist (among other things!) analyzes the implementation, correctness, and efficiency of algorithms. All these topics are tested on the APCS exam.\nThe Waterfall Model\nThe waterfall model of software development came about in the 1960s in order to bring structure and efficiency into the process of creating large programs.\nThe specification is a written description of the project. Typically it is based on a customer's requirements. The first step in writing a program is to analyze the specification, make sure you understand it, and clarify with the customer anything that is unclear.\nEven for a small-scale program a good design can save programming time and enhance the reliability of the final program. The design is a fairly detailed plan for solving the problem outlined in the specification. It should include all objects that will be used in the solution, the data structures that will implement them, plus a detailed list of the tasks to be performed by the program.\nA good design provides a fairly detailed overall plan at a glance, without including the minutiae of Java code.\nProgram implementation is the coding phase. Design and implementation are discussed in more detail on p. 210.\nTEST DATA\nNot every possible input value can be tested, so a programmer should be diligent in selecting a representative set of test data. Typical values in each part of a domain of the program should be selected, as well as endpoint values and out-of-range values. If only positive input is required, your test data should include a negative value just to check that your program handles it appropriately.\n\nExample\nA program must be written to insert a value into its correct position in this sorted list:\n2 5 9\nTest data should include\n\u2022 A value less than 2\n\u2022 A value between 2 and 5\n\u2022 A value between 5 and 9\n\u2022 A value greater than 9\n\u2022 2, 5, and 9\n\u2022 A negative value\n\nTYPES OF ERRORS (BUGS)\n\u2022 A compile-time error occurs during compilation of the program. The compiler is unable to translate the program into bytecode and prints an appropriate error message. A syntax error is a compile-time error caused by violating the rules of the programming language. Some examples are omitting semicolons or braces, using undeclared identifiers, using keywords inappropriately, having parameters that don\u2019t match in type and number, and invoking a method for an object whose class definition doesn\u2019t contain that method.\n\u2022 A run-time error occurs during execution of the program. The Java run-time environment throws an exception, which means that it stops execution and prints an error message. Typical causes of run-time errors include attempting to divide an integer by zero, using an array index that is out of bounds, attempting to open a file that cannot be found, and so on. An error that causes a program to run forever (\u201cinfinite loop\u201d) can also be regarded as a run-time error. (See also Errors and Exceptions, p. 74.)\n\u2022 An intent or logic error is one that fails to carry out the specification of the program. The program compiles and runs but does not do the job. These are sometimes the hardest types of errors to fix.\n\nROBUSTNESS\nAlways assume that any user of your program is not as smart as you are. You must therefore aim to write a robust program, namely one that\n\u2022 Won\u2019t give inaccurate answers for some input data.\n\u2022 Won\u2019t crash if the input data are invalid.\n\u2022 Won\u2019t allow execution to proceed if invalid data are entered.\nExamples of bad input data include out-of-range numbers, characters instead of numerical data, and a response of \u201cmaybe\u201d when \u201cyes\u201d or \u201cno\u201d was asked for.\nNote that bad input data that invalidates a computation won\u2019t be detected by Java. Your program should include code that catches the error, allows the error to be fixed, and allows program execution to resume.\n\nProgram maintenance involves upgrading the code as circumstances change. New features may be added. New programmers may come on board. To make their task easier, the original program must have clear and precise documentation.\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: A program that reads in a five-digit identification number is to be written. The specification does not state whether zero can be entered as a first digit. The programmer should \nCorrect: check with the writer of the specification whether zero is acceptable as a first digit.\n\n\nIncorrect: write the code to accept zero as a first digit since zero is a valid digit.\nIncorrect: write the code to reject zero as a first digit since five-digit integers do not start with zero.\nIncorrect: eliminate zero as a possibility for any of the digits.\nIncorrect: treat the identification number as a four-digit number if the user enters a number starting with zero.END"}
{"prompt": "Object-oriented programming has been the dominant programming methodology since the mid 1990s. It uses an approach that blurs the lines of the waterfall model. Anal ysis of the problem, development of the design, and pieces of the implementation all overlap and influence one another.\nHere are the steps in object-oriented design:\n\u2022 Identify classes to be written.\n\u2022 Identify behaviors (i.e., methods) for each class.\n\u2022 Determine the relationships between classes.\n\u2022 Write the interface (public method headers) for each class.\n\u2022 Implement the methods.\n\nIdentify the objects in the program by picking out the nouns in the program speci fication. Ignore pronouns and nouns that refer to the user. Select those nouns that seem suitable as classes, the \u201cbig-picture\u201d nouns that describe the major objects in the application. Some of the other nouns may end up as attributes of the classes.\nMany applications have similar object types: a low-level basic component; a collec\ntion of low-level components; a controlling object that puts everything together; and a display object that could be a GUI (graphical user interface) but doesn\u2019t have to be.\n\nExample 1\nWrite a program that maintains an inventory of stock items for a small store.\nNouns to consider: inventory, item, store.\nBasic Object: StockItem\nCollection: Inventory (a list of StockItems)\nController: Store (has an Inventory, uses a StoreDisplay)\nDisplay: StoreDisplay (could be a GUI)\n\nExample 2\nWrite a program that simulates a game of bingo. There should be at least two play\ners, each of whom has a bingo card, and a caller who calls the numbers.\nNouns to consider: game, players, bingo card, caller.\nBasic Objects: BingoCard, Caller\nCollection: Players (each has a BingoCard)\nController: GameMaster (sets up the Players and Caller)\nDisplay: BingoDisplay (shows each player\u2019s card and displays winners, etc.)\n\nExample 3\nWrite a program that creates random bridge deals and displays them in a specified format. (The specification defines a \u201cdeal\u201d as consisting of four hands. It also describes a deck of cards, and shows how each card should be displayed.)\nNouns to consider: deal, hand, format, deck, card.\nBasic Object: Card\nCollection: Deck (has an array of Cards)\nHand (has an array of Cards)\nDeal (has an array of Hands)\nDealer (has a Deck, or several Decks)\nController: Formatter (has a Deal and a TableDisplay)\nDisplay: TableDisplay (could be a GUI)\n\nIdentifying Behaviors\nFind all verbs in the program description that help lead to the solution of the programming task. These are likely behaviors that will probably become the methods of the classes. Now decide which methods belong in which classes. Recall that the process of bundling a group of methods and data fields into a class is called encapsulation.\nThink carefully about who should do what. Do not ask a basic object to perform operations for the group. For example, a StockItem should keep track of its own details (price, description, how many on the shelf, etc.) but should not be required to search for another item. A Card should know its value and suit but should not be responsible for keeping track of how many cards are left in a deck. A Caller in a bingo game should be responsible for keeping track of the numbers called so far and for producing the next number but not for checking whether a player has bingo: That is the job of an individual player (element of Players) and his BingoCard.\nYou will also need to decide which data fields each class will need and which data structures should store them. For example, if an object represents a list of items, consider an array or ArrayList as the data structure.\n\nINHERITANCE RELATIONSHIPS\nLook for classes with common behaviors. This will help identify inheritance relationships. Recall the is-a relationship\u2014if object1 is-a object2, then object2 is a candidate for a superclass.\nCOMPOSITION RELATIONSHIPS\nComposition relationships are defined by the has-a relationship. For example, a Nurse has-a Uniform. Typically, if two classes have a composition relationship, one of them contains an instance variable whose type is the other class.\nNote that a wrapper class always implements a has-a relationship with any objects that it wraps.\nAn excellent way to keep track of the relationships between classes and show the inheritance hierarchy in your programs is with a UML (Unified Modeling Language) diagram. This is a standard graphical scheme used by object-oriented programmers. Although it is not part of the AP subset, on the AP exam you may be expected to interpret simple UML diagrams and inheritance hierarchies.\nHere is a simplified version of the UML rules:\n\u2022 Represent classes with rectangles.\n\u2022 Use angle brackets with the word \u201cabstract\u201d or \u201cinterface\u201d to indicate either an abstract class or interface.\n\u2022 Show the is-a relationship between classes with an open up-arrow.\n\u2022 Show the is-a relationship that involves an interface with an open, dotted up arrow.\n\u2022 Show the has-a relationship with a down arrow or sideways arrow (indicates composition).\n\n\nThe following question asks about a hypothetical program or design choice with multiple options:\n\n###\n\n", "completion": "Question: Refer to the following three program descriptions: \nI Test whether there exists at least one three-digit integer whose value equals the sum of the squares of its digits. \nII Read in a three-digit code number and check if it is valid according to some given formula. \nIII Passwords consist of three digits and three capital letters in any order. Read in a password, and check if there are any repeated characters. \nFor which of the preceding program descriptions would a ThreeDigitNumber class be suitable? \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "For each method in a class, list all of the other classes needed to implement that particular method. These classes are called collaborators. A class that has no collaborators is independent.\nTo implement the classes, often an incremental, bottom-up approach is used. This means that independent classes are fully implemented and tested before being incorporated into the overall project. Typically, these are the basic objects of the program, like StockItem, Card, and BingoCard. Unrelated classes in a programming project can be implemented by different programmers.\nNote that a class can be tested using a dummy Tester class that will be discarded when the methods of the class are working. Constructors, then methods, should be added, and tested, one at a time. A driver class that contains a main method can be used to test the program as you go. The purpose of the driver is to test the class fully before incorporating it as an object in a new class.\nWhen each of the independent classes is working, classes that depend on just one other class are implemented and tested, and so on. This may lead to a working, bare bones version of the project. New features and enhancements can be added later.\nDesign flaws can be corrected at each stage of development. Remember, a design is never set in stone: It simply guides the implementation.\n\nIn a top-down design, the programmer starts with an overview of the program, selecting the highest-level controlling object and the tasks needed. During development of the program, subsidiary classes may be added to simplify existing classes.\nA good programmer avoids chunks of repeated code wherever possible. To this end, if several methods in a class require the same task, like a search or a swap, you should use helper methods. The reduce method in the Rational class on p. 118 is an example of such a method. Also, wherever possible you should enhance the readability of your code by using helper methods to break long methods into smaller tasks. The use of helper methods within a class is known as procedural abstraction and is an example of top-down development within a class. This process of breaking a long method into a sequence of smaller tasks is sometimes called stepwise refinement.\nInstance variables and helper methods are generally declared as private, which prevents client classes from accessing them. This strategy is called information hiding.\nSometimes it makes more sense in the development of a class to test a calling method before testing a method it invokes. A stub is a dummy method that stands in for a method until the actual method has been written and tested. A stub typically has an output statement to show that it was called in the correct place, or it may return some reasonable values if necessary.\nAn algorithm is a precise step-by-step procedure that solves a problem or achieves a goal. Don\u2019t write any code for an algorithm in a method until the steps are completely clear to you.\n\nExample 1\nA program must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. The number is valid if the fourth digit equals the remainder when the sum of the first three digits is divided by seven.\nClasses in the program may include an IDNumber, the four-digit code; Display, which would handle input and output; and IDMain, the driver for the program. The data structure used to implement an IDNumber could be an instance variable of type int, or an instance variable of type String, or four instance variables of type int\u2014one per digit, and so on.\nA top-down design for the program that tests the validity of the number is reflected in the steps of the main method of IDMain:\nCreate Display\nRead in IDNumber\nCheck validity\nPrint message\nEach method in this design is tested before the next method is added to main. If the display will be handled in a GUI (graphical user interface), stepwise refinement of the design might look like this:\nCreate Display\n    Construct a Display\n    Create window panels\n    Set up text fields\n    Add panels and fields to window\nRead in IDNumber\n    Prompt and read\nCheck validity of IDNumber\n    Check input\n        Check characters\n        Check range\n    Separate into digits\n    Check validity property\nPrint message\n    Write number\n    State if valid\n\nNOTE\n1. The IDNumber class, which contains the four-digit code, is responsible for the following operations:\n    Split value into separate digits\n    Check condition for validity\nThe Display class, which contains objects to read and display, must also contain an IDNumber object. It is responsible for the following operations:\n    Set up display\n    Read in code number\n    Display validity message\nCreating these two classes with their data fields (instance variables) and operations (methods) is an example of encapsulation.\n\n2. The Display method readCodeNumber needs private helper methods to check the input: checkCharacters and checkRange. This is an example of procedural abstraction (use of helper methods) and information hiding (making them private).\n3. Initially the programmer had just an IDNumber class and a driver class. The Display class was added as a refinement, when it was realized that handling the input and message display was separate from checking the validity of the IDNumber. This is an example of top-down development (adding an auxiliary class to clarify the code).\n4. The IDNumber class contains no data fields that are objects. It is therefore an in dependent class. The Display class, which contains an IDNumber data member, has a composition relationship with IDNumber (Display has-a IDNumber).\n5. When testing the final program, the programmer should be sure to include each of the following as a user-entered code number: a valid four-digit number, an invalid four-digit number, an n-digit number, where n 6= 4, and a \u201cnumber\u201d that contains a nondigit character. A robust program should be able to deal with all these cases.\n\nExample 2\nA program must create a teacher\u2019s grade book. The program should maintain a class list of students for any number of classes in the teacher\u2019s schedule. A menu should be provided that allows the teacher to\n\u2022 Create a new class of students.\n\u2022 Enter a set of scores for any class.\n\u2022 Correct any data that\u2019s been entered.\n\u2022 Display the record of any student.\n\u2022 Calculate the final average and grade for all students in a class.\n\u2022 Print a class list, with or without grades.\n\u2022 Add a student, delete a student, or transfer a student to another class.\n\u2022 Save all the data in a file.\n\n\nThe following question asks about general programming knowledge:\n\n###\n\n", "completion": "Question: Top-down programming is illustrated by which of the following? \nCorrect: Writing the program in terms of the operations to be performed and then refining these operations by adding more detail\n\n\nIncorrect: Writing a program from top to bottom in Java\nIncorrect: Writing an essay describing how the program will work, without including any Java code\nIncorrect: Using driver programs to test all methods in the order that they\u2019re called in the program\nIncorrect: Writing and testing the lowest level methods first and then combining them to form appropriate abstract operationsEND"}
{"prompt": "For each method in a class, list all of the other classes needed to implement that particular method. These classes are called collaborators. A class that has no collaborators is independent.\nTo implement the classes, often an incremental, bottom-up approach is used. This means that independent classes are fully implemented and tested before being incorporated into the overall project. Typically, these are the basic objects of the program, like StockItem, Card, and BingoCard. Unrelated classes in a programming project can be implemented by different programmers.\nNote that a class can be tested using a dummy Tester class that will be discarded when the methods of the class are working. Constructors, then methods, should be added, and tested, one at a time. A driver class that contains a main method can be used to test the program as you go. The purpose of the driver is to test the class fully before incorporating it as an object in a new class.\nWhen each of the independent classes is working, classes that depend on just one other class are implemented and tested, and so on. This may lead to a working, bare bones version of the project. New features and enhancements can be added later.\nDesign flaws can be corrected at each stage of development. Remember, a design is never set in stone: It simply guides the implementation.\n\nIn a top-down design, the programmer starts with an overview of the program, selecting the highest-level controlling object and the tasks needed. During development of the program, subsidiary classes may be added to simplify existing classes.\nA good programmer avoids chunks of repeated code wherever possible. To this end, if several methods in a class require the same task, like a search or a swap, you should use helper methods. The reduce method in the Rational class on p. 118 is an example of such a method. Also, wherever possible you should enhance the readability of your code by using helper methods to break long methods into smaller tasks. The use of helper methods within a class is known as procedural abstraction and is an example of top-down development within a class. This process of breaking a long method into a sequence of smaller tasks is sometimes called stepwise refinement.\nInstance variables and helper methods are generally declared as private, which prevents client classes from accessing them. This strategy is called information hiding.\nSometimes it makes more sense in the development of a class to test a calling method before testing a method it invokes. A stub is a dummy method that stands in for a method until the actual method has been written and tested. A stub typically has an output statement to show that it was called in the correct place, or it may return some reasonable values if necessary.\nAn algorithm is a precise step-by-step procedure that solves a problem or achieves a goal. Don\u2019t write any code for an algorithm in a method until the steps are completely clear to you.\n\nExample 1\nA program must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. The number is valid if the fourth digit equals the remainder when the sum of the first three digits is divided by seven.\nClasses in the program may include an IDNumber, the four-digit code; Display, which would handle input and output; and IDMain, the driver for the program. The data structure used to implement an IDNumber could be an instance variable of type int, or an instance variable of type String, or four instance variables of type int\u2014one per digit, and so on.\nA top-down design for the program that tests the validity of the number is reflected in the steps of the main method of IDMain:\nCreate Display\nRead in IDNumber\nCheck validity\nPrint message\nEach method in this design is tested before the next method is added to main. If the display will be handled in a GUI (graphical user interface), stepwise refinement of the design might look like this:\nCreate Display\n    Construct a Display\n    Create window panels\n    Set up text fields\n    Add panels and fields to window\nRead in IDNumber\n    Prompt and read\nCheck validity of IDNumber\n    Check input\n        Check characters\n        Check range\n    Separate into digits\n    Check validity property\nPrint message\n    Write number\n    State if valid\n\nNOTE\n1. The IDNumber class, which contains the four-digit code, is responsible for the following operations:\n    Split value into separate digits\n    Check condition for validity\nThe Display class, which contains objects to read and display, must also contain an IDNumber object. It is responsible for the following operations:\n    Set up display\n    Read in code number\n    Display validity message\nCreating these two classes with their data fields (instance variables) and operations (methods) is an example of encapsulation.\n\n2. The Display method readCodeNumber needs private helper methods to check the input: checkCharacters and checkRange. This is an example of procedural abstraction (use of helper methods) and information hiding (making them private).\n3. Initially the programmer had just an IDNumber class and a driver class. The Display class was added as a refinement, when it was realized that handling the input and message display was separate from checking the validity of the IDNumber. This is an example of top-down development (adding an auxiliary class to clarify the code).\n4. The IDNumber class contains no data fields that are objects. It is therefore an in dependent class. The Display class, which contains an IDNumber data member, has a composition relationship with IDNumber (Display has-a IDNumber).\n5. When testing the final program, the programmer should be sure to include each of the following as a user-entered code number: a valid four-digit number, an invalid four-digit number, an n-digit number, where n 6= 4, and a \u201cnumber\u201d that contains a nondigit character. A robust program should be able to deal with all these cases.\n\nExample 2\nA program must create a teacher\u2019s grade book. The program should maintain a class list of students for any number of classes in the teacher\u2019s schedule. A menu should be provided that allows the teacher to\n\u2022 Create a new class of students.\n\u2022 Enter a set of scores for any class.\n\u2022 Correct any data that\u2019s been entered.\n\u2022 Display the record of any student.\n\u2022 Calculate the final average and grade for all students in a class.\n\u2022 Print a class list, with or without grades.\n\u2022 Add a student, delete a student, or transfer a student to another class.\n\u2022 Save all the data in a file.\n\n\nThe following question asks about general programming knowledge with multiple options:\n\n###\n\n", "completion": "Question: Which of the following should influence your choice of a particular algorithm? \nI The run time of the algorithm \nII The memory requirements of the algorithm \nIII The ease with which the logic of the algorithm can be understood \nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and III only\nIncorrect: I and II onlyEND"}
{"prompt": "Use the verbs to identify key methods in the program: simulate<game>, place <ships>, shoot<at position>, call out<position>, respond<hit or miss>, sink <ship>, inform that<ship was sunk>, keep track of<hits or misses>, sink <opponent\u2019s fleet>, win<game>.\nYou need to decide who will do what. There\u2019s no definitive way of implementingthe program, but it seems clear that the GameManager should run the game and declare the winner. Should the GameManager also be in charge of announcing if a ship is sunk? It makes sense because the game manager can see both players\u2019 grids. Each player should keep track of his calls, so that he can make an intelligent next call and also respond \u201chit\u201d or \u201cmiss.\u201d Will each player have a display? Or will the Display have both players? You have to set it up so that a player can\u2019t see his opponent\u2019s FleetGrid, but he can see his own and also a grid showing the state of the calls he has made. Should each player have a list of his ships, so he can keep track of the state of his fleet? And what about each ship in the fleet? Should a ship have a list of its positions, and should it keep track of if it\u2019s hit or sunk?\nSaving and retrieving updated information is crucial to this program. It seems a bit overwhelming. Where should you start? The Ship classes are low-level classes, independent of the players and grids. Start with these and test that you can get accurate information about each ship. In your driver program create an ArrayList<Ship>. Have a loop that prints information about each ship. Polymorphism will take care of getting the correct information about each ship.\nNow try the Grid classes. This is a complicated program where each small piece should be coded and tested with simple output. For example, a Grid can be displayed with a two-dimensional array of 0\u2019s and 1\u2019s to show the positions of ships. Other symbols can be used to show what\u2019s been hit and what\u2019s been sunk.\nWhen everything is working with the grids, you could add a Display class that has Grid variables and a display method.\nTry a Player. Give him a list of ships, two grids and a Display.\nThen create a GameManager. Give her two Player variables and be sure she has a playGame method.\nThe program development shown above is an example of bottom-up development.\nProgram Correctness\nTesting that a program works does not prove that the program is correct. After all, you can hardly expect to test programs for every conceivable set of input data. Computer scientists have developed mathematical techniques to prove correctness in certain cases, but these are beyond the scope of the APCS course. Nevertheless, you are expected to be able to make assertions about the state of a program at various points during its execution.\n\nAssertions\nAn assertion is a precise statement about a program at any given point. The idea is that if an assertion is proved to be true, then the program is working correctly at that point.\nAn informal step on the way to writing correct algorithms is to be able to make different kinds of assertions about your code.\n\nPRECONDITION\nThe precondition for any piece of code, whether it is a method, loop, or block, is a statement of what is true immediately before execution of that code.\nPOSTCONDITION\nThe postcondition for a piece of code is a statement of what is true immediately after execution of that code.\n\nEfficiency\nAn efficient algorithm is one that is economical in the use of\n\u2022 CPU time. This refers to the number of machine operations required to carry out the algorithm (arithmetic operations, comparisons, data movements, etc.).\n\u2022 Memory. This refers to the number and complexity of the variables used.\n\nSome factors that affect run-time efficiency include unnecessary tests, excessive movement of data elements, and redundant computations, especially in loops.\nAlways aim for early detection of output conditions: Your sorting algorithm should halt when the list is sorted; your search should stop if the key element has been found. In discussing efficiency of an algorithm, we refer to the best case, worst case, and average case. The best case is a configuration of the data that causes the algorithm to run in the least possible amount of time. The worst case is a configuration that leads to the greatest possible run time. Typical configurations (i.e., not specially chosen data) give the average case. It is possible that best, worst, and average cases don\u2019t differ much in their run times.\nFor example, suppose that a list of distinct random numbers must be searched for a given key value. The algorithm used is a sequential search starting at the beginning of the list. In the best case, the key will be found in the first position examined. In the worst case, it will be in the last position or not in the list at all. On average, the key will be somewhere in the middle of the list.\n\n\nThe following question asks about a hypothetical program or design choice with multiple options:\n\n###\n\n", "completion": "Question: A list of numbers is stored in a sorted array. It is required that the list be maintained in sorted order. This requirement leads to inefficient execution for which of the following processes? \nI Summing the five smallest numbers in the list \nII Finding the maximum value in the list \nIII Inserting and deleting numbers \nCorrect: III only\nIncorrect: I only\nIncorrect: II and III only\nIncorrect: I and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "Students of introductory computer science typically see themselves as programmers. They no sooner have a new programming project in their heads than they\u2019re at the computer, typing madly to get some code up and running. (Is this you?) To succeed as a programmer, however, you have to combine the practical skills of a software engineer with the analytical mindset of a computer scientist. A software engineer oversees the life cycle of software development: initiation of the project, analysis of the specification, and design of the program, as well as implementation, testing, and maintenance of the final product. A computer scientist (among other things!) analyzes the implementation, correctness, and efficiency of algorithms. All these topics are tested on the APCS exam.\nThe Waterfall Model\nThe waterfall model of software development came about in the 1960s in order to bring structure and efficiency into the process of creating large programs.\nThe specification is a written description of the project. Typically it is based on a customer's requirements. The first step in writing a program is to analyze the specification, make sure you understand it, and clarify with the customer anything that is unclear.\nEven for a small-scale program a good design can save programming time and enhance the reliability of the final program. The design is a fairly detailed plan for solving the problem outlined in the specification. It should include all objects that will be used in the solution, the data structures that will implement them, plus a detailed list of the tasks to be performed by the program.\nA good design provides a fairly detailed overall plan at a glance, without including the minutiae of Java code.\nProgram implementation is the coding phase. Design and implementation are discussed in more detail on p. 210.\nTEST DATA\nNot every possible input value can be tested, so a programmer should be diligent in selecting a representative set of test data. Typical values in each part of a domain of the program should be selected, as well as endpoint values and out-of-range values. If only positive input is required, your test data should include a negative value just to check that your program handles it appropriately.\n\nExample\nA program must be written to insert a value into its correct position in this sorted list:\n2 5 9\nTest data should include\n\u2022 A value less than 2\n\u2022 A value between 2 and 5\n\u2022 A value between 5 and 9\n\u2022 A value greater than 9\n\u2022 2, 5, and 9\n\u2022 A negative value\n\nTYPES OF ERRORS (BUGS)\n\u2022 A compile-time error occurs during compilation of the program. The compiler is unable to translate the program into bytecode and prints an appropriate error message. A syntax error is a compile-time error caused by violating the rules of the programming language. Some examples are omitting semicolons or braces, using undeclared identifiers, using keywords inappropriately, having parameters that don\u2019t match in type and number, and invoking a method for an object whose class definition doesn\u2019t contain that method.\n\u2022 A run-time error occurs during execution of the program. The Java run-time environment throws an exception, which means that it stops execution and prints an error message. Typical causes of run-time errors include attempting to divide an integer by zero, using an array index that is out of bounds, attempting to open a file that cannot be found, and so on. An error that causes a program to run forever (\u201cinfinite loop\u201d) can also be regarded as a run-time error. (See also Errors and Exceptions, p. 74.)\n\u2022 An intent or logic error is one that fails to carry out the specification of the program. The program compiles and runs but does not do the job. These are sometimes the hardest types of errors to fix.\n\nROBUSTNESS\nAlways assume that any user of your program is not as smart as you are. You must therefore aim to write a robust program, namely one that\n\u2022 Won\u2019t give inaccurate answers for some input data.\n\u2022 Won\u2019t crash if the input data are invalid.\n\u2022 Won\u2019t allow execution to proceed if invalid data are entered.\nExamples of bad input data include out-of-range numbers, characters instead of numerical data, and a response of \u201cmaybe\u201d when \u201cyes\u201d or \u201cno\u201d was asked for.\nNote that bad input data that invalidates a computation won\u2019t be detected by Java. Your program should include code that catches the error, allows the error to be fixed, and allows program execution to resume.\n\nProgram maintenance involves upgrading the code as circumstances change. New features may be added. New programmers may come on board. To make their task easier, the original program must have clear and precise documentation.\n\n\nThe following question asks about general programming knowledge:\n\n###\n\n", "completion": "Question: Which of the following is not necessarily a feature of a robust program? \nCorrect: Will run on any computer without modification\nIncorrect: Does not allow execution to proceed with invalid data\nIncorrect: Uses algorithms that give correct answers for extreme data values\nIncorrect: Will not allow division by zero\nIncorrect: Will anticipate the types of errors that users of the program may make\n\nEND"}
{"prompt": "Students of introductory computer science typically see themselves as programmers. They no sooner have a new programming project in their heads than they\u2019re at the computer, typing madly to get some code up and running. (Is this you?) To succeed as a programmer, however, you have to combine the practical skills of a software engineer with the analytical mindset of a computer scientist. A software engineer oversees the life cycle of software development: initiation of the project, analysis of the specification, and design of the program, as well as implementation, testing, and maintenance of the final product. A computer scientist (among other things!) analyzes the implementation, correctness, and efficiency of algorithms. All these topics are tested on the APCS exam.\nThe Waterfall Model\nThe waterfall model of software development came about in the 1960s in order to bring structure and efficiency into the process of creating large programs.\nThe specification is a written description of the project. Typically it is based on a customer's requirements. The first step in writing a program is to analyze the specification, make sure you understand it, and clarify with the customer anything that is unclear.\nEven for a small-scale program a good design can save programming time and enhance the reliability of the final program. The design is a fairly detailed plan for solving the problem outlined in the specification. It should include all objects that will be used in the solution, the data structures that will implement them, plus a detailed list of the tasks to be performed by the program.\nA good design provides a fairly detailed overall plan at a glance, without including the minutiae of Java code.\nProgram implementation is the coding phase. Design and implementation are discussed in more detail on p. 210.\nTEST DATA\nNot every possible input value can be tested, so a programmer should be diligent in selecting a representative set of test data. Typical values in each part of a domain of the program should be selected, as well as endpoint values and out-of-range values. If only positive input is required, your test data should include a negative value just to check that your program handles it appropriately.\n\nExample\nA program must be written to insert a value into its correct position in this sorted list:\n2 5 9\nTest data should include\n\u2022 A value less than 2\n\u2022 A value between 2 and 5\n\u2022 A value between 5 and 9\n\u2022 A value greater than 9\n\u2022 2, 5, and 9\n\u2022 A negative value\n\nTYPES OF ERRORS (BUGS)\n\u2022 A compile-time error occurs during compilation of the program. The compiler is unable to translate the program into bytecode and prints an appropriate error message. A syntax error is a compile-time error caused by violating the rules of the programming language. Some examples are omitting semicolons or braces, using undeclared identifiers, using keywords inappropriately, having parameters that don\u2019t match in type and number, and invoking a method for an object whose class definition doesn\u2019t contain that method.\n\u2022 A run-time error occurs during execution of the program. The Java run-time environment throws an exception, which means that it stops execution and prints an error message. Typical causes of run-time errors include attempting to divide an integer by zero, using an array index that is out of bounds, attempting to open a file that cannot be found, and so on. An error that causes a program to run forever (\u201cinfinite loop\u201d) can also be regarded as a run-time error. (See also Errors and Exceptions, p. 74.)\n\u2022 An intent or logic error is one that fails to carry out the specification of the program. The program compiles and runs but does not do the job. These are sometimes the hardest types of errors to fix.\n\nROBUSTNESS\nAlways assume that any user of your program is not as smart as you are. You must therefore aim to write a robust program, namely one that\n\u2022 Won\u2019t give inaccurate answers for some input data.\n\u2022 Won\u2019t crash if the input data are invalid.\n\u2022 Won\u2019t allow execution to proceed if invalid data are entered.\nExamples of bad input data include out-of-range numbers, characters instead of numerical data, and a response of \u201cmaybe\u201d when \u201cyes\u201d or \u201cno\u201d was asked for.\nNote that bad input data that invalidates a computation won\u2019t be detected by Java. Your program should include code that catches the error, allows the error to be fixed, and allows program execution to resume.\n\nProgram maintenance involves upgrading the code as circumstances change. New features may be added. New programmers may come on board. To make their task easier, the original program must have clear and precise documentation.\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: A certain freight company charges its customers for shipping overseas according to this scale: \n$80 per ton for a weight of 10 tons or less \n$40 per ton for each additional ton over 10 tons but not exceeding 25 tons \n$30 per ton for each additional ton over 25 tons \n\nFor example, to ship a weight of 12 tons will cost 10(80) + 2(40) = $880. To ship 26 tons will cost 10(80) + 15(40) + 1(30) = $1430. \nA method takes as parameter an integer that represents a valid shipping weight and outputs the charge for the shipment. Which of the following is the smallest set of input values for shipping weights that will adequately test this method? \nCorrect: 5, 10, 15, 25, 30\nIncorrect: 10, 25\nIncorrect: 5, 15, 30\nIncorrect: 0, 5, 10, 15, 25, 30\nIncorrect: 5, 10, 15, 20, 25, 30\n\nEND"}
{"prompt": "Students of introductory computer science typically see themselves as programmers. They no sooner have a new programming project in their heads than they\u2019re at the computer, typing madly to get some code up and running. (Is this you?) To succeed as a programmer, however, you have to combine the practical skills of a software engineer with the analytical mindset of a computer scientist. A software engineer oversees the life cycle of software development: initiation of the project, analysis of the specification, and design of the program, as well as implementation, testing, and maintenance of the final product. A computer scientist (among other things!) analyzes the implementation, correctness, and efficiency of algorithms. All these topics are tested on the APCS exam.\nThe Waterfall Model\nThe waterfall model of software development came about in the 1960s in order to bring structure and efficiency into the process of creating large programs.\nThe specification is a written description of the project. Typically it is based on a customer's requirements. The first step in writing a program is to analyze the specification, make sure you understand it, and clarify with the customer anything that is unclear.\nEven for a small-scale program a good design can save programming time and enhance the reliability of the final program. The design is a fairly detailed plan for solving the problem outlined in the specification. It should include all objects that will be used in the solution, the data structures that will implement them, plus a detailed list of the tasks to be performed by the program.\nA good design provides a fairly detailed overall plan at a glance, without including the minutiae of Java code.\nProgram implementation is the coding phase. Design and implementation are discussed in more detail on p. 210.\nTEST DATA\nNot every possible input value can be tested, so a programmer should be diligent in selecting a representative set of test data. Typical values in each part of a domain of the program should be selected, as well as endpoint values and out-of-range values. If only positive input is required, your test data should include a negative value just to check that your program handles it appropriately.\n\nExample\nA program must be written to insert a value into its correct position in this sorted list:\n2 5 9\nTest data should include\n\u2022 A value less than 2\n\u2022 A value between 2 and 5\n\u2022 A value between 5 and 9\n\u2022 A value greater than 9\n\u2022 2, 5, and 9\n\u2022 A negative value\n\nTYPES OF ERRORS (BUGS)\n\u2022 A compile-time error occurs during compilation of the program. The compiler is unable to translate the program into bytecode and prints an appropriate error message. A syntax error is a compile-time error caused by violating the rules of the programming language. Some examples are omitting semicolons or braces, using undeclared identifiers, using keywords inappropriately, having parameters that don\u2019t match in type and number, and invoking a method for an object whose class definition doesn\u2019t contain that method.\n\u2022 A run-time error occurs during execution of the program. The Java run-time environment throws an exception, which means that it stops execution and prints an error message. Typical causes of run-time errors include attempting to divide an integer by zero, using an array index that is out of bounds, attempting to open a file that cannot be found, and so on. An error that causes a program to run forever (\u201cinfinite loop\u201d) can also be regarded as a run-time error. (See also Errors and Exceptions, p. 74.)\n\u2022 An intent or logic error is one that fails to carry out the specification of the program. The program compiles and runs but does not do the job. These are sometimes the hardest types of errors to fix.\n\nROBUSTNESS\nAlways assume that any user of your program is not as smart as you are. You must therefore aim to write a robust program, namely one that\n\u2022 Won\u2019t give inaccurate answers for some input data.\n\u2022 Won\u2019t crash if the input data are invalid.\n\u2022 Won\u2019t allow execution to proceed if invalid data are entered.\nExamples of bad input data include out-of-range numbers, characters instead of numerical data, and a response of \u201cmaybe\u201d when \u201cyes\u201d or \u201cno\u201d was asked for.\nNote that bad input data that invalidates a computation won\u2019t be detected by Java. Your program should include code that catches the error, allows the error to be fixed, and allows program execution to resume.\n\nProgram maintenance involves upgrading the code as circumstances change. New features may be added. New programmers may come on board. To make their task easier, the original program must have clear and precise documentation.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: A code segment calculates the mean of values stored in integers n1, n2, n3, and n4 and stores the result in average, which is of type double. What kind of error is caused with this statement? \ndouble average = n1 + n2 + n3 + n4 / (double) 4; \nCorrect: Logic\nIncorrect: Run-time\nIncorrect: Overflow\nIncorrect: Syntax\nIncorrect: Type mismatch\n\nEND"}
{"prompt": "Students of introductory computer science typically see themselves as programmers. They no sooner have a new programming project in their heads than they\u2019re at the computer, typing madly to get some code up and running. (Is this you?) To succeed as a programmer, however, you have to combine the practical skills of a software engineer with the analytical mindset of a computer scientist. A software engineer oversees the life cycle of software development: initiation of the project, analysis of the specification, and design of the program, as well as implementation, testing, and maintenance of the final product. A computer scientist (among other things!) analyzes the implementation, correctness, and efficiency of algorithms. All these topics are tested on the APCS exam.\nThe Waterfall Model\nThe waterfall model of software development came about in the 1960s in order to bring structure and efficiency into the process of creating large programs.\nThe specification is a written description of the project. Typically it is based on a customer's requirements. The first step in writing a program is to analyze the specification, make sure you understand it, and clarify with the customer anything that is unclear.\nEven for a small-scale program a good design can save programming time and enhance the reliability of the final program. The design is a fairly detailed plan for solving the problem outlined in the specification. It should include all objects that will be used in the solution, the data structures that will implement them, plus a detailed list of the tasks to be performed by the program.\nA good design provides a fairly detailed overall plan at a glance, without including the minutiae of Java code.\nProgram implementation is the coding phase. Design and implementation are discussed in more detail on p. 210.\nTEST DATA\nNot every possible input value can be tested, so a programmer should be diligent in selecting a representative set of test data. Typical values in each part of a domain of the program should be selected, as well as endpoint values and out-of-range values. If only positive input is required, your test data should include a negative value just to check that your program handles it appropriately.\n\nExample\nA program must be written to insert a value into its correct position in this sorted list:\n2 5 9\nTest data should include\n\u2022 A value less than 2\n\u2022 A value between 2 and 5\n\u2022 A value between 5 and 9\n\u2022 A value greater than 9\n\u2022 2, 5, and 9\n\u2022 A negative value\n\nTYPES OF ERRORS (BUGS)\n\u2022 A compile-time error occurs during compilation of the program. The compiler is unable to translate the program into bytecode and prints an appropriate error message. A syntax error is a compile-time error caused by violating the rules of the programming language. Some examples are omitting semicolons or braces, using undeclared identifiers, using keywords inappropriately, having parameters that don\u2019t match in type and number, and invoking a method for an object whose class definition doesn\u2019t contain that method.\n\u2022 A run-time error occurs during execution of the program. The Java run-time environment throws an exception, which means that it stops execution and prints an error message. Typical causes of run-time errors include attempting to divide an integer by zero, using an array index that is out of bounds, attempting to open a file that cannot be found, and so on. An error that causes a program to run forever (\u201cinfinite loop\u201d) can also be regarded as a run-time error. (See also Errors and Exceptions, p. 74.)\n\u2022 An intent or logic error is one that fails to carry out the specification of the program. The program compiles and runs but does not do the job. These are sometimes the hardest types of errors to fix.\n\nROBUSTNESS\nAlways assume that any user of your program is not as smart as you are. You must therefore aim to write a robust program, namely one that\n\u2022 Won\u2019t give inaccurate answers for some input data.\n\u2022 Won\u2019t crash if the input data are invalid.\n\u2022 Won\u2019t allow execution to proceed if invalid data are entered.\nExamples of bad input data include out-of-range numbers, characters instead of numerical data, and a response of \u201cmaybe\u201d when \u201cyes\u201d or \u201cno\u201d was asked for.\nNote that bad input data that invalidates a computation won\u2019t be detected by Java. Your program should include code that catches the error, allows the error to be fixed, and allows program execution to resume.\n\nProgram maintenance involves upgrading the code as circumstances change. New features may be added. New programmers may come on board. To make their task easier, the original program must have clear and precise documentation.\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: A program evaluates binary arithmetic expressions that are read from an input file. All of the operands are integers, and the only operators are +, -, *, and /. In writing the program, the programmer forgot to include a test that checks whether the right-hand operand in a division expression equals zero. When will this oversight be detected by the computer? \nCorrect: During evaluation of the expressions\nIncorrect: At compile time\nIncorrect: While editing the program\nIncorrect: As soon as the data from the input file is read\nIncorrect: When at least one incorrect value for the expressions is output\n\nEND"}
{"prompt": "Use the verbs to identify key methods in the program: simulate<game>, place <ships>, shoot<at position>, call out<position>, respond<hit or miss>, sink <ship>, inform that<ship was sunk>, keep track of<hits or misses>, sink <opponent\u2019s fleet>, win<game>.\nYou need to decide who will do what. There\u2019s no definitive way of implementingthe program, but it seems clear that the GameManager should run the game and declare the winner. Should the GameManager also be in charge of announcing if a ship is sunk? It makes sense because the game manager can see both players\u2019 grids. Each player should keep track of his calls, so that he can make an intelligent next call and also respond \u201chit\u201d or \u201cmiss.\u201d Will each player have a display? Or will the Display have both players? You have to set it up so that a player can\u2019t see his opponent\u2019s FleetGrid, but he can see his own and also a grid showing the state of the calls he has made. Should each player have a list of his ships, so he can keep track of the state of his fleet? And what about each ship in the fleet? Should a ship have a list of its positions, and should it keep track of if it\u2019s hit or sunk?\nSaving and retrieving updated information is crucial to this program. It seems a bit overwhelming. Where should you start? The Ship classes are low-level classes, independent of the players and grids. Start with these and test that you can get accurate information about each ship. In your driver program create an ArrayList<Ship>. Have a loop that prints information about each ship. Polymorphism will take care of getting the correct information about each ship.\nNow try the Grid classes. This is a complicated program where each small piece should be coded and tested with simple output. For example, a Grid can be displayed with a two-dimensional array of 0\u2019s and 1\u2019s to show the positions of ships. Other symbols can be used to show what\u2019s been hit and what\u2019s been sunk.\nWhen everything is working with the grids, you could add a Display class that has Grid variables and a display method.\nTry a Player. Give him a list of ships, two grids and a Display.\nThen create a GameManager. Give her two Player variables and be sure she has a playGame method.\nThe program development shown above is an example of bottom-up development.\nProgram Correctness\nTesting that a program works does not prove that the program is correct. After all, you can hardly expect to test programs for every conceivable set of input data. Computer scientists have developed mathematical techniques to prove correctness in certain cases, but these are beyond the scope of the APCS course. Nevertheless, you are expected to be able to make assertions about the state of a program at various points during its execution.\n\nAssertions\nAn assertion is a precise statement about a program at any given point. The idea is that if an assertion is proved to be true, then the program is working correctly at that point.\nAn informal step on the way to writing correct algorithms is to be able to make different kinds of assertions about your code.\n\nPRECONDITION\nThe precondition for any piece of code, whether it is a method, loop, or block, is a statement of what is true immediately before execution of that code.\nPOSTCONDITION\nThe postcondition for a piece of code is a statement of what is true immediately after execution of that code.\n\nEfficiency\nAn efficient algorithm is one that is economical in the use of\n\u2022 CPU time. This refers to the number of machine operations required to carry out the algorithm (arithmetic operations, comparisons, data movements, etc.).\n\u2022 Memory. This refers to the number and complexity of the variables used.\n\nSome factors that affect run-time efficiency include unnecessary tests, excessive movement of data elements, and redundant computations, especially in loops.\nAlways aim for early detection of output conditions: Your sorting algorithm should halt when the list is sorted; your search should stop if the key element has been found. In discussing efficiency of an algorithm, we refer to the best case, worst case, and average case. The best case is a configuration of the data that causes the algorithm to run in the least possible amount of time. The worst case is a configuration that leads to the greatest possible run time. Typical configurations (i.e., not specially chosen data) give the average case. It is possible that best, worst, and average cases don\u2019t differ much in their run times.\nFor example, suppose that a list of distinct random numbers must be searched for a given key value. The algorithm used is a sequential search starting at the beginning of the list. In the best case, the key will be found in the first position examined. In the worst case, it will be in the last position or not in the list at all. On average, the key will be somewhere in the middle of the list.\n\n\nThe following question asks about general programming knowledge:\n\n###\n\n", "completion": "Question: Which best describes the precondition of a method? It is an assertion that \nCorrect: describes precisely the conditions that must be true at the time the method is called.\nIncorrect: initializes the parameters of the method.\nIncorrect: describes the effect of the method on its postcondition.\nIncorrect: explains what the method does.\nIncorrect: states what the initial values of the local variables in the method must be.\n\nEND"}
{"prompt": "Use the verbs to identify key methods in the program: simulate<game>, place <ships>, shoot<at position>, call out<position>, respond<hit or miss>, sink <ship>, inform that<ship was sunk>, keep track of<hits or misses>, sink <opponent\u2019s fleet>, win<game>.\nYou need to decide who will do what. There\u2019s no definitive way of implementingthe program, but it seems clear that the GameManager should run the game and declare the winner. Should the GameManager also be in charge of announcing if a ship is sunk? It makes sense because the game manager can see both players\u2019 grids. Each player should keep track of his calls, so that he can make an intelligent next call and also respond \u201chit\u201d or \u201cmiss.\u201d Will each player have a display? Or will the Display have both players? You have to set it up so that a player can\u2019t see his opponent\u2019s FleetGrid, but he can see his own and also a grid showing the state of the calls he has made. Should each player have a list of his ships, so he can keep track of the state of his fleet? And what about each ship in the fleet? Should a ship have a list of its positions, and should it keep track of if it\u2019s hit or sunk?\nSaving and retrieving updated information is crucial to this program. It seems a bit overwhelming. Where should you start? The Ship classes are low-level classes, independent of the players and grids. Start with these and test that you can get accurate information about each ship. In your driver program create an ArrayList<Ship>. Have a loop that prints information about each ship. Polymorphism will take care of getting the correct information about each ship.\nNow try the Grid classes. This is a complicated program where each small piece should be coded and tested with simple output. For example, a Grid can be displayed with a two-dimensional array of 0\u2019s and 1\u2019s to show the positions of ships. Other symbols can be used to show what\u2019s been hit and what\u2019s been sunk.\nWhen everything is working with the grids, you could add a Display class that has Grid variables and a display method.\nTry a Player. Give him a list of ships, two grids and a Display.\nThen create a GameManager. Give her two Player variables and be sure she has a playGame method.\nThe program development shown above is an example of bottom-up development.\nProgram Correctness\nTesting that a program works does not prove that the program is correct. After all, you can hardly expect to test programs for every conceivable set of input data. Computer scientists have developed mathematical techniques to prove correctness in certain cases, but these are beyond the scope of the APCS course. Nevertheless, you are expected to be able to make assertions about the state of a program at various points during its execution.\n\nAssertions\nAn assertion is a precise statement about a program at any given point. The idea is that if an assertion is proved to be true, then the program is working correctly at that point.\nAn informal step on the way to writing correct algorithms is to be able to make different kinds of assertions about your code.\n\nPRECONDITION\nThe precondition for any piece of code, whether it is a method, loop, or block, is a statement of what is true immediately before execution of that code.\nPOSTCONDITION\nThe postcondition for a piece of code is a statement of what is true immediately after execution of that code.\n\nEfficiency\nAn efficient algorithm is one that is economical in the use of\n\u2022 CPU time. This refers to the number of machine operations required to carry out the algorithm (arithmetic operations, comparisons, data movements, etc.).\n\u2022 Memory. This refers to the number and complexity of the variables used.\n\nSome factors that affect run-time efficiency include unnecessary tests, excessive movement of data elements, and redundant computations, especially in loops.\nAlways aim for early detection of output conditions: Your sorting algorithm should halt when the list is sorted; your search should stop if the key element has been found. In discussing efficiency of an algorithm, we refer to the best case, worst case, and average case. The best case is a configuration of the data that causes the algorithm to run in the least possible amount of time. The worst case is a configuration that leads to the greatest possible run time. Typical configurations (i.e., not specially chosen data) give the average case. It is possible that best, worst, and average cases don\u2019t differ much in their run times.\nFor example, suppose that a list of distinct random numbers must be searched for a given key value. The algorithm used is a sequential search starting at the beginning of the list. In the best case, the key will be found in the first position examined. In the worst case, it will be in the last position or not in the list at all. On average, the key will be somewhere in the middle of the list.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the following code fragment:\n\n/** Precondition: a1, a2, a3 contain 3 distinct integers. \n* Postcondition: max contains the largest of a1, a2, a3. \n*/ \n//first set max equal to larger of a1 and a2 \nif (a1 > a2) \n    max = a1; \nelse \n    max = a2; \n//set max equal to larger of max and a3 \nif (max < a3) \n    max = a3; \n\nFor this algorithm, which of the following initial setups for a1, a2, and a3 will cause \n(1) the least number of computer operations (best case) and \n(2) the greatest number of computer operations (worst case)? \nCorrect: (1) largest value in a1 or a2 (2) largest value in a3\nIncorrect: (1) largest value in a2 or a3 (2) largest value in a1\nIncorrect: (1) smallest value in a1 (2) largest value in a2\nIncorrect: (1) largest value in a2 (2) smallest value in a3\nIncorrect: (1) smallest value in a1 or a2 (2) largest value in a3\n\nEND"}
{"prompt": "Use the verbs to identify key methods in the program: simulate<game>, place <ships>, shoot<at position>, call out<position>, respond<hit or miss>, sink <ship>, inform that<ship was sunk>, keep track of<hits or misses>, sink <opponent\u2019s fleet>, win<game>.\nYou need to decide who will do what. There\u2019s no definitive way of implementingthe program, but it seems clear that the GameManager should run the game and declare the winner. Should the GameManager also be in charge of announcing if a ship is sunk? It makes sense because the game manager can see both players\u2019 grids. Each player should keep track of his calls, so that he can make an intelligent next call and also respond \u201chit\u201d or \u201cmiss.\u201d Will each player have a display? Or will the Display have both players? You have to set it up so that a player can\u2019t see his opponent\u2019s FleetGrid, but he can see his own and also a grid showing the state of the calls he has made. Should each player have a list of his ships, so he can keep track of the state of his fleet? And what about each ship in the fleet? Should a ship have a list of its positions, and should it keep track of if it\u2019s hit or sunk?\nSaving and retrieving updated information is crucial to this program. It seems a bit overwhelming. Where should you start? The Ship classes are low-level classes, independent of the players and grids. Start with these and test that you can get accurate information about each ship. In your driver program create an ArrayList<Ship>. Have a loop that prints information about each ship. Polymorphism will take care of getting the correct information about each ship.\nNow try the Grid classes. This is a complicated program where each small piece should be coded and tested with simple output. For example, a Grid can be displayed with a two-dimensional array of 0\u2019s and 1\u2019s to show the positions of ships. Other symbols can be used to show what\u2019s been hit and what\u2019s been sunk.\nWhen everything is working with the grids, you could add a Display class that has Grid variables and a display method.\nTry a Player. Give him a list of ships, two grids and a Display.\nThen create a GameManager. Give her two Player variables and be sure she has a playGame method.\nThe program development shown above is an example of bottom-up development.\nProgram Correctness\nTesting that a program works does not prove that the program is correct. After all, you can hardly expect to test programs for every conceivable set of input data. Computer scientists have developed mathematical techniques to prove correctness in certain cases, but these are beyond the scope of the APCS course. Nevertheless, you are expected to be able to make assertions about the state of a program at various points during its execution.\n\nAssertions\nAn assertion is a precise statement about a program at any given point. The idea is that if an assertion is proved to be true, then the program is working correctly at that point.\nAn informal step on the way to writing correct algorithms is to be able to make different kinds of assertions about your code.\n\nPRECONDITION\nThe precondition for any piece of code, whether it is a method, loop, or block, is a statement of what is true immediately before execution of that code.\nPOSTCONDITION\nThe postcondition for a piece of code is a statement of what is true immediately after execution of that code.\n\nEfficiency\nAn efficient algorithm is one that is economical in the use of\n\u2022 CPU time. This refers to the number of machine operations required to carry out the algorithm (arithmetic operations, comparisons, data movements, etc.).\n\u2022 Memory. This refers to the number and complexity of the variables used.\n\nSome factors that affect run-time efficiency include unnecessary tests, excessive movement of data elements, and redundant computations, especially in loops.\nAlways aim for early detection of output conditions: Your sorting algorithm should halt when the list is sorted; your search should stop if the key element has been found. In discussing efficiency of an algorithm, we refer to the best case, worst case, and average case. The best case is a configuration of the data that causes the algorithm to run in the least possible amount of time. The worst case is a configuration that leads to the greatest possible run time. Typical configurations (i.e., not specially chosen data) give the average case. It is possible that best, worst, and average cases don\u2019t differ much in their run times.\nFor example, suppose that a list of distinct random numbers must be searched for a given key value. The algorithm used is a sequential search starting at the beginning of the list. In the best case, the key will be found in the first position examined. In the worst case, it will be in the last position or not in the list at all. On average, the key will be somewhere in the middle of the list.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Refer to the following code segment.\n\n/** Compute the mean of integers 1 .. N. \n* N is an integer >= 1 and has been initialized. \n*/ \nint k = 1; \ndouble mean, sum = 1.0; \nwhile (k < N) \n{ \n    /* loop body */ \n} \nmean = sum / N; \n\nWhat is the precondition for the while loop? \nCorrect: N \u2265 1, k = 1, sum = 1.0\nIncorrect: k \u2265 N, sum = 1.0\nIncorrect: sum = 1 + 2 + 3 + ... + k\nIncorrect: k < N, sum = 1.0\nIncorrect: mean = sum / N\n\nEND"}
{"prompt": "Use the verbs to identify key methods in the program: simulate<game>, place <ships>, shoot<at position>, call out<position>, respond<hit or miss>, sink <ship>, inform that<ship was sunk>, keep track of<hits or misses>, sink <opponent\u2019s fleet>, win<game>.\nYou need to decide who will do what. There\u2019s no definitive way of implementingthe program, but it seems clear that the GameManager should run the game and declare the winner. Should the GameManager also be in charge of announcing if a ship is sunk? It makes sense because the game manager can see both players\u2019 grids. Each player should keep track of his calls, so that he can make an intelligent next call and also respond \u201chit\u201d or \u201cmiss.\u201d Will each player have a display? Or will the Display have both players? You have to set it up so that a player can\u2019t see his opponent\u2019s FleetGrid, but he can see his own and also a grid showing the state of the calls he has made. Should each player have a list of his ships, so he can keep track of the state of his fleet? And what about each ship in the fleet? Should a ship have a list of its positions, and should it keep track of if it\u2019s hit or sunk?\nSaving and retrieving updated information is crucial to this program. It seems a bit overwhelming. Where should you start? The Ship classes are low-level classes, independent of the players and grids. Start with these and test that you can get accurate information about each ship. In your driver program create an ArrayList<Ship>. Have a loop that prints information about each ship. Polymorphism will take care of getting the correct information about each ship.\nNow try the Grid classes. This is a complicated program where each small piece should be coded and tested with simple output. For example, a Grid can be displayed with a two-dimensional array of 0\u2019s and 1\u2019s to show the positions of ships. Other symbols can be used to show what\u2019s been hit and what\u2019s been sunk.\nWhen everything is working with the grids, you could add a Display class that has Grid variables and a display method.\nTry a Player. Give him a list of ships, two grids and a Display.\nThen create a GameManager. Give her two Player variables and be sure she has a playGame method.\nThe program development shown above is an example of bottom-up development.\nProgram Correctness\nTesting that a program works does not prove that the program is correct. After all, you can hardly expect to test programs for every conceivable set of input data. Computer scientists have developed mathematical techniques to prove correctness in certain cases, but these are beyond the scope of the APCS course. Nevertheless, you are expected to be able to make assertions about the state of a program at various points during its execution.\n\nAssertions\nAn assertion is a precise statement about a program at any given point. The idea is that if an assertion is proved to be true, then the program is working correctly at that point.\nAn informal step on the way to writing correct algorithms is to be able to make different kinds of assertions about your code.\n\nPRECONDITION\nThe precondition for any piece of code, whether it is a method, loop, or block, is a statement of what is true immediately before execution of that code.\nPOSTCONDITION\nThe postcondition for a piece of code is a statement of what is true immediately after execution of that code.\n\nEfficiency\nAn efficient algorithm is one that is economical in the use of\n\u2022 CPU time. This refers to the number of machine operations required to carry out the algorithm (arithmetic operations, comparisons, data movements, etc.).\n\u2022 Memory. This refers to the number and complexity of the variables used.\n\nSome factors that affect run-time efficiency include unnecessary tests, excessive movement of data elements, and redundant computations, especially in loops.\nAlways aim for early detection of output conditions: Your sorting algorithm should halt when the list is sorted; your search should stop if the key element has been found. In discussing efficiency of an algorithm, we refer to the best case, worst case, and average case. The best case is a configuration of the data that causes the algorithm to run in the least possible amount of time. The worst case is a configuration that leads to the greatest possible run time. Typical configurations (i.e., not specially chosen data) give the average case. It is possible that best, worst, and average cases don\u2019t differ much in their run times.\nFor example, suppose that a list of distinct random numbers must be searched for a given key value. The algorithm used is a sequential search starting at the beginning of the list. In the best case, the key will be found in the first position examined. In the worst case, it will be in the last position or not in the list at all. On average, the key will be somewhere in the middle of the list.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: The sequence of Fibonacci numbers is 1, 1, 2, 3, 5, 8, 13, 21, . . . . The first two Fibonacci numbers are each 1. Each subsequent number is obtained by adding the previous two. Consider this method: \n\n/** Precondition: n >= 1. \n* Postcondition: The nth Fibonacci number has been returned. \n*/ \npublic static int fib(int n) \n{ \n    int prev = 1, next = 1, sum = 1; \n    for (int i = 3; i <= n; i++) \n    { \n        /* assertion */ \n        sum = next + prev; \n        prev = next; \n        next = sum; \n    } \n    return sum; \n} \n\nWhich of the following is a correct /* assertion */ about the loop variable i? \nCorrect: 3 \u2264 i \u2264 n\nIncorrect: 1 \u2264 i \u2264 n\nIncorrect: 0 \u2264 i \u2264 n\nIncorrect: 3 < i \u2264 n\nIncorrect: 3 < i < n+1\n\nEND"}
{"prompt": "Use the verbs to identify key methods in the program: simulate<game>, place <ships>, shoot<at position>, call out<position>, respond<hit or miss>, sink <ship>, inform that<ship was sunk>, keep track of<hits or misses>, sink <opponent\u2019s fleet>, win<game>.\nYou need to decide who will do what. There\u2019s no definitive way of implementingthe program, but it seems clear that the GameManager should run the game and declare the winner. Should the GameManager also be in charge of announcing if a ship is sunk? It makes sense because the game manager can see both players\u2019 grids. Each player should keep track of his calls, so that he can make an intelligent next call and also respond \u201chit\u201d or \u201cmiss.\u201d Will each player have a display? Or will the Display have both players? You have to set it up so that a player can\u2019t see his opponent\u2019s FleetGrid, but he can see his own and also a grid showing the state of the calls he has made. Should each player have a list of his ships, so he can keep track of the state of his fleet? And what about each ship in the fleet? Should a ship have a list of its positions, and should it keep track of if it\u2019s hit or sunk?\nSaving and retrieving updated information is crucial to this program. It seems a bit overwhelming. Where should you start? The Ship classes are low-level classes, independent of the players and grids. Start with these and test that you can get accurate information about each ship. In your driver program create an ArrayList<Ship>. Have a loop that prints information about each ship. Polymorphism will take care of getting the correct information about each ship.\nNow try the Grid classes. This is a complicated program where each small piece should be coded and tested with simple output. For example, a Grid can be displayed with a two-dimensional array of 0\u2019s and 1\u2019s to show the positions of ships. Other symbols can be used to show what\u2019s been hit and what\u2019s been sunk.\nWhen everything is working with the grids, you could add a Display class that has Grid variables and a display method.\nTry a Player. Give him a list of ships, two grids and a Display.\nThen create a GameManager. Give her two Player variables and be sure she has a playGame method.\nThe program development shown above is an example of bottom-up development.\nProgram Correctness\nTesting that a program works does not prove that the program is correct. After all, you can hardly expect to test programs for every conceivable set of input data. Computer scientists have developed mathematical techniques to prove correctness in certain cases, but these are beyond the scope of the APCS course. Nevertheless, you are expected to be able to make assertions about the state of a program at various points during its execution.\n\nAssertions\nAn assertion is a precise statement about a program at any given point. The idea is that if an assertion is proved to be true, then the program is working correctly at that point.\nAn informal step on the way to writing correct algorithms is to be able to make different kinds of assertions about your code.\n\nPRECONDITION\nThe precondition for any piece of code, whether it is a method, loop, or block, is a statement of what is true immediately before execution of that code.\nPOSTCONDITION\nThe postcondition for a piece of code is a statement of what is true immediately after execution of that code.\n\nEfficiency\nAn efficient algorithm is one that is economical in the use of\n\u2022 CPU time. This refers to the number of machine operations required to carry out the algorithm (arithmetic operations, comparisons, data movements, etc.).\n\u2022 Memory. This refers to the number and complexity of the variables used.\n\nSome factors that affect run-time efficiency include unnecessary tests, excessive movement of data elements, and redundant computations, especially in loops.\nAlways aim for early detection of output conditions: Your sorting algorithm should halt when the list is sorted; your search should stop if the key element has been found. In discussing efficiency of an algorithm, we refer to the best case, worst case, and average case. The best case is a configuration of the data that causes the algorithm to run in the least possible amount of time. The worst case is a configuration that leads to the greatest possible run time. Typical configurations (i.e., not specially chosen data) give the average case. It is possible that best, worst, and average cases don\u2019t differ much in their run times.\nFor example, suppose that a list of distinct random numbers must be searched for a given key value. The algorithm used is a sequential search starting at the beginning of the list. In the best case, the key will be found in the first position examined. In the worst case, it will be in the last position or not in the list at all. On average, the key will be somewhere in the middle of the list.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Refer to the following method. \n\n/** Precondition: a and b are initialized integers. */ \npublic static int mystery(int a, int b) \n{ \n    int total = 0, count = 1; \n    while (count <= b) \n    { \n        total += a; \n        count++; \n    } \n    return total; \n} \n\nWhat is the postcondition for method mystery? \nCorrect: total = a * b\nIncorrect: total = a + b\nIncorrect: total = a^b\nIncorrect: total = b^a\nIncorrect: total = a/b\n\nEND"}
{"prompt": "Object-oriented programming has been the dominant programming methodology since the mid 1990s. It uses an approach that blurs the lines of the waterfall model. Anal ysis of the problem, development of the design, and pieces of the implementation all overlap and influence one another.\nHere are the steps in object-oriented design:\n\u2022 Identify classes to be written.\n\u2022 Identify behaviors (i.e., methods) for each class.\n\u2022 Determine the relationships between classes.\n\u2022 Write the interface (public method headers) for each class.\n\u2022 Implement the methods.\n\nIdentify the objects in the program by picking out the nouns in the program speci fication. Ignore pronouns and nouns that refer to the user. Select those nouns that seem suitable as classes, the \u201cbig-picture\u201d nouns that describe the major objects in the application. Some of the other nouns may end up as attributes of the classes.\nMany applications have similar object types: a low-level basic component; a collec\ntion of low-level components; a controlling object that puts everything together; and a display object that could be a GUI (graphical user interface) but doesn\u2019t have to be.\n\nExample 1\nWrite a program that maintains an inventory of stock items for a small store.\nNouns to consider: inventory, item, store.\nBasic Object: StockItem\nCollection: Inventory (a list of StockItems)\nController: Store (has an Inventory, uses a StoreDisplay)\nDisplay: StoreDisplay (could be a GUI)\n\nExample 2\nWrite a program that simulates a game of bingo. There should be at least two play\ners, each of whom has a bingo card, and a caller who calls the numbers.\nNouns to consider: game, players, bingo card, caller.\nBasic Objects: BingoCard, Caller\nCollection: Players (each has a BingoCard)\nController: GameMaster (sets up the Players and Caller)\nDisplay: BingoDisplay (shows each player\u2019s card and displays winners, etc.)\n\nExample 3\nWrite a program that creates random bridge deals and displays them in a specified format. (The specification defines a \u201cdeal\u201d as consisting of four hands. It also describes a deck of cards, and shows how each card should be displayed.)\nNouns to consider: deal, hand, format, deck, card.\nBasic Object: Card\nCollection: Deck (has an array of Cards)\nHand (has an array of Cards)\nDeal (has an array of Hands)\nDealer (has a Deck, or several Decks)\nController: Formatter (has a Deal and a TableDisplay)\nDisplay: TableDisplay (could be a GUI)\n\nIdentifying Behaviors\nFind all verbs in the program description that help lead to the solution of the programming task. These are likely behaviors that will probably become the methods of the classes. Now decide which methods belong in which classes. Recall that the process of bundling a group of methods and data fields into a class is called encapsulation.\nThink carefully about who should do what. Do not ask a basic object to perform operations for the group. For example, a StockItem should keep track of its own details (price, description, how many on the shelf, etc.) but should not be required to search for another item. A Card should know its value and suit but should not be responsible for keeping track of how many cards are left in a deck. A Caller in a bingo game should be responsible for keeping track of the numbers called so far and for producing the next number but not for checking whether a player has bingo: That is the job of an individual player (element of Players) and his BingoCard.\nYou will also need to decide which data fields each class will need and which data structures should store them. For example, if an object represents a list of items, consider an array or ArrayList as the data structure.\n\nINHERITANCE RELATIONSHIPS\nLook for classes with common behaviors. This will help identify inheritance relationships. Recall the is-a relationship\u2014if object1 is-a object2, then object2 is a candidate for a superclass.\nCOMPOSITION RELATIONSHIPS\nComposition relationships are defined by the has-a relationship. For example, a Nurse has-a Uniform. Typically, if two classes have a composition relationship, one of them contains an instance variable whose type is the other class.\nNote that a wrapper class always implements a has-a relationship with any objects that it wraps.\nAn excellent way to keep track of the relationships between classes and show the inheritance hierarchy in your programs is with a UML (Unified Modeling Language) diagram. This is a standard graphical scheme used by object-oriented programmers. Although it is not part of the AP subset, on the AP exam you may be expected to interpret simple UML diagrams and inheritance hierarchies.\nHere is a simplified version of the UML rules:\n\u2022 Represent classes with rectangles.\n\u2022 Use angle brackets with the word \u201cabstract\u201d or \u201cinterface\u201d to indicate either an abstract class or interface.\n\u2022 Show the is-a relationship between classes with an open up-arrow.\n\u2022 Show the is-a relationship that involves an interface with an open, dotted up arrow.\n\u2022 Show the has-a relationship with a down arrow or sideways arrow (indicates composition).\n\n\nThe following question asks about a hypothetical program or design choice with multiple options:\n\n###\n\n", "completion": "Question: A program is to be written that prints an invoice for a small store. A copy of the invoice will be given to the customer and will display \n\u2022 A list of items purchased. \n\u2022 The quantity, unit price, and total price for each item. \n\u2022 The amount due. \nThree candidate classes for this program are Invoice, Item, and ItemList, where an Item is a single item purchased and ItemList is the list of all items purchased. \nWhich class is a reasonable choice to be responsible for the amountDue method, which returns the amount the customer must pay? \nI Item \nII ItemList \nIII Invoice \nCorrect: II and III only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "Object-oriented programming has been the dominant programming methodology since the mid 1990s. It uses an approach that blurs the lines of the waterfall model. Anal ysis of the problem, development of the design, and pieces of the implementation all overlap and influence one another.\nHere are the steps in object-oriented design:\n\u2022 Identify classes to be written.\n\u2022 Identify behaviors (i.e., methods) for each class.\n\u2022 Determine the relationships between classes.\n\u2022 Write the interface (public method headers) for each class.\n\u2022 Implement the methods.\n\nIdentify the objects in the program by picking out the nouns in the program speci fication. Ignore pronouns and nouns that refer to the user. Select those nouns that seem suitable as classes, the \u201cbig-picture\u201d nouns that describe the major objects in the application. Some of the other nouns may end up as attributes of the classes.\nMany applications have similar object types: a low-level basic component; a collec\ntion of low-level components; a controlling object that puts everything together; and a display object that could be a GUI (graphical user interface) but doesn\u2019t have to be.\n\nExample 1\nWrite a program that maintains an inventory of stock items for a small store.\nNouns to consider: inventory, item, store.\nBasic Object: StockItem\nCollection: Inventory (a list of StockItems)\nController: Store (has an Inventory, uses a StoreDisplay)\nDisplay: StoreDisplay (could be a GUI)\n\nExample 2\nWrite a program that simulates a game of bingo. There should be at least two play\ners, each of whom has a bingo card, and a caller who calls the numbers.\nNouns to consider: game, players, bingo card, caller.\nBasic Objects: BingoCard, Caller\nCollection: Players (each has a BingoCard)\nController: GameMaster (sets up the Players and Caller)\nDisplay: BingoDisplay (shows each player\u2019s card and displays winners, etc.)\n\nExample 3\nWrite a program that creates random bridge deals and displays them in a specified format. (The specification defines a \u201cdeal\u201d as consisting of four hands. It also describes a deck of cards, and shows how each card should be displayed.)\nNouns to consider: deal, hand, format, deck, card.\nBasic Object: Card\nCollection: Deck (has an array of Cards)\nHand (has an array of Cards)\nDeal (has an array of Hands)\nDealer (has a Deck, or several Decks)\nController: Formatter (has a Deal and a TableDisplay)\nDisplay: TableDisplay (could be a GUI)\n\nIdentifying Behaviors\nFind all verbs in the program description that help lead to the solution of the programming task. These are likely behaviors that will probably become the methods of the classes. Now decide which methods belong in which classes. Recall that the process of bundling a group of methods and data fields into a class is called encapsulation.\nThink carefully about who should do what. Do not ask a basic object to perform operations for the group. For example, a StockItem should keep track of its own details (price, description, how many on the shelf, etc.) but should not be required to search for another item. A Card should know its value and suit but should not be responsible for keeping track of how many cards are left in a deck. A Caller in a bingo game should be responsible for keeping track of the numbers called so far and for producing the next number but not for checking whether a player has bingo: That is the job of an individual player (element of Players) and his BingoCard.\nYou will also need to decide which data fields each class will need and which data structures should store them. For example, if an object represents a list of items, consider an array or ArrayList as the data structure.\n\nINHERITANCE RELATIONSHIPS\nLook for classes with common behaviors. This will help identify inheritance relationships. Recall the is-a relationship\u2014if object1 is-a object2, then object2 is a candidate for a superclass.\nCOMPOSITION RELATIONSHIPS\nComposition relationships are defined by the has-a relationship. For example, a Nurse has-a Uniform. Typically, if two classes have a composition relationship, one of them contains an instance variable whose type is the other class.\nNote that a wrapper class always implements a has-a relationship with any objects that it wraps.\nAn excellent way to keep track of the relationships between classes and show the inheritance hierarchy in your programs is with a UML (Unified Modeling Language) diagram. This is a standard graphical scheme used by object-oriented programmers. Although it is not part of the AP subset, on the AP exam you may be expected to interpret simple UML diagrams and inheritance hierarchies.\nHere is a simplified version of the UML rules:\n\u2022 Represent classes with rectangles.\n\u2022 Use angle brackets with the word \u201cabstract\u201d or \u201cinterface\u201d to indicate either an abstract class or interface.\n\u2022 Show the is-a relationship between classes with an open up-arrow.\n\u2022 Show the is-a relationship that involves an interface with an open, dotted up arrow.\n\u2022 Show the has-a relationship with a down arrow or sideways arrow (indicates composition).\n\n\nThe following question asks about general programming knowledge:\n\n###\n\n", "completion": "Question: Which is a false statement about classes in object-oriented program design? \nCorrect: If classes C1 and C2 are related such that C1 is-a C2, then C2 has-a C1.\nIncorrect: If a class C1 has an instance variable whose type is another class, C2, then C1 has-a C2.\nIncorrect: If a class C1 is associated with another class, C2, then C1 depends on C2 for its implementation.\nIncorrect: If class C1 is independent, then none of its methods will have parameters that are objects of other classes.\nIncorrect: Classes that have common methods do not necessarily define an inheritance relationship.\n\nEND"}
{"prompt": "Object-oriented programming has been the dominant programming methodology since the mid 1990s. It uses an approach that blurs the lines of the waterfall model. Anal ysis of the problem, development of the design, and pieces of the implementation all overlap and influence one another.\nHere are the steps in object-oriented design:\n\u2022 Identify classes to be written.\n\u2022 Identify behaviors (i.e., methods) for each class.\n\u2022 Determine the relationships between classes.\n\u2022 Write the interface (public method headers) for each class.\n\u2022 Implement the methods.\n\nIdentify the objects in the program by picking out the nouns in the program speci fication. Ignore pronouns and nouns that refer to the user. Select those nouns that seem suitable as classes, the \u201cbig-picture\u201d nouns that describe the major objects in the application. Some of the other nouns may end up as attributes of the classes.\nMany applications have similar object types: a low-level basic component; a collec\ntion of low-level components; a controlling object that puts everything together; and a display object that could be a GUI (graphical user interface) but doesn\u2019t have to be.\n\nExample 1\nWrite a program that maintains an inventory of stock items for a small store.\nNouns to consider: inventory, item, store.\nBasic Object: StockItem\nCollection: Inventory (a list of StockItems)\nController: Store (has an Inventory, uses a StoreDisplay)\nDisplay: StoreDisplay (could be a GUI)\n\nExample 2\nWrite a program that simulates a game of bingo. There should be at least two play\ners, each of whom has a bingo card, and a caller who calls the numbers.\nNouns to consider: game, players, bingo card, caller.\nBasic Objects: BingoCard, Caller\nCollection: Players (each has a BingoCard)\nController: GameMaster (sets up the Players and Caller)\nDisplay: BingoDisplay (shows each player\u2019s card and displays winners, etc.)\n\nExample 3\nWrite a program that creates random bridge deals and displays them in a specified format. (The specification defines a \u201cdeal\u201d as consisting of four hands. It also describes a deck of cards, and shows how each card should be displayed.)\nNouns to consider: deal, hand, format, deck, card.\nBasic Object: Card\nCollection: Deck (has an array of Cards)\nHand (has an array of Cards)\nDeal (has an array of Hands)\nDealer (has a Deck, or several Decks)\nController: Formatter (has a Deal and a TableDisplay)\nDisplay: TableDisplay (could be a GUI)\n\nIdentifying Behaviors\nFind all verbs in the program description that help lead to the solution of the programming task. These are likely behaviors that will probably become the methods of the classes. Now decide which methods belong in which classes. Recall that the process of bundling a group of methods and data fields into a class is called encapsulation.\nThink carefully about who should do what. Do not ask a basic object to perform operations for the group. For example, a StockItem should keep track of its own details (price, description, how many on the shelf, etc.) but should not be required to search for another item. A Card should know its value and suit but should not be responsible for keeping track of how many cards are left in a deck. A Caller in a bingo game should be responsible for keeping track of the numbers called so far and for producing the next number but not for checking whether a player has bingo: That is the job of an individual player (element of Players) and his BingoCard.\nYou will also need to decide which data fields each class will need and which data structures should store them. For example, if an object represents a list of items, consider an array or ArrayList as the data structure.\n\nINHERITANCE RELATIONSHIPS\nLook for classes with common behaviors. This will help identify inheritance relationships. Recall the is-a relationship\u2014if object1 is-a object2, then object2 is a candidate for a superclass.\nCOMPOSITION RELATIONSHIPS\nComposition relationships are defined by the has-a relationship. For example, a Nurse has-a Uniform. Typically, if two classes have a composition relationship, one of them contains an instance variable whose type is the other class.\nNote that a wrapper class always implements a has-a relationship with any objects that it wraps.\nAn excellent way to keep track of the relationships between classes and show the inheritance hierarchy in your programs is with a UML (Unified Modeling Language) diagram. This is a standard graphical scheme used by object-oriented programmers. Although it is not part of the AP subset, on the AP exam you may be expected to interpret simple UML diagrams and inheritance hierarchies.\nHere is a simplified version of the UML rules:\n\u2022 Represent classes with rectangles.\n\u2022 Use angle brackets with the word \u201cabstract\u201d or \u201cinterface\u201d to indicate either an abstract class or interface.\n\u2022 Show the is-a relationship between classes with an open up-arrow.\n\u2022 Show the is-a relationship that involves an interface with an open, dotted up arrow.\n\u2022 Show the has-a relationship with a down arrow or sideways arrow (indicates composition).\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: A Java program maintains a large database of vehicles and parts for a car dealership. Some of the classes in the program are Vehicle, Car, Truck, Tire, Circle, SteeringWheel, and AirBag. The declarations below show the relationships between classes. Which is a poor choice? \nCorrect: public class Tire extends Circle\n{\n    ... \n    //inherits methods that compute circumference \n    //and center point \n} \nIncorrect: public class Vehicle\n{\n    ... \n    private Tire[] tires; \n    private SteeringWheel sw; \n    ... \n} \nIncorrect: public class Car extends Vehicle\n{\n    ... \n    //inherits private Tire[] tires from Vehicle class \n    //inherits private SteeringWheel sw from Vehicle class \n    ... \n} \nIncorrect: public class Tire\n{\n    ... \n    private String rating; //speed rating of tire \n    private Circle boundary; \n} \nIncorrect: public class SteeringWheel\n{\n    ... \n    private AirBag ab; //AirBag is stored in SteeringWheel \n    private Circle boundary; \n} \n\nEND"}
{"prompt": "Object-oriented programming has been the dominant programming methodology since the mid 1990s. It uses an approach that blurs the lines of the waterfall model. Anal ysis of the problem, development of the design, and pieces of the implementation all overlap and influence one another.\nHere are the steps in object-oriented design:\n\u2022 Identify classes to be written.\n\u2022 Identify behaviors (i.e., methods) for each class.\n\u2022 Determine the relationships between classes.\n\u2022 Write the interface (public method headers) for each class.\n\u2022 Implement the methods.\n\nIdentify the objects in the program by picking out the nouns in the program speci fication. Ignore pronouns and nouns that refer to the user. Select those nouns that seem suitable as classes, the \u201cbig-picture\u201d nouns that describe the major objects in the application. Some of the other nouns may end up as attributes of the classes.\nMany applications have similar object types: a low-level basic component; a collec\ntion of low-level components; a controlling object that puts everything together; and a display object that could be a GUI (graphical user interface) but doesn\u2019t have to be.\n\nExample 1\nWrite a program that maintains an inventory of stock items for a small store.\nNouns to consider: inventory, item, store.\nBasic Object: StockItem\nCollection: Inventory (a list of StockItems)\nController: Store (has an Inventory, uses a StoreDisplay)\nDisplay: StoreDisplay (could be a GUI)\n\nExample 2\nWrite a program that simulates a game of bingo. There should be at least two play\ners, each of whom has a bingo card, and a caller who calls the numbers.\nNouns to consider: game, players, bingo card, caller.\nBasic Objects: BingoCard, Caller\nCollection: Players (each has a BingoCard)\nController: GameMaster (sets up the Players and Caller)\nDisplay: BingoDisplay (shows each player\u2019s card and displays winners, etc.)\n\nExample 3\nWrite a program that creates random bridge deals and displays them in a specified format. (The specification defines a \u201cdeal\u201d as consisting of four hands. It also describes a deck of cards, and shows how each card should be displayed.)\nNouns to consider: deal, hand, format, deck, card.\nBasic Object: Card\nCollection: Deck (has an array of Cards)\nHand (has an array of Cards)\nDeal (has an array of Hands)\nDealer (has a Deck, or several Decks)\nController: Formatter (has a Deal and a TableDisplay)\nDisplay: TableDisplay (could be a GUI)\n\nIdentifying Behaviors\nFind all verbs in the program description that help lead to the solution of the programming task. These are likely behaviors that will probably become the methods of the classes. Now decide which methods belong in which classes. Recall that the process of bundling a group of methods and data fields into a class is called encapsulation.\nThink carefully about who should do what. Do not ask a basic object to perform operations for the group. For example, a StockItem should keep track of its own details (price, description, how many on the shelf, etc.) but should not be required to search for another item. A Card should know its value and suit but should not be responsible for keeping track of how many cards are left in a deck. A Caller in a bingo game should be responsible for keeping track of the numbers called so far and for producing the next number but not for checking whether a player has bingo: That is the job of an individual player (element of Players) and his BingoCard.\nYou will also need to decide which data fields each class will need and which data structures should store them. For example, if an object represents a list of items, consider an array or ArrayList as the data structure.\n\nINHERITANCE RELATIONSHIPS\nLook for classes with common behaviors. This will help identify inheritance relationships. Recall the is-a relationship\u2014if object1 is-a object2, then object2 is a candidate for a superclass.\nCOMPOSITION RELATIONSHIPS\nComposition relationships are defined by the has-a relationship. For example, a Nurse has-a Uniform. Typically, if two classes have a composition relationship, one of them contains an instance variable whose type is the other class.\nNote that a wrapper class always implements a has-a relationship with any objects that it wraps.\nAn excellent way to keep track of the relationships between classes and show the inheritance hierarchy in your programs is with a UML (Unified Modeling Language) diagram. This is a standard graphical scheme used by object-oriented programmers. Although it is not part of the AP subset, on the AP exam you may be expected to interpret simple UML diagrams and inheritance hierarchies.\nHere is a simplified version of the UML rules:\n\u2022 Represent classes with rectangles.\n\u2022 Use angle brackets with the word \u201cabstract\u201d or \u201cinterface\u201d to indicate either an abstract class or interface.\n\u2022 Show the is-a relationship between classes with an open up-arrow.\n\u2022 Show the is-a relationship that involves an interface with an open, dotted up arrow.\n\u2022 Show the has-a relationship with a down arrow or sideways arrow (indicates composition).\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: A Java programmer has completed a preliminary design for a large program. The programmer has developed a list of classes, determined the methods for each class, established the relationships between classes, and written an outline for each class. Which class(es) should be implemented first? \nCorrect: All independent classes (classes that have no references to other classes)\n\n\nIncorrect: Any superclasses\nIncorrect: Any subclasses\nIncorrect: All collaborator classes (classes that will be used to implement other classes)\nIncorrect: The class that represents the dominant object in the programEND"}
{"prompt": "Use the nouns in the specification as a starting point for identifying classes in the program. The nouns are: program, teacher, grade book, class list, class, student, schedule, menu, set of scores, data, record, average, grade, and file. Eliminate each of the following:\nprogram (Always eliminate \u201cprogram\u201d when used in this context.)\nteacher (Eliminate, because he or she is the user.)\nschedule (This will be reflected in the name of the external file for each class, e.g., apcs_period3.dat.)\ndata, record (These are synonymous with student name, scores, grades, etc., and will be covered by these features.)\nclass (This is synonymous with class list.)\n\nThe following seem to be excellent candidates for classes: GradeBook, ClassList, Student, and FileHandler. Other possibilities are Menu, ScoreList, and a GUI_Display. On further thought: Basic independent objects are Student, Menu, Score, and FileHandler. Group objects are ClassList (collection of students), ScoreList (collection of scores), and AllClasses (collection of ClassLists). The controlling class is the GradeBook. A Display class is essential for many of the grade book operations, like showing a class list or displaying information for a single student.\n\nThere are no inheritance relationships. There are many composition relationships between objects, however. The GradeBook has-a Menu, the ClassList has-a Student (several, in fact!), a Student has-a name, average, grade, list_of_scores, etc. The programmer must decide whether to code these attributes as classes or data fields.\nUse the verbs in the specification to identify required operations in the program. The verbs are: maintain <list>, provide <menu>, allow <user>, create <list>, enter <scores>, correct <data>, display <record>, calculate <average>, calculate <grade>, print <list>, add <student>, delete <student>, transfer <student>, and save <data>.\nYou must make some design decisions about which class is responsible for which behavior. For example, will a ClassList display the record of a single Student, or will a Student display his or her own record? Who will enter scores\u2014the GradeBook, a ClassList, or a Student? Is it desirable for a Student to enter scores of other Students? Probably not!\n\nHere are some preliminary decisions. The GradeBook will provideMenu. The menu selection will send execution to the relevant object.\nThe ClassList will maintain an updated list of each class. It will have these public methods: addStudent, deleteStudent, transferStudent, createNewClass, printClassList, printScores, and updateList. A good candidate for a helper method in this class is search for a given student.\nEach Student will have complete personal and grade information. Public methods will include setName, getName, enterScore, correctData, findAverage, getAverage, getGrade, and displayRecord.\nSaving and retrieving information is crucial to this program. The FileHandler will take care of openFileForReading, openFileForWriting, closeFiles, loadClass, and saveClass. The FileHandler class should be written and tested right at the beginning, using a small dummy class list.\nScore, ScoreList, and Student are easy classes to implement. When these are working, the programmer can go on to ClassList. Finally the Display GUI class, which will have the GradeBook, can be developed. This is an example of bottom-up development.\n\nExample 3\nA program simulates a game of Battleships, which is a game between two players, each of whom has a grid where ships are placed. Each player has five ships:\nbattleship o o o o o\ncruiser o o o o\nsubmarine o o o\ndestroyer o o\nfrigate o\nThe grids of the players\u2019 fleets may look like this. Any two adjacent squares that are taken must belong to the same ship, i.e., different ships shouldn\u2019t \u201ctouch.\u201d\nEach player\u2019s grid is hidden from the other player. Players alternate \u201cshooting\u201d at each other\u2019s ships by calling out a position, a row and column number. A player must make an honest response, \u201chit\u201d or \u201cmiss.\u201d If it\u2019s a hit, a player gets another turn. If the whole ship has been hit, the owner must say something like, \u201cYou sank my cruiser.\u201d Each player must keep track of hits and misses. The first player to sink his opponent\u2019s fleet is the winner.\nThe nouns in the specification are program, game, players, grid, ship, battleship, cruiser, submarine, destroyer, frigate, square, position, opponent, row, column, turn, hits, misses, fleet, winner.\n\nEliminate each of the following:\nprogram Always eliminate.\nrow, col These are parts of a given position or square, more suitable as instance variables for a position or square object.\nhits, misses These are simply marked positions and probably don\u2019t need their own class.\nturn Taking a turn is an action and will be described by a method rather than a class.\nopponent This is another word for player.\n\nThe following seem to be good candidates for classes: Player, Grid, Position, Ship, Battleship, Cruiser, Submarine, Destroyer, and Frigate. Additionally, it seems there should be a GameManager and Display.\n\nThis program provides two examples of inheritance relationships. Each of the five ships is-a Ship, and shares common features, like isHit, isSunk, and array of positions. However, each has a unique name, length, and position in the grid. This means that Ship is a good candidate for an abstract class with abstract methods like getLength, getName, and getPositions, which depend on the kind of ship.\nThe second inheritance relationship is between the grids. There are two types of\ngrids for each player: his own FleetGrid (the current state of his own ships) and his opponent\u2019s HitGrid, which keeps track of his hits and misses. Each of these grids is-a Grid. A grid is a candidate for an interface, with a list of methods like getAdjacentNeighbors, getRightNeighbor, etc. Each of FleetGrid and HitGrid would implement Grid.\nThere are several composition relationships in this program. A Player has-a HitGrid and a FleetGrid and also has five ships. The GameManager has each of the two Player objects and also has-a Display. The Display has each of the grids.\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: Consider the following program description:\n\nA program is to be written that simulates bumper cars in a video game. The cars move on a square grid and are located on grid points (x, y), where x and y are integers between \u221220 and 20. A bumper car moves in a random direction, either left, right, up, or down. If it reaches a boundary (i.e., x or y is \u00b120), then it reverses direction. If it is about to collide with another bumper car, it reverses direction. Your program should be able to add bumper cars and run the simulation. One step of the simulation allows each car in the grid to move. After a bumper car has reversed direction twice, its turn is over and the next car gets to move. 19. To identify classes in the program, the nouns in the specification are listed: program, bumper car, grid, grid point, integer, direction, boundary, simulation \n\nHow many nouns in the list should immediately be discarded because they are unsuitable as classes for the program? \nCorrect: 2\nIncorrect: 0\nIncorrect: 1\nIncorrect: 3\nIncorrect: 4\n\nEND"}
{"prompt": "Use the nouns in the specification as a starting point for identifying classes in the program. The nouns are: program, teacher, grade book, class list, class, student, schedule, menu, set of scores, data, record, average, grade, and file. Eliminate each of the following:\nprogram (Always eliminate \u201cprogram\u201d when used in this context.)\nteacher (Eliminate, because he or she is the user.)\nschedule (This will be reflected in the name of the external file for each class, e.g., apcs_period3.dat.)\ndata, record (These are synonymous with student name, scores, grades, etc., and will be covered by these features.)\nclass (This is synonymous with class list.)\n\nThe following seem to be excellent candidates for classes: GradeBook, ClassList, Student, and FileHandler. Other possibilities are Menu, ScoreList, and a GUI_Display. On further thought: Basic independent objects are Student, Menu, Score, and FileHandler. Group objects are ClassList (collection of students), ScoreList (collection of scores), and AllClasses (collection of ClassLists). The controlling class is the GradeBook. A Display class is essential for many of the grade book operations, like showing a class list or displaying information for a single student.\n\nThere are no inheritance relationships. There are many composition relationships between objects, however. The GradeBook has-a Menu, the ClassList has-a Student (several, in fact!), a Student has-a name, average, grade, list_of_scores, etc. The programmer must decide whether to code these attributes as classes or data fields.\nUse the verbs in the specification to identify required operations in the program. The verbs are: maintain <list>, provide <menu>, allow <user>, create <list>, enter <scores>, correct <data>, display <record>, calculate <average>, calculate <grade>, print <list>, add <student>, delete <student>, transfer <student>, and save <data>.\nYou must make some design decisions about which class is responsible for which behavior. For example, will a ClassList display the record of a single Student, or will a Student display his or her own record? Who will enter scores\u2014the GradeBook, a ClassList, or a Student? Is it desirable for a Student to enter scores of other Students? Probably not!\n\nHere are some preliminary decisions. The GradeBook will provideMenu. The menu selection will send execution to the relevant object.\nThe ClassList will maintain an updated list of each class. It will have these public methods: addStudent, deleteStudent, transferStudent, createNewClass, printClassList, printScores, and updateList. A good candidate for a helper method in this class is search for a given student.\nEach Student will have complete personal and grade information. Public methods will include setName, getName, enterScore, correctData, findAverage, getAverage, getGrade, and displayRecord.\nSaving and retrieving information is crucial to this program. The FileHandler will take care of openFileForReading, openFileForWriting, closeFiles, loadClass, and saveClass. The FileHandler class should be written and tested right at the beginning, using a small dummy class list.\nScore, ScoreList, and Student are easy classes to implement. When these are working, the programmer can go on to ClassList. Finally the Display GUI class, which will have the GradeBook, can be developed. This is an example of bottom-up development.\n\nExample 3\nA program simulates a game of Battleships, which is a game between two players, each of whom has a grid where ships are placed. Each player has five ships:\nbattleship o o o o o\ncruiser o o o o\nsubmarine o o o\ndestroyer o o\nfrigate o\nThe grids of the players\u2019 fleets may look like this. Any two adjacent squares that are taken must belong to the same ship, i.e., different ships shouldn\u2019t \u201ctouch.\u201d\nEach player\u2019s grid is hidden from the other player. Players alternate \u201cshooting\u201d at each other\u2019s ships by calling out a position, a row and column number. A player must make an honest response, \u201chit\u201d or \u201cmiss.\u201d If it\u2019s a hit, a player gets another turn. If the whole ship has been hit, the owner must say something like, \u201cYou sank my cruiser.\u201d Each player must keep track of hits and misses. The first player to sink his opponent\u2019s fleet is the winner.\nThe nouns in the specification are program, game, players, grid, ship, battleship, cruiser, submarine, destroyer, frigate, square, position, opponent, row, column, turn, hits, misses, fleet, winner.\n\nEliminate each of the following:\nprogram Always eliminate.\nrow, col These are parts of a given position or square, more suitable as instance variables for a position or square object.\nhits, misses These are simply marked positions and probably don\u2019t need their own class.\nturn Taking a turn is an action and will be described by a method rather than a class.\nopponent This is another word for player.\n\nThe following seem to be good candidates for classes: Player, Grid, Position, Ship, Battleship, Cruiser, Submarine, Destroyer, and Frigate. Additionally, it seems there should be a GameManager and Display.\n\nThis program provides two examples of inheritance relationships. Each of the five ships is-a Ship, and shares common features, like isHit, isSunk, and array of positions. However, each has a unique name, length, and position in the grid. This means that Ship is a good candidate for an abstract class with abstract methods like getLength, getName, and getPositions, which depend on the kind of ship.\nThe second inheritance relationship is between the grids. There are two types of\ngrids for each player: his own FleetGrid (the current state of his own ships) and his opponent\u2019s HitGrid, which keeps track of his hits and misses. Each of these grids is-a Grid. A grid is a candidate for an interface, with a list of methods like getAdjacentNeighbors, getRightNeighbor, etc. Each of FleetGrid and HitGrid would implement Grid.\nThere are several composition relationships in this program. A Player has-a HitGrid and a FleetGrid and also has five ships. The GameManager has each of the two Player objects and also has-a Display. The Display has each of the grids.\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: Consider the following program description:\n\nA program is to be written that simulates bumper cars in a video game. The cars move on a square grid and are located on grid points (x, y), where x and y are integers between \u221220 and 20. A bumper car moves in a random direction, either left, right, up, or down. If it reaches a boundary (i.e., x or y is \u00b120), then it reverses direction. If it is about to collide with another bumper car, it reverses direction. Your program should be able to add bumper cars and run the simulation. One step of the simulation allows each car in the grid to move. After a bumper car has reversed direction twice, its turn is over and the next car gets to move. 19. To identify classes in the program, the nouns in the specification are listed: program, bumper car, grid, grid point, integer, direction, boundary, simulation \n\nA programmer decides to include the following classes in the program.\n\u2022 Simulation will run the simulation. \n\u2022 Display will show the state of the game. \n\u2022 BumperCar will know its identification number, position in the grid, and current direction when moving. \n\u2022 GridPoint will be a position in the grid. It will be represented by two integer fields, x_coord and y_coord. \n\u2022 Grid will keep track of all bumper cars in the game, the number of cars, and their positions in the grid. It will update the grid each time a car moves. It will be implemented with a two-dimensional array of BumperCar. \n\nWhich operation should not be the responsibility of the GridPoint class? \nCorrect: isEmpty returns false if grid point contains a BumperCar, true otherwise\nIncorrect: atBoundary returns true if x or y coordinate = \u00b120, false otherwise\nIncorrect: left if not at left boundary, change grid point to 1 unit left of current point\nIncorrect: up if not at top of grid, change grid point to 1 unit above current point\nIncorrect: get_x return x-coordinate of this point\n\nEND"}
{"prompt": "Use the nouns in the specification as a starting point for identifying classes in the program. The nouns are: program, teacher, grade book, class list, class, student, schedule, menu, set of scores, data, record, average, grade, and file. Eliminate each of the following:\nprogram (Always eliminate \u201cprogram\u201d when used in this context.)\nteacher (Eliminate, because he or she is the user.)\nschedule (This will be reflected in the name of the external file for each class, e.g., apcs_period3.dat.)\ndata, record (These are synonymous with student name, scores, grades, etc., and will be covered by these features.)\nclass (This is synonymous with class list.)\n\nThe following seem to be excellent candidates for classes: GradeBook, ClassList, Student, and FileHandler. Other possibilities are Menu, ScoreList, and a GUI_Display. On further thought: Basic independent objects are Student, Menu, Score, and FileHandler. Group objects are ClassList (collection of students), ScoreList (collection of scores), and AllClasses (collection of ClassLists). The controlling class is the GradeBook. A Display class is essential for many of the grade book operations, like showing a class list or displaying information for a single student.\n\nThere are no inheritance relationships. There are many composition relationships between objects, however. The GradeBook has-a Menu, the ClassList has-a Student (several, in fact!), a Student has-a name, average, grade, list_of_scores, etc. The programmer must decide whether to code these attributes as classes or data fields.\nUse the verbs in the specification to identify required operations in the program. The verbs are: maintain <list>, provide <menu>, allow <user>, create <list>, enter <scores>, correct <data>, display <record>, calculate <average>, calculate <grade>, print <list>, add <student>, delete <student>, transfer <student>, and save <data>.\nYou must make some design decisions about which class is responsible for which behavior. For example, will a ClassList display the record of a single Student, or will a Student display his or her own record? Who will enter scores\u2014the GradeBook, a ClassList, or a Student? Is it desirable for a Student to enter scores of other Students? Probably not!\n\nHere are some preliminary decisions. The GradeBook will provideMenu. The menu selection will send execution to the relevant object.\nThe ClassList will maintain an updated list of each class. It will have these public methods: addStudent, deleteStudent, transferStudent, createNewClass, printClassList, printScores, and updateList. A good candidate for a helper method in this class is search for a given student.\nEach Student will have complete personal and grade information. Public methods will include setName, getName, enterScore, correctData, findAverage, getAverage, getGrade, and displayRecord.\nSaving and retrieving information is crucial to this program. The FileHandler will take care of openFileForReading, openFileForWriting, closeFiles, loadClass, and saveClass. The FileHandler class should be written and tested right at the beginning, using a small dummy class list.\nScore, ScoreList, and Student are easy classes to implement. When these are working, the programmer can go on to ClassList. Finally the Display GUI class, which will have the GradeBook, can be developed. This is an example of bottom-up development.\n\nExample 3\nA program simulates a game of Battleships, which is a game between two players, each of whom has a grid where ships are placed. Each player has five ships:\nbattleship o o o o o\ncruiser o o o o\nsubmarine o o o\ndestroyer o o\nfrigate o\nThe grids of the players\u2019 fleets may look like this. Any two adjacent squares that are taken must belong to the same ship, i.e., different ships shouldn\u2019t \u201ctouch.\u201d\nEach player\u2019s grid is hidden from the other player. Players alternate \u201cshooting\u201d at each other\u2019s ships by calling out a position, a row and column number. A player must make an honest response, \u201chit\u201d or \u201cmiss.\u201d If it\u2019s a hit, a player gets another turn. If the whole ship has been hit, the owner must say something like, \u201cYou sank my cruiser.\u201d Each player must keep track of hits and misses. The first player to sink his opponent\u2019s fleet is the winner.\nThe nouns in the specification are program, game, players, grid, ship, battleship, cruiser, submarine, destroyer, frigate, square, position, opponent, row, column, turn, hits, misses, fleet, winner.\n\nEliminate each of the following:\nprogram Always eliminate.\nrow, col These are parts of a given position or square, more suitable as instance variables for a position or square object.\nhits, misses These are simply marked positions and probably don\u2019t need their own class.\nturn Taking a turn is an action and will be described by a method rather than a class.\nopponent This is another word for player.\n\nThe following seem to be good candidates for classes: Player, Grid, Position, Ship, Battleship, Cruiser, Submarine, Destroyer, and Frigate. Additionally, it seems there should be a GameManager and Display.\n\nThis program provides two examples of inheritance relationships. Each of the five ships is-a Ship, and shares common features, like isHit, isSunk, and array of positions. However, each has a unique name, length, and position in the grid. This means that Ship is a good candidate for an abstract class with abstract methods like getLength, getName, and getPositions, which depend on the kind of ship.\nThe second inheritance relationship is between the grids. There are two types of\ngrids for each player: his own FleetGrid (the current state of his own ships) and his opponent\u2019s HitGrid, which keeps track of his hits and misses. Each of these grids is-a Grid. A grid is a candidate for an interface, with a list of methods like getAdjacentNeighbors, getRightNeighbor, etc. Each of FleetGrid and HitGrid would implement Grid.\nThere are several composition relationships in this program. A Player has-a HitGrid and a FleetGrid and also has five ships. The GameManager has each of the two Player objects and also has-a Display. The Display has each of the grids.\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: Consider the following program description:\n\nA program is to be written that simulates bumper cars in a video game. The cars move on a square grid and are located on grid points (x, y), where x and y are integers between \u221220 and 20. A bumper car moves in a random direction, either left, right, up, or down. If it reaches a boundary (i.e., x or y is \u00b120), then it reverses direction. If it is about to collide with another bumper car, it reverses direction. Your program should be able to add bumper cars and run the simulation. One step of the simulation allows each car in the grid to move. After a bumper car has reversed direction twice, its turn is over and the next car gets to move. 19. To identify classes in the program, the nouns in the specification are listed: program, bumper car, grid, grid point, integer, direction, boundary, simulation \n\nA programmer decides to include the following classes in the program.\n\u2022 Simulation will run the simulation. \n\u2022 Display will show the state of the game. \n\u2022 BumperCar will know its identification number, position in the grid, and current direction when moving. \n\u2022 GridPoint will be a position in the grid. It will be represented by two integer fields, x_coord and y_coord. \n\u2022 Grid will keep track of all bumper cars in the game, the number of cars, and their positions in the grid. It will update the grid each time a car moves. It will be implemented with a two-dimensional array of BumperCar. \n\nWhich method is not suitable for the BumperCar class? \nCorrect: public void update()\n//Modify Grid to reflect new position after each stage \n// of move.\nIncorrect: public boolean atBoundary()\n//Returns true if BumperCar at boundary, false otherwise. \nIncorrect: public void selectRandomDirection()\n//Select random direction (up, down, left, or right) \n// at start of turn. \nIncorrect: public void reverseDirection()\n//Move to grid position that is in direction opposite to \n// current direction. \nIncorrect: public void move()\n//Take turn to move. Stop move after two changes \n// of direction. END"}
{"prompt": "Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization\u20140 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); //calls default constructor of superclass\n}\n\nRules for Subclasses\n\u2022 A subclass can add new private instance variables.\n\u2022 A subclass can add new public, private, or static methods.\n\u2022 A subclass can override inherited methods.\n\u2022 A subclass may not redefine a public method as private.\n\u2022 A subclass may not override static methods of the superclass.\n\u2022 A subclass should define its own constructors.\n\u2022 A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won\u2019t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters\u2014for example, new int[] {90,90,100}\u2014 will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { /* implementation not shown */ }\n\n    public SavingsAccount(double acctBalance, double rate) { /* implementation not shown */ }\n\n    public void addInterest() // Add interest to balance\n    { /* implementation not shown */ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { /* implementation not shown */ }\n\n    /**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     */\n    public void withdraw(double amount) { /* implementation not shown */ }\n}\n\nOf the methods shown, how many different nonconstructor methods can be invoked by a SavingsAccount object? \nCorrect: 4\nIncorrect: 1\nIncorrect: 2\nIncorrect: 3\nIncorrect: 5\n\nEND"}
{"prompt": "Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization\u20140 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); //calls default constructor of superclass\n}\n\nRules for Subclasses\n\u2022 A subclass can add new private instance variables.\n\u2022 A subclass can add new public, private, or static methods.\n\u2022 A subclass can override inherited methods.\n\u2022 A subclass may not redefine a public method as private.\n\u2022 A subclass may not override static methods of the superclass.\n\u2022 A subclass should define its own constructors.\n\u2022 A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won\u2019t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters\u2014for example, new int[] {90,90,100}\u2014 will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { /* implementation not shown */ }\n\n    public SavingsAccount(double acctBalance, double rate) { /* implementation not shown */ }\n\n    public void addInterest() // Add interest to balance\n    { /* implementation not shown */ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { /* implementation not shown */ }\n\n    /**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     */\n    public void withdraw(double amount) { /* implementation not shown */ }\n}\n\nWhich of the following correctly implements the default constructor of the SavingsAccount class? \nI interestRate = 0; \nsuper(); \nII super(); \ninterestRate = 0; \nIII super(); \nCorrect: II and III only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization\u20140 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); //calls default constructor of superclass\n}\n\nRules for Subclasses\n\u2022 A subclass can add new private instance variables.\n\u2022 A subclass can add new public, private, or static methods.\n\u2022 A subclass can override inherited methods.\n\u2022 A subclass may not redefine a public method as private.\n\u2022 A subclass may not override static methods of the superclass.\n\u2022 A subclass should define its own constructors.\n\u2022 A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won\u2019t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters\u2014for example, new int[] {90,90,100}\u2014 will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { /* implementation not shown */ }\n\n    public SavingsAccount(double acctBalance, double rate) { /* implementation not shown */ }\n\n    public void addInterest() // Add interest to balance\n    { /* implementation not shown */ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { /* implementation not shown */ }\n\n    /**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     */\n    public void withdraw(double amount) { /* implementation not shown */ }\n}\n\nWhich is a correct implementation of the constructor with parameters in the SavingsAccount class? \nCorrect: super(acctBalance);\ninterestRate = rate; \nIncorrect: balance = acctBalance;\ninterestRate = rate; \nIncorrect: getBalance() = acctBalance;\ninterestRate = rate; \nIncorrect: super();\ninterestRate = rate; \nIncorrect: super(acctBalance, rate);\n\nEND"}
{"prompt": "Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization\u20140 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); //calls default constructor of superclass\n}\n\nRules for Subclasses\n\u2022 A subclass can add new private instance variables.\n\u2022 A subclass can add new public, private, or static methods.\n\u2022 A subclass can override inherited methods.\n\u2022 A subclass may not redefine a public method as private.\n\u2022 A subclass may not override static methods of the superclass.\n\u2022 A subclass should define its own constructors.\n\u2022 A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won\u2019t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters\u2014for example, new int[] {90,90,100}\u2014 will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { /* implementation not shown */ }\n\n    public SavingsAccount(double acctBalance, double rate) { /* implementation not shown */ }\n\n    public void addInterest() // Add interest to balance\n    { /* implementation not shown */ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { /* implementation not shown */ }\n\n    /**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     */\n    public void withdraw(double amount) { /* implementation not shown */ }\n}\n\nWhich is a correct implementation of the CheckingAccount constructor? \nI super(acctBalance); \nII super(); \ndeposit(acctBalance); \nIII deposit(acctBalance); \nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: II and III onlyEND"}
{"prompt": "Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization\u20140 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); //calls default constructor of superclass\n}\n\nRules for Subclasses\n\u2022 A subclass can add new private instance variables.\n\u2022 A subclass can add new public, private, or static methods.\n\u2022 A subclass can override inherited methods.\n\u2022 A subclass may not redefine a public method as private.\n\u2022 A subclass may not override static methods of the superclass.\n\u2022 A subclass should define its own constructors.\n\u2022 A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won\u2019t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters\u2014for example, new int[] {90,90,100}\u2014 will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { /* implementation not shown */ }\n\n    public SavingsAccount(double acctBalance, double rate) { /* implementation not shown */ }\n\n    public void addInterest() // Add interest to balance\n    { /* implementation not shown */ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { /* implementation not shown */ }\n\n    /**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     */\n    public void withdraw(double amount) { /* implementation not shown */ }\n}\n\nWhich is correct implementation code for the withdraw method in the CheckingAccount class? \nCorrect: super.withdraw(amount);\nif (getBalance() < MIN_BALANCE) \n    super.withdraw(FEE); \nIncorrect: super.withdraw(amount);\nif (balance < MIN_BALANCE) \n    super.withdraw(FEE); \nIncorrect: withdraw(amount);\nif (balance < MIN_BALANCE) \n    withdraw(FEE); \nIncorrect: withdraw(amount);\nif (getBalance() < MIN_BALANCE) \n    withdraw(FEE); \nIncorrect: balance -= amount;\nif (balance < MIN_BALANCE) \n    balance -= FEE; \n\nEND"}
{"prompt": "Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization\u20140 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); //calls default constructor of superclass\n}\n\nRules for Subclasses\n\u2022 A subclass can add new private instance variables.\n\u2022 A subclass can add new public, private, or static methods.\n\u2022 A subclass can override inherited methods.\n\u2022 A subclass may not redefine a public method as private.\n\u2022 A subclass may not override static methods of the superclass.\n\u2022 A subclass should define its own constructors.\n\u2022 A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won\u2019t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters\u2014for example, new int[] {90,90,100}\u2014 will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { /* implementation not shown */ }\n\n    public SavingsAccount(double acctBalance, double rate) { /* implementation not shown */ }\n\n    public void addInterest() // Add interest to balance\n    { /* implementation not shown */ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { /* implementation not shown */ }\n\n    /**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     */\n    public void withdraw(double amount) { /* implementation not shown */ }\n}\n\nRedefining the withdraw method in the CheckingAccount class is an example of \nCorrect: method overriding.\nIncorrect: method overloading.\nIncorrect: downcasting.\nIncorrect: dynamic binding (late binding).\nIncorrect: static binding (early binding).\n\nEND"}
{"prompt": "Consider the statements\nStudent s = new GradStudent();\nGradStudent g = new GradStudent();\nint x = s.getID(); //compile-time error\nint y = g.getID(); //legal\nBoth s and g represent GradStudent objects, so why does s.getID() cause an error? The reason is that s is of type Student, and the Student class doesn\u2019t have a getID method. At compile time, only nonprivate methods of the Student class can appear to the right of the dot operator when applied to s. Don\u2019t confuse this with polymor phism: getID is not a polymorphic method. It occurs in just the GradStudent class and can therefore be called only by a GradStudent object.\nThe error shown above can be fixed by casting s to the correct type:\nint x = ((GradStudent) s).getID();\nSince s (of type Student) is actually representing a GradStudent object, such a cast can be carried out. Casting a superclass to a subclass type is called a downcast.\n\nNOTE\n1. The outer parentheses are necessary:\nint x = (GradStudent) s.getID();\nwill still cause an error, despite the cast. This is because the dot operator has\nhigher precedence than casting, so s.getID() is invoked before s is cast to\nGradStudent.\n2. The statement\nint y = g.getID();\ncompiles without problem because g is declared to be of type GradStudent, and this is the class that contains getID. No cast is required.\n\nType Rules for Polymorphic Method Calls\na.method(b)\n\nMethod selected by type of a at run time\nParameter b must be of correct type at compile time\n\n\u2022 For a declaration like Superclass a = new Subclass(); the type of a at compile time is Superclass; at run time it is Subclass.\n\u2022 At compile time, method must be found in the class of a, that is, in Superclass. (This is true whether the method is polymorphic or not.) If method cannot be found in the class of a, you need to do an explicit cast on a to its actual type.\n\u2022 For a polymorphic method, at run time the actual type of a is determined\u2014Subclass in this example\u2014and method is selected from Subclass. This could be an inherited method if there is no overriding method.\n\u2022 The type of parameter b is checked at compile time. You may need to do an explicit cast to the subclass type to make this correct.\n\nThe ClassCastException is a run-time exception thrown to signal an attempt to cast an object to a class of which it is not an instance.\nStudent u = new UnderGrad();\nSystem.out.println((String) u); //ClassCastException\n//u is not an instance of String\nint x = ((GradStudent) u).getID(); //ClassCastException\n//u is not an instance of GradStudent\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { /* implementation not shown */ }\n\n    public SavingsAccount(double acctBalance, double rate) { /* implementation not shown */ }\n\n    public void addInterest() // Add interest to balance\n    { /* implementation not shown */ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { /* implementation not shown */ }\n\n    /**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     */\n    public void withdraw(double amount) { /* implementation not shown */ }\n}\n\nA program to test the BankAccount, SavingsAccount, and CheckingAccount classes has these declarations: \nBankAccount b = new BankAccount(1400); \nBankAccount s = new SavingsAccount(1000, 0.04); \nBankAccount c = new CheckingAccount(500); \n\nWhich method call will cause an error? \nCorrect: s.addInterest();\n\n\nIncorrect: b.deposit(200);\nIncorrect: s.withdraw(500);\nIncorrect: c.withdraw(500);\nIncorrect: s.deposit(10000);END"}
{"prompt": "Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization\u20140 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); //calls default constructor of superclass\n}\n\nRules for Subclasses\n\u2022 A subclass can add new private instance variables.\n\u2022 A subclass can add new public, private, or static methods.\n\u2022 A subclass can override inherited methods.\n\u2022 A subclass may not redefine a public method as private.\n\u2022 A subclass may not override static methods of the superclass.\n\u2022 A subclass should define its own constructors.\n\u2022 A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won\u2019t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters\u2014for example, new int[] {90,90,100}\u2014 will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { /* implementation not shown */ }\n\n    public SavingsAccount(double acctBalance, double rate) { /* implementation not shown */ }\n\n    public void addInterest() // Add interest to balance\n    { /* implementation not shown */ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { /* implementation not shown */ }\n\n    /**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     */\n    public void withdraw(double amount) { /* implementation not shown */ }\n}\n\nA program to test the BankAccount, SavingsAccount, and CheckingAccount classes has these declarations: \nBankAccount b = new BankAccount(1400); \nBankAccount s = new SavingsAccount(1000, 0.04); \nBankAccount c = new CheckingAccount(500); \n\nIn order to test polymorphism, which method must be used in the program? \nCorrect: withdraw\nIncorrect: Either a SavingsAccount constructor or a CheckingAccount constructor\nIncorrect: addInterest\nIncorrect: deposit\nIncorrect: getBalance\n\nEND"}
{"prompt": "Consider the statements\nStudent s = new GradStudent();\nGradStudent g = new GradStudent();\nint x = s.getID(); //compile-time error\nint y = g.getID(); //legal\nBoth s and g represent GradStudent objects, so why does s.getID() cause an error? The reason is that s is of type Student, and the Student class doesn\u2019t have a getID method. At compile time, only nonprivate methods of the Student class can appear to the right of the dot operator when applied to s. Don\u2019t confuse this with polymor phism: getID is not a polymorphic method. It occurs in just the GradStudent class and can therefore be called only by a GradStudent object.\nThe error shown above can be fixed by casting s to the correct type:\nint x = ((GradStudent) s).getID();\nSince s (of type Student) is actually representing a GradStudent object, such a cast can be carried out. Casting a superclass to a subclass type is called a downcast.\n\nNOTE\n1. The outer parentheses are necessary:\nint x = (GradStudent) s.getID();\nwill still cause an error, despite the cast. This is because the dot operator has\nhigher precedence than casting, so s.getID() is invoked before s is cast to\nGradStudent.\n2. The statement\nint y = g.getID();\ncompiles without problem because g is declared to be of type GradStudent, and this is the class that contains getID. No cast is required.\n\nType Rules for Polymorphic Method Calls\na.method(b)\n\nMethod selected by type of a at run time\nParameter b must be of correct type at compile time\n\n\u2022 For a declaration like Superclass a = new Subclass(); the type of a at compile time is Superclass; at run time it is Subclass.\n\u2022 At compile time, method must be found in the class of a, that is, in Superclass. (This is true whether the method is polymorphic or not.) If method cannot be found in the class of a, you need to do an explicit cast on a to its actual type.\n\u2022 For a polymorphic method, at run time the actual type of a is determined\u2014Subclass in this example\u2014and method is selected from Subclass. This could be an inherited method if there is no overriding method.\n\u2022 The type of parameter b is checked at compile time. You may need to do an explicit cast to the subclass type to make this correct.\n\nThe ClassCastException is a run-time exception thrown to signal an attempt to cast an object to a class of which it is not an instance.\nStudent u = new UnderGrad();\nSystem.out.println((String) u); //ClassCastException\n//u is not an instance of String\nint x = ((GradStudent) u).getID(); //ClassCastException\n//u is not an instance of GradStudent\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { /* implementation not shown */ }\n\n    public SavingsAccount(double acctBalance, double rate) { /* implementation not shown */ }\n\n    public void addInterest() // Add interest to balance\n    { /* implementation not shown */ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { /* implementation not shown */ }\n\n    /**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     */\n    public void withdraw(double amount) { /* implementation not shown */ }\n}\n\nA program to test the BankAccount, SavingsAccount, and CheckingAccount classes has these declarations: \nBankAccount b = new BankAccount(1400); \nBankAccount s = new SavingsAccount(1000, 0.04); \nBankAccount c = new CheckingAccount(500); \n\nWhich of the following will not cause a ClassCastException to be thrown? \nCorrect: ((CheckingAccount) c).deposit(800);\nIncorrect: ((SavingsAccount) b).addInterest();\nIncorrect: ((CheckingAccount) b).withdraw(200);\nIncorrect: ((CheckingAccount) s).withdraw(150);\nIncorrect: ((SavingsAccount) c).addInterest();\n\nEND"}
{"prompt": "Consider the statements\nStudent s = new GradStudent();\nGradStudent g = new GradStudent();\nint x = s.getID(); //compile-time error\nint y = g.getID(); //legal\nBoth s and g represent GradStudent objects, so why does s.getID() cause an error? The reason is that s is of type Student, and the Student class doesn\u2019t have a getID method. At compile time, only nonprivate methods of the Student class can appear to the right of the dot operator when applied to s. Don\u2019t confuse this with polymor phism: getID is not a polymorphic method. It occurs in just the GradStudent class and can therefore be called only by a GradStudent object.\nThe error shown above can be fixed by casting s to the correct type:\nint x = ((GradStudent) s).getID();\nSince s (of type Student) is actually representing a GradStudent object, such a cast can be carried out. Casting a superclass to a subclass type is called a downcast.\n\nNOTE\n1. The outer parentheses are necessary:\nint x = (GradStudent) s.getID();\nwill still cause an error, despite the cast. This is because the dot operator has\nhigher precedence than casting, so s.getID() is invoked before s is cast to\nGradStudent.\n2. The statement\nint y = g.getID();\ncompiles without problem because g is declared to be of type GradStudent, and this is the class that contains getID. No cast is required.\n\nType Rules for Polymorphic Method Calls\na.method(b)\n\nMethod selected by type of a at run time\nParameter b must be of correct type at compile time\n\n\u2022 For a declaration like Superclass a = new Subclass(); the type of a at compile time is Superclass; at run time it is Subclass.\n\u2022 At compile time, method must be found in the class of a, that is, in Superclass. (This is true whether the method is polymorphic or not.) If method cannot be found in the class of a, you need to do an explicit cast on a to its actual type.\n\u2022 For a polymorphic method, at run time the actual type of a is determined\u2014Subclass in this example\u2014and method is selected from Subclass. This could be an inherited method if there is no overriding method.\n\u2022 The type of parameter b is checked at compile time. You may need to do an explicit cast to the subclass type to make this correct.\n\nThe ClassCastException is a run-time exception thrown to signal an attempt to cast an object to a class of which it is not an instance.\nStudent u = new UnderGrad();\nSystem.out.println((String) u); //ClassCastException\n//u is not an instance of String\nint x = ((GradStudent) u).getID(); //ClassCastException\n//u is not an instance of GradStudent\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { /* implementation not shown */ }\n\n    public SavingsAccount(double acctBalance, double rate) { /* implementation not shown */ }\n\n    public void addInterest() // Add interest to balance\n    { /* implementation not shown */ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { /* implementation not shown */ }\n\n    /**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     */\n    public void withdraw(double amount) { /* implementation not shown */ }\n}\n\nA new method is added to the BankAccount class. \n\n/** Transfer amount from this BankAccount to another BankAccount. \n* Precondition: balance > amount \n* @param another a different BankAccount object \n* @param amount the amount to be transferred \n*/ \npublic void transfer(BankAccount another, double amount) \n{ \n    withdraw(amount); \n    another.deposit(amount); \n} \n\nA program has these declarations: \nBankAccount b = new BankAccount(650); \nSavingsAccount timsSavings = new SavingsAccount(1500, 0.03); \nCheckingAccount daynasChecking = new CheckingAccount(2000); \n\nWhich of the following will transfer money from one account to another without error? \nI b.transfer(timsSavings, 50); \nII timsSavings.transfer(daynasChecking, 30); \nIII daynasChecking.transfer(b, 55); \nCorrect: I, II, and III\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: None\n\nEND"}
{"prompt": "Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization\u20140 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); //calls default constructor of superclass\n}\n\nRules for Subclasses\n\u2022 A subclass can add new private instance variables.\n\u2022 A subclass can add new public, private, or static methods.\n\u2022 A subclass can override inherited methods.\n\u2022 A subclass may not redefine a public method as private.\n\u2022 A subclass may not override static methods of the superclass.\n\u2022 A subclass should define its own constructors.\n\u2022 A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won\u2019t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters\u2014for example, new int[] {90,90,100}\u2014 will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\nThe following question asks about the properties or summary of a program with multiple options:\n\n###\n\n", "completion": "Question: Consider these class declarations: \n\npublic class Person \n{ \n    ... \n} \npublic class Teacher extends Person \n{ \n    ... \n} \n\nWhich is a true statement? \nI Teacher inherits the constructors of Person. \nII Teacher can add new methods and private instance variables. \nIII Teacher can override existing private methods of Person. \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: II and III only\n\nEND"}
{"prompt": "Consider writing a program that simulates a game of Battleships. The program may have a Ship class with subclasses Submarine, Cruiser, Destroyer, and so on. The various ships will be placed in a two-dimensional grid that represents a part of the ocean.\nAn abstract class Ship is a good design choice. There will not be any instances of Ship objects because the specific features of the subclasses must be known in order to place these ships in the grid. A Grid interface that manipulates objects in a two dimensional setting suggests itself for the two-dimensional grid.\nNotice that the abstract Ship class is specific to the Battleships application, whereas the Grid interface is not. You could use the Grid interface in any program that has a two-dimensional grid.\n\nInterface vs. Abstract Class\n\u2022 Use an abstract class for an object that is application-specific\nbut incomplete without its subclasses.\n\u2022 Consider using an interface when its methods are suitable\nfor your program but could be equally applicable in a vari\nety of programs.\n\u2022 An interface typically doesn\u2019t provide implementations for\nany of its methods, whereas an abstract class does. (In Java 8,\nimplementation of default methods is allowed in interfaces.)\n\u2022 An interface cannot contain instance variables, whereas an\nabstract class can.\n\u2022 It is not possible to create an instance of an interface object\nor an abstract class object.\n\n\nThe following question asks about general programming knowledge:\n\n###\n\n", "completion": "Question: Which statement about abstract classes and interfaces is false? \nCorrect: All of the methods in both an abstract class and an interface are public.\n\n\nIncorrect: An interface cannot implement any non-default instance methods, whereas\nan abstract class can. \nIncorrect: A class can implement many interfaces but can have only one superclass.\nIncorrect: An unlimited number of unrelated classes can implement the same inter\nface. \nIncorrect: It is not possible to construct either an abstract class object or an interface\nobject. END"}
{"prompt": "Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization\u20140 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); //calls default constructor of superclass\n}\n\nRules for Subclasses\n\u2022 A subclass can add new private instance variables.\n\u2022 A subclass can add new public, private, or static methods.\n\u2022 A subclass can override inherited methods.\n\u2022 A subclass may not redefine a public method as private.\n\u2022 A subclass may not override static methods of the superclass.\n\u2022 A subclass should define its own constructors.\n\u2022 A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won\u2019t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters\u2014for example, new int[] {90,90,100}\u2014 will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the classes defined below:\n\npublic class ClassA \n{ \n    //default constructor not shown ... \n    public void method1() \n    { /* implementation of method1 */ } \n} \n\npublic class ClassB extends ClassA \n{ \n    //default constructor not shown ... \n    public void method1() \n    { /* different implementation from method1 in ClassA*/ } \n\n    public void method2() \n    { /* implementation of method2 */ } \n} \n\nThe method1 method in ClassB is an example of \nCorrect: method overriding.\nIncorrect: method overloading.\nIncorrect: polymorphism.\nIncorrect: information hiding.\nIncorrect: procedural abstraction.\n\nEND"}
{"prompt": "Consider the statements\nStudent s = new GradStudent();\nGradStudent g = new GradStudent();\nint x = s.getID(); //compile-time error\nint y = g.getID(); //legal\nBoth s and g represent GradStudent objects, so why does s.getID() cause an error? The reason is that s is of type Student, and the Student class doesn\u2019t have a getID method. At compile time, only nonprivate methods of the Student class can appear to the right of the dot operator when applied to s. Don\u2019t confuse this with polymor phism: getID is not a polymorphic method. It occurs in just the GradStudent class and can therefore be called only by a GradStudent object.\nThe error shown above can be fixed by casting s to the correct type:\nint x = ((GradStudent) s).getID();\nSince s (of type Student) is actually representing a GradStudent object, such a cast can be carried out. Casting a superclass to a subclass type is called a downcast.\n\nNOTE\n1. The outer parentheses are necessary:\nint x = (GradStudent) s.getID();\nwill still cause an error, despite the cast. This is because the dot operator has\nhigher precedence than casting, so s.getID() is invoked before s is cast to\nGradStudent.\n2. The statement\nint y = g.getID();\ncompiles without problem because g is declared to be of type GradStudent, and this is the class that contains getID. No cast is required.\n\nType Rules for Polymorphic Method Calls\na.method(b)\n\nMethod selected by type of a at run time\nParameter b must be of correct type at compile time\n\n\u2022 For a declaration like Superclass a = new Subclass(); the type of a at compile time is Superclass; at run time it is Subclass.\n\u2022 At compile time, method must be found in the class of a, that is, in Superclass. (This is true whether the method is polymorphic or not.) If method cannot be found in the class of a, you need to do an explicit cast on a to its actual type.\n\u2022 For a polymorphic method, at run time the actual type of a is determined\u2014Subclass in this example\u2014and method is selected from Subclass. This could be an inherited method if there is no overriding method.\n\u2022 The type of parameter b is checked at compile time. You may need to do an explicit cast to the subclass type to make this correct.\n\nThe ClassCastException is a run-time exception thrown to signal an attempt to cast an object to a class of which it is not an instance.\nStudent u = new UnderGrad();\nSystem.out.println((String) u); //ClassCastException\n//u is not an instance of String\nint x = ((GradStudent) u).getID(); //ClassCastException\n//u is not an instance of GradStudent\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the classes defined below:\n\npublic class ClassA \n{ \n    //default constructor not shown ... \n    public void method1() \n    { /* implementation of method1 */ } \n} \n\npublic class ClassB extends ClassA \n{ \n    //default constructor not shown ... \n    public void method1() \n    { /* different implementation from method1 in ClassA*/ } \n\n    public void method2() \n    { /* implementation of method2 */ } \n} \n\nConsider the following declarations in a client class. \n\nClassA ob1 = new ClassA(); \nClassA ob2 = new ClassB(); \n\nWhich of the following method calls will cause an error? \nI ob1.method2(); \nII ob2.method2(); \nIII ((ClassB) ob1).method2(); \nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and III onlyEND"}
{"prompt": "An abstract class is a superclass that represents an abstract concept, and therefore should not be instantiated. For example, a maze program could have several different maze components\u2014paths, walls, entrances, and exits. All of these share certain features (e.g., location, and a way of displaying). They can therefore all be declared as subclasses of the abstract class MazeComponent. The program will create path objects, wall objects, and so on, but no instances of MazeComponent.\nAn abstract class may contain abstract methods. An abstract method has no imple mentation code, just a header. The rationale for an abstract method is that there is no good default code for the method. Every subclass will need to override this method, so why bother with a meaningless implementation in the superclass? The method appears in the abstract class as a placeholder. The implementation for the method oc curs in the subclasses. If a class contains any abstract methods, it must be declared an abstract class.\n\nAn abstract class is declared with the keyword abstract in the header:\npublic abstract class AbstractClass\n{ ...\nThe keyword extends is used as before to declare a subclass:\npublic class SubClass extends AbstractClass\n{ ...\nIf a subclass of an abstract class does not provide implementation code for all the abstract methods of its superclass, it too becomes an abstract class and must be declared as such to avoid a compile-time error:\npublic abstract class SubClass extends AbstractClass\n{ ...\nHere is an example of an abstract class, with two concrete (nonabstract) subclasses.\n\npublic abstract class Shape {\n    private String name;\n\n    // constructor\n    public Shape(String shapeName) {\n        name = shapeName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double area();\n\n    public abstract double perimeter();\n\n    public double semiPerimeter() {\n        return perimeter() / 2;\n    }\n}\n\npublic class Circle extends Shape {\n    private double radius;\n\n    // constructor\n    public Circle(double circleRadius, String circleName) {\n        super(circleName);\n        radius = circleRadius;\n    }\n\n    public double perimeter() {\n        return 2 * Math.PI * radius;\n    }\n\n    public double area() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class Square extends Shape {\n    private double side;\n\n    // constructor\n    public Square(double squareSide, String squareName) {\n        super(squareName);\n        side = squareSide;\n    }\n\n    public double perimeter() {\n        return 4 * side;\n    }\n\n    public double area() {\n        return side * side;\n    }\n}\n\nNOTE\n1. It is meaningless to define perimeter and area methods for Shape\u2014thus, these are declared as abstract methods.\n2. An abstract class can have both instance variables and concrete (nonabstract) methods. See, for example, name, getName, and semiPerimeter in the Shape class.\n3. Abstract methods are declared with the keyword abstract. There is no method body. The header is terminated with a semicolon.\n4. A concrete (non-abstract) subclass of an abstract superclass must provide implementation code for all abstract methods of the superclass. Therefore both the Circle and Square classes implement both the perimeter and area methods.\n5. It is possible for an abstract class to have no abstract methods. (An abstract subclass of an abstract superclass inherits the abstract methods without explicitly declaring them.)\n6. An abstract class may or may not have constructors.\n7. No instances can be created for an abstract class:\nShape a = new Shape(\"blob\"); //Illegal.\n//Can\u2019t create instance of abstract class.\nShape c = new Circle(1.5, \"small circle\"); //legal\n8. Polymorphism works with abstract classes as it does with concrete classes:\nShape circ = new Circle(10, \"circle\");\nShape sq = new Square(9.4, \"square\");\nShape s = null;\nSystem.out.println(\"Which shape?\");\nString str = IO.readString(); //read user input\nif (str.equals(\"circle\"))\n    s = circ;\nelse\n    s = sq;\nSystem.out.println(\"Area of \" + s.getName() + \" is \" + s.area());\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the classes defined below:\n\npublic abstract class Solid {\n    private String name;\n\n    // constructor\n    public Solid(String solidName) {\n        name = solidName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double volume();\n}\n\npublic class Sphere extends Solid {\n    private double radius;\n\n    // constructor\n    public Sphere(String sphereName, double sphereRadius) {\n        super(sphereName);\n        radius = sphereRadius;\n    }\n\n    public double volume() {\n        return (4.0 / 3.0) * Math.PI * radius * radius * radius;\n    }\n}\n\npublic class RectangularPrism extends Solid {\n    private double length;\n    private double width;\n    private double height;\n\n    // constructor\n    public RectangularPrism(String prismName, double l, double w, double h) {\n        super(prismName);\n        length = l;\n        width = w;\n        height = h;\n    }\n\n    public double volume() {\n        return length * width * height;\n    }\n}\n\nA program that tests these classes has the following declarations and assignments: \nSolid s1, s2, s3, s4; \ns1 = new Solid(\"blob\"); \ns2 = new Sphere(\"sphere\", 3.8); \ns3 = new RectangularPrism(\"box\", 2, 4, 6.5); \ns4 = null; \n\nHow many of the above lines of code are incorrect? \nCorrect: 1\nIncorrect: 0\nIncorrect: 2\nIncorrect: 3\nIncorrect: 4\n\nEND"}
{"prompt": "An abstract class is a superclass that represents an abstract concept, and therefore should not be instantiated. For example, a maze program could have several different maze components\u2014paths, walls, entrances, and exits. All of these share certain features (e.g., location, and a way of displaying). They can therefore all be declared as subclasses of the abstract class MazeComponent. The program will create path objects, wall objects, and so on, but no instances of MazeComponent.\nAn abstract class may contain abstract methods. An abstract method has no imple mentation code, just a header. The rationale for an abstract method is that there is no good default code for the method. Every subclass will need to override this method, so why bother with a meaningless implementation in the superclass? The method appears in the abstract class as a placeholder. The implementation for the method oc curs in the subclasses. If a class contains any abstract methods, it must be declared an abstract class.\n\nAn abstract class is declared with the keyword abstract in the header:\npublic abstract class AbstractClass\n{ ...\nThe keyword extends is used as before to declare a subclass:\npublic class SubClass extends AbstractClass\n{ ...\nIf a subclass of an abstract class does not provide implementation code for all the abstract methods of its superclass, it too becomes an abstract class and must be declared as such to avoid a compile-time error:\npublic abstract class SubClass extends AbstractClass\n{ ...\nHere is an example of an abstract class, with two concrete (nonabstract) subclasses.\n\npublic abstract class Shape {\n    private String name;\n\n    // constructor\n    public Shape(String shapeName) {\n        name = shapeName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double area();\n\n    public abstract double perimeter();\n\n    public double semiPerimeter() {\n        return perimeter() / 2;\n    }\n}\n\npublic class Circle extends Shape {\n    private double radius;\n\n    // constructor\n    public Circle(double circleRadius, String circleName) {\n        super(circleName);\n        radius = circleRadius;\n    }\n\n    public double perimeter() {\n        return 2 * Math.PI * radius;\n    }\n\n    public double area() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class Square extends Shape {\n    private double side;\n\n    // constructor\n    public Square(double squareSide, String squareName) {\n        super(squareName);\n        side = squareSide;\n    }\n\n    public double perimeter() {\n        return 4 * side;\n    }\n\n    public double area() {\n        return side * side;\n    }\n}\n\nNOTE\n1. It is meaningless to define perimeter and area methods for Shape\u2014thus, these are declared as abstract methods.\n2. An abstract class can have both instance variables and concrete (nonabstract) methods. See, for example, name, getName, and semiPerimeter in the Shape class.\n3. Abstract methods are declared with the keyword abstract. There is no method body. The header is terminated with a semicolon.\n4. A concrete (non-abstract) subclass of an abstract superclass must provide implementation code for all abstract methods of the superclass. Therefore both the Circle and Square classes implement both the perimeter and area methods.\n5. It is possible for an abstract class to have no abstract methods. (An abstract subclass of an abstract superclass inherits the abstract methods without explicitly declaring them.)\n6. An abstract class may or may not have constructors.\n7. No instances can be created for an abstract class:\nShape a = new Shape(\"blob\"); //Illegal.\n//Can\u2019t create instance of abstract class.\nShape c = new Circle(1.5, \"small circle\"); //legal\n8. Polymorphism works with abstract classes as it does with concrete classes:\nShape circ = new Circle(10, \"circle\");\nShape sq = new Square(9.4, \"square\");\nShape s = null;\nSystem.out.println(\"Which shape?\");\nString str = IO.readString(); //read user input\nif (str.equals(\"circle\"))\n    s = circ;\nelse\n    s = sq;\nSystem.out.println(\"Area of \" + s.getName() + \" is \" + s.area());\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the classes defined below:\n\npublic abstract class Solid {\n    private String name;\n\n    // constructor\n    public Solid(String solidName) {\n        name = solidName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double volume();\n}\n\npublic class Sphere extends Solid {\n    private double radius;\n\n    // constructor\n    public Sphere(String sphereName, double sphereRadius) {\n        super(sphereName);\n        radius = sphereRadius;\n    }\n\n    public double volume() {\n        return (4.0 / 3.0) * Math.PI * radius * radius * radius;\n    }\n}\n\npublic class RectangularPrism extends Solid {\n    private double length;\n    private double width;\n    private double height;\n\n    // constructor\n    public RectangularPrism(String prismName, double l, double w, double h) {\n        super(prismName);\n        length = l;\n        width = w;\n        height = h;\n    }\n\n    public double volume() {\n        return length * width * height;\n    }\n}\n\nWhich is false? \nCorrect: Since Solid is abstract and its subclasses are nonabstract, polymorphism no longer applies when these classes are used in a program.\n\n\nIncorrect: If a program has several objects declared as type Solid, the decision about which volume method to call will be resolved at run time.\nIncorrect: If the Solid class were modified to provide a default implementation for the volume method, it would no longer need to be an abstract class.\nIncorrect: If the Sphere and RectangularPrism classes failed to provide an implementation for the volume method, they would need to be declared as abstract classes.\nIncorrect: The fact that there is no reasonable default implementation for the volume method in the Solid class suggests that it should be an abstract method.END"}
{"prompt": "Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization\u20140 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); //calls default constructor of superclass\n}\n\nRules for Subclasses\n\u2022 A subclass can add new private instance variables.\n\u2022 A subclass can add new public, private, or static methods.\n\u2022 A subclass can override inherited methods.\n\u2022 A subclass may not redefine a public method as private.\n\u2022 A subclass may not override static methods of the superclass.\n\u2022 A subclass should define its own constructors.\n\u2022 A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won\u2019t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters\u2014for example, new int[] {90,90,100}\u2014 will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the classes defined below:\n\npublic abstract class Solid {\n    private String name;\n\n    // constructor\n    public Solid(String solidName) {\n        name = solidName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double volume();\n}\n\npublic class Sphere extends Solid {\n    private double radius;\n\n    // constructor\n    public Sphere(String sphereName, double sphereRadius) {\n        super(sphereName);\n        radius = sphereRadius;\n    }\n\n    public double volume() {\n        return (4.0 / 3.0) * Math.PI * radius * radius * radius;\n    }\n}\n\npublic class RectangularPrism extends Solid {\n    private double length;\n    private double width;\n    private double height;\n\n    // constructor\n    public RectangularPrism(String prismName, double l, double w, double h) {\n        super(prismName);\n        length = l;\n        width = w;\n        height = h;\n    }\n\n    public double volume() {\n        return length * width * height;\n    }\n}\n\nHere is a program that prints the volume of a solid: \npublic class SolidMain {\n    /** Output volume of Solid s. */\n    public static void printVolume(Solid s) {\n        System.out.println(\"Volume = \" + s.volume() + \" cubic units\");\n    }\n\n    public static void main(String[] args) {\n        Solid sol;\n        Solid sph = new Sphere(\"sphere\", 4);\n        Solid rec = new RectangularPrism(\"box\", 3, 6, 9);\n        int flipCoin = (int) (Math.random() * 2); // 0 or 1\n        if (flipCoin == 0)\n            sol = sph;\n        else\n            sol = rec;\n        printVolume(sol);\n    }\n}\n\nWhich is a true statement about this program? \nCorrect: It will output the volume of the sphere or box, as intended.\nIncorrect: It will output the volume of the default Solid s, which is neither a sphere nor a box.\nIncorrect: A ClassCastException will be thrown.\nIncorrect: A compile-time error will occur because there is no implementation code for volume in the Solid class.\nIncorrect: A run-time error will occur because of parameter type mismatch in the method call printVolume(sol).\n\nEND"}
{"prompt": "An interface is a collection of related methods, either abstract (headers only) or default (implementation provided in the interface). Default methods are new in Java 8, and will not be tested on the AP exam. Non-default (i.e., abstract) methods will be tested on the exam and are discussed below.\nStudents may be required to design, create, or modify classes that implement inter faces with abstract methods.\nThe non-default methods are both public and abstract\u2014no need to explicitly include these keywords. As such, they provide a framework of behavior for any class.\nThe classes that implement a given interface may represent objects that are vastly different. They all, however, have in common a capability or feature expressed in the methods of the interface. An interface called FlyingObject, for example, may have the methods fly and isFlying. Some classes that implement FlyingObject could be Bird, Airplane, Missile, Butterfly, and Witch. A class called Turtle would be unlikely to implement FlyingObject because turtles don\u2019t fly.\nAn interface called Computable may have just three methods: add, subtract, and multiply. Classes that implement Computable could be Fraction, Matrix, LongInteger, and ComplexNumber. It would not be meaningful, however, for a TelevisionSet to implement Computable\u2014what does it mean, for example, to mul tiply two TelevisionSet objects?\nA class that implements an interface can define any number of methods. In par\n\nticular, it contracts to provide implementations for all the non-default (i.e., abstract) methods declared in the interface. If it fails to implement any of the methods, the class must be declared abstract.\nA nonabstract class that implements an interface must\nimplement every abstract method of the interface.\n\nAn interface is declared with the interface keyword. For example,\npublic interface FlyingObject\n{\n    void fly(); //method that simulates flight of object\n    boolean isFlying(); //true if object is in flight,\n    //false otherwise\n}\n\nInterfaces are implemented using the implements keyword. For example,\npublic class Bird implements FlyingObject\n{\n...\nThis declaration means that two of the methods in the Bird class must be fly and isFlying. Note that any subclass of Bird will automatically implement the interface FlyingObject, since fly and isFlying will be inherited by the subclass.\nA class that extends a superclass can also directly implement an interface. For exam ple,\npublic class Mosquito extends Insect implements FlyingObject\n{\n...\n\nNOTE\n1. The extends clause must precede the implements clause.\n2. A class can have just one superclass, but it can implement any number of interfaces:\npublic class SubClass extends SuperClass\nimplements Interface1, Interface2, ...\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the Computable interface below for performing simple calculator operations: \npublic interface Computable \n{ \n    /** Return this Object + y. */ \n    Object add(Object y); \n\n    /** Return this Object - y. */ \n    Object subtract(Object y); \n\n    /** Return this Object * y. */ \n    Object multiply(Object y); \n} \n\nWhich of the following is the least suitable class for implementing Computable? \nCorrect: BankAccount //implemented with balance\n\n\nIncorrect: LargeInteger //integers with 100 digits or more\nIncorrect: Fraction //implemented with numerator and\n//denominator of type int \nIncorrect: IrrationalNumber //nonrepeating, nonterminating decimal\nIncorrect: Length //implemented with different units, such\n//as inches, centimeters, etc. END"}
{"prompt": "An interface is a collection of related methods, either abstract (headers only) or default (implementation provided in the interface). Default methods are new in Java 8, and will not be tested on the AP exam. Non-default (i.e., abstract) methods will be tested on the exam and are discussed below.\nStudents may be required to design, create, or modify classes that implement inter faces with abstract methods.\nThe non-default methods are both public and abstract\u2014no need to explicitly include these keywords. As such, they provide a framework of behavior for any class.\nThe classes that implement a given interface may represent objects that are vastly different. They all, however, have in common a capability or feature expressed in the methods of the interface. An interface called FlyingObject, for example, may have the methods fly and isFlying. Some classes that implement FlyingObject could be Bird, Airplane, Missile, Butterfly, and Witch. A class called Turtle would be unlikely to implement FlyingObject because turtles don\u2019t fly.\nAn interface called Computable may have just three methods: add, subtract, and multiply. Classes that implement Computable could be Fraction, Matrix, LongInteger, and ComplexNumber. It would not be meaningful, however, for a TelevisionSet to implement Computable\u2014what does it mean, for example, to mul tiply two TelevisionSet objects?\nA class that implements an interface can define any number of methods. In par\n\nticular, it contracts to provide implementations for all the non-default (i.e., abstract) methods declared in the interface. If it fails to implement any of the methods, the class must be declared abstract.\nA nonabstract class that implements an interface must\nimplement every abstract method of the interface.\n\nAn interface is declared with the interface keyword. For example,\npublic interface FlyingObject\n{\n    void fly(); //method that simulates flight of object\n    boolean isFlying(); //true if object is in flight,\n    //false otherwise\n}\n\nInterfaces are implemented using the implements keyword. For example,\npublic class Bird implements FlyingObject\n{\n...\nThis declaration means that two of the methods in the Bird class must be fly and isFlying. Note that any subclass of Bird will automatically implement the interface FlyingObject, since fly and isFlying will be inherited by the subclass.\nA class that extends a superclass can also directly implement an interface. For exam ple,\npublic class Mosquito extends Insect implements FlyingObject\n{\n...\n\nNOTE\n1. The extends clause must precede the implements clause.\n2. A class can have just one superclass, but it can implement any number of interfaces:\npublic class SubClass extends SuperClass\nimplements Interface1, Interface2, ...\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the Player interface defined below:\n\npublic interface Player \n{ \n    /** Return an integer that represents a move in a game. */ \n    int getMove();\n\n    /** Display the status of the game for this Player after \n    * implementing the next move. */ \n    void updateDisplay(); \n} \n\nHumanPlayer is a class that implements the Player interface. Another class, SmartPlayer, is a subclass of HumanPlayer. Which statement is false? \nCorrect: It is not possible to declare a reference of type Player.\nIncorrect: SmartPlayer automatically implements the Player interface.\nIncorrect: HumanPlayermust contain implementations of both the updateDisplay and getMove methods, or be declared as abstract.\nIncorrect: The SmartPlayer class can override the methods updateDisplay and getMove of the HumanPlayer class.\nIncorrect: A method in a client program can have Player as a parameter type.\n\nEND"}
{"prompt": "An interface is a collection of related methods, either abstract (headers only) or default (implementation provided in the interface). Default methods are new in Java 8, and will not be tested on the AP exam. Non-default (i.e., abstract) methods will be tested on the exam and are discussed below.\nStudents may be required to design, create, or modify classes that implement inter faces with abstract methods.\nThe non-default methods are both public and abstract\u2014no need to explicitly include these keywords. As such, they provide a framework of behavior for any class.\nThe classes that implement a given interface may represent objects that are vastly different. They all, however, have in common a capability or feature expressed in the methods of the interface. An interface called FlyingObject, for example, may have the methods fly and isFlying. Some classes that implement FlyingObject could be Bird, Airplane, Missile, Butterfly, and Witch. A class called Turtle would be unlikely to implement FlyingObject because turtles don\u2019t fly.\nAn interface called Computable may have just three methods: add, subtract, and multiply. Classes that implement Computable could be Fraction, Matrix, LongInteger, and ComplexNumber. It would not be meaningful, however, for a TelevisionSet to implement Computable\u2014what does it mean, for example, to mul tiply two TelevisionSet objects?\nA class that implements an interface can define any number of methods. In par\n\nticular, it contracts to provide implementations for all the non-default (i.e., abstract) methods declared in the interface. If it fails to implement any of the methods, the class must be declared abstract.\nA nonabstract class that implements an interface must\nimplement every abstract method of the interface.\n\nAn interface is declared with the interface keyword. For example,\npublic interface FlyingObject\n{\n    void fly(); //method that simulates flight of object\n    boolean isFlying(); //true if object is in flight,\n    //false otherwise\n}\n\nInterfaces are implemented using the implements keyword. For example,\npublic class Bird implements FlyingObject\n{\n...\nThis declaration means that two of the methods in the Bird class must be fly and isFlying. Note that any subclass of Bird will automatically implement the interface FlyingObject, since fly and isFlying will be inherited by the subclass.\nA class that extends a superclass can also directly implement an interface. For exam ple,\npublic class Mosquito extends Insect implements FlyingObject\n{\n...\n\nNOTE\n1. The extends clause must precede the implements clause.\n2. A class can have just one superclass, but it can implement any number of interfaces:\npublic class SubClass extends SuperClass\nimplements Interface1, Interface2, ...\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the Player interface defined below:\n\npublic interface Player \n{ \n    /** Return an integer that represents a move in a game. */ \n    int getMove();\n\n    /** Display the status of the game for this Player after \n    * implementing the next move. */ \n    void updateDisplay(); \n} \n\nA programmer plans to write programs that simulate various games. In each case he will have several classes, each representing a different kind of competitor in the game, such as ExpertPlayer, ComputerPlayer, RecklessPlayer, CheatingPlayer, Beginner, IntermediatePlayer, and so on. It may or may not be suitable for these classes to implement the Player interface, depending on the particular game being simulated. In the games described below, which is the least suitable for having the competitor classes implement the given Player interface? \nCorrect: Chess: Played on a square board of 64 squares of alternating colors. There are just two players, called White and Black, the colors of their respective pieces. The players each have a set of pieces on the board that can move according to a set of rules. The players alternate moves, where a move consists of moving any one piece to another square. If that square is occupied by an opponent\u2019s piece, the piece is captured and removed from the board.\nIncorrect: High-Low Guessing Game: The computer thinks of a number and the competitor who guesses it with the least number of guesses wins. After each guess, the computer tells whether its number is higher or lower than the guess.\nIncorrect: Chips: Start with a pile of chips. Each player in turn removes some number of chips. The winner is the one who removes the final chip. The first player may remove any number of chips, but not all of them. Each subsequent player must remove at least one chip and at most twice the number removed by the preceding player.\nIncorrect: Tic-Tac-Toe: Two players alternate placing \u201cX\u201d or \u201cO\u201d on a 3 \u00d7 3 grid. The first player to get three in a row, where a row can be vertical, horizontal, or diagonal, wins.\nIncorrect: Battleships: There are two players, each with a 10 \u00d7 10 grid hidden from his opponent. Various \u201cships\u201d are placed on the grid. A move consists of calling out a grid location, trying to \u201chit\u201d an opponent\u2019s ship. Players alternate moves. The first player to sink his opponent\u2019s fleet wins.\n\nEND"}
{"prompt": "Starting in 2015, this will not be tested on the AP exam. Students will, however, be required to use compareTo for comparison of strings (p. 178).\nThe standard java.lang package contains the Comparable interface, which provides a useful method for comparing objects.\nClasses written for objects that need to be compared\nshould implement Comparable.\npublic interface Comparable\n{\n    int compareTo(Object obj);\n}\nAny class that implements Comparable must provide a compareTomethod. This method compares the implicit object (this) with the parameter object (obj) and returns a nega tive integer, zero, or a positive integer depending on whether the implicit object is less than, equal to, or greater than the parameter. If the two objects being compared are not type compatible, a ClassCastException is thrown by the method.\nExample\nThe abstract Shape class defined previously (p. 143) is modified to implement the Comparable interface:\npublic abstract class Shape implements Comparable {\n    private String name;\n\n    // constructor\n    public Shape(String shapeName) {\n        name = shapeName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double area();\n\n    public abstract double perimeter();\n\n    public double semiPerimeter() {\n        return perimeter() / 2;\n    }\n\n    public int compareTo(Object obj) {\n        final double EPSILON = 1.0e-15; // slightly bigger than //machine precision\n        Shape rhs = (Shape) obj;\n        double diff = area() - rhs.area();\n        if (Math.abs(diff) <= EPSILON * Math.abs(area()))\n            return 0; // area of this shape equals area of obj\n        else if (diff < 0)\n            return -1; // area of this shape less than area of obj\n        else\n            return 1; // area of this shape greater than area of obj }\n    }\n}\n\nNOTE\n1. The Circle, Square, and other subclasses of Shape will all automatically imple ment Comparable and inherit the compareTo method.\n2. It is tempting to use a simpler test for equality of areas, namely\nif (diff == 0)\nreturn 0;\nBut recall that real numbers can have round-off errors in their storage (Box p. 65). This means that the simple test may return false even though the two areas are essentially equal. A more robust test is implemented in the code given, namely to test if the relative error in diff is small enough to be considered zero.\n3. The Object class is a universal superclass (see p. 174). This means that the compareTo method can take as a parameter any object reference that imple ments Comparable.\n4. One of the first steps of a compareTo method must cast the Object argument to the class type, in this case Shape. If this is not done, the compiler won\u2019t find the area method\u2014remember, an Object is not necessarily a Shape.\n5. The algorithm one chooses in compareTo should in general be consistent with the equals method (see p. 176): Whenever object1.equals(object2) returns true, object1.compareTo(object2) returns 0.\nHere is a program that finds the larger of two Comparable objects.\n\npublic class FindMaxTest {\n    /** Return the larger of two objects a and b. */\n    public static Comparable max(Comparable a, Comparable b) {\n        if (a.compareTo(b) > 0) // if a > b ...\n            return a;\n        else\n            return b;\n    }\n\n    public static void main(String[] args) {\n        Shape s1 = new Circle(3.0, \"circle\");\n        Shape s2 = new Square(4.5, \"square\");\n        System.out.println(\"Area of \" + s1.getName() + \" is \" +\n                s1.area());\n        System.out.println(\"Area of \" + s2.getName() + \" is \" +\n                s2.area());\n        Shape s3 = (Shape) max(s1, s2);\n        System.out.println(\"The larger shape is the \" +\n                s3.getName());\n    }\n}\n\nHere is the output:\nArea of circle is 28.27\nArea of square is 20.25\nThe larger shape is the circle\n\nNOTE\n1. The max method takes parameters of type Comparable. Since s1 is-a Comparable object and s2 is-a Comparable object, no casting is necessary in the method call.\n2. The max method can be called with any two Comparable objects, for example, two String objects or two Integer objects (see Chapter 4).\n3. The objects must be type compatible (i.e., it must make sense to compare them). For example, in the program shown, if s1 is-a Shape and s2 is-a String, the compareTo method will throw a ClassCastException at the line\nShape rhs = (Shape) obj;\n4. The cast is needed in the line\nShape s3 = (Shape) max(s1, s2);\nsince max(s1, s2) returns a Comparable.\n5. A primitive type is not an object and therefore cannot be passed as Comparable. You can, however, use a wrapper class and in this way convert a primitive type to a Comparable (see p. 180).\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the interface and classes defined below:\n\npublic interface Player \n{ \n    /** Return an integer that represents a move in a game. */ \n    int getMove();\n\n    /** Display the status of the game for this Player after \n    * implementing the next move. */ \n    void updateDisplay(); \n} \n\npublic class HumanPlayer implements Player {\n    private String name;\n\n    // Constructors not shown ...\n    // Code to implement getMove and updateDisplay not shown ...\n    public String getName() { /* implementation not shown */ }\n}\n\npublic class ExpertPlayer extends HumanPlayer {\n    private int rating;\n\n    // Constructors not shown ...\n    public int compareTo(ExpertPlayer expert) { /* implementation not shown */ }\n}\n\nWhich code segment in a client program will cause an error? \nI Player p1 = new HumanPlayer(); \nPlayer p2 = new ExpertPlayer(); \nint x1 = p1.getMove(); \nint x2 = p2.getMove(); \nII int x; \nPlayer c1 = new ExpertPlayer(/* correct parameter list */); \nPlayer c2 = new ExpertPlayer(/* correct parameter list */); \nif (c1.compareTo(c2) < 0) \n    x = c1.getMove(); \nelse \n    x = c2.getMove(); \nIII int x; \nHumanPlayer h1 = new HumanPlayer(/* correct parameter list */); \nHumanPlayer h2 = new HumanPlayer(/* correct parameter list */); \nif (h1.compareTo(h2) < 0) \n    x = h1.getMove(); \nelse \n    x = h2.getMove(); \nCorrect: II and III only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\nIncorrect: None\n\nEND"}
{"prompt": "Starting in 2015, this will not be tested on the AP exam. Students will, however, be required to use compareTo for comparison of strings (p. 178).\nThe standard java.lang package contains the Comparable interface, which provides a useful method for comparing objects.\nClasses written for objects that need to be compared\nshould implement Comparable.\npublic interface Comparable\n{\n    int compareTo(Object obj);\n}\nAny class that implements Comparable must provide a compareTomethod. This method compares the implicit object (this) with the parameter object (obj) and returns a nega tive integer, zero, or a positive integer depending on whether the implicit object is less than, equal to, or greater than the parameter. If the two objects being compared are not type compatible, a ClassCastException is thrown by the method.\nExample\nThe abstract Shape class defined previously (p. 143) is modified to implement the Comparable interface:\npublic abstract class Shape implements Comparable {\n    private String name;\n\n    // constructor\n    public Shape(String shapeName) {\n        name = shapeName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double area();\n\n    public abstract double perimeter();\n\n    public double semiPerimeter() {\n        return perimeter() / 2;\n    }\n\n    public int compareTo(Object obj) {\n        final double EPSILON = 1.0e-15; // slightly bigger than //machine precision\n        Shape rhs = (Shape) obj;\n        double diff = area() - rhs.area();\n        if (Math.abs(diff) <= EPSILON * Math.abs(area()))\n            return 0; // area of this shape equals area of obj\n        else if (diff < 0)\n            return -1; // area of this shape less than area of obj\n        else\n            return 1; // area of this shape greater than area of obj }\n    }\n}\n\nNOTE\n1. The Circle, Square, and other subclasses of Shape will all automatically imple ment Comparable and inherit the compareTo method.\n2. It is tempting to use a simpler test for equality of areas, namely\nif (diff == 0)\nreturn 0;\nBut recall that real numbers can have round-off errors in their storage (Box p. 65). This means that the simple test may return false even though the two areas are essentially equal. A more robust test is implemented in the code given, namely to test if the relative error in diff is small enough to be considered zero.\n3. The Object class is a universal superclass (see p. 174). This means that the compareTo method can take as a parameter any object reference that imple ments Comparable.\n4. One of the first steps of a compareTo method must cast the Object argument to the class type, in this case Shape. If this is not done, the compiler won\u2019t find the area method\u2014remember, an Object is not necessarily a Shape.\n5. The algorithm one chooses in compareTo should in general be consistent with the equals method (see p. 176): Whenever object1.equals(object2) returns true, object1.compareTo(object2) returns 0.\nHere is a program that finds the larger of two Comparable objects.\n\npublic class FindMaxTest {\n    /** Return the larger of two objects a and b. */\n    public static Comparable max(Comparable a, Comparable b) {\n        if (a.compareTo(b) > 0) // if a > b ...\n            return a;\n        else\n            return b;\n    }\n\n    public static void main(String[] args) {\n        Shape s1 = new Circle(3.0, \"circle\");\n        Shape s2 = new Square(4.5, \"square\");\n        System.out.println(\"Area of \" + s1.getName() + \" is \" +\n                s1.area());\n        System.out.println(\"Area of \" + s2.getName() + \" is \" +\n                s2.area());\n        Shape s3 = (Shape) max(s1, s2);\n        System.out.println(\"The larger shape is the \" +\n                s3.getName());\n    }\n}\n\nHere is the output:\nArea of circle is 28.27\nArea of square is 20.25\nThe larger shape is the circle\n\nNOTE\n1. The max method takes parameters of type Comparable. Since s1 is-a Comparable object and s2 is-a Comparable object, no casting is necessary in the method call.\n2. The max method can be called with any two Comparable objects, for example, two String objects or two Integer objects (see Chapter 4).\n3. The objects must be type compatible (i.e., it must make sense to compare them). For example, in the program shown, if s1 is-a Shape and s2 is-a String, the compareTo method will throw a ClassCastException at the line\nShape rhs = (Shape) obj;\n4. The cast is needed in the line\nShape s3 = (Shape) max(s1, s2);\nsince max(s1, s2) returns a Comparable.\n5. A primitive type is not an object and therefore cannot be passed as Comparable. You can, however, use a wrapper class and in this way convert a primitive type to a Comparable (see p. 180).\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the interface and classes defined below:\n\npublic interface Player \n{ \n    /** Return an integer that represents a move in a game. */ \n    int getMove();\n\n    /** Display the status of the game for this Player after \n    * implementing the next move. */ \n    void updateDisplay(); \n} \n\npublic class HumanPlayer implements Player {\n    private String name;\n\n    // Constructors not shown ...\n    // Code to implement getMove and updateDisplay not shown ...\n    public String getName() { /* implementation not shown */ }\n}\n\npublic class ExpertPlayer extends HumanPlayer {\n    private int rating;\n\n    // Constructors not shown ...\n    public int compareTo(ExpertPlayer expert) { /* implementation not shown */ }\n}\n\nWhich of the following is correct implementation code for the compareTo method in the ExpertPlayer class? \nI if (rating == expert.rating) \n    return 0; \nelse if (rating < expert.rating) \n    return -1; \nelse \n    return 1; \nII return rating - expert.rating; \nIII if (getName().equals(expert.getName())) \n    return 0; \nelse if (getName().compareTo(expert.getName()) < 0) \n    return -1; \nelse \n    return 1; \nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II onlyEND"}
{"prompt": "Starting in 2015, this will not be tested on the AP exam. Students will, however, be required to use compareTo for comparison of strings (p. 178).\nThe standard java.lang package contains the Comparable interface, which provides a useful method for comparing objects.\nClasses written for objects that need to be compared\nshould implement Comparable.\npublic interface Comparable\n{\n    int compareTo(Object obj);\n}\nAny class that implements Comparable must provide a compareTomethod. This method compares the implicit object (this) with the parameter object (obj) and returns a nega tive integer, zero, or a positive integer depending on whether the implicit object is less than, equal to, or greater than the parameter. If the two objects being compared are not type compatible, a ClassCastException is thrown by the method.\nExample\nThe abstract Shape class defined previously (p. 143) is modified to implement the Comparable interface:\npublic abstract class Shape implements Comparable {\n    private String name;\n\n    // constructor\n    public Shape(String shapeName) {\n        name = shapeName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double area();\n\n    public abstract double perimeter();\n\n    public double semiPerimeter() {\n        return perimeter() / 2;\n    }\n\n    public int compareTo(Object obj) {\n        final double EPSILON = 1.0e-15; // slightly bigger than //machine precision\n        Shape rhs = (Shape) obj;\n        double diff = area() - rhs.area();\n        if (Math.abs(diff) <= EPSILON * Math.abs(area()))\n            return 0; // area of this shape equals area of obj\n        else if (diff < 0)\n            return -1; // area of this shape less than area of obj\n        else\n            return 1; // area of this shape greater than area of obj }\n    }\n}\n\nNOTE\n1. The Circle, Square, and other subclasses of Shape will all automatically imple ment Comparable and inherit the compareTo method.\n2. It is tempting to use a simpler test for equality of areas, namely\nif (diff == 0)\nreturn 0;\nBut recall that real numbers can have round-off errors in their storage (Box p. 65). This means that the simple test may return false even though the two areas are essentially equal. A more robust test is implemented in the code given, namely to test if the relative error in diff is small enough to be considered zero.\n3. The Object class is a universal superclass (see p. 174). This means that the compareTo method can take as a parameter any object reference that imple ments Comparable.\n4. One of the first steps of a compareTo method must cast the Object argument to the class type, in this case Shape. If this is not done, the compiler won\u2019t find the area method\u2014remember, an Object is not necessarily a Shape.\n5. The algorithm one chooses in compareTo should in general be consistent with the equals method (see p. 176): Whenever object1.equals(object2) returns true, object1.compareTo(object2) returns 0.\nHere is a program that finds the larger of two Comparable objects.\n\npublic class FindMaxTest {\n    /** Return the larger of two objects a and b. */\n    public static Comparable max(Comparable a, Comparable b) {\n        if (a.compareTo(b) > 0) // if a > b ...\n            return a;\n        else\n            return b;\n    }\n\n    public static void main(String[] args) {\n        Shape s1 = new Circle(3.0, \"circle\");\n        Shape s2 = new Square(4.5, \"square\");\n        System.out.println(\"Area of \" + s1.getName() + \" is \" +\n                s1.area());\n        System.out.println(\"Area of \" + s2.getName() + \" is \" +\n                s2.area());\n        Shape s3 = (Shape) max(s1, s2);\n        System.out.println(\"The larger shape is the \" +\n                s3.getName());\n    }\n}\n\nHere is the output:\nArea of circle is 28.27\nArea of square is 20.25\nThe larger shape is the circle\n\nNOTE\n1. The max method takes parameters of type Comparable. Since s1 is-a Comparable object and s2 is-a Comparable object, no casting is necessary in the method call.\n2. The max method can be called with any two Comparable objects, for example, two String objects or two Integer objects (see Chapter 4).\n3. The objects must be type compatible (i.e., it must make sense to compare them). For example, in the program shown, if s1 is-a Shape and s2 is-a String, the compareTo method will throw a ClassCastException at the line\nShape rhs = (Shape) obj;\n4. The cast is needed in the line\nShape s3 = (Shape) max(s1, s2);\nsince max(s1, s2) returns a Comparable.\n5. A primitive type is not an object and therefore cannot be passed as Comparable. You can, however, use a wrapper class and in this way convert a primitive type to a Comparable (see p. 180).\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: Which of the following classes is the least suitable candidate for containing a compareTo method? \nCorrect: public class Point\n{ \n    private double x; \n    private double y; \n    //various methods follow \n    ... \n} \nIncorrect: public class Name\n{ \n    private String firstName; \n    private String lastName; \n    //various methods follow \n    ... \n} \nIncorrect: public class Car\n{ \n    private int modelNumber; \n    private int year; \n    private double price; \n    //various methods follow \n    ... \n} \nIncorrect: public class Student\n{ \n    private String name; \n    private double gpa; \n    //various methods follow \n    ... \n} \nIncorrect: public class Employee\n{ \n    private String name; \n    private int hireDate; \n    private double salary; \n    //various methods follow \n    ... \n}\n\nEND"}
{"prompt": "Consider writing a program that simulates a game of Battleships. The program may have a Ship class with subclasses Submarine, Cruiser, Destroyer, and so on. The various ships will be placed in a two-dimensional grid that represents a part of the ocean.\nAn abstract class Ship is a good design choice. There will not be any instances of Ship objects because the specific features of the subclasses must be known in order to place these ships in the grid. A Grid interface that manipulates objects in a two dimensional setting suggests itself for the two-dimensional grid.\nNotice that the abstract Ship class is specific to the Battleships application, whereas the Grid interface is not. You could use the Grid interface in any program that has a two-dimensional grid.\n\nInterface vs. Abstract Class\n\u2022 Use an abstract class for an object that is application-specific\nbut incomplete without its subclasses.\n\u2022 Consider using an interface when its methods are suitable\nfor your program but could be equally applicable in a vari\nety of programs.\n\u2022 An interface typically doesn\u2019t provide implementations for\nany of its methods, whereas an abstract class does. (In Java 8,\nimplementation of default methods is allowed in interfaces.)\n\u2022 An interface cannot contain instance variables, whereas an\nabstract class can.\n\u2022 It is not possible to create an instance of an interface object\nor an abstract class object.\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: A programmer has the task of maintaining a database of students of a large university. There are two types of students, undergraduates and graduate students. About a third of the graduate students are doctoral candidates. All of the students have the same personal information stored, like name, address, and phone number, and also student information like courses taken and grades. Each student\u2019s GPA is computed, but differently for undergraduates and graduates. The doctoral candidates have information about their dissertations and faculty advisors. \nThe programmer will write a Java program to handle all the student information. Which of the following is the best design, in terms of programmer efficiency and code reusability? Note: { ... } denotes class code. \nCorrect: public abstract class Student { ...}\npublic class Undergraduate extends Student { ... } \npublic class Graduate extends Student { ... } \npublic class DocStudent extends Graduate { ... } \nIncorrect: public interface Student { ...}\npublic class Undergraduate implements Student { ... } \npublic class Graduate implements Student { ... } \npublic class DocStudent extends Graduate { ... } \nIncorrect: public class Student { ...}\npublic class Undergraduate extends Student { ... } \npublic class Graduate extends Student { ... } \npublic class DocStudent extends Graduate { ... } \nIncorrect: public abstract class Student { ...}\npublic class Undergraduate extends Student { ... } \npublic class Graduate extends Student { ... } \npublic class DocStudent extends Student { ... } \nIncorrect: public interface PersonalInformation { ... }\npublic class Student implements PersonalInformation { ...} \npublic class Undergraduate extends Student { ... } \npublic abstract class Graduate extends Student { ... } \npublic class DocStudent extends Graduate { ... }\n\nEND"}
{"prompt": "Starting in 2015, this will not be tested on the AP exam. Students will, however, be required to use compareTo for comparison of strings (p. 178).\nThe standard java.lang package contains the Comparable interface, which provides a useful method for comparing objects.\nClasses written for objects that need to be compared\nshould implement Comparable.\npublic interface Comparable\n{\n    int compareTo(Object obj);\n}\nAny class that implements Comparable must provide a compareTomethod. This method compares the implicit object (this) with the parameter object (obj) and returns a nega tive integer, zero, or a positive integer depending on whether the implicit object is less than, equal to, or greater than the parameter. If the two objects being compared are not type compatible, a ClassCastException is thrown by the method.\nExample\nThe abstract Shape class defined previously (p. 143) is modified to implement the Comparable interface:\npublic abstract class Shape implements Comparable {\n    private String name;\n\n    // constructor\n    public Shape(String shapeName) {\n        name = shapeName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double area();\n\n    public abstract double perimeter();\n\n    public double semiPerimeter() {\n        return perimeter() / 2;\n    }\n\n    public int compareTo(Object obj) {\n        final double EPSILON = 1.0e-15; // slightly bigger than //machine precision\n        Shape rhs = (Shape) obj;\n        double diff = area() - rhs.area();\n        if (Math.abs(diff) <= EPSILON * Math.abs(area()))\n            return 0; // area of this shape equals area of obj\n        else if (diff < 0)\n            return -1; // area of this shape less than area of obj\n        else\n            return 1; // area of this shape greater than area of obj }\n    }\n}\n\nNOTE\n1. The Circle, Square, and other subclasses of Shape will all automatically imple ment Comparable and inherit the compareTo method.\n2. It is tempting to use a simpler test for equality of areas, namely\nif (diff == 0)\nreturn 0;\nBut recall that real numbers can have round-off errors in their storage (Box p. 65). This means that the simple test may return false even though the two areas are essentially equal. A more robust test is implemented in the code given, namely to test if the relative error in diff is small enough to be considered zero.\n3. The Object class is a universal superclass (see p. 174). This means that the compareTo method can take as a parameter any object reference that imple ments Comparable.\n4. One of the first steps of a compareTo method must cast the Object argument to the class type, in this case Shape. If this is not done, the compiler won\u2019t find the area method\u2014remember, an Object is not necessarily a Shape.\n5. The algorithm one chooses in compareTo should in general be consistent with the equals method (see p. 176): Whenever object1.equals(object2) returns true, object1.compareTo(object2) returns 0.\nHere is a program that finds the larger of two Comparable objects.\n\npublic class FindMaxTest {\n    /** Return the larger of two objects a and b. */\n    public static Comparable max(Comparable a, Comparable b) {\n        if (a.compareTo(b) > 0) // if a > b ...\n            return a;\n        else\n            return b;\n    }\n\n    public static void main(String[] args) {\n        Shape s1 = new Circle(3.0, \"circle\");\n        Shape s2 = new Square(4.5, \"square\");\n        System.out.println(\"Area of \" + s1.getName() + \" is \" +\n                s1.area());\n        System.out.println(\"Area of \" + s2.getName() + \" is \" +\n                s2.area());\n        Shape s3 = (Shape) max(s1, s2);\n        System.out.println(\"The larger shape is the \" +\n                s3.getName());\n    }\n}\n\nHere is the output:\nArea of circle is 28.27\nArea of square is 20.25\nThe larger shape is the circle\n\nNOTE\n1. The max method takes parameters of type Comparable. Since s1 is-a Comparable object and s2 is-a Comparable object, no casting is necessary in the method call.\n2. The max method can be called with any two Comparable objects, for example, two String objects or two Integer objects (see Chapter 4).\n3. The objects must be type compatible (i.e., it must make sense to compare them). For example, in the program shown, if s1 is-a Shape and s2 is-a String, the compareTo method will throw a ClassCastException at the line\nShape rhs = (Shape) obj;\n4. The cast is needed in the line\nShape s3 = (Shape) max(s1, s2);\nsince max(s1, s2) returns a Comparable.\n5. A primitive type is not an object and therefore cannot be passed as Comparable. You can, however, use a wrapper class and in this way convert a primitive type to a Comparable (see p. 180).\n\n\nThe following question asks about writing or replacing code with multiple options:\n\n###\n\n", "completion": "Question: Consider the Orderable interface and the partial implementation of the Temperature class defined below:\n\npublic interface Orderable {\n    /**\n     * Returns -1, 0, or 1 depending on whether the implicit\n     * object is less than, equal to, or greater than other.\n     */\n    int compareTo(Object other);\n}\n\npublic class Temperature implements Orderable {\n    private String scale;\n    private double degrees;\n\n    // default constructor\n    public Temperature() { /* implementation not shown */ }\n\n    // constructor\n    public Temperature(String tempScale, double tempDegrees) { /* implementation not shown */ }\n\n    public int compareTo(Object obj) { /* implementation not shown */ }\n\n    public String toString() { /* implementation not shown */ }\n    // Other methods are not shown.\n}\n\nHere is a program that finds the lowest of three temperatures:\n\npublic class TemperatureMain {\n    /** Find smaller of objects a and b. */\n    public static Orderable min(Orderable a, Orderable b) {\n        if (a.compareTo(b) < 0)\n            return a;\n        else\n            return b;\n    }\n\n    /** Find smallest of objects a, b, and c. */\n    public static Orderable minThree(Orderable a, Orderable b, Orderable c) {\n        return min(min(a, b), c);\n    }\n\n    public static void main(String[] args) { /* code to test minThree method */ }\n}\n\nWhich are correct replacements for /* code to test minThree method */? \nI Temperature t1 = new Temperature(\"C\", 85); \nTemperature t2 = new Temperature(\"F\", 45); \nTemperature t3 = new Temperature(\"F\", 120); \nSystem.out.println(\"The lowest temperature is \" + \nminThree(t1, t2, t3)); \nII Orderable c1 = new Temperature(\"C\", 85); \nOrderable c2 = new Temperature(\"F\", 45); \nOrderable c3 = new Temperature(\"F\", 120); \nSystem.out.println(\"The lowest temperature is \" + \nminThree(c1, c2, c3)); \nIII Orderable c1 = new Orderable(\"C\", 85); \nOrderable c2 = new Orderable(\"F\", 45); \nOrderable c3 = new Orderable(\"F\", 120); \nSystem.out.println(\"The lowest temperature is \" + \nminThree(c1, c2, c3)); \nCorrect: I and II only\nIncorrect: II only\nIncorrect: II and III only\nIncorrect: I and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "An interface is a collection of related methods, either abstract (headers only) or default (implementation provided in the interface). Default methods are new in Java 8, and will not be tested on the AP exam. Non-default (i.e., abstract) methods will be tested on the exam and are discussed below.\nStudents may be required to design, create, or modify classes that implement inter faces with abstract methods.\nThe non-default methods are both public and abstract\u2014no need to explicitly include these keywords. As such, they provide a framework of behavior for any class.\nThe classes that implement a given interface may represent objects that are vastly different. They all, however, have in common a capability or feature expressed in the methods of the interface. An interface called FlyingObject, for example, may have the methods fly and isFlying. Some classes that implement FlyingObject could be Bird, Airplane, Missile, Butterfly, and Witch. A class called Turtle would be unlikely to implement FlyingObject because turtles don\u2019t fly.\nAn interface called Computable may have just three methods: add, subtract, and multiply. Classes that implement Computable could be Fraction, Matrix, LongInteger, and ComplexNumber. It would not be meaningful, however, for a TelevisionSet to implement Computable\u2014what does it mean, for example, to mul tiply two TelevisionSet objects?\nA class that implements an interface can define any number of methods. In par\n\nticular, it contracts to provide implementations for all the non-default (i.e., abstract) methods declared in the interface. If it fails to implement any of the methods, the class must be declared abstract.\nA nonabstract class that implements an interface must\nimplement every abstract method of the interface.\n\nAn interface is declared with the interface keyword. For example,\npublic interface FlyingObject\n{\n    void fly(); //method that simulates flight of object\n    boolean isFlying(); //true if object is in flight,\n    //false otherwise\n}\n\nInterfaces are implemented using the implements keyword. For example,\npublic class Bird implements FlyingObject\n{\n...\nThis declaration means that two of the methods in the Bird class must be fly and isFlying. Note that any subclass of Bird will automatically implement the interface FlyingObject, since fly and isFlying will be inherited by the subclass.\nA class that extends a superclass can also directly implement an interface. For exam ple,\npublic class Mosquito extends Insect implements FlyingObject\n{\n...\n\nNOTE\n1. The extends clause must precede the implements clause.\n2. A class can have just one superclass, but it can implement any number of interfaces:\npublic class SubClass extends SuperClass\nimplements Interface1, Interface2, ...\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: A certain interface provided by a Java package contains just a single method: \n\npublic interface SomeName \n{ \n    int method1(Object o); \n} \n\nA programmer adds some functionality to this interface by adding another abstract method to it, method2: \n\npublic interface SomeName \n{ \n    int method1(Object ob1); \n    void method2(Object ob2); \n} \n\nAs a result of this addition, which of the following is true? \nCorrect: All classes that implement the original SomeName interface will need to be rewritten because they no longer implement SomeName.\nIncorrect: A ClassCastException will occur if ob1 and ob2 are not compatible.\nIncorrect: A class that implements the original SomeName interface will need to modify its declaration as follows:\npublic class ClassName implements SomeName extends method2 \n{ ... \nIncorrect: SomeName will need to be changed to an abstract class and provide implementation code for method2, so that the original and upgraded versions of SomeName are compatible.\nIncorrect: Any new class that implements the upgraded version of SomeName will not compile.END"}
{"prompt": "Selection and insertion sorts are inefficient for large n, requiring approximately n passes through a list of n elements. More efficient algorithms can be devised using a \u201cdivide-and-conquer\u201d approach, which is used in both the sorting algorithms that follow.\n\nMergesort\nHere is a recursive description of how mergesort works:\n\nIf there is more than one element in the array\n    Break the array into two halves.\n    Mergesort the left half.\n    Mergesort the right half.\n    Merge the two subarrays into a sorted array.\n\nMergesort uses a merge method to merge two sorted pieces of an array into a single sorted array. For example, suppose array a[0] . . . a[n-1] is such that a[0] . . . a[k] is sorted and a[k+1] . . . a[n-1] is sorted, both parts in increasing order. Example:\na[0] a[1] a[2] a[3] a[4] a[5]\n2 5 8 9 1 6\n\nIn this case, a[0] . . . a[3] and a[4] . . . a[5] are the two sorted pieces. The method call merge(a,0,3,5) should produce the \u201cmerged\u201d array:\na[0] a[1] a[2] a[3] a[4] a[5]\n1 2 5 6 8 9\n\nThe middle numerical parameter in merge (the 3 in this case) represents the index of the last element in the first \u201cpiece\u201d of the array. The first and third numerical parameters are the lowest and highest index, respectively, of array a.\nHere\u2019s what happens in mergesort:\n1. Start with an unsorted list of n elements.\n2. The recursive calls break the list into n sublists, each of length 1. Note that these n arrays, each containing just one element, are sorted!\n3. Recursively merge adjacent pairs of lists. There are then approximately n/2 lists of length 2; then, approximately n/4 lists of approximate length 4, and so on, until there is just one list of length n.\n\nAnalysis of Mergesort:\n1. The major disadvantage of mergesort is that it needs a temporary array that is as large as the original array to be sorted. This could be a problem if space is a factor.\n2. Mergesort is not affected by the initial ordering of the elements. Thus, best, worst, and average cases have similar run times.\n\nFor large n, quicksort is, on average, the fastest known sorting algorithm. Here is a recursive description of how quicksort works:\n\nIf there are at least two elements in the array\n    Partition the array.\n    Quicksort the left subarray.\n    Quicksort the right subarray.\n\nThe partition method splits the array into two subarrays as follows: a pivot element is chosen at random from the array (often just the first element) and placed so that all items to the left of the pivot are less than or equal to the pivot, whereas those to the right are greater than or equal to it.\nFor example, if the array is 4, 1, 2, 7, 5, \u22121, 8, 0, 6, and a[0] = 4 is the pivot, the partition method produces\n\u22121 1 2 0 4 5 8 7 6\n\nHere\u2019s how the partitioning works: Let a[0], 4 in this case, be the pivot. Markers up and down are initialized to index values 0 and n \u2212 1, as shown. Move the up marker until a value less than the pivot is found, or down equals up. Move the down marker until a value greater than the pivot is found, or down equals up. Swap a[up] and a[down]. Continue the process until down equals up. This is the pivot position. Swap a[0] and a[pivotPosition].\nNotice that the pivot element, 4, is in its final sorted position.\n\nAnalysis of Quicksort:\n1. For the fastest run time, the array should be partitioned into two parts of roughly the same size.\n2. If the pivot happens to be the smallest or largest element in the array, the split is not much of a split\u2014one of the subarrays is empty! If this happens repeatedly, quicksort degenerates into a slow, recursive version of selection sort and is very inefficient.\n3. The worst case for quicksort occurs when the partitioning algorithm repeatedly divides the array into pieces of size 1 and n \u2212 1. An example is when the array is initially sorted in either order and the first or last element is chosen as the pivot. Some algorithms avoid this situation by initially shuffling up the given array (!) or selecting the pivot by examining several elements of the array (such as first, middle, and last) and then taking the median.\n\nNOTE\nFor both quicksort and mergesort, when a subarray gets down to some small size m, it becomes faster to sort by straight insertion. The optimal value of m is machine dependent, but it\u2019s approximately equal to 7.\n\n\nThe following question asks about general programming knowledge with multiple options:\n\n###\n\n", "completion": "Question: The decision to choose a particular sorting algorithm should be made based on \nI Run-time efficiency of the sort \nII Size of the array \nIII Space efficiency of the algorithm \nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II onlyEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about writing or replacing code:\n\n###\n\n", "completion": "Question: The following code fragment does a sequential search to determine whether a given integer, value, is stored in an array a[0]...a[n-1]. \n\nint i = 0; \nwhile (/* boolean expression */) \n{ \n    i++; \n} \nif (i == n) \n    return -1; //value not found \nelse \n    return i; // value found at location i \n\nWhich of the following should replace /* boolean expression */ so that the algorithm works as intended? \nCorrect: i < n && value != a[i]\nIncorrect: value != a[i]\nIncorrect: i < n && value == a[i]\nIncorrect: value != a[i] && i < n\nIncorrect: i < n || value != a[i]\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about general programming knowledge:\n\n###\n\n", "completion": "Question: A feature of data that is used for a binary search but not necessarily used for a sequential search is \nCorrect: order of data.\nIncorrect: length of list.\nIncorrect: type of data.\nIncorrect: smallest value in the list.\nIncorrect: median value of the data.\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about a hypothetical program or design choice with multiple options:\n\n###\n\n", "completion": "Question: Array unsortedArr contains an unsorted list of integers. Array sortedArr contains a sorted list of integers. Which of the following operations is more efficient for sortedArr than unsortedArr? Assume the most efficient algorithms are used. \nI Inserting a new element \nII Searching for a given element \nIII Computing the mean of the elements \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: An algorithm for searching a large sorted array for a specific value x compares every third item in the array to x until it finds one that is greater than or equal to x. When a larger value is found, the algorithm compares x to the previous two items. If the array is sorted in increasing order, which of the following describes all cases when this algorithm uses fewer comparisons to find x than would a binary search? \nCorrect: When x is very close to the beginning of the array\nIncorrect: It will never use fewer comparisons.\nIncorrect: When x is in the middle position of the array\nIncorrect: When x is very close to the end of the array\nIncorrect: When x is not in the array\n\nEND"}
{"prompt": "In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a \u201csearch-and-swap\u201d algorithm. Here\u2019s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is \u201cit,\u201d the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that \u201cit\u201d is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: Assume that a[0]...a[N-1] is an array of N positive integers and that the following assertion is true: \na[0] > a[k] for all k such that 0 < k < N \nWhich of the following must be true? \nCorrect: a[0] holds the largest value in the array.\n\n\nIncorrect: The array is sorted in ascending order.\nIncorrect: The array is sorted in descending order.\nIncorrect: All values in the array are different.\nIncorrect: a[0] holds the smallest value in the array.END"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: The following code is designed to set index to the location of the first occurrence of key in array a and to set index to \u22121 if key is not in a. \n\nindex = 0; \nwhile (a[index] != key) \n    index++; \nif (a[index] != key) \n    index = -1; \n\nIn which case will this program definitely fail to perform the task described? \nCorrect: When key is not in the array\nIncorrect: When key is the first element of the array\nIncorrect: When key is the last element of the array\nIncorrect: When key equals 0\nIncorrect: When key equals a[key]\n\nEND"}
{"prompt": "In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a \u201csearch-and-swap\u201d algorithm. Here\u2019s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is \u201cit,\u201d the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that \u201cit\u201d is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the following class. \n\n/**\n * A class that sorts an array of Integer objects from\n * largest to smallest using a selection sort.\n */\npublic class Sorter {\n    private Integer[] a;\n\n    public Sorter(Integer[] arr) {\n        a = arr;\n    }\n\n    /** Swap a[i] and a[j] in array a. */\n    private void swap(int i, int j) { /* implementation not shown */ }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of Integer objects.\n     */\n    public void selectionSort() {\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[n-1]\n            Integer max = a[i];\n            int maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max.compareTo(a[j]) < 0) // max less than a[j]\n                {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nIf an array of Integer contains the following elements, what would the array look like after the third pass of selectionSort, sorting from high to low? \n89 42 \u2212 3 13 109 70 2 \nCorrect: 109 89 70 13 42 \u22123 2\nIncorrect: 109 89 70 42 13 2 \u22123\nIncorrect: 109 89 70 \u22123 2 13 42\nIncorrect: 89 42 13 \u22123 109 70 2\nIncorrect: 109 89 42 \u22123 13 70 2\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Refer to method search. \n\n/** @param v an initialized array of integers \n* @param key the value to be found \n* Postcondition: \n* - Returned value k is such that -1 <= k <= v.length-1. \n* - If k >= 0 then v[k] == key. \n* - If k == -1, then key != any of the elements in v. \n*/ \npublic static int search(int[] v, int key) \n{ \n    int index = 0; \n    while (index < v.length && v[index] < key) \n        index++; \n    if (v[index] == key) \n        return index; \n    else \n        return -1; \n} \n\nAssuming that the method works as intended, which of the following should be added to the precondition of search? \nCorrect: v is sorted smallest to largest.\nIncorrect: v is sorted largest to smallest.\nIncorrect: v is unsorted.\nIncorrect: There is at least one occurrence of key in v.\nIncorrect: key occurs no more than once in v.\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the binSearch method and the private instance variable a for some class: \n\nprivate int[] a; \n\n/** Does binary search for key in array a[0]...a[a.length-1], \n* sorted in ascending order. \n* @param key the integer value to be found \n* Postcondition: \n* - index has been returned such that a[index]==key. \n* - If key not in a, return -1. \n*/ \npublic int binSearch(int key) \n{ \n    int low = 0; \n    int high = a.length - 1; \n    while (low <= high) \n    { \n        int mid = (low + high) / 2; \n        if (a[mid] == key) \n            return mid; \n        else if (a[mid] < key) \n            low = mid + 1; \n        else \n            high = mid - 1; \n    } \n    return -1; \n}\n\nA binary search will be performed on the following list. \na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] \n4 7 9 11 20 24 30 41 \n\nTo find the key value 27, the search interval after the first pass through the while loop will be \nCorrect: a[4] . . . a[7]\nIncorrect: a[0] . . . a[7]\nIncorrect: a[5] . . . a[6]\nIncorrect: a[2] . . . a[6]\nIncorrect: a[6] . . . a[7]\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the binSearch method and the private instance variable a for some class: \n\nprivate int[] a; \n\n/** Does binary search for key in array a[0]...a[a.length-1], \n* sorted in ascending order. \n* @param key the integer value to be found \n* Postcondition: \n* - index has been returned such that a[index]==key. \n* - If key not in a, return -1. \n*/ \npublic int binSearch(int key) \n{ \n    int low = 0; \n    int high = a.length - 1; \n    while (low <= high) \n    { \n        int mid = (low + high) / 2; \n        if (a[mid] == key) \n            return mid; \n        else if (a[mid] < key) \n            low = mid + 1; \n        else \n            high = mid - 1; \n    } \n    return -1; \n}\n\nA binary search will be performed on the following list. \na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] \n4 7 9 11 20 24 30 41 \n\nHow many iterations will be required to determine that 27 is not in the list? \nCorrect: 3\nIncorrect: 1\nIncorrect: 8\nIncorrect: 27\nIncorrect: An infinite loop since 27 is not found\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the binSearch method and the private instance variable a for some class: \n\nprivate int[] a; \n\n/** Does binary search for key in array a[0]...a[a.length-1], \n* sorted in ascending order. \n* @param key the integer value to be found \n* Postcondition: \n* - index has been returned such that a[index]==key. \n* - If key not in a, return -1. \n*/ \npublic int binSearch(int key) \n{ \n    int low = 0; \n    int high = a.length - 1; \n    while (low <= high) \n    { \n        int mid = (low + high) / 2; \n        if (a[mid] == key) \n            return mid; \n        else if (a[mid] < key) \n            low = mid + 1; \n        else \n            high = mid - 1; \n    } \n    return -1; \n}\n\nA binary search will be performed on the following list. \na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] \n4 7 9 11 20 24 30 41 \n\nWhat will be stored in y after executing the following? \nint y = binSearch(4); \nCorrect: 0\nIncorrect: 20\nIncorrect: 7\nIncorrect: 4\nIncorrect: -1\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the binSearch method and the private instance variable a for some class: \n\nprivate int[] a; \n\n/** Does binary search for key in array a[0]...a[a.length-1], \n* sorted in ascending order. \n* @param key the integer value to be found \n* Postcondition: \n* - index has been returned such that a[index]==key. \n* - If key not in a, return -1. \n*/ \npublic int binSearch(int key) \n{ \n    int low = 0; \n    int high = a.length - 1; \n    while (low <= high) \n    { \n        int mid = (low + high) / 2; \n        if (a[mid] == key) \n            return mid; \n        else if (a[mid] < key) \n            low = mid + 1; \n        else \n            high = mid - 1; \n    } \n    return -1; \n}\n\nA binary search will be performed on the following list. \na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] \n4 7 9 11 20 24 30 41 \n\nIf the test for the while loop is changed to \nwhile (low < high) \nthe binSearch method does not work as intended. Which value in the given list will not be found? \nCorrect: 4\nIncorrect: 7\nIncorrect: 11\nIncorrect: 24\nIncorrect: 30\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the binSearch method and the private instance variable a for some class: \n\nprivate int[] a; \n\n/** Does binary search for key in array a[0]...a[a.length-1], \n* sorted in ascending order. \n* @param key the integer value to be found \n* Postcondition: \n* - index has been returned such that a[index]==key. \n* - If key not in a, return -1. \n*/ \npublic int binSearch(int key) \n{ \n    int low = 0; \n    int high = a.length - 1; \n    while (low <= high) \n    { \n        int mid = (low + high) / 2; \n        if (a[mid] == key) \n            return mid; \n        else if (a[mid] < key) \n            low = mid + 1; \n        else \n            high = mid - 1; \n    } \n    return -1; \n}\n\nA binary search will be performed on the following list. \na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] \n4 7 9 11 20 24 30 41 \n\nFor binSearch, which of the following assertions will be true following every iteration of the while loop? \nCorrect: key = a[mid], or a[low] \u2264 key \u2264 a[high], or key is not in array a.\n\n\nIncorrect: key = a[mid] or key is not in a.\nIncorrect: a[low] \u2264 key \u2264 a[high]\nIncorrect: low \u2264 mid \u2264 high\nIncorrect: key = a[mid], or a[low] \u2264 key \u2264 a[high]END"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: A large sorted array containing about 30,000 elements is to be searched for a value key using an iterative binary search algorithm. Assuming that key is in the array, which of the following is closest to the smallest number of iterations that will guarantee that key is found? Note: 10^3 \u2248 2^10. \nCorrect: 15\nIncorrect: 30\nIncorrect: 100\nIncorrect: 300\nIncorrect: 3000\n\nEND"}
{"prompt": "In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a \u201csearch-and-swap\u201d algorithm. Here\u2019s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is \u201cit,\u201d the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that \u201cit\u201d is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\nThe following question asks about the output of a program:\n\n###\n\n", "completion": "Question: Consider the insertionSort method and the private instance variable a, both in a Sorter class. \n\nprivate Integer[] a; \n\n/** Precondition: a[0],a[1]...a[a.length-1] is an unsorted array \n* of Integer objects. \n* Postcondition: Array a is sorted in descending order. \n*/ \npublic void insertionSort() \n{ \n    for (int i = 1; i < a.length; i++) \n    { \n        Integer temp = a[i]; \n        int j = i - 1; \n        while (j >= 0 && temp.compareTo(a[j]) > 0) \n        { \n            a[j+1] = a[j]; \n            j--; \n        } \n        a[j+1] = temp; \n    } \n} \n\nAn array of Integer is to be sorted biggest to smallest using the insertionSort method. If the array originally contains \n1 7 9 5 4 12 \nwhat will it look like after the third pass of the for loop? \nCorrect: 9 7 5 1 4 12\nIncorrect: 9 7 1 5 4 12\nIncorrect: 12 9 7 1 5 4\nIncorrect: 12 9 7 5 4 1\nIncorrect: 9 7 12 5 4 1\n\nEND"}
{"prompt": "In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a \u201csearch-and-swap\u201d algorithm. Here\u2019s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is \u201cit,\u201d the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that \u201cit\u201d is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the insertionSort method and the private instance variable a, both in a Sorter class. \n\nprivate Integer[] a; \n\n/** Precondition: a[0],a[1]...a[a.length-1] is an unsorted array \n* of Integer objects. \n* Postcondition: Array a is sorted in descending order. \n*/ \npublic void insertionSort() \n{ \n    for (int i = 1; i < a.length; i++) \n    { \n        Integer temp = a[i]; \n        int j = i - 1; \n        while (j >= 0 && temp.compareTo(a[j]) > 0) \n        { \n            a[j+1] = a[j]; \n            j--; \n        } \n        a[j+1] = temp; \n    } \n} \n\nWhen sorted biggest to smallest with insertionSort, which list will need the fewest changes of position for individual elements? \nCorrect: 9, 5, 1, 4, 3, 2\nIncorrect: 5, 1, 2, 3, 4, 9\nIncorrect: 9, 4, 2, 5, 1, 3\nIncorrect: 9, 3, 5, 1, 4, 2\nIncorrect: 3, 2, 1, 9, 5, 4\n\nEND"}
{"prompt": "In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a \u201csearch-and-swap\u201d algorithm. Here\u2019s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is \u201cit,\u201d the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that \u201cit\u201d is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the insertionSort method and the private instance variable a, both in a Sorter class. \n\nprivate Integer[] a; \n\n/** Precondition: a[0],a[1]...a[a.length-1] is an unsorted array \n* of Integer objects. \n* Postcondition: Array a is sorted in descending order. \n*/ \npublic void insertionSort() \n{ \n    for (int i = 1; i < a.length; i++) \n    { \n        Integer temp = a[i]; \n        int j = i - 1; \n        while (j >= 0 && temp.compareTo(a[j]) > 0) \n        { \n            a[j+1] = a[j]; \n            j--; \n        } \n        a[j+1] = temp; \n    } \n} \n\nWhen sorted biggest to smallest with insertionSort, which list will need the greatest number of changes in position? \nCorrect: 5, 1, 2, 3, 4, 7, 6, 9\nIncorrect: 9, 5, 1, 4, 3, 2, 1, 0\nIncorrect: 9, 4, 6, 2, 1, 5, 1, 3\nIncorrect: 9, 6, 9, 5, 6, 7, 2, 0\nIncorrect: 3, 2, 1, 0, 9, 6, 5, 4\n\nEND"}
{"prompt": "In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a \u201csearch-and-swap\u201d algorithm. Here\u2019s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is \u201cit,\u201d the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that \u201cit\u201d is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\nThe following question asks about the properties or summary of a program with multiple options:\n\n###\n\n", "completion": "Question: Consider the insertionSort method and the private instance variable a, both in a Sorter class. \n\nprivate Integer[] a; \n\n/** Precondition: a[0],a[1]...a[a.length-1] is an unsorted array \n* of Integer objects. \n* Postcondition: Array a is sorted in descending order. \n*/ \npublic void insertionSort() \n{ \n    for (int i = 1; i < a.length; i++) \n    { \n        Integer temp = a[i]; \n        int j = i - 1; \n        while (j >= 0 && temp.compareTo(a[j]) > 0) \n        { \n            a[j+1] = a[j]; \n            j--; \n        } \n        a[j+1] = temp; \n    } \n} \n\nWhile typing the insertionSort method, a programmer by mistake enters \nwhile (temp.compareTo( a[j]) > 0) \ninstead of \nwhile (j >= 0 && temp.compareTo( a[j]) > 0) \n\nDespite this mistake, the method works as intended the first time the programmer enters an array to be sorted in descending order. Which of the following could explain this? \nI The first element in the array was the largest element in the array. \nII The array was already sorted in descending order. \nIII The first element was less than or equal to all the other elements in the array. \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: II and III only\n\nEND"}
{"prompt": "In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a \u201csearch-and-swap\u201d algorithm. Here\u2019s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is \u201cit,\u201d the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that \u201cit\u201d is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\nThe following question asks about a hypothetical program or design choice with multiple options:\n\n###\n\n", "completion": "Question: The elements in a long list of integers are roughly sorted in decreasing order. No more than 5 percent of the elements are out of order. Which of the following is a valid reason for using an insertion sort rather than a selection sort to sort this list into decreasing order? \nI There will be fewer comparisons of elements for insertion sort. \nII There will be fewer changes of position of elements for insertion sort. \nIII There will be less space required for insertion sort. \nCorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt": "Selection and insertion sorts are inefficient for large n, requiring approximately n passes through a list of n elements. More efficient algorithms can be devised using a \u201cdivide-and-conquer\u201d approach, which is used in both the sorting algorithms that follow.\n\nMergesort\nHere is a recursive description of how mergesort works:\n\nIf there is more than one element in the array\n    Break the array into two halves.\n    Mergesort the left half.\n    Mergesort the right half.\n    Merge the two subarrays into a sorted array.\n\nMergesort uses a merge method to merge two sorted pieces of an array into a single sorted array. For example, suppose array a[0] . . . a[n-1] is such that a[0] . . . a[k] is sorted and a[k+1] . . . a[n-1] is sorted, both parts in increasing order. Example:\na[0] a[1] a[2] a[3] a[4] a[5]\n2 5 8 9 1 6\n\nIn this case, a[0] . . . a[3] and a[4] . . . a[5] are the two sorted pieces. The method call merge(a,0,3,5) should produce the \u201cmerged\u201d array:\na[0] a[1] a[2] a[3] a[4] a[5]\n1 2 5 6 8 9\n\nThe middle numerical parameter in merge (the 3 in this case) represents the index of the last element in the first \u201cpiece\u201d of the array. The first and third numerical parameters are the lowest and highest index, respectively, of array a.\nHere\u2019s what happens in mergesort:\n1. Start with an unsorted list of n elements.\n2. The recursive calls break the list into n sublists, each of length 1. Note that these n arrays, each containing just one element, are sorted!\n3. Recursively merge adjacent pairs of lists. There are then approximately n/2 lists of length 2; then, approximately n/4 lists of approximate length 4, and so on, until there is just one list of length n.\n\nAnalysis of Mergesort:\n1. The major disadvantage of mergesort is that it needs a temporary array that is as large as the original array to be sorted. This could be a problem if space is a factor.\n2. Mergesort is not affected by the initial ordering of the elements. Thus, best, worst, and average cases have similar run times.\n\nFor large n, quicksort is, on average, the fastest known sorting algorithm. Here is a recursive description of how quicksort works:\n\nIf there are at least two elements in the array\n    Partition the array.\n    Quicksort the left subarray.\n    Quicksort the right subarray.\n\nThe partition method splits the array into two subarrays as follows: a pivot element is chosen at random from the array (often just the first element) and placed so that all items to the left of the pivot are less than or equal to the pivot, whereas those to the right are greater than or equal to it.\nFor example, if the array is 4, 1, 2, 7, 5, \u22121, 8, 0, 6, and a[0] = 4 is the pivot, the partition method produces\n\u22121 1 2 0 4 5 8 7 6\n\nHere\u2019s how the partitioning works: Let a[0], 4 in this case, be the pivot. Markers up and down are initialized to index values 0 and n \u2212 1, as shown. Move the up marker until a value less than the pivot is found, or down equals up. Move the down marker until a value greater than the pivot is found, or down equals up. Swap a[up] and a[down]. Continue the process until down equals up. This is the pivot position. Swap a[0] and a[pivotPosition].\nNotice that the pivot element, 4, is in its final sorted position.\n\nAnalysis of Quicksort:\n1. For the fastest run time, the array should be partitioned into two parts of roughly the same size.\n2. If the pivot happens to be the smallest or largest element in the array, the split is not much of a split\u2014one of the subarrays is empty! If this happens repeatedly, quicksort degenerates into a slow, recursive version of selection sort and is very inefficient.\n3. The worst case for quicksort occurs when the partitioning algorithm repeatedly divides the array into pieces of size 1 and n \u2212 1. An example is when the array is initially sorted in either order and the first or last element is chosen as the pivot. Some algorithms avoid this situation by initially shuffling up the given array (!) or selecting the pivot by examining several elements of the array (such as first, middle, and last) and then taking the median.\n\nNOTE\nFor both quicksort and mergesort, when a subarray gets down to some small size m, it becomes faster to sort by straight insertion. The optimal value of m is machine dependent, but it\u2019s approximately equal to 7.\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: The code shown sorts array a[0] . . . a[a.length-1] in descending order. \n\npublic static void sort(String[] a) \n{ \n    for (int i = 0; i < a.length - 1; i++) \n        for (int j = 0; j < a.length - i - 1; j++) \n            if (a[j].compareTo(a[j+1]) < 0) \n                swap(a, j, j + 1); //swap a[j] and a[j+1] \n} \n\nThis is an example of \nCorrect: none of the above.\n\n\nIncorrect: selection sort.\nIncorrect: insertion sort.\nIncorrect: mergesort.\nIncorrect: quicksort.END"}
{"prompt": "Selection and insertion sorts are inefficient for large n, requiring approximately n passes through a list of n elements. More efficient algorithms can be devised using a \u201cdivide-and-conquer\u201d approach, which is used in both the sorting algorithms that follow.\n\nMergesort\nHere is a recursive description of how mergesort works:\n\nIf there is more than one element in the array\n    Break the array into two halves.\n    Mergesort the left half.\n    Mergesort the right half.\n    Merge the two subarrays into a sorted array.\n\nMergesort uses a merge method to merge two sorted pieces of an array into a single sorted array. For example, suppose array a[0] . . . a[n-1] is such that a[0] . . . a[k] is sorted and a[k+1] . . . a[n-1] is sorted, both parts in increasing order. Example:\na[0] a[1] a[2] a[3] a[4] a[5]\n2 5 8 9 1 6\n\nIn this case, a[0] . . . a[3] and a[4] . . . a[5] are the two sorted pieces. The method call merge(a,0,3,5) should produce the \u201cmerged\u201d array:\na[0] a[1] a[2] a[3] a[4] a[5]\n1 2 5 6 8 9\n\nThe middle numerical parameter in merge (the 3 in this case) represents the index of the last element in the first \u201cpiece\u201d of the array. The first and third numerical parameters are the lowest and highest index, respectively, of array a.\nHere\u2019s what happens in mergesort:\n1. Start with an unsorted list of n elements.\n2. The recursive calls break the list into n sublists, each of length 1. Note that these n arrays, each containing just one element, are sorted!\n3. Recursively merge adjacent pairs of lists. There are then approximately n/2 lists of length 2; then, approximately n/4 lists of approximate length 4, and so on, until there is just one list of length n.\n\nAnalysis of Mergesort:\n1. The major disadvantage of mergesort is that it needs a temporary array that is as large as the original array to be sorted. This could be a problem if space is a factor.\n2. Mergesort is not affected by the initial ordering of the elements. Thus, best, worst, and average cases have similar run times.\n\nFor large n, quicksort is, on average, the fastest known sorting algorithm. Here is a recursive description of how quicksort works:\n\nIf there are at least two elements in the array\n    Partition the array.\n    Quicksort the left subarray.\n    Quicksort the right subarray.\n\nThe partition method splits the array into two subarrays as follows: a pivot element is chosen at random from the array (often just the first element) and placed so that all items to the left of the pivot are less than or equal to the pivot, whereas those to the right are greater than or equal to it.\nFor example, if the array is 4, 1, 2, 7, 5, \u22121, 8, 0, 6, and a[0] = 4 is the pivot, the partition method produces\n\u22121 1 2 0 4 5 8 7 6\n\nHere\u2019s how the partitioning works: Let a[0], 4 in this case, be the pivot. Markers up and down are initialized to index values 0 and n \u2212 1, as shown. Move the up marker until a value less than the pivot is found, or down equals up. Move the down marker until a value greater than the pivot is found, or down equals up. Swap a[up] and a[down]. Continue the process until down equals up. This is the pivot position. Swap a[0] and a[pivotPosition].\nNotice that the pivot element, 4, is in its final sorted position.\n\nAnalysis of Quicksort:\n1. For the fastest run time, the array should be partitioned into two parts of roughly the same size.\n2. If the pivot happens to be the smallest or largest element in the array, the split is not much of a split\u2014one of the subarrays is empty! If this happens repeatedly, quicksort degenerates into a slow, recursive version of selection sort and is very inefficient.\n3. The worst case for quicksort occurs when the partitioning algorithm repeatedly divides the array into pieces of size 1 and n \u2212 1. An example is when the array is initially sorted in either order and the first or last element is chosen as the pivot. Some algorithms avoid this situation by initially shuffling up the given array (!) or selecting the pivot by examining several elements of the array (such as first, middle, and last) and then taking the median.\n\nNOTE\nFor both quicksort and mergesort, when a subarray gets down to some small size m, it becomes faster to sort by straight insertion. The optimal value of m is machine dependent, but it\u2019s approximately equal to 7.\n\n\nThe following question asks about general programming knowledge with multiple options:\n\n###\n\n", "completion": "Question: Which of the following is a valid reason why mergesort is a better sorting algorithm than insertion sort for sorting long, randomly ordered lists? \nI Mergesort requires less code than insertion sort. \nII Mergesort requires less storage space than insertion sort. \nIII Mergesort runs faster than insertion sort. \nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: II and III only\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: A large array of lowercase characters is to be searched for the pattern \u201cpqrs.\u201d The first step in a very efficient searching algorithm is to look at characters with index \nCorrect: 3, 7, 11, . . . until any letter in \u201cp\u201d . . . \u201cs\u201d is encountered.\nIncorrect: 0, 1, 2, . . . until a \u201cp\u201d is encountered.\nIncorrect: 0, 1, 2, . . . until any letter in \u201cp\u201d . . . \u201cs\u201d is encountered.\nIncorrect: 3, 7, 11, . . . until an \u201cs\u201d is encountered.\nIncorrect: 3, 7, 11, . . . until any letter other than \u201cp\u201d . . . \u201cs\u201d is encountered.\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: The array names[0], names[1], . . . , names[9999] is a list of 10,000 name strings. The list is to be searched to determine the location of some name X in the list. \nWhich of the following preconditions is necessary for a binary search? \nCorrect: The list is in alphabetical order.\nIncorrect: There are no duplicate names in the list.\nIncorrect: The number of names N in the list is large.\nIncorrect: Name X is definitely in the list.\nIncorrect: Name X occurs near the middle of the list.\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about the properties or summary of a program:\n\n###\n\n", "completion": "Question: Consider the following method: \n\n/** Precondition: a[0],a[1]...a[n-1] contain integers. */ \npublic static int someMethod(int[] a, int n, int value) \n{ \n    if (n == 0) \n        return -1; \n    else \n    { \n        if (a[n-1] == value) \n            return n - 1; \n        else \n            return someMethod(a, n - 1, value); \n    } \n} \n\nThe method shown is an example of \nCorrect: sequential search.\n\n\nIncorrect: insertion sort.\nIncorrect: mergesort.\nIncorrect: selection sort.\nIncorrect: binary search.END"}
{"prompt": "Selection and insertion sorts are inefficient for large n, requiring approximately n passes through a list of n elements. More efficient algorithms can be devised using a \u201cdivide-and-conquer\u201d approach, which is used in both the sorting algorithms that follow.\n\nMergesort\nHere is a recursive description of how mergesort works:\n\nIf there is more than one element in the array\n    Break the array into two halves.\n    Mergesort the left half.\n    Mergesort the right half.\n    Merge the two subarrays into a sorted array.\n\nMergesort uses a merge method to merge two sorted pieces of an array into a single sorted array. For example, suppose array a[0] . . . a[n-1] is such that a[0] . . . a[k] is sorted and a[k+1] . . . a[n-1] is sorted, both parts in increasing order. Example:\na[0] a[1] a[2] a[3] a[4] a[5]\n2 5 8 9 1 6\n\nIn this case, a[0] . . . a[3] and a[4] . . . a[5] are the two sorted pieces. The method call merge(a,0,3,5) should produce the \u201cmerged\u201d array:\na[0] a[1] a[2] a[3] a[4] a[5]\n1 2 5 6 8 9\n\nThe middle numerical parameter in merge (the 3 in this case) represents the index of the last element in the first \u201cpiece\u201d of the array. The first and third numerical parameters are the lowest and highest index, respectively, of array a.\nHere\u2019s what happens in mergesort:\n1. Start with an unsorted list of n elements.\n2. The recursive calls break the list into n sublists, each of length 1. Note that these n arrays, each containing just one element, are sorted!\n3. Recursively merge adjacent pairs of lists. There are then approximately n/2 lists of length 2; then, approximately n/4 lists of approximate length 4, and so on, until there is just one list of length n.\n\nAnalysis of Mergesort:\n1. The major disadvantage of mergesort is that it needs a temporary array that is as large as the original array to be sorted. This could be a problem if space is a factor.\n2. Mergesort is not affected by the initial ordering of the elements. Thus, best, worst, and average cases have similar run times.\n\nFor large n, quicksort is, on average, the fastest known sorting algorithm. Here is a recursive description of how quicksort works:\n\nIf there are at least two elements in the array\n    Partition the array.\n    Quicksort the left subarray.\n    Quicksort the right subarray.\n\nThe partition method splits the array into two subarrays as follows: a pivot element is chosen at random from the array (often just the first element) and placed so that all items to the left of the pivot are less than or equal to the pivot, whereas those to the right are greater than or equal to it.\nFor example, if the array is 4, 1, 2, 7, 5, \u22121, 8, 0, 6, and a[0] = 4 is the pivot, the partition method produces\n\u22121 1 2 0 4 5 8 7 6\n\nHere\u2019s how the partitioning works: Let a[0], 4 in this case, be the pivot. Markers up and down are initialized to index values 0 and n \u2212 1, as shown. Move the up marker until a value less than the pivot is found, or down equals up. Move the down marker until a value greater than the pivot is found, or down equals up. Swap a[up] and a[down]. Continue the process until down equals up. This is the pivot position. Swap a[0] and a[pivotPosition].\nNotice that the pivot element, 4, is in its final sorted position.\n\nAnalysis of Quicksort:\n1. For the fastest run time, the array should be partitioned into two parts of roughly the same size.\n2. If the pivot happens to be the smallest or largest element in the array, the split is not much of a split\u2014one of the subarrays is empty! If this happens repeatedly, quicksort degenerates into a slow, recursive version of selection sort and is very inefficient.\n3. The worst case for quicksort occurs when the partitioning algorithm repeatedly divides the array into pieces of size 1 and n \u2212 1. An example is when the array is initially sorted in either order and the first or last element is chosen as the pivot. Some algorithms avoid this situation by initially shuffling up the given array (!) or selecting the pivot by examining several elements of the array (such as first, middle, and last) and then taking the median.\n\nNOTE\nFor both quicksort and mergesort, when a subarray gets down to some small size m, it becomes faster to sort by straight insertion. The optimal value of m is machine dependent, but it\u2019s approximately equal to 7.\n\n\nThe following question asks about general programming knowledge:\n\n###\n\n", "completion": "Question: The partition method for quicksort partitions a list as follows: \n(i) A pivot element is selected from the array. \n(ii) The elements of the list are rearranged such that all elements to the left of the pivot are less than or equal to it; all elements to the right of the pivot are greater than or equal to it. \nPartitioning the array requires which of the following? \nCorrect: A swap algorithm for interchanging array elements\nIncorrect: A recursive algorithm\nIncorrect: A temporary array\nIncorrect: An external file for the array\nIncorrect: A merge method for merging two sorted lists\n\nEND"}
{"prompt": "Selection and insertion sorts are inefficient for large n, requiring approximately n passes through a list of n elements. More efficient algorithms can be devised using a \u201cdivide-and-conquer\u201d approach, which is used in both the sorting algorithms that follow.\n\nMergesort\nHere is a recursive description of how mergesort works:\n\nIf there is more than one element in the array\n    Break the array into two halves.\n    Mergesort the left half.\n    Mergesort the right half.\n    Merge the two subarrays into a sorted array.\n\nMergesort uses a merge method to merge two sorted pieces of an array into a single sorted array. For example, suppose array a[0] . . . a[n-1] is such that a[0] . . . a[k] is sorted and a[k+1] . . . a[n-1] is sorted, both parts in increasing order. Example:\na[0] a[1] a[2] a[3] a[4] a[5]\n2 5 8 9 1 6\n\nIn this case, a[0] . . . a[3] and a[4] . . . a[5] are the two sorted pieces. The method call merge(a,0,3,5) should produce the \u201cmerged\u201d array:\na[0] a[1] a[2] a[3] a[4] a[5]\n1 2 5 6 8 9\n\nThe middle numerical parameter in merge (the 3 in this case) represents the index of the last element in the first \u201cpiece\u201d of the array. The first and third numerical parameters are the lowest and highest index, respectively, of array a.\nHere\u2019s what happens in mergesort:\n1. Start with an unsorted list of n elements.\n2. The recursive calls break the list into n sublists, each of length 1. Note that these n arrays, each containing just one element, are sorted!\n3. Recursively merge adjacent pairs of lists. There are then approximately n/2 lists of length 2; then, approximately n/4 lists of approximate length 4, and so on, until there is just one list of length n.\n\nAnalysis of Mergesort:\n1. The major disadvantage of mergesort is that it needs a temporary array that is as large as the original array to be sorted. This could be a problem if space is a factor.\n2. Mergesort is not affected by the initial ordering of the elements. Thus, best, worst, and average cases have similar run times.\n\nFor large n, quicksort is, on average, the fastest known sorting algorithm. Here is a recursive description of how quicksort works:\n\nIf there are at least two elements in the array\n    Partition the array.\n    Quicksort the left subarray.\n    Quicksort the right subarray.\n\nThe partition method splits the array into two subarrays as follows: a pivot element is chosen at random from the array (often just the first element) and placed so that all items to the left of the pivot are less than or equal to the pivot, whereas those to the right are greater than or equal to it.\nFor example, if the array is 4, 1, 2, 7, 5, \u22121, 8, 0, 6, and a[0] = 4 is the pivot, the partition method produces\n\u22121 1 2 0 4 5 8 7 6\n\nHere\u2019s how the partitioning works: Let a[0], 4 in this case, be the pivot. Markers up and down are initialized to index values 0 and n \u2212 1, as shown. Move the up marker until a value less than the pivot is found, or down equals up. Move the down marker until a value greater than the pivot is found, or down equals up. Swap a[up] and a[down]. Continue the process until down equals up. This is the pivot position. Swap a[0] and a[pivotPosition].\nNotice that the pivot element, 4, is in its final sorted position.\n\nAnalysis of Quicksort:\n1. For the fastest run time, the array should be partitioned into two parts of roughly the same size.\n2. If the pivot happens to be the smallest or largest element in the array, the split is not much of a split\u2014one of the subarrays is empty! If this happens repeatedly, quicksort degenerates into a slow, recursive version of selection sort and is very inefficient.\n3. The worst case for quicksort occurs when the partitioning algorithm repeatedly divides the array into pieces of size 1 and n \u2212 1. An example is when the array is initially sorted in either order and the first or last element is chosen as the pivot. Some algorithms avoid this situation by initially shuffling up the given array (!) or selecting the pivot by examining several elements of the array (such as first, middle, and last) and then taking the median.\n\nNOTE\nFor both quicksort and mergesort, when a subarray gets down to some small size m, it becomes faster to sort by straight insertion. The optimal value of m is machine dependent, but it\u2019s approximately equal to 7.\n\n\nThe following question asks about general programming knowledge:\n\n###\n\n", "completion": "Question: Assume that mergesort will be used to sort an array arr of n integers into increasing order. What is the purpose of the merge method in the mergesort algorithm?\nCorrect: Merge two sorted parts of arr into a single sorted array.\nIncorrect: Partition arr into two parts of roughly equal length, then merge these parts.\nIncorrect: Use a recursive algorithm to sort arr into increasing order.\nIncorrect: Divide arr into n subarrays, each with one element.\nIncorrect: Merge two sorted arrays into a temporary array that is sorted.\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: A binary search is to be performed on an array with 600 elements. In the worst case, which of the following best approximates the number of iterations of the algorithm? \nCorrect: 10\nIncorrect: 6\nIncorrect: 100\nIncorrect: 300\nIncorrect: 600\n\nEND"}
{"prompt": "In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a \u201csearch-and-swap\u201d algorithm. Here\u2019s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is \u201cit,\u201d the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n \u2212 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that \u201cit\u201d is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\nThe following question asks about general programming knowledge with multiple options:\n\n###\n\n", "completion": "Question: A worst case situation for insertion sort would be \nI A list in correct sorted order. \nII A list sorted in reverse order. \nIII A list in random order. \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: II and III only\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about a hypothetical program or design choice with multiple options:\n\n###\n\n", "completion": "Question: Consider a binary search algorithm to search an ordered list of numbers. Which of the following choices is closest to the maximum number of times that such an algorithm will execute its main comparison loop when searching a list of 1 million numbers? \nCorrect: 20\nIncorrect: 6\nIncorrect: 100\nIncorrect: 120\nIncorrect: 1000\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about a hypothetical program or design choice with multiple options:\n\n###\n\n", "completion": "Question: Consider these three tasks: \nI A sequential search of an array of n names \nII A binary search of an array of n names in alphabetical order \nIII An insertion sort into alphabetical order of an array of n names that are initially in random order \nFor large n, which of the following lists these tasks in order (from least to greatest) of their average case run times? \nCorrect: II I III\nIncorrect: I II III\nIncorrect: II III I\nIncorrect: III I II\nIncorrect: III II I\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: Consider the problem of writing a Hi-Lo game in which a user thinks of an integer from 1 to 100 inclusive and the computer tries to guess that number. Each time the computer makes a guess, the user makes one of three responses: \n\u2022 \u201clower\u201d (i.e., the number is lower than the computer\u2019s guess) \n\u2022 \u201chigher\u201d (i.e., the number is higher than the computer\u2019s guess) \n\u2022 \u201cyou got it in < however many > tries!\u201d \n\nSuppose the game is programmed so that the computer uses a binary search strategy for making its guesses. What is the maximum number of guesses the computer could make before guessing the user\u2019s number? \nCorrect: 7\nIncorrect: 50\nIncorrect: 25\nIncorrect: 10\nIncorrect: 6\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: Consider the problem of writing a Hi-Lo game in which a user thinks of an integer from 1 to 100 inclusive and the computer tries to guess that number. Each time the computer makes a guess, the user makes one of three responses: \n\u2022 \u201clower\u201d (i.e., the number is lower than the computer\u2019s guess) \n\u2022 \u201chigher\u201d (i.e., the number is higher than the computer\u2019s guess) \n\u2022 \u201cyou got it in < however many > tries!\u201d\n\nSuppose the computer used a sequential search strategy for guessing the user\u2019s number. What is the maximum number of guesses the computer could make before guessing the user\u2019s number? \nCorrect: 100\nIncorrect: 99\nIncorrect: 50\nIncorrect: 25\nIncorrect: 10\n\nEND"}
{"prompt": "Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user\u2019s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n/* A class that sorts an array of ints from\n* largest to smallest using selection sort. */\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    /**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     */\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    /**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     */\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            // find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); // swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns \u22121.\n\nif (low > high) //Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)/2;\n    if (key is equal to a[mid]) //found the key\n        return mid;\n    else if (key is less than a[mid]) //key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else //key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)/2 = 4. Check a[4].\nSecond pass: mid = (0+3)/2 = 1. Check a[1].\nThird pass: mid = (2+3)/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\nThe following question asks about a hypothetical program or design choice:\n\n###\n\n", "completion": "Question: Consider the problem of writing a Hi-Lo game in which a user thinks of an integer from 1 to 100 inclusive and the computer tries to guess that number. Each time the computer makes a guess, the user makes one of three responses: \n\u2022 \u201clower\u201d (i.e., the number is lower than the computer\u2019s guess) \n\u2022 \u201chigher\u201d (i.e., the number is higher than the computer\u2019s guess) \n\u2022 \u201cyou got it in < however many > tries!\u201d\n\nUsing a sequential search strategy, how many guesses on average would the computer need to guess the number? \nCorrect: 50\nIncorrect: 100\nIncorrect: 51\nIncorrect: 25\nIncorrect: Fewer than 25END"}
