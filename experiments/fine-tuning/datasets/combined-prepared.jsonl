{"prompt":"Variables allow us to store information such as numbers, words, or true\/false expressions. A variable can be thought of as a box that stores information inside.\n\nIn Java, variables are composed of three things: a name, type, and value.In Java you must specify what type of information you want our variables to hold. There are two types that are used in Java: primitive and reference. You must always give your variable a type before naming it, and specifying the value it holds. (Ex. int myVariable = 10;)\n\nAs seen above, primitive numeric types in Java include both integers and doubles.\n\nIntegers are whole numbers, or counting numbers. (Ex. -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5). In Java you declare an integer using int before the variable name. Here are a couple of examples:\n\nint itemsInStore = 10; \nint numberOfMessages = 8;\n\ndoubles are like integers, but can have decimals. (Ex. -54.34, 90.21, 0.1223). In Java you declare a double using double before the variable name. Here are a couple of examples:\n\ndouble costOfApple = 1.24;\ndouble milesToRun = 5.64;\n\nCharacters represent a single character. In Java you declare a character using char before the variable name. You also use single quotes to identify a character (Ex. ‘A’). Here are a couple of examples:\n\nchar currentGrade = 'A';\nchar favoriteLetter = 'W';\n\nBooleans are variables that hold a true or a false value. In Java you declare a boolean using boolean before the variable name. Here are a couple of examples:\n\nboolean passedCalculus = true;\nboolean hasDog = false;\n\nWhile primitive types are considered the building blocks of programming languages, reference types are types that have been created by programmers using those primitive types. String for example, is a variable type that was created using char variable types, and has its own functionality that has been created by programmers.\n\nOne of the primary differences between primitive types and reference types is how they are stored in memory. When you assign a value to a variable, you are actually associating that variable with binary data. Computers store all data in binary, and associate that variable with the binary data associated with the value that its been assigned. When primitives are given values, they are associated directly with those values. If the value of one variable changes, then the primitive value that it stores also changes.\n\nIn this example, the value of first is being changed to equal the value stored in second. Both first and second now store the value b.\n\nReference types store an address that points to where the value is located in memory.\n\nStrings are variables that hold text. Strings are not a primitive type, so you must declare them using String with a capital S. Unlike characters, you need to use double quotes when assigning strings (Ex. \"This is my string.\"). Here are a couple of examples:\n\nString fishName = \"Dog\";\nString myUniversity = \"Arizona State University\";\n\nVariables can be protected from alteration if the keyword final is included before the data type. If there is an attempt to change the variable value, then an error will be called indicating that variable has already been assigned. This is often used as a security measure in more complex programs to ensure that values cannot be modified by others.\n\nfinal int numApples = 5;\nnumApples = 0;\n\nIn this example, the program will throw an error because the value of numApples cannot be changed if the keyword final is added to the variable declaration.\n\nGiving your variables meaningful names throughout your code is very important. Proper variable names allow others to easily read and understand your code. A good way to name your variables is to give them as descriptive of a name as possible, without making it too long.\n\nFor example,int numberOfApplesOnTheTree = 10; is a very long name, and can easily be replaced with a name like int numApples = 10;\n\nVariable Naming Conventions:\n- Variable names must start with a letter, $ symbol, or _ symbol.\n- Variable names are case sensitive so myVariable is different thanMyVariable\n- Variable names, after the first character, can contain letters, numbers, or other characters.\n\n###\n\n","completion":" Question: If you were to create a variable to store your age, which of the following would be best considering the variable type and Java naming conventions?\nCorrect: int age;\nIncorrect: double Age;\nIncorrect: int number;\nIncorrect: int Age;END"}
{"prompt":"Arithmetic expressions allow your to perform mathematical operations within Java. Such expressions can be used for basic math and even more complex algorithms.\n\nThe addition operator allows you to add values together. Here is an example of the addition operator in Java:\n\npublic class AdditionOperator\n{\n  public static void main(String[] args)\n  {\n    int firstVal = 5;\n    int secondVal = 2;\n\n    int firstPlusSecond = firstVal + secondVal;\n\n    \/\/ The output will be '7'\n    System.out.println(firstPlusSecond);\n  }\n}\n\nThe subtraction operator allows you to subtract values from one another. Here is an example of the subtraction operator in Java:\n\npublic class SubtractionOperator\n{\n  public static void main(String[] args)\n  {\n    int firstVal = 4;\n    int secondVal = 2;\n\n    int firstMinusSecond = firstVal - secondVal;\n\n    \/\/ The output will be '2'\n    System.out.println(firstMinusSecond);\n  }\n}\n\nThe multiplication operator allows you to multiply values. Here is an example of the multiplication operator in Java:\n\npublic class MultiplicationOperator\n{\n  public static void main(String[] args)\n  {\n    int firstVal = 4;\n    int secondVal = 2;\n\n    int firstMultSecond = firstVal * secondVal;\n\n    \/\/ The output will be '8'\n    System.out.println(firstMultSecond);\n  }\n}\n\nThe division operator allows you to divide values. Here is an example of the division operator in Java:\n\npublic class DivisionOperator\n{\n  public static void main(String[] args)\n  {\n    int firstVal = 6;\n    int secondVal = 3;\n\n    int firstDivSecond = firstVal \/ secondVal;\n\n    \/\/ The output will be '2'\n    System.out.println(firstDivSecond);\n  }\n}\n\nThere are multiple types of division that can be performed in Java. These forms include: integer division, double division, and mixed division.\n\nInteger Division\nIf you divide two integers you will be returned an integer value.\n\nSo in this case, while 2 \/ 5 equals 2.5, in Java 2 \/ 5 = 2. This always holds true, unless the type is specified as a double. Whenever you divide two integers, the return value is always truncated.\n\nDouble Division\nDividing doubles is different from dividing integers.\n\nWhen you divide two doubles you will be returned a double. In this case,2.0 \/ 5.0 = 2.5 will be your result.\n\nMixed Division\nMixed division is when you divide a double by an integer or an integer by a double.\n\nWhen you use mixed division in your program you will be returned a double. This is true, unless the type is specifically defined as an integer.\n\nConsider the following piece of code:\n\ndouble x = 2;\nint y = 5;\n\ndouble outXY = x \/ y;   \/\/ 0.4\n\ndouble outYX = y \/ x;   \/\/ 2.5\n\nint outInt = (int)(y \/ x);  \/\/ 2\n\nNo matter which data type you use, dividing by zero will cause your programs to throw an ArithmeticException. Exceptions are unwanted or unexpected events which occur during the execution of a program. In this case, dividing by zero causes the variable to store the value of undefined, which cannot be used in arithmetic expression. The program throws the ArithmeticException to warn programmers that there is an issue that needs to be resolved.\n\nThe modulus operator allows you to divide two numbers and get the remainder. Here is an example of the modulus operator in Java:\n\npublic class ModulusOperator\n{\n  public static void main(String[] args)\n  {\n    int firstVal = 17;\n    int secondVal = 5;\n\n    int firstModSecond = firstVal % secondVal;\n\n    \/\/ The output will be '2' since the remainder of 17 \/ 5 is 3.\n    System.out.println(firstModSecond);\n  }\n}\n\nIt is important to remember that the order of operations still applies. In instances where you have multiple operators with the same precedence the order will be left to right.\n\n\n###\n\n","completion":" Question: What is the result of this expression?\n\n54 % 5\nCorrect: 4\nIncorrect: 10\nIncorrect: 10.8\nIncorrect: 11END"}
{"prompt":"Casting allows you to change a variable’s type to better suit our needs.\n\nLet’s say you want to turn a double into an integer, or an integer into a double. To change a variable’s type you just add the type in between parentheses to cast it.\n\nConsider the following:\n\nint doubleToInt = (int)10.95;\n\/\/ This will become '10'\n\nTo cast an integer value to a double you add double in front of the variable.\n\nint intVal = 10;\n\n\/\/ Our 'doubleVal' variable is now '10.0'\ndouble doubleVal = (double)intVal;\n\nPrograms can also cast an int value to a double automatically since the value doesn’t change.\n\nint intVal = 10;\n\n\/\/ Our 'doubleVal' variable is now '10.0'\ndouble doubleVal = intVal; \/\/ cast automatically\n\nTo cast a double to an integer you add (int) in front of the variable. It is important to remember your new integer value will truncate the decimal.\n\ndouble doubleVal = 7.6;\n\n\/\/ Our 'intVal' variable is now '7'\nint intVal = (int)doubleVal;\n\nNote that the change from casting is temporary. In the above example, intVal has a value of 7, but the value of doubleVal remains 7.6.\n\nTruncating the value may not be the desired result. If you want to round the value, you can do this programmatically by adding half to the original value before truncating.\n\nIf you divide two integers, even if you are setting them to a double, you will always be returned an integer.\n\nint currResidents = 50;\nint floorTotal = 56;\n\ndouble average = floorTotal \/ currResidents;\n\/\/ 'average' will return the value '1'\n\nWe can get the correct answer by casting one of the variables to a double.\n\nint currResidents = 50;\nint floorTotal = 56;\n\ndouble average = (double)floorTotal \/ currResidents;\n\/\/ We now have the value of '1.12'\n\nAs you begin to explore numerical values in greater depth, it’s important to know about the existing range of variables. When you assign a value to a variable, you are actually associating that variable with binary data. Computers store all data in binary, and associate that variable with the binary data associated with the value that it has been assigned. int values are represented by 32 bits, or binary digits!\n\nWhile that may seem like a lot, it actually does give you a finite limit to the numbers that you can store. Since ints are represented by 32 bits, the total possible combination of different values that can exist is 4,294,967,296. This range is split nearly evenly between negative and positive numbers, so you are able to store values from -2,147,483,648 to 2,147,483,647.\n\nWhat happens if you go over the maximum or less than the minimum? If you go over or under the max and min, the value actually wraps around. This is called overflow. It’s important to note that overflow doesn’t always act as intended, and can create unexpected results. You will still get a value, but it may not be the value you expect.\n\nA data type of lower size (occupying less memory) is assigned to a data type of higher size (more memory). This is done implicitly by the Java Virtual Machine, unlike the explicit casting we did in previous examples (so by the programmer). The lower size is widened to a higher size. This is also called automatic type conversion.\n\nint x = 10;                    \/\/ occupies 4 bytes\ndouble y = x;                  \/\/ occupies 8 bytes\nSystem.out.println(y);         \/\/ prints 10.0\n\nIn the above code, the 4 bytes integer value is assigned to 8 bytes double value.\n\nInteger values in Java are represented by values of type int, which are stored using a finite amount (4 bytes) of memory. Therefore, an int value must be in the range from Integer.MIN_VALUE to Integer.MAX_ VALUE inclusive.\n\nWe can print the maximum, minimum and bit-length of the integer primitive types. The maximum, minimum and bit-size of int are kept in built-in constants Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.SIZE.\n\nThe expected outputs are:\n\nThe minimium integer value in Java is -2147483648\nThe maximum integer value in Java is 2147483647\nThe total bit size for an integer in Java is 32\n\n###\n\n","completion":" Question: What will this java expression evaluate to?\n(int) 5.6\nCorrect: 5\nIncorrect: 6\nIncorrect: 5.6\nIncorrect: 6.0END"}
{"prompt":"Classes and Objects are utilized in Java as part of the object-oriented programming model. This model focuses on objects and the data and actions associated with the objects.\n\nObjects are variables of user-defined data types. You can refer to these as reference type variables. Just as you initialize and declare primitive types, reference types are also declared and initialized. The initialized form of a reference type is referred to as an object.\n\nObjects are structures that contain a state and behavior. Everyday objects you commonly use have states and behaviors. For example, a car is an object with both a state and behavior.\n\nState\nThe state contains information about the specific object. An example of a state for a car would be how much fuel it has.\n\nBehavior\nThe behavior is the actions that can be performed on a specific object. A behavior of the car may be to get the mileage from the remaining fuel.\n\nClasses are the templates you use for creating objects.\n\nHere is an example of a class that lets us create a rectangle, and get its area:\n\npublic class Rectangle\n{\n  private double width;\n  private double height;\n\n  public Rectangle(double rectWidth, double rectHeight)\n  {\n    width = rectWidth;\n    height = rectHeight;\n  }\n\n  public int getWidth()\n  {\n    return width;\n  }\n\n  public int getHeight()\n  {\n    return height;\n  }\n\n  public int getArea()\n  {\n    return width * height;\n  }\n\n  public String toString()\n  {\n    String rectInfo = \"Rectangle with width \" + width + \" and height \" + height + \n     \" and area \" + getArea();\n\n    return rectInfo;\n  }\n}\n\nHere is another example of a class that lets us create new animal objects:\n\npublic class Animal\n{\n  private String name;\n  private boolean isPet;\n  private int age;\n\n  public Animal(String animalName, boolean isAnimalPet, int animalAge)\n  {\n    name = animalName;\n    isPet = isAnimalPet;\n    age = animalAge;\n  }\n\n  public String getName()\n  {\n    return name;\n  }\n\n  public boolean getPetStatus()\n  {\n    return isPet;\n  }\n\n  public int getAge()\n  {\n    return age;\n  }\n\n  public String toString()\n  {\n    String aInfo = \"This animal's name is \" + name + \". They are currently a pet: \" +\n      isPet + \". The animal is \" + age + \" years old.\";\n\n    return aInfo;\n  }\n}\n\nHere is another example of a class that takes in a vehicle type, its age, and how many miles it has:\n\npublic class Vehicle\n{\n  private String vehicleType;\n  private int vehicleAge;\n  private double vehicleMiles;\n\n  public Vehicle(String vType, int vAge, double vMiles)\n  {\n    vehicleType = vType;\n    vehicleAge = vAge;\n    vehicleMiles = vMiles;\n  }\n\n  public String getType()\n  {\n    return vehicleType;\n  }\n\n  public int getAge()\n  {\n    return vehicleAge;\n  }\n\n  public double getMiles()\n  {\n    return vehicleMiles;\n  }\n\n  public double estimateMilesPerYear()\n  {\n    return vehicleMiles \/ vehicleAge;\n  }\n}\n\nIt is important to remember that classes are just templates for creating new objects. A class is a formal implementation, or blueprint, of the attributes and behaviors of an object.\n\nAn object on the other hand is a specific instance of a class with defined attributes. Objects contain both a state and behavior, and are an instance of a class.\n\nInstances\nAn instance is a specific version of an object that can differ in numerous ways. Going back to the previous section, Rectangle, Animal, and Vehicle are all classes. If you create two different vehicles they would be specific instances of the Vehicle class. Or in other words, they would be two different vehicle objects. Remember, an object is an instance of a class.\n\nExamples:\n\npublic class ExampleClass\n{\n public static void main(String[] args)\n {\n  \/\/ `Animal` is our class.\n\n  \/\/ `myDog` and `myCat` are objects, because\n  \/\/ they are specific instances of our `Animal` class.\n  Animal myDog = new Animal(\"Cujo\", true, 7);\n  Animal myCat = new Animal(\"Kerby\", true, 2);\n }\n}\n\npublic class ExampleClass\n{\n public static void main(String[] args)\n {\n   \/\/ `Rectangle` is our class.\n\n   \/\/`mySquare` and `myRectangle` are objects, because\n   \/\/ they are specific instances of our `Rectangle` class.\n   Rectangle mySquare = new Rectangle(20, 20);\n   Rectangle myRectangle = new Rectangle(5, 10);\n }\n}\n\n###\n\n","completion":" Question: Consider this class definition of Weather.\n\npublic class Weather\n{\n    private boolean isRaining;\n    private String forecast;\n    private double temperature;\n\n    \/\/ Rest of class goes here\n}\n\nWhen we use this class to create Weather objects, which of the following is guaranteed to be true?\nCorrect: Every Weather object will have the same attributes.\nIncorrect: Every Weather object will have a temperature of 50.\nIncorrect: Every Weather object must choose which attributes it wants.\nIncorrect: It is impossible to know what attributes the Weather objects will have since the objects are not listed here.END"}
{"prompt":"In Java, you can think of everything as a class. If you want to write a program to act as a grade book, GradeBook is a class. Because of this, you can bundle classes and their functionality. You can even use classes that are written by other people without knowing exactly how they work. In this section, you will explore how to create objects from pre-existing classes.\n\nTo better understand how to create an object, let’s first look at the different parts of a class. There are 3 main parts to any class:\n\nThe instance variables, or attributes, hold the state of the object. These are declared at the beginning of the class. When declaring them, they are typically declared as private, which means that they are only accessible within the class.\n\nInstance variables are not usually initialized when you declare them. For primitive variables, that means that these variables are created with default values. When an object has not been created, or “instantiated”, it isn’t pointing to any particular object data. When that happens, the object, in this case, is considered to be a null object. The keyword null is a special value used to indicate that a reference variable is not associated with any object.\n\nThe constructor is used to instantiate – create an instance of – an object. Anytime a new object is created, the constructor is run. Notice that the constructor has a different header (first line) compared to other methods. The constructor header has the same name as the class, is always declared public, and has no return type (you will learn more about return type later in this section). A class contains constructors that are invoked to create objects.\n\nThe third part of the class is the methods. These make up the behaviors of the object. There can be any number of methods, some of which take an input, some of which return a value, and some that do either both or neither. You will discuss methods later in this unit.\n\nLet’s take a closer look at the constructor. The first line of the constructor (and other methods) is known as the method signature. A signature consists of the constructor name and the parameter list.\n\nThe parameter list, in the header of a constructor, lists the types of the values that are passed in and their variable names. These are often referred to as formal parameters. Parameters allow values to be passed to the constructor to establish the initial state of the object.\n\nTo create a new rectangle, you call the constructor and pass values that correspond to the parameter list. For example, to create a rectangle with a width of 5 and a height of 3, you would call it from the main function like this.\n\nRectangle rect = new Rectangle(5, 3);\n\nIn the above example, the 5 and 3 are known as arguments. An argument is a value that is passed into a constructor (or any method) when called. These are often referred to as actual parameters. The actual parameters passed to a constructor must be compatible with the types identified in the formal parameter list.\n\nArguments are passed to the object using call by value. Call by value initializes the formal parameters with copies of the actual parameters.\n\nAs you saw in the example above, every object is created using the keyword new followed by a call to the class’ constructor. The call to the constructor must contain the list of parameters that match the formal parameters.\n\nOnce you create a new object, Java allocates memory for this object. Unlike primitive variables that store the object address, the memory associated with a variable of a reference type holds an object reference value or, if there is no object, null. This value is the memory address of the referenced object.\n\nTo create an object, the arguments need to match the formal parameters, but what if you want to specify a different set of parameters? For example, maybe you want to create a square and only provide one side length.\n\nIn Java, you can do this with what is called a constructor overload. Let’s take a look at an example:\n\npublic class Rectangle\n{\n  private int width;\n  private int height;\n  public Rectangle(int rectWidth, int rectHeight)\n  {\n    width = rectWidth;\n    height = rectHeight;\n  }\n  public Rectangle(int sidelength)\n  {\n    width = sidelength;\n    height = sidelength;\n  }\n}\n\nConstructors are said to be overloaded when there are multiple constructors with the same name but a different signature. In the example above, you see two constructors with the name Rectangle. One constructor takes two integers and the other takes one. Since the formal parameter lists are different, the signatures are different, and you can say that the constructor is overloaded. Now you can create a rectangle object by passing either one or two arguments in the call to the class constructor.\n\nYou have seen here how you can create the Rectangle class and instantiate new objects, but you can also use existing classes and class libraries to create objects. When you do this, you need to make use of documentation.\n\nDocumentation is a great resource to use to see how a class works. As long as you can read the documentation, you don’t need to know how the class works.\n\nThe documentation for a class tells us how to use the class constructor and various methods that the class provides.\n\n###\n\n","completion":" Question: \/** \n * The Plant class describes a plant.\n * \n * Every plant has a type and number of watering days.\n * \n *\/ \n\npublic class Plant\n{\n    \/\/ Attributes\n    private String plantType;\n    private int wateringDays;\n\n   public Shark(String type, int days)\n   {\n          plantType = type;\n          wateringDays = wateringDays;\n   }\n}\n\nWhich of the following choices is a formal parameter of the constructor?\nCorrect: days\nIncorrect: plantType\nIncorrect: int\nIncorrect: PlantEND"}
{"prompt":"As stated earlier, objects have both state and behavior. The state of the object is stored in the instance variables and can be initialized through the constructor. An object’s behavior refers to what the object can do (or what can be done to it) and is defined by methods. Methods are procedures that allow us to control and define the behavior of an object.\n\nIn this section, you are going to look at methods that do not take any input and do not return any values. In subsequent sections, you will take a look at methods that take an input and\/or return a value.\n\nAs you saw with constructors, methods have a signature that consists of the name of the method and the parameter list. A method signature for a method without parameters consists of the method name and an empty parameter list. Here are some examples:\n\npublic void printHello();\npublic void printWidth();\n\nEach method signature has four parts:\n\npublic - The public statement tells Java which classes can see and use the method. In this course, you will see public methods that allow other classes to call the methods and private methods which are only available to that particular class.\n\nvoid - After the public or private declaration, the signature contains the return type. You will explore return value in a subsequent section, but when a method doesn’t return a value, you use void as the return type. Some return type or void is required for all methods, but not for the constructor.\n\nmethodName - After the return type, you see the name of the method. While the name can be anything, it is important to give methods names that make sense. For example, if you want a method to print the value of a rectangle width, you may name it printWidth() so that the user would know what to expect from the method.\n\n() - Finally you have a set of parentheses that hold the parameter list. In this case, you have no parameters, so you include an empty set of parentheses.\n\nMethods allow programmers to perform a specific task without having to know the details of how that method was written. This is known as procedural abstraction. The programmer only needs to know what the method does, including any inputs and any outputs to the method.\n\nWhen calling a method (or constructor), the call interrupts the sequential execution of statements, causing the program to first execute the statements in the method or constructor before continuing. Once the last statement in the method or constructor has been executed or a return statement is executed, the flow of control is returned to the point immediately following where the method or constructor was called.\n\nMethods can be called from any other method, including the main method or another method in a class. How a method is called depends on the type of method that you are calling. In this section, you are going to look at calling non-static void methods. Non-static methods are called through objects of a class and you need to create an object before you can call them. In contrast, static methods can be called without creating a particular instance of an object.\n\nUser input is an important part of any user program. While this course will not go into a lot of detail on user input, it is important to understand the basics to help make interactive programs.\n\nUser input in this course will be accomplished using a scanner object. A scanner object is a type of variable that allows you to read from the console.\n\nHere is the basic setup for using the scanner.\n\nimport java.util.Scanner;\nclass MyProgram \n{\n    public static void main(String[] args) \n    {\n        Scanner input = new Scanner(System.in);\n     }\n}\n\nNotice that the program imports the Scanner from the java.util library. Java uses import statements to load additional libraries that are not available by default.\n\nOnce imported, you create an input variable using the Scanner class. In this case, the scanner is reading from System.in which is the console.\n\nAfter creating the scanner object, you can then use the variable to read different values in from the user. Depending on the value type, you use will use a different method to import the value.\n\nLet’s take a look at an example with the Rectangle class below.\n\nNotice in this example how the two objects, r1, and r2 are created using the Rectangle constructor. To call the printArea() function, the dot operator is used along with the object name.\n\nIt is important to note that an object must be instantiated to call a method. If the object is only declared, any attempt to call a method on that object will result in a NullPointerException being thrown. For example:\n\nRectangle r1;  \/\/ Declared but not instantiated\nr1.printArea();  \/\/ Will throw NullPointerException\n\nSince a void method doesn’t have a return type, it must be called as a separate call, not as part of an expression. As you saw in the example above, the printArea() method was called on a separate line. Calling it to assign a value or as part of a print statement will cause an error.\n\nRectangle r1 = new Rectangle(10, 2);\nr1.printArea(); \/\/ Valid\ndouble a = r1.printArea();  \/\/ Invalid since printArea doesn't return a value\nSystem.out.println(r1.printArea()); \/\/ Also invalid\n\n###\n\n","completion":" Question: Which of the following is a correctly written method for the class below?\n\npublic class Alarm \n{\n    private int startMin;\n    private int length;\n\n    public Alarm(int minute, int duration)\n    {\n        startMin = minute;\n        length = duration;\n    }\n\n    public Alarm(int duration)\n    {\n        startMin = 0;\n        length = duration;\n    }\n}\nCorrect: public void addTenMinutes()\n{\n    length = length + 10;\n}\nIncorrect: public addTenMinutes()\n{\n    length = length + 10;\n}\nIncorrect: addTenMinutes()\n{\n    length = length + 10;\n}\nIncorrect: public void addTenMinutes\n{\n    length = length + 10;\n}END"}
{"prompt":"As you saw in the section above, you can use methods to help control and define procedures for your objects. In the last section, you looked at methods that took no input and returned no values. In this section, you are going to look at methods that take an input value, but do not return a value.\n\nRecall that methods are like blocks of code that do a particular thing. You can write a method that prints out “hello” when called or a method that draws a circle. But what if you want to create a method to add ten to a number?\n\nYou would expect an addTen() method to add 10 to any number it is given. If you give it 3, the method will give us 13. Were you to give it 32, it would give us 42. This pattern can be generalized even more: if you give the method any number x, it will give us x + 10 in return. The action that the addTen() method takes is the same every time – it adds 10 – the only thing that changes is the number you give to the method. The number that you pass to the method is called a parameter.\n\nLet’s write the addTen() method in code:\n\npublic void addTen(int x)\n{\n  int xPlusTen = x + 10;\n  System.out.println(xPlusTen);\n}\n\nNotice that there is an x that is being taken in and used by the method. This is the parameter. Its value will be whatever the user decides to “pass” to the method. Also, note that the x parameter can be used as a regular variable in the body of the method.\n\nNow that the addTen() method is defined, it’s time to call the method. Let’s first add ten to the number 5:\n\naddTen(5);\n\nThis will result in 15 being printed to the console.\n\nThis works with variables as well. You can create a variable y that stores a number, then pass y to the addTen() method:\n\nint y = 115;\naddTen(y);\n\nThe variable 115 is passed as an argument to the addTen() method. The method accepts 115 as the parameter, adds 10 to it, and then prints 125 to the console. Note that the argument type needs to match the parameter type.\n\nWhen we pass an argument to a method, it is said to be passed by value, which means a copy of that argument is made to use in the method. As a result, any change to the formal parameter will not be reflected in the actual parameters from the original calling function.\n\nIt’s often helpful to write methods that can take in more than one parameter. For example, if you were to write a generic add() method, you would want to be able to input two numbers. To include more than one parameter, you can simply write more than one parameter, separated by a comma. The code below takes in two numbers, represented by x and y, and adds them:\n\npublic void add(int x, int y)\n{\n  int sum = x + y;\n  System.out.println(sum);\n}\n\nYou call the method in a similar manner. If you give the function the following calls:\n\nadd(10, 90);\nadd(635, 1000);\nint first = 72;\nint second = 14;\nadd(first, second);\n\nthen the program will print the following to the console:\n\n100\n1635\n86\n\nUsing parameters allows us to write code that is flexible and reusable. Writing a method is like telling the program to do something (for example, add two numbers or draw a rectangle on the canvas). Parameters are like giving that method specific instructions (“I want to add 3 and 7” or “I want my greeting message to say their name and my name”).\n\nFor example, if you wanted to print several greetings, you’d likely want them to contain different text depending on the person receiving the greeting. If each of these pieces of information was hard-coded into the method, you would need a separate method for each greeting!\n\nUsing parameters allows you to write one printMessage method that can be used to send many greeting messages:\n\npublic void printMessage(String to, String from, String salutation, String message)\n{\n  System.out.println(\"-------------\");\n  System.out.println(salutation + \" \" + to + \",\");\n  System.out.println(message);\n  System.out.println(\"Best regards,\");\n  System.out.println(from);\n  System.out.println(\"-------------\");\n}\n\nIf Karel wants to send a birthday message to Bill Gates and a Halloween card to Steve Wozniak, Karel could write:\n\nprintMessage(\"Bill Gates\", \"Karel\", \"Howdy\", \"Wishing you a happy birthday!\");\nString halloweenMessage = \"Hope you have a spooky Halloween!\";\nprintMessage(\"Steve Wozniak\", \"Karel\", \"Hi\", halloweenMessage);\nJava\nThis would print two letters to the console:\n\n-------------\nHowdy Bill Gates,\nWishing you a happy birthday!\nBest regards,\nKarel\n-------------\n-------------\nHi Steve Wozniak,\nHope you have a spooky Halloween!\nBest regards,\nKarel\n-------------\n\nIt’s very important to pass arguments to methods in the proper order. Using the printMessage example above, you may know that Karel is the name of the person sending the message and that you want it to start with “Howdy”, but the computer does not know this information. The way that the computer finds out which argument goes to which parameter is by the order in which your code passes the arguments into the method.\n\nFor example, if you wrote:\n\nprintMessage(\"Howdy\", \"Karel\", \"Wishing you a happy birthday!\", \"Bill Gates\");\n\nyou would end up with a mixed-up message:\n\n-------------\nWishing you a happy birthday! Howdy,\nBill Gates\nBest regards,\nKarel\n-------------\nPlain text\nAs you can see, order matters when you are using parameters.\n\nAs you saw with constructors, you can also overload methods. Recall that a method signature consists of the method name and the ordered list of parameter types. You can overload a method by giving the method the same name as another method, but a different signature by having a different ordered list.\n\nHere is an example of a proper overload:\n\npublic int add(int a, int b) {  }\npublic int add(int a, int b, int c) {  }\n\nNotice in the example above how one method takes two integers as an input and the other takes 3 integers. It is important to note that the variable names do not make a difference, it is only the type and order of the parameters. Given a method signature like this:\n\npublic int add(int x, int y, int z) {  }\n\nThe above would not overload the methods above since there is already a method that takes three integers. Changing the variable names doesn’t impact whether a method is overloaded.\n\n###\n\n","completion":" Question: Suppose there is a class called Athlete. One of the methods is given below. It sets the instance variable isAllStar to the parameter value.\n\npublic void setAllStarStatus(boolean status)\n{\n    isAllStar = status;\n}\n\nUsing the Athlete object called karel, which of the following is the correct way to set karel’s all-star status to false?\nCorrect: karel.setAllStarStatus(false);\nIncorrect: karel.setAllStarStatus(status=false);\nIncorrect: karel.isAllStar = false;\nIncorrect: karel.setAllStarStatus(isAllStar = false);END"}
{"prompt":"Similar to how methods can take in values as parameters, methods can also return values.\n\nRecall the addTen() method from the previous section:\n\npublic void addTen(int x)\n{\n  int xPlusTen = x + 10;\n  System.out.println(xPlusTen);\n}\n\nThis method takes in a parameter, x, and adds 10 to it. Lastly, the program prints the value to the console.\n\nBut what if you wanted to store the value of x + 10? In the method above, x + 10 is stored into a local variable called xPlusTen. However, this variable is lost when the method is finished – it cannot be accessed outside of the method.\n\nUsing a return statement will allow you to pass a value back out of the method. That return value can be stored into a variable for later use.\n\nHere’s how to rewrite addTen() to return a value instead of printing:\n\npublic int addTen(int x)\n{\n  int xPlusTen = x + 10;\n  return xPlusTen;\n}\n\nThere are a few differences here.\n\nFirst, the return statement on line 4 replaces the print statement and does not require parentheses. Second, take a look at the first line of the method: public int addTen(int x). Instead of void, you now use int. This tells the program that the addTen() method will return a value that is an int. This is called the return type of the method.\n\nNon-void methods return a value that is the same type as the return type in the signature. To use the return value when calling a non-void method, it must be stored in a variable or used as part of an expression. Up to this point, you’ve only used the void return type, which indicates that the method does not return anything. Because the addTen() method will return an integer, you set the return type to int.\n\nWhen returning a value, it’s important to note that that method is not printing the value to the console, but rather sending back to the method call statement. This is similar to how passing in a value as an argument does not print the value to the console.\n\nA return value by itself would not be very useful, given that it does not print to the console. Fortunately, you can store a method’s return value into a variable. Take a look at the following code:\n\nint num = 7;\nint tenAdded = addTen(num);\n\nFirst, you create a variable named num and initialize it to 7. Then, you create another variable called tenAdded. Notice that tenAdded is not given a normal value. Instead, you are setting it equal to addTen(num). This means that the tenAdded variable will hold the result of whatever the method call addTen(num) returns. You know that addTen(num) will return 17, so tenAdded will be 17.\n\nReturn values work in many situations. For example, you can rewrite the add method from the previous section to return the sum instead of print it to the screen:\n\npublic int add(int x, int y)\n{\n    int sum = x + y;\n    return sum;\n}\n\nYou can now call the method and store its return values\n\nint sum = add(10, 90);\nSystem.out.println(sum);\n\nwhich would print 100 to the console.\n\n###\n\n","completion":" Question: Suppose you have a class called Rollercoaster. The Rollercoaster class has a method called goingDown, partially defined below\n\npublic boolean goingDown()\n{\n    \/\/ code omitted\n}\n\nWhich of the following statements correctly stores the return value of goingDown when it is called on the Rollercoaster object called ferrisWheel?\nCorrect: boolean down = ferrisWheel.goingDown();\nIncorrect: int down = ferrisWheel.goingDown();\nIncorrect: double down = ferrisWheel.goingDown();\nIncorrect: String down = ferrisWheel.goingDown();END"}
{"prompt":"As you have learned, a character is one of the primitive data types in Java. You use the char keyword to declare it. A character is a single letter. 'A', 'a', 'D', and 'Z' are all examples of characters. It is great that you have an easy way to represent a single character, but what if you wanted to represent words or sentences? How can you do this?\n\nA String is a sequence of characters. You use Strings to represent full words and sentences. For example, the famous \"Hello World\" is a String. Some more examples of Strings:\n\n\"I am a String. A sequence of characters strung together to form words and\/or sentences.\"\n\"CodeHS is the best coding website ever! Everyone loves CodeHS!\"\n\"She sells seashells by the seashore.\"\n\"Strings!\"\n\"abcdefghijklmnopqrstuvwxyz\"\n\nA String is not a primitive type like int, char, boolean, and double. Primitive types always start with lowercase letters, but a String starts with a capital letter. This makes it an object.\n\nYou can create Strings using a string literal or calling the String constructor. A string literal is a string inside of quotes, as you saw above. The String constructor takes a string literal as an input.\n\nString strLiteral = \"karel\"; \/\/ String Literal\nString strConstr = new String(\"karel\"); \/\/ String constructor\n\nBoth options will create a String variable. The constructor method will force Java to create a new String value in the heap, while the String literal may allow Java to reuse an existing value in the heap.\n\nConcatenate is a fancy word for joining or linking two things together. To concatenate two or more Strings means that you are joining them together to form one String. You can do this in Java by using the addition operator, +, or +=.\n\nIn this example, you concatenate two separate Strings, \"Mc\" and \"Donald's\", to form one String, \"McDonald's\".\n\nString one = \"Mc\";\nString two = \"Donald's\";\nString concatenate = one + two;\nSystem.out.println(concatenate);\n\nAfter running the program, the concatenated String \"McDonald's\" gets printed to the screen.\n\nIt is important to note that String objects are immutable, meaning that strings cannot be changed by methods or concatenation. Instead, when you run methods or concatenate values with Strings, you are actually overwriting the existing String with a new String.\n\nYou are not limited to concatenating strings with other strings. You can concatenate Strings with other data types. Here you are concatenating a string and an integer together:\n\nint number = 24;\nSystem.out.println(\"This String is concatenated with an integer at the end: \" + number);\n\nLook familiar? You have been doing this all the time in previous programs when printing out results to the screen! After running the program, you get:\n\nThis String is concatenated with an integer at the end: 24\nPlain text\nYou can also concatenate Strings with other primitive types like char, boolean, and double. When you concatenate a String with a primitive variable, there is an implicit conversion of the primitive variable to a String to perform the conversion.\n\nIn Java, you create string literals using quotation marks, but what if you want to print a string with quotes, for example \"Hello, Karel,\" said Tracy.\n\nJava uses the concept of an escape sequence to essentially send a signal to the compiler to treat a character a little differently. In Java, the escape character is a backslash, \\. When Java sees a backslash inside of quotation marks, it knows that it is a signal to treat the next character differently within the literal string. For example, if you want to include quotation marks in your output, you would use a \\\".\n\n\/\/ Print \"Hello, Karel,\" said Tracy\nSystem.out.println(\"\\\"Hello, Karel,\\\" said Tracy\");\n\n\n###\n\n","completion":" Question: What would be printed by this code snippet?\n\nString subject = \"Computer Science\";\nString opinion = \" is for everyone!\";\n\nSystem.out.println(subject + opinion);\nCorrect: Computer Science is for everyone!\nIncorrect: Computer Science\nIncorrect: Computer Scienceis for everyone!\nIncorrect: This code would not compile. You can’t add Strings.END"}
{"prompt":"In this section, you will examine the different methods that can be run on String objects to create new, transformed String objects. You will also take a look at how Java uses libraries and documentation to help programmers implement more complex programs.\n\nLike physical town libraries, Java libraries and APIs (Application Programming Interface) are collections of written works made by other authors. An API is typically used to interface two systems and make using them easier. For example, if you wanted to program a robot in Java, you may use a set of commands from an API to control the motors. In contrast, libraries tend to be extensions of the main programming language that can help simplify your code since it takes common tasks and allows you to implement them without having to write out your own code.\n\nLibraries can be broken down into a series of packages. Each package is then subdivided into specific classes with specific methods that can be run for that class.\n\nTo help you do this, Java provides documentation. Documentation for APIs and libraries are essential to understanding the attributes and behaviors of an object of a class. This section will focus on the Java String documentation, but you can find all the documentation for Java here: https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/\n\nAs a note, String objects are found in the java.lang package and are available by default in your programs.\n\nJust like you can concatenate primitive data types with strings, you can also concatenate reference data types with strings. In doing so, the reference data type’s toString() method gets called and concatenated to the existing String. The toString() method provides the string representation of the given object and is called anytime the object is referenced where it needs to be shown as a string, for example in a print statement.\n\nLet’s look at an example of the Nickname class.\n\npublic class Nickname\n{\n  private String firstName;\n  private String lastName;\n  private String nickname;\n  public Nickname(String realFirstName, String realLastName, String moniker)\n  {\n    firstName = realFirstName;\n    lastName = realLastName;\n    nickname = moniker;\n  }\n  public String toString()\n  {\n    return firstName + \" (\" + nickname + \") \" + lastName;\n  }\n}\n\nAny Nickname object that is created has three different instance variables, so how does Java know what to use when you want to print out the name? It uses the toString() method. For example, if you create an object like this:\n\nNickname karel = new Nickname(\"Karel\", \"Dog\", \"the Dog\");\n\nThen print the object using the following statement:\n\nSystem.out.println(karel);\n\nYou will get the following out:\n\nKarel (the Dog) Dog\n\nNotice in the example above that you don’t specifically call the toString() method. The method is called implicitly when you use the object in a situation where a string is needed.\n\nIf you want to concatenate the output with another string, you can.\n\nSystem.out.println(karel + \" went to a movie.\");\n\nResults:\n\nKarel (the Dog) Dog went to a movie.\n\nYou will remember that strings are a sequence of characters. Let’s look at this example String below:\n\nString str = \"Hello World\";\n\nEach character in this string has a position from 0 to 10. For example, the first character, 'H', is at position 0. The second character, 'e', is at position 1. The last character, 'd', is at position 10. Note that the space between the two words, ' ', is also a character and is located at position 5.\n\nA character’s particular position in a string is formally known as its index. A String object has index values from 0 to the length of the string - 1. Attempting to access indices outside this range will result in an IndexOutOfBoundsException.\n\nMany useful String methods make use of the string’s index value. While there are many different String methods, there are several that are widely used within the AP Java programming course.\n\nString str2 = new String(str)\tConstructs a new String object that represents the same sequence of characters as str\nname.length()\tReturns the number of characters in a String object\nname.substring(2, 6)\tReturns the substring beginning at index 2 and ending at index 5.\nname.substring(index, index + 1)\tReturns the string identical to the single element substring at position index\nname.indexOf(\"d\")\tReturns the index of the first occurrence of d; returns -1 if not found.\nname.equals(\"Karel\")\tReturns true if name is equal to Karel; returns false otherwise\nname.compareTo(\"Karel\")\tReturns a value < 0 if name is less than Karel; returns zero if name is equal to Karel; returns a value > 0 if name is greater than Karel.\n\n###\n\n","completion":" Question: What method must a class implement in order to concatenate an object of the class with a String object?\nCorrect: toString\nIncorrect: A constructor\nIncorrect: length\nIncorrect: printEND"}
{"prompt":"As you saw with strings, using Java packages can make your program easier to implement. In this section, you are going to explore two other members of the java.lang package, the Integer and Double classes.\n\nA wrapper class in Java is a class that contains or “wraps” primitive data types as an object. You will find wrapper classes for all of our primitive data types. One thing to note about the wrapper classes is that they have similar (if not the same) names as the primitive data types, but they all begin with capital letters.\n\nThe wrapper classes in Java actually serve two purposes. First, as their name implies, they can take primitive data types and convert them into an object. Later in the course, you will see some examples of when you need to use an object representation of primitive data.\n\nSecond, wrapper classes provide static methods that allow you to perform some basic number operations, such as converting data from a string to a number. This means you can do some basic operations without creating an instance of the object. This section will take a closer look at some of these methods within the Integer and Double classes.\n\nCreating wrapper objects, such as Integer and Double objects can be done in a similar way to other objects. The constructor takes a single value and converts it into the object version of that value.\n\nInteger y = new Integer(17);\nDouble z = new Double(3.14);\n\nFortunately, you don’t need to explicitly create Integer and Double objects every time you need to use them. Java provides a process called autoboxing. Autoboxing is the automatic conversion that the Java compiler makes between primitive types and their corresponding object wrapper classes. This includes converting an int to an Integer and a double to a Double.\n\nThe Java compiler applies autoboxing when a primitive value is passed as a parameter to a method that expects an object or if a primitive value is assigned to a variable of the corresponding wrapper class.\n\nSimilarly, Java has a process for unboxing. Unboxing is the automatic conversion that the Java compiler makes from the wrapper class to the primitive type. This includes converting an Integer to an int and a Double to a double. The Java compiler applies unboxing when a wrapper class object is passed as a parameter to a method that expects a value of the corresponding primitive type or a wrapper class object is assigned to a variable of the corresponding primitive type.\n\nIn addition to creating objects, the wrapper classes also provide several useful methods, some of which are static. As a reminder, a static method is a method that can be used without creating an instance of the object. You use the class name followed by a dot and the method name to call static methods.\n\n###\n\n","completion":" Question: Java automatically converts between objects and primitives in the process of autoboxing and unboxing.\n\nWhat happens when an Integer is unboxed?\nCorrect: An Integer is unboxed when it is converted to a primitive value.\nIncorrect: An Integer is unboxed when it is converted to a Double.\nIncorrect: An Integer is unboxed when it is passed to a method.\nIncorrect: An Integer is unboxed when it is converted to an Integer value.END"}
{"prompt":"In this section, you are going to take a look at another class in the java.lang package, the Math class. The Math class is a class that only contains static methods that are used for specific purposes.\n\nSeveral of the methods that are used from the Math class perform basic math functions. These are listed in the table below.\n\nMath.abs(x)\tReturns the absolute value of x. This can take either an int or a double.\nMath.pow(base, exponent)\tReturns the value of base raised to the power of exponent.\nMath.sqrt(x)\tReturns the positive square root of x.\n\nAs a reminder, since the math class contains only static methods, you do not need to instantiate an object to use it. Static methods are called using the dot operator along with the class name.\n\nAnother useful method from the Math class is the random method. The random method takes no input and returns a random number from zero to one, inclusive of zero, but not inclusive of one.\n\n\/\/ Generate a random number\ndouble ranNum = Math.random();\n\nNow you may be thinking that a random number between zero and one is not that useful, however, the number can be manipulated to generate a random number in any range. Using three basic operations, you can convert the output of Math.random() into any random number you need.\n\nMultiply - By multiplying the results of Math.random(), you can create values from 0 up to (but not including) the number you multiple by.\n\n\/\/ Generates a random value from 0 to 10\ndouble ranNum = Math.random() * 10;\n\nAdd - Adding to the results offsets the range that you will get from the random number.\n\n\/\/ Generates a random value from 100 to 110\ndouble ranNum = Math.random() * 10 + 100;\n\nCasting to an integer - Finally, if you cast the value to an integer, you will truncate the value and only have random whole numbers.\n\n\/\/ Generates random integers between 50 and 75 (not including 75)\nint ranNum = (int)(Math.random() * 25) + 50;\n\nWatch out! Be careful, a common mistake that programers make is to cast the value at the wrong place. You must include the multiplier inside parentheses along with the random call. If you do not, you will end up casting only the Math.random() part, and since it is always less than one, your random function will always result in zero. The offset addition operation can either be inside or outside the parentheses.\n\n\/\/ Same as above, but without the parentheses\n\/\/ The result is zero every time\nint ranNum = (int)Math.random() * 25 + 50;\n\n###\n\n","completion":" Question: What range of numbers would be generated by using:\n\nint num  = (int) (Math.random() * 201);\nCorrect: 0 - 200\nIncorrect: \n1 - 200\nIncorrect: 1 - 201\nIncorrect: 0 - 201END"}
{"prompt":"How do you write code that tells us whether a user is logged in to our program? Booleans are the solution to these questions.\n\nA boolean refers to a value that is true or false. Those are the only values of a boolean expression, and these are useful if you want to check if something is true or false.\n\nLet’s meet the fellow behind the name, “booleans,” George Boole. Mr. Boole was an English-born mathematician, philosopher, and logician. He introduced boolean algebra in The Mathematical Analysis of Logic (1847) and Investigation of the Laws of Thought (1854). Many consider him to be one of the founders of Computer Science.\n\nLet’s start with an example – create a variable, set it equal to true or false, then print the value.\n\nYou first want to declare the variable, loggedIn, and initialize its value.\n\nboolean loggedIn = false;\n\nYou can similarly set the variable to true instead:\n\nboolean loggedIn = true;\n\nYou can imagine a boolean variable as a box that can hold only the values true or false.\n\nNotice that you do not need to have quotations around true or false.\n\nThe full example looks like:\n\nboolean loggedIn = false;\nSystem.out.println(\"User logged in?: \" + loggedIn);\n\nComparison operators allow you to compare two values against one another. A comparison returns a boolean result of either true or false.\n\nThe table below lists each of the common comparison operators and their usages:\n\nOperator\tUsage\n>\tGreater Than\n<\tLess Than\n>=\tGreater Than Or Equal To\n<=\tLess Than Or Equal To\n==\tEqual To\n!=\tNot Equal To\n\nIn the following example, you compare two variables x and y. You store the result of this comparison in variable z.\n\nint x = 10;\nint y = 8;\nboolean z = x > y;\nSystem.out.println(z);\n\nWhat will get printed to the screen? The above comparison, x > y is evaluating if 10 is greater than 8. Because 10 is indeed greater than 8, z is assigned a value of true. Thus, true will get printed to the screen.\n\nLet’s get a little more practice. Take a look at the following code segment below. Pay close attention to each comparison and the operator being used.\n\n\/\/ Declare some integer variables to use for practice comparisons below.\nint a = 3;\nint b = 5;\nint c = 2;\nint d = 3;\n\n\/\/ You store the boolean results of each comparison into boolean variables t-z.\nboolean t = a > 0; \/\/ true\nboolean u = a == d; \/\/ true\nboolean v = d >= b; \/\/ false\nboolean w = b > c; \/\/ true\nboolean x = a != d; \/\/ false\nboolean y = d < = a; \/\/ true\nboolean z = 4 < = c; \/\/ false\n\nIn addition to integers, it is possible to compare other data types too. In the example below, the boolean variables are storing the results of a comparison between some of the boolean values computed above.\n\nboolean boolComparison1 = t == u; \/\/ true\nboolean boolComparison2 = t == w; \/\/ true\nboolean boolComparison3 = t != u; \/\/ false\nboolean boolComparison4 = x != y; \/\/ true\n\nSuppose you want to write a program that restricts people under a certain height from riding on a roller coaster. For this particular roller coaster, people who are under 4 feet (48 inches) are not allowed on the ride. How would you do this?\n\nint heightInInches = readInt(\"How tall are you (in inches)? \");\nboolean isTallEnough = heightInInches >= 48;\nSystem.out.println(\"Can ride on the roller coaster: \" + isTallEnough);\n\nAfter getting the potential rider’s height in inches, you do a comparison to ensure that they are over 48 inches. The result of this comparison is then printed out.\n\nA common mistake is using = when you actually want to use ==. = is used for assignment of variables whereas == is used for comparing the equality of two values.\nFor example, x = 5 stores the value 5 into the variable x. However, x == 5 tests to see if the value 5 is equal to the variable x and then returns either true or false. They are not the same thing!\n\n###\n\n","completion":" Question: Which of the following is NOT a relational operator?\nCorrect: =\nIncorrect: >\nIncorrect: !=\nIncorrect: <=END"}
{"prompt":"In the previous section, you learned all about logical operators and comparison operators. These form the basis for writing boolean expressions in if statements.\n\nThe if statement is a conditional statement that can be used to alter the flow of a program. You use if statements to run a segment of code only if some boolean expression first evaluates to true.\n\nAn if statement takes the following basic form:\n\nif (boolean expression)\n{\n   \/\/ Segment of code that will run if the boolean expression is true\n}\n\nIf the boolean expression evaluates to false, nothing will happen. The code within the if statement is ignored.\n\nAs mentioned above, the if statement affects the flow of the program and the code that executes based on whether the boolean expression evaluates to true or false.\n\nif statements by themselves are known as a one-way selection. A set of statements only executes if the condition of the boolean expression is true.\n\n###\n\n","completion":" Question: What is the output of this program?\n\nint phLevel = 7;\nif(phLevel < 7)\n{\n    System.out.println(\"It is acidic!\");\n}\nif(phLevel > 7)\n{\n    System.out.println(\"It is basic!\");\n}\nif(phLevel == 7)\n{\n    System.out.println(\"It is neutral!\");    \n}\nCorrect: It is neutral!\nIncorrect: It is acidic!\nIncorrect: It is basic!\nIncorrect: It is acidic!\nIt is basic!\nIt is neutral!END"}
{"prompt":"In the previous section, you saw how an if statement allowed you to use a conditional statement to determine if a block of code would be executed. In this section, you are going to extend that concept into an else statement.\n\nYou can add the else keyword to our if statement block. Using an else statement allows for a two-way selection, a set of code to execute if the statement is true and another set of code to execute if the statement is false.\n\nIn this case, if the boolean expression in our if statement evaluates to false, the code within the else segment will run. If the boolean expression evaluates to true, the code within the if segment will run.\n\nif (boolean expression) {\n   \/\/ Segment of code that will run if the boolean expression is true\n}\nelse {\n   \/\/ Segment of code that will run if the boolean expression is false\n}\n\n###\n\n","completion":" Question: Consider the following code snippet\n\nif ( x == y)\n{\n    \/\/ Statement A\n} \nelse \n{\n    \/\/ Statement B\n}\n\nWhich statement will be executed if x = 20 and y = 15?\nCorrect: Statement B\nIncorrect: Statement A\nIncorrect: Statement A and Statement B\nIncorrect: Neither StatementEND"}
{"prompt":"Building on the previous two sections, you are going to look at adding the else if clause to our if blocks. The else if clause allows for a multi-way selection by using different conditional statements to represent different conditions.\n\nYou can add the else if keyword between your if and your else statement. If boolean expression one evaluates to false, then boolean expression two gets evaluated next. If boolean expression two also turns out to be false, the code within the else segment will run.\n\nif (boolean expression one) {\n   \/\/ Segment of code that will run if boolean expression one is true\n}\nelse if (boolean expression two) {\n   \/\/ Segment of code that will run if boolean expression one is false and two is true\n}\nelse {\n   \/\/ Segment of code that will run if boolean expression one and boolean expression two are both false\n}\n\nIt is important to note that you can have as many else if statements as you want, or you can have none. When looking at conditional blocks of code, the only required statement is the if statement. This can optionally be followed with any number of else if statements, and then optionally one else statement.\n\n###\n\n","completion":" Question: What is the output of the following code snippet?\n\ndouble ticketPrice = 15.75;\n\nif(ticketPrice > 15)\n{\n   System.out.println(\"Too expensive!\");\n}\nif(ticketPrice > 10)\n{\n   System.out.println(\"Typical\");\n}\nelse if(ticketPrice > 5)\n{\n   System.out.println(\"Great deal!\");\n}\nelse \n{\n    System.out.println(\"Must be a scam\");\n}\nCorrect: Too expensive!\nTypical\nIncorrect: Must be a scam\nIncorrect: Typical\nIncorrect: Too expensive!END"}
{"prompt":"In the previous sections, you looked at how boolean expressions can be used in an if-else if-else statement. In this section, you are going to take a step back and look at the boolean expressions used in those conditional statements.\n\nBoolean variables can only take on one of two possible values, true or false. Logical operators allow you to combine and connect booleans in useful ways. When you use logical operators, the resulting expression will result in a single boolean value.\n\nThere are three fundamental logical operators:\n\n- NOT\n- OR\n- AND\n\nThese should look quite familiar; in fact, you use them in speech every day! The NOT operator is used on a single boolean, whereas AND and OR are used across multiple boolean values.\n\nLogical operators can be used to help avoid nested if statements. A nested if statement consists of an if statement within an if statement. For example:\n\nif (temp > 70) {\n    if (sunny) {\n        System.out.println(\"Time to get outside!\");\n   }\n}\n\nUsing logical operators, you can condense a nested if statement into a single statement, for example:\n\nif (temp > 70 && sunny) {\n    System.out.println(\"Time to get outside!\");\n}\n\nAND is represented in Java as: &&. An expression using AND is true only when all its component parts are true. If any of the boolean values are false, the whole expression evaluates to false.\n\nFor example, if it is 6:30am AND it is a school day, you should wake up. You can test the expression of “6:30am AND a school day.” If both are true, then the whole expression evaluates to true. If either or both are false, then the whole expression is false, and you should stay in bed.\n\nboolean sixThirty = true;\nboolean schoolDay = false;\nSystem.out.println(sixThirty && schoolDay);  \/\/ because both values aren't true, it prints \"false\"\n\nFor variables p and q that can be true or false:\n\np\tq\tp AND q\ntrue\ttrue\ttrue\ntrue\tfalse\tfalse\nfalse\ttrue\tfalse\nfalse\tfalse\tfalse\n\nOR is represented in Java as ||. An expression using OR is true when all or any of its parts are true. It is only false when all of the boolean values are false.\n\nSay that you are trying to decide whether to wear a coat today. You’ll wear your coat if it is raining right now or if it is cold outside. You can evaluate this expression based on the answers to those two boolean values. If it’s raining, cold, or raining and cold, then you will wear your coat. The only case in which you would not wear your coat is if it’s neither raining nor cold.\n\nboolean isRaining = true;\nboolean isCold = false;\nSystem.out.println(isRaining || isCold); \/\/ it's not cold, but it is raining, so it prints true\n\nFor variables p and q that can be true or false:\n\np\tq\tp OR q\ntrue\ttrue\ttrue\ntrue\tfalse\ttrue\nfalse\ttrue\ttrue\nfalse\tfalse\tfalse\n\nSince AND expressions evaluate to false if any condition is false, and OR expressions will evaluate to true if any condition is true, there is a shortcut that Java uses to make your programs run more efficiently. If the first value of the boolean expression is false in an AND operation, or the first value is true in an OR operation, the remaining conditions are irrelevant!\n\nBecause these expressions will always evaluate to false and true respectively, regardless of what the other expression evaluates to, Java will not evaluate the second expression. This process of skipping the second condition in a boolean expression is called short circuit evaluation.\n\nExpression\tResult\nfirst && second\tIf first is false, then the whole expression must be false. Don’t bother evaluating second.\nfirst || second\tIf first is true, then the whole expression must be true. Don’t bother evaluating second.\n\nNOT is represented in Java as !. When placed in front of a boolean value, NOT causes the boolean to take on its opposite value. For example “NOT true” gives the answer “false.” This is fairly intuitive – if something is not true, then it must be false. Similarly, if something is not false, then it must be true.\n\nThe example below sets up a variable hungry as being true. Then it prints out NOT hungry.\n\nboolean hungry = true;\nSystem.out.println(!hungry);  \/\/ prints \"false\"\n\nFor a variable p that can be true or false:\n\np\t!p\ntrue\tfalse\nfalse\ttrue\n\nJust like mathematical expressions have an order of operations, boolean operators also follow an order of operations. In the case of Booleans, the ! operator takes precedence over &&, and && takes precedence over ||. Here is an example:\n\nboolean a = true;\nboolean b = false;\nboolean c = a && b || b\n\nIn this example, c evaluates to false. The first part of the expression to be evaluated would be the a && b since AND takes precedence over OR. Since that part evaluates to false, the expression short circuits and returns false.\n\n###\n\n","completion":" Question: Which of the following will result in a logical short circuit assuming a is true and b is false?\nCorrect: a || b\nIncorrect: a && b\nIncorrect: b || a\nIncorrect: !b && aEND"}
{"prompt":"In this section, you will apply some of the concepts of booleans and logical expressions as you evaluate expressions to determine whether they are equivalent.\n\nAugustus De Morgan was a British mathematician who devised two laws to help understand equivalent boolean expressions.\n\n- not(A and B) is the same as (not A) or (not B)\n- not(A or B) is the same as (not A) and (not B)\n\nCollectively these two laws are known as De Morgan’s Law. At the heart of these laws, De Morgan is saying that you can transform one expression into an equivalent expression. In terms of boolean expressions, you saw that 2 expressions are equivalent if they both evaluate to the same value for all cases. In the case of De Morgan’s law, that means that regardless of whether A is true or false and B is true or false, not(A and B) will always be the same as (not A) or (not B). Likewise, not(A and B) will always be the same as (not A) and (not B).\n\nTo help better understand De Morgan’s Law, you can use truth tables. Truth tables look at various values of boolean variables and expressions and can be used to prove boolean identities such as De Morgan’s Law.\n\nDe Morgan’s First Law states that not(A and B) is the same as (not A) or (not B). If you were to put this in terms of Java, it would look like this:\n\n!(A && B) == !A || !B\n\nLet’s break this down in a truth table.\n\nA\tB\tA&&B\t!(A&&B)\t!A\t!B\t!A || !B\nT\tT\tT\tF\tF\tF\tF\nT\tF\tF\tT\tF\tT\tT\nF\tT\tF\tT\tT\tF\tT\nF\tF\tF\tT\tT\tT\tT\n\nNotice in the table above how our two columns that contain expressions show the same values for each expression for all 4 possible combinations of values for A and B. As a result, you can see that the two expressions are equivalent.\n\nTurning now to De Morgan’s Second Law, you can do the same thing. Expressed as a Java expression, De Morgan’s second law states:\n\n!(A || B) == !A && !B\n\nLet’s take a look at the truth table for this law.\n\nA\tB\tA||B\t!(A||B)\t!A\t!B\t!A && !B\nT\tT\tT\tF\tF\tF\tF\nT\tF\tT\tF\tF\tT\tF\nF\tT\tT\tF\tT\tF\tF\nF\tF\tF\tT\tT\tT\tT\n\nAgain, if you focus on the two highlighted columns, you can see that the two sides of the expression in De Morgan’s second law are also equivalent.\n\nTruth tables can be powerful tools to help determine if two or more expressions are equivalent. To use a truth table, it is best to break down expressions into small pieces and then build them back up. Let’s take a look at this expression:\n\nA && !B || !A && B \n\nUnder what circumstances would this expression evaluate to true? You can use a truth table to answer that question. You should lay the truth table out to follow the order of operations, which means you will evaluate the NOT operators first, then the AND operators, and finally the OR operator.\n\nA\tB\t!B\tA && !B\t!A\t!A && B\tA && !B || !A && B\nT\tT\tF\tF\tF\tF\tF\nT\tF\tT\tT\tF\tF\tT\nF\tT\tF\tF\tT\tT\tT\nF\tF\tT\tF\tT\tF\tF\n\nWhen you lay out the results in a truth table, it is easy to see that the expression will evaluate to true anytime A and B have opposite values.\n\n###\n\n","completion":" Question: Which of the following logical statements is equivalent to\n\n!(A || B)\n\nWhere A and B are boolean values.\nCorrect: !A && !B\nIncorrect: A && B\nIncorrect: !A || !B\nIncorrect: !A || BEND"}
{"prompt":"In this section, you are going to look at how to compare objects. As you may recall from previous sections, objects, or reference variables, differ in several ways from primitive variables. The important difference that you will explore in this lesson is the way that the values are stored. Recall that primitive variables store actual values for the variable while objects store a reference to the memory location of the value.\n\nThe == comparison operator is designed to compare the value of two variables. Since the value that is stored for a reference variable is the memory location, using == will return whether or not the two objects have the same reference. When two objects have the same reference, they are said to be aliases.\n\nIf the objects are aliases of one another, then you know that they will also be equal.\n\nTake a look at the example below:\n\nRectangle one = new Rectangle(3,7);\nRectangle two = one;\n\nboolean same = one == two; \/\/ Will be true\n\nIn this example, the two rectangles are the same and they are also aliases of one another. As a result, comparing the objects with == returns true.\n\nYou can also do this comparison with != to check if two objects are not aliases, and both can be used to compare to null to determine whether the reference is actually to an object.\n\nRectangle three;\nboolean isSet = three != null; \/\/ Will be false\n\nIn this example, you can see the isSet variable will be set to false since variable three has not yet been set to reference an object.\n\nUsing == allowed us to find if two reference variables were aliases, but what if you want to find if two reference variables are the same?\n\nFor example:\n\nRectangle one = new Rectangle(3,7);\nRectangle two = new Rectangle(3,7);\n\nAre rectangles one and two the same? In this case, they appear to be, however, if you test them with ==, Java will return false. Why is that?\n\nRecall above that you saw how == compares the memory locations of the variables. Since both rectangles were instantiated as separate objects, they are stored in a different place in memory, so using == will return false.\n\nObjects can have several pieces of information associated with them. As a result, an object needs to have a specific method that can be used to determine if they are equal. For example, what would make two rectangles equal? Would it be that the rectangles have the same dimensions or can two rectangles be equal if they have different dimensions, but the same area?\n\nIn Java, the method that is used is called .equals(). This method is called from a variable and it passes a parameter to compare to in order to determine if the values are equal.\n\nIf you assume that one rectangle equals another rectangle if they have the same width and height, then .equals() can return true if the method compares the width and height of two rectangles and finds them to be the same.\n\nTake a look at the example below:\n\nRectangle one = new Rectangle(3,7);\nRectangle two = new Rectangle(3,7);\nboolean isAlias = one == two; \/\/ Will be set to false\nboolean isEqual = one.equals(two); \/\/ Will be set to true\n\nIn this example, you can see that one and two are not aliases of one another. If you compare them with the comparison operator, it will return false. Since both rectangles were created the same way, it seems logical that they are in fact equal and by using the .equals(), you can see that this is the case.\n\n###\n\n","completion":" Question: What is the proper way to compare String values in Java?\nCorrect: The .equals() String method\nIncorrect: The = operator\nIncorrect: The == operator\nIncorrect: The && operatorEND"}
{"prompt":"while loops are a way to change the flow of control by repeating a block of code so long as some condition remains true. The condition is written in the form of a boolean expression.\n\nThe basic structure of a while loop is shown below.\n\nwhile(boolean expression)\n{\n   \/\/ code block inside of while loop to execute if the boolean expression is true\n}\n   \/\/ code outside of while loop to execute if the boolean expression is false\n\nAs long as the boolean expression remains true, code within the while loop will be executed. The moment that the boolean expression becomes false, code outside of the while loop will be executed; the loop is done.\n\nThe boolean expression evaluates before the loop executes each time, including the first time. It is possible that the condition is false initially and the loop body is never executed.\n\nHere is a basic example of a countdown.\n\nint i = 5;\nSystem.out.println(\"Initiating countdown:\");\nwhile(i >= 0) {\n  System.out.println(i + \"...\");\n  i--;\n}\n\nYou first declare a variable i and set it equal to 5. Before the while loop, you print out a message letting the user know that the countdown is about to begin. Your while loop starts by checking to see if the boolean expression, i >= 0, is true. The current value of i is 5. 5 >= 0 is true, so the code within the while loop gets executed. It prints out the number 5 and then decrements it by subtracting 1.\n\ni is now set to 4. Our while loop then checks to see if 4 >= 0. Since this condition is still true, the code within the while loop gets executed again. This will continue until i gets down to 0. After 0 gets printed to the screen, you decrement i so that it is now set to -1. Your while loop tests to see if -1 >= 0. Since -1 is not greater than or equal to 0, the boolean expression is false. The code within the while loop is skipped. The while loop has finished its execution.\n\nAfter you run the above program, this is what gets printed to the screen:\n\nInitiating countdown:\n5...\n4...\n3...\n2...\n1...\n0\n\nYou must exercise caution when using while loops to avoid the dreaded infinite loop. An infinite loop is a loop that always evaluates to true and therefore, never terminates. It never finishes its execution. It will continue to repeat until the end of time! Infinite loops will often cause a program to freeze and crash.\n\nThe countdown program above has been rewritten below, but it is missing an essential line of code. This will cause an infinite loop:\n\nint i = 5;\nSystem.out.println(\"Initiating countdown:\");\nwhile(i >= 0) {\n  System.out.println(i + \"...\");\n}\n\nBut why? Why does this cause an infinite loop?\n\nWith the omission of i--, you are no longer changing our variable. i will forever be set to 5. Our while loop will repeatedly check to see if 5 >= 0. Since this condition is always true, the code within the while loop body will execute forever. The while loop will never terminate.\n\nYour program will just keep printing a value of 5 over and over again. Thus, after running the program, your output will look something like this (assuming the browser does not freeze and crash):\n\nInitiating countdown:\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5\n\n[NOTE: This will continue printing “5…” forever!]\n\nIn the CodeHS editor, you can manually stop the program by clicking on the “STOP” button next to the “RUN CODE” button. Otherwise, it will continue spamming the number 5 at us until the end of time.\n\nOne way to break out of a loop, infinite or otherwise is to execute a return statement. If a while loop is set up to run in a method and a return statement is placed inside the while loop, executing the return statement will return the program to the original calling point, thus exiting the loop.\n\nHere is an example:\n\nint sumTo(int num) {\n    int i = 1;\n    int sum = 0;\n    while (true) {\n        sum += i;\n        if (sum > num) {\n            return i;\n        }\n        i++;\n    }\n}\n\nIn the example above, notice that you potentially have an infinite loop since true will always evaluate to true. The loop will not continue forever though. Once sum is greater than num the return statement will execute and exit the loop and the method.\n\nAs you start writing more and more programs, you will find many applications of while loops. You saw one application above where the while loop was used to sum numbers. Similar loops can be used to calculate average, mode, minimum, or maximum for a set of numbers.\n\nAnother application that is typically used with a while loop is to split out individual digits of a number. Here is an example of a loop that can do that.\n\nint num = 345;\n\nwhile (num > 0) {\n  \/\/ get the first digit by using the mod function\n  int digit = num % 10;\n  System.out.println(digit);\n\n  \/\/ Divide the number by 10\n  num \/= 10; \/\/ Integer division truncates the number\n}\n\nIn the example above, notice how you can use mod and division to separate out each digit. If you start with the number 345, mod 10 returns the 5. When you then use integer division and divide 345 by 10, you get 34. Since 34 is greater than 0, the while loop executes again. Now the mod function splits off 4 and the division function reduces the number to 3. The program then enters the while loop again, printing out 3. When it divides 3 by 10, it gets zero. Now zero is no longer greater than 0, so the loop is complete.\n\nOther uses of while loops include identifying if an integer is or is not evenly divisible by another integer and determining the frequency with which a specific criterion is met.\n\n###\n\n","completion":" Question: What will this while loop do?\n\nwhile(false)\n{\n    System.out.println(\"Welcome\");\n}\nCorrect: Nothing\nIncorrect: Print Welcome one time\nIncorrect: Print Welcome until program receives user input\nIncorrect: Print Welcome in an infinite loopEND"}
{"prompt":"Like while loops, for loops are a way to change the flow of control by repeating a block of code. for loops allow us to repeat code a fixed number of times.\n\nA basic for loop is structured like this:\n\nfor (int i = 0; i < COUNT; i++) \n{  \n    \/\/ Code segment that is executed COUNT times. \n}\n\nA for loop can be divided into three major parts. The first part initializes the loop variable, the second part tests some condition and the third part increments or decrements the loop variable. Each part of the for loop is separated by a semicolon (;).\n\nLet’s break down the following example into its three major parts:\n\nPart 1: Initialize\nThe first part of a for loop initializes some variable. In the example above, int i = 0 initially sets the variable i equal to 0.\n\nPart 2: Condition\nThe second part of a for loop tests a condition. If the condition is true, the code within the for loop executes. If the condition is false, the code within the for loop is skipped. In the example above, i < 3 compares the current value of our variable i to determine if it is less than 3. Each time i is less than 3, the value of i will be printed to the screen. This happens three times.\n\nPart 3: Increment\/Decrement\nThe third part of a for loop changes the variable after each time the loop runs. Remember, i++ means 1 is added to i. It is incremented. Conversely, i-- means 1 is subtracted from i. It is decremented.\n\nWhen a for loop runs, each of the 3 parts runs in a particular order. The initialization step only runs one time before the boolean expression is evaluated the first time. After this, the boolean expression is evaluated and if it is true, the loop executes. After the loop execution, the increment\/decrement statement executes before the is evaluated again.\n\nWhat happens when you run the example for loop? What gets printed to the screen?\n\nThe first part of our for loop, int i = 0, initializes our variable. It sets our loop variable i equal to 0. Next, the condition part of the loop is evaluated. Is i< 3? Since i is currently set to 0, and 0 is indeed less than 3, the condition i < 3 is true. Thus, the code within the for loop is executed. 0 is printed to the screen. After this, i is incremented. i++ means you add 1 to i, so i is now set to 1.\n\nSince i is now set to 1, the condition i < 3 is re-evaluated. It is still true. 1 is now printed to the screen. i is incremented again and becomes set to 2.\n\nThe condition i < 3 is re-evaluated. Since i is now set to 2, our condition is still true. 2 is printed to the screen. i is incremented again and becomes set to 3.\n\nFinally, when the condition i < 3 is re-evaluated, our condition is false. 3 is not less than 3, so the code within the for loop is skipped. Nothing else gets printed. The for loop is done.\n\nThus, our output would be:\n\n0\n1\n2\n\nfor loops and while loops can be interchangeable. A for loop can be rewritten as a while loop and vice versa. Take a look at the countdown while loop from earlier.\n\nint i = 100;\nSystem.out.println(\"Initiating countdown:\");\nwhile(i >= 0) {\n  System.out.println(i + \"...\");\n  i--;\n}\n\nIn this countdown example, i is initially set to 100. The while loop checks the condition and insider the loop, i is decremented. The same process can happen in a for loop.\n\nEach piece that you saw in the while loop is still present as one of the three parts of the for loop.\n\nOne thing to be cautious of is off by one errors. Off by one errors occur when your loop doesn’t start or stop at the correct place. Think about summing the numbers from 1 to 100. You may think of setting up your for loop like this:\n\nfor (int i = 1; i < 100; i++) {  ...  }\n\nDoing so will cause an off by one error since you are missing the 100. Since you want to include 100, you need to use a <= (less than or equal) instead of just a less than. Here is a correct loop to sum the numbers from 1 to 100.\n\n###\n\n","completion":" Question: What does the following code print?\n\nfor (int i = 4; i < 8; i++)\n{\n   System.out.print(i + \", \");\n}\nCorrect: 4, 5, 6, 7,\nIncorrect: 4, 5, 6, 7, 8,\nIncorrect: 0, 1, 2, 3, 4, 5, 6, 7,\nIncorrect: This code will produce an infinite loop.END"}
{"prompt":"You looked at several string methods that can be used for a variety of functions such as taking substrings, searching Strings, and comparing them to other Strings. In this section, you will take a look at several common algorithms that can be performed with Strings.\n\nTraversing is the process of going through a String one character at a time, often using loops. for loops tend to be common for this type of task since the string length is fixed. Here is an example of a String traversal that will translate a string into a vertical column.\n\nIn this example, notice how you loop from 0 to less than the print length and then use the substring function to print the current index to the next index, which will print one character.\n\nUsing this idea, you can take a look at different algorithm examples.\n\nOne application of a substring traversal is to determine if a particular substring meets a criteria or alternately, count the number of times that it meets that criteria. Take a look at the method below where you count the number of vowels in a String:\n\npublic int numUpperCase(String string){\n    int counter = 0;\n    for(int i = 0; i < string.length(); i++) {\n        String letter = string.substring(i, i+1);\n        if(letter.equals(letter.toUpperCase())) {\n            counter++;\n        }\n    }\n    return counter;\n}\n\nIn this example, notice how you traverse the String and grab one letter each time through. Then, by checking if the letter is equal to the uppercase version of the letter, you can determine if it matches the criteria. If so, then you can increase the counter.\n\nAnother common string algorithm is to reverse a String. In the example below, a String is reversed by creating a new empty String and then adding one letter at a time to that String.\n\nNotice in this example how the loop starts at the end of the current String and loops to the beginning of the String. Each time, it still grabs a letter in the same manner as the original loop.\n\nString original = \"Let's reverse this string!\";\nSystem.out.println(original);\n\nString newString = \"\";\nfor(int i = original.length() - 1; i >= 0; i--)\n{\n    String character = original.substring(i, i+1);\n    newString += character;\n}\nSystem.out.println(\"The original string reversed = \" + newString);\n\n###\n\n","completion":" Question: What is the general formula for traversing a String character by character?\nCorrect: for(int i = 0; i < string.length(); i++)\n{\n    String character = string.substring(i, i +1);\n}\nIncorrect: for(int i = 0; i <= string.length(); i++)\n{\n    String character = string.substring(i, i +1);\n}\nIncorrect: for(int i = 0; i < string.substring(i, i+1); i++)\n{\n    String character = string.length();\n}\nIncorrect: for(int i = string.length(); i > 0; i++)\n{\n    String character = string.substring(i, i +1);\n}END"}
{"prompt":"Earlier in this unit, you saw how to use a loop for a repeated task. For example, if you wanted to print the numbers 1 through 5 on a line, you could use a loop like this:\n\nfor(int count = 1; count < 6; count++) \n{ \n   System.out.print(count + \" \"); \n}\n\nWhat if you wanted to print something like this?\n\n1 2 3 4 5\n2 4 6 8 10\n3 6 9 12 15\n4 8 12 16 20\n5 10 15 20 25 \n\nYou could use 5 loops, one for each line and each loop starting and stopping at different values. This would get repetitive and you saw how you could use loops to avoid repetitive code. In this section, you are going to explore the concept of a nested loop.\n\nJust as you saw with if statements, putting a loop inside another loop is called nesting. A nested iteration statement is an iteration statement that appears in the body of another iteration statement.\n\nIn the example above, you can achieve the five-by-five print out using a nested for loop.\n\n\/\/ New loop outside\nfor (int row = 1; row < 6; row++) {\n    \/\/ Original loop inside\n    for(int count = 1; count < 6; count++) {\n        System.out.print(count * row + \" \" );\n    }\n    System.out.println();\n}\n\nThe original loop is now wrapped inside of a second loop. Notice how each of the loops uses a different loop variable.\n\nEach time through the outer loop, the inside loop starts over and runs to completion. After completing the inside loop and printing a row, a line feed is added, then the outer loop loops around and starts the next row.\n\nIn this example, the inner loop executes 5 times each time it is called. The outer loop also executes 5 times, each time creating a new inner loop. So each line of code inside the inner loop actually executes 25 times!\n\nJust as there are nested for loops, you can also have nested while loops, or even mixed nested loops with a for loop inside a while loop, or vice versa.\n\nint line = 1;\nwhile(line < 6) {\n    int number = 1;\n    while(number < 6) {\n        System.out.print(number*line +\" \");\n        number++;\n    }\n    System.out.println()\n    line++;\n}\n\n###\n\n","completion":" Question: How often is the inner loop of a nested loop run?\nCorrect: Each time the outer loop runs\nIncorrect: Infinitely\nIncorrect: Twice as often as the outer loop\nIncorrect: One less time than the outer loop runsEND"}
{"prompt":"Throughout this course, you have spent a considerable amount of time developing algorithms. Algorithms are a step-by-step process that solves a problem. Many, if not all, of the programs that you have developed, are considered algorithms because they solve a problem.\n\nYou also use algorithms in our daily lives and don’t think about it. Most of the tasks that you perform on a daily basis are routinized and have procedures that you follow so that you can complete them as planned. Making a PBJ sandwich is an example of a practice that you do that has a procedural, step-by-step nature.\n\nmakePBJ()\n{\n    takeBread();\n    spreadJelly();\n    spreadPeanutButter();\n    if (likeToasted){\n        toast();\n    }\n}\n\nSo what makes a good algorithm?\n\n- Correctness\n- Easy to understand by someone else\n- Efficiency (run time and memory requirements)\n\nCorrectness refers to whether the algorithm solves the given problem. Easy to understand can be a function of how the code is laid out, using appropriate variable names, and the use of comments. Efficiency can be looked at in several ways, which you will explore in this section.\n\nProgram efficiency is important because it affects both the speed and cost to execute a program. Oftentimes speed and cost are impacted by the physical computer’s specification and as a programmer, you do not have much control over this.\n\nTo help estimate the cost and efficiency of a program, you can use an informal code analysis by looking at the number of statements that a program needs to execute. A statement execution count indicates the number of times a statement is executed by the program, which can be a good indicator of the cost and speed of the program.\n\nThe Statement Execution Count is the number of times a statement is executed by the program. When comparing different algorithms, you can estimate the costs for each by looking at the number of statements that need to be executed to run the program.\n\nAn execution statement might refer to:\n\n- an arithmetic operation ( + , * )\n- an assignment (int value = 2)\n- a test (x == 0)\n- an input\/output\n\nTake a look at the example below:\n\npublic void computeSum (int n) {\n    int sum = 0; \n    int n = 10;\n\n    for (int i = 0; i < n; i++) {\n        sum += i; \n    }\n    System.out.println(sum); \n}\n\nIn this example, the code executes the first two assignment statements before the loop. Then the loop executes n times, followed by one additional statement. The total number of steps executes for this algorithm would be n + 3.\n\n###\n\n","completion":" Question: How many times does the following loop iterate?\n\n\/\/ x has been initialized with a positive int value\nfor (int count = 0; count <x; count++) \n{\n    System.out.print(\"*\");\n}\nCorrect: x times\nIncorrect: x + 1 times\nIncorrect: x - 1 times\nIncorrect: Infinite number of timesEND"}
{"prompt":"In Unit 2, you had the opportunity to explore classes from the perspective of a user of the class. In this unit you will take a deeper dive and look at how you can create classes of your own. Classes allow you to create custom objects that can make your program easier to implement.\n\nIn Java, there are two main access levels that you will see in this course, private and public. Private access is used when an element (such as a variable or method) should only be able to be accessed within the declaring class. What does that mean? Access in the class is when other statements in the same class try to access a value or function. For example given the class definition below:\n\npublic class Sample {\n    private int value;\n}\n\nAny statement in the Sample class will be able to access value, but any other class that may create a Sample object will not have access to value since it is private.\n\nIn contrast, public access allows for an element to be accessed by any other class. Take a look at the updated class definition below:\n\npublic class Sample {\n    private int value;\n\n    public int getValue(){\n        return value; \n    }\n}\n\nIn this example, you will notice that the getValue method is public. In this case, if a Sample object was created in another class, you would be able to call the getValue method, and thus get indirect access to value.\n\nWhen creating classes, classes should always be declared public since they need to be accessed by other classes. Likewise, a constructor in the class should always be public since it needs to be called by external classes.\n\nWhen designing a class, programmers can make certain decisions about which elements should be public or private, however there are some basic governing rules that should be followed.\n\nWhen it comes to instance variables, all instance variables should be designated private to keep access internal to the class. There are several reasons why you should always declare instance variables private.\n\nThe first reason revolves around the idea of data encapsulation. Data encapsulation is a technique in which the implementation of details of the class are kept hidden from the user. By using the private level access, instance variables are encapsulated in the class.\n\nWhen designing a class, programmers make decisions about what data to make accessible and modifiable from an external class. Each piece of data can be either accessible or modifiable, or it can be both or neither. This access is accomplished through accessor and mutator methods (getters and setters).\n\nIn addition to data encapsulation, private access to instance variables can be used to help manage complexity. For example, think about a student object that may have an instance variable for grade and another variable to designate school level (such as middle school or high school). A programmer may decide to limit modifications to only the grade level and within the grade mutator method they also make updates to the school level. Not only does this streamline the update process, but it also controls the process to make sure you don’t have a 12th grade middle school student.\n\nWhile instance variables are always declared private, methods can be declared either public or private, making them either external or internal to the class. Many behaviors need to be available externally, so oftentimes methods are declared public, but there are times when private access is preferable.\n\nPrivate access is usually used with helper methods. For example, think back to the student object described above. The programmer may decide to write a public mutator method to change the grade. Once the grade is changed, the school level needs to be checked and possibly changed. If the programmer decided to do this check and make the change using another method, then that method would be private. As a private method, it can be called from the grade mutator method, but the end user cannot call the method directly from the other class.\n\nProgrammers will use private methods when they want to have a method to use in their class, but do not want that method called and used from an instance of the object.\n\n###\n\n","completion":" Question: Which of the following class members should NOT be public?\nCorrect: Instance Variables\nIncorrect: Constructors\nIncorrect: Accessors\/Mutators\nIncorrect: Methods the user needs to manipulate the objects of the classEND"}
{"prompt":"Constructors are essentially object creators. You use constructors to create new objects using a class. When you create new objects using constructors, you also set any initial values of instance variables if necessary. These initial values of instance variables can be set either with or without the use of parameters.\n\nAn object is said to have state and behaviors. The state of an object represents the attributes and their values at a given time and is defined by instance variables belonging to the object. These instance variables create a “has-a” relationship. For example, if you think about a Rectangle object, you can say that the Rectangle has a length and the Rectangle has a width. At any given point in time, the state of the rectangle can be defined by the length and width of the Rectangle.\n\nConstructors are used to set the initial state of an object, which should include initial values for all instance variables.\n\nAs you saw back in unit 2, the constructor is used to instantiate a new object and is called anytime an object is created. Constructors can serve multiple purposes, but one purpose is to set the initial state of variables. Take a look at the example showing how you would write a constructor:\n\npublic class Dog\n{\n    \/\/ Instance variables\n    private String name;\n    private int age;\n    private double weight;\n    private boolean isAlive;\n\n    \/\/ Constructor\n    public Dog(String theName, int theAge, double theWeight, boolean isThisAlive)\n    {\n        \/\/ Instance variable initialization\n        name = theName;\n        age = theAge;\n        weight = theWeight;\n        isAlive = isThisAlive;\n    }\n}\n\nThe constructor parameters are local to the constructor only. Because of this, you will notice how the local constructor parameters are used inside the constructor to set the initial value of the instance variables. Additionally, it is important to note that when a mutable object is passed as a parameter, the instance variable is initialized with a copy of the variable. As a result, any modifications to the instance variable will not be reflected in the original object.\n\nWhile a constructor does play an important role, it is possible to create a class without a constructor. When no constructor is provided, Java provides what is known as a no-argument constructor. The no-argument constructor executes anytime an object is created and sets any instant variable to their default value.\n\nExample:\n\npublic class Dog\n{\n    private String name;\n    private int age;\n    private double weight;\n    private boolean isAlive;\n}\n\nIn this example, when a Dog object is created, the instance variables will be set to their default values, which is zero for the integer and double, an empty string for name, and false for the Boolean value.\n\n###\n\n","completion":" Question: An object’s state is defined by the object’s\nCorrect: instance variables and their values\nIncorrect: methods and instance variables\nIncorrect: access modifiers of the instance variables\nIncorrect: methods and their return valuesEND"}
{"prompt":"There are two parts to writing a program: One part is getting it to work (the functionality). The other part is the style: How did you write the program? Did you break it down into parts? Is it clear to read? This is where comments come into play!\n\nComments are a way for you to leave notes about what your code is doing in plain English so that other people can understand it.\n\nWhy comment?\n\nEven though code is run by computers, it is read by other people. Comments help others understand your code. If you read your code ten years from now, would you be able to understand what it does?\n\nThe computer that runs your program knows to ignore comments if they are written as multi-line, single line, or Javadoc comments.\n\nUse multi-line comments to leave a comment so a reader understands what your program or method is doing. The start of a multi-line comment uses \/*, each line following with a single *, and ending the multi-line comment with *\/.\n\n\/* \n* This program does ______. \n*\/\n\nUse single line comments to leave a comment for a single line in your code. For each single line comment, put two backslashes (\/\/) before the comment.\n\n\/\/This line does ______.\n\nAnother important part of commenting is using preconditions and postconditions. You can leave notes at the top of our methods about assumptions that you make.\n\nPreconditions: A precondition is a condition that must be true just prior to the execution of a section of program code in order for the method to behave as expected. There is no expectation that the method will check to ensure preconditions are satisfied.\n\nPostconditions: A postcondition is a condition that must always be true after the execution of a section of program code. Postconditions describe the outcome of the execution in terms of what is being returned or the state of an object.\n\nThis helps you think about the problem and make sure our methods line up.\n\n###\n\n","completion":" Question: Which of the following is NOT a valid comment?\nCorrect: \/\/ Comment\n    Comment \/\/\nIncorrect: \/\/ Comment\nIncorrect: \/\/ Comment \/\/\nIncorrect: \/* Comment\n    Comment *\/END"}
{"prompt":"One key aspect of writing classes in Java is that you can control how the class is used. As mentioned earlier, instance variables are kept private in your Java classes, but that doesn’t mean that users can’t access them via public methods. Access to variables is controlled by the developer through accessor methods.\n\nAn accessor method is a method that is used to return the value of an instance (or static) variable to the user. Since the method is returning a value to the user, the method header should contain the return type in place of the keyword void.\n\nWhen creating accessor methods there is a common convention you should follow. When naming your method you should always use this format: get[Variable Name] for the name. Some examples of this would be: getWidth(), getHeight(), and getColor(). As a result of this naming convention, accessor methods are sometimes referred to as “getter” methods.\n\nHere is an examples of how this would look:\n\nprivate int width = 10;\nprivate int height = 3;\nprivate Color rectCol = Color.blue;\n\npublic int getWidth()\n{\n  return width;\n}\n\npublic int getHeight()\n{\n  return height;\n}\n\npublic Color getColor()\n{\n  return rectCol;\n}\n\nAs a non-void method, the accessor method returns a single value. This value needs to be compatible with the return type in the method header, for example a string needs to return a string, or a double return type needs to return a number (an int or double is compatible with a double).\n\nWhen returning a value, a copy of that value is returned to the calling method, whether the value is a primitive or an object. This is referred to as “return by value.”\n\nAs soon as the return keyword is used, the program returns to the point immediately following where the method was called. This can be used to return a value or to interrupt the progress execution and end the method execution.\n\nThe toString method is a specific method that is used to return a string representation of the object. The method is often included in many classes as a way to override the default object description and provides a description of the object. It will generally include some of the values stored in instance variables, or a calculation with those values, but it doesn’t have to.\n\nWhile the method can be called with using the standard dot syntax, such as obj.toString(), the method is also called by default for print statements.\n\nFor example, if there is a Shape class that has a toString method, the toString would be called int he following situation:\n\nShape s1 = new Shape(\"Rectangle\");\nSystem.out.println(s1); \/\/ calls the toString for s1\n\nShape s2 = new Shape(\"Circle\");\nSystem.out.print(s2); \/\/ calls the toString for s2\n\n###\n\n","completion":" Question: Which of the following method signatures would be appropriate as an accessor method for an String instance variable called name?\nCorrect: public String getName()\nIncorrect: public void getName()\nIncorrect: private void getName()\nIncorrect: private String getName()END"}
{"prompt":"Just like you can control which instance variables an end user can access, developers can also control access to updating variables. This access is controlled by the mutator methods.\n\nA mutator method is a method that is used to update the value of an instance (or static) variable. Since the method is designed to update a value, the method header often contains the void keyword since it doesn’t return a value.\n\nMutator methods set a new value. As such, they are often referred to as setter methods. Setter methods allow us to set the values of an object’s instance variables.\n\nAs with accessor\/getter methods you use a common convention when creating mutator methods. When creating mutator methods you should always use: set[Variable Name]. Some common examples include: setWidth(int width), setHeight(int height), setColor(Color color). Here are some examples of how to create these setter methods:\n\nprivate int width = 10;\nprivate int height = 3;\nprivate Color rectCol = Color.blue;\n\npublic void setWidth(int newWidth)\n{\n  width = newWidth;\n}\n\npublic void setHeight(int newHeight)\n{\n  height = newHeight;\n}\n\npublic void setColor(Color color)\n{\n  rectCol = color;\n}\n\n###\n\n","completion":" Question: Which of the following is NOT a characteristic of a mutator?\nCorrect: Mutator methods are generally private methods\nIncorrect: Mutator methods generally have a void return type\nIncorrect: Mutator method generally have a parameter\nIncorrect: Mutator methods generally update instance variablesEND"}
{"prompt":"The last two sections looked at creating two specific types of class method focused on accessing and updating instance variables. What if you want to do something else, like perform a calculation or print out a result? Using class methods, you can write your own behaviors for a class.\n\nRecall from Unit 2 where you first methods, a method header is the first line that is used to define a method. For example:\n\npublic int addFive(int num)\n\nIn the above example, since the method is a non-void method with a parameter, the method would take the formal parameter (parameter in the method) value in, use it, and then return a computed value. The return value needs to match the return type.\n\nWhen a primitive value is passed to the method, the formal parameter is initialized with a copy of the value. In other words, any changes to the formal parameter in the method will not change the actual parameter in the calling method.\n\nHere is an example. Given a Numbers class:\n\npublic class Numbers {\n  public int addFive(int num) {\n    num += 5;\n    return num;\n  }\n}\n\nIf the following code is executed to call the addFive method:\n\nNumbers myNum = new Numbers();\nint a = 12;\nSystem.out.println(myNum.addFive(a));\n\nThe output will be 17 however, the value of a will remain unchanged at 12.\n\nIn contrast, when an object is passed to a function as a parameter, the formal parameter is initialized with a copy of the reference, not a copy of the object. What does this mean?\n\nAs a copy of the reference, both the original reference and the copy point back to the same object. This makes the actual parameter and formal parameter aliases that refer to the same object. Assuming the object is mutable, updates in the method will be reflected in the original value also getting updated.\n\nAs a note, it is good programming practice to not modify mutable objects that are passed as parameters unless required in the specification.\n\nIf the formal parameter is a reference object, you can actually access the private data associated with that reference if the method has been written in the object’s class file. In the example below, because MyProgram is not the file that the Rectangle class was written in, you have to use rect.setWidth() and rect.setHeight() to access the instance variables.\n\nMyProgram.java\n\npublic void resetRect(Rectangle rect) {\n  rect.setWidth(0);\n  rect.setHeight(0);\n}\n\nIf the method was written inside the Rectangle class file, then you could access the object’s data by using the .variable notation. Notice that instead of using setWidth and setHeight, you can just change the value of width and height by writing rect.width and rect.height. This works when the parameter reference object is the same as the class file.\n\nRectangle.java\n\npublic void resetRect(Rectangle rect) {\n  rect.setWidth(0);\n  rect.setHeight(0);\n}\n\n###\n\n","completion":" Question: Each of the methods below can be found in the Student class. Which of the following methods would have access to the parameter object’s private data and methods?\nCorrect: public void copy(Student other)\nIncorrect: public void copy(Person other)\nIncorrect: public void setId(Integer newId)\nIncorrect: public void setName(String newName)END"}
{"prompt":"Recall that an object is an instance of a class. The class is like the blueprint from which instances can be built. Each instance can have its own state and behavior. An object’s state is stored in instance variables, and its behavior is carried out with instance methods. These are called instance variables and instance methods because they belong to a single instance of the class. But what if you wanted to keep track of a single variable or have a shared behavior across all the members of a class? Because each object has its own instance variables and methods, these won’t work to store information for the entire class.\n\nSometimes it is useful to store information that is shared across all the objects of an entire class. A class variable (also referred to as a static variable) is a variable or attribute of a class that is common to all instances of a class. A class method (or static method) is a method of a class that is common to all instances of a class and is not called on any specific object instance.\n\nA new static variable defined by adding the keyword static to the variable declaration. Static variables can be either public or private.\n\nLikewise, static methods also use the keyword static. Classes can have both instance variables and static variables, but static methods can only update static variables. As a result, static methods cannot use the this reference and are unable to use non-static variables or methods.\n\nA method to return the total number of birds of the Bird class may look like:\n\nprivate static int getTotalBirds()\n{\n  return totalBirds;\n}\n\nFor example, if you run your own indoor skate park, you may want to keep track of the skaters at the park. In order to use the park, a new skater would sign up and a new instance of the Skater class would be created. What information would be useful to track about each skater? You may want to know a skater’s name, age, experience level, and a history of times he or she arrived at and left the park. These are all unique to each skater and could be stored as instance variables.\n\nIt would also be useful to know how many skaters have ever skated at the park. This is a useful stat to know, but it is affected by all the skaters, not just one. Because this information is shared across the whole class, it can be stored in a class variable. The Skater class could be defined to include these:\n\npublic class Skater\n{\n  private static int totalSkaters = 0;\n\n  public Skater()\n  {\n    totalSkaters++;\n  }\n\n  public static int getTotalSkaters()\n  {\n    return totalSkaters;\n  }\n}\n\nWhenever a new skater is added, the static variable totalSkaters is increased. The totalSkaters variable is shared across all instances of the Skater class. Each object in the class has the same value for this variable, and you can get the value of this variable with the static getTotalSkaters method.\n\nBecause static methods and variables are available across an entire class, they don’t need to be called on a particular instance of the class. You do not need to create a new object just to call a class method.\n\nTo find out how many skaters have been to the skate park, you can write:\n\nSkater.getTotalSkaters();\n\nThis will call the getTotalSkaters() method on the Skater class without requiring an instance of the class to be created.\n\nIf a static variable were to be declared as public, you could also access it using the dot notation, such as:\n\nSkater.totalSkaters; \/\/ Only works if variable is public\n\n###\n\n","completion":" Question: Static methods can access\nCorrect: Only other static instance variables and class methods\nIncorrect: Any class method, but not the instance variables\nIncorrect: All instance variables and class methods\nIncorrect: Only private instance variables and private class methodsEND"}
{"prompt":"Think back to some of the examples where you had variables in methods. Some of these variables had the same name as other variables in your program, but they didn’t have the same values. How can that be? Each variable has a specific scope and access level where that variable is defined. Outside that scope, a different variable can be defined with the same name. In this section, you will look at how variable scope is determined.\n\nWhen declaring a variable inside the body a constructor or a method, you create a local variable for that method. What does this mean? By local variable, it means that the variable is only defined for that specific constructor or method. These variables may only be used within the constructor or method and cannot be declared to be public or private.\n\nLikewise, another variable with the same name can be used outside the constructor or method and it will be considered a different variable.\n\npublic void addFive() {\n  int num = 10; \/\/ num is only defined inside the addFive method\n  int result = num + 5;\n  System.out.println(result); \/\/ prints 15\n}\n\npublic void addTen() {\n  int num = 20; \/\/ This is a different num variable that needs to be declared\n  int result = num + 10;\n  System.out.println(result); \/\/ prints 30\n}\n\nSometimes you will see a local variable inside a method or constructor sharing the same name as an instance variable. When this happens, the variable name in the method by default will refer to the local variable instead of the instance variable.\n\npublic class MyClass {\n  private int myNum = 10;\n\n  public void addFive() {\n    int myNum = 7;\n    \/\/ Will print 12 since the local myNum is used instead\n    \/\/ of the instance variable.\n    System.out.println(myNum + 5); \n  }\n}\n\nWhen variables are declared as formal parameters, they act the same as a variable that has been declared inside a constructor or method. That means that they are only available inside the constructor or method where they are declared and that they will take precedence over any instance variables that have the same name.\n\npublic class Name {\n  private String name = \"Karel\";\n\n  public Name(String name) {\n    \/\/ Will print the value passed in, not the value of the instance variable\n    System.out.println(name); \n  }\n}\n\nMethod decomposition is the process of breaking down large problems into smaller sub-problems by creating methods to solve the individual sub-problems.\n\nFor example, if you want to create a program that asks users a random trivia question and informs them if they got the answer correct, you could break the problem into several parts:\n\n- Build a Trivia class.\n- Create Program that uses Trivia class.\n\nYou can then break each of these problems into several parts. For example, the program that uses the trivia class might break into the following parts:\n\n1. Create a Trivia Object\n2. Ask User a random trivia question\n3. Allow User to Respond\n4. Check if Response Matches Answer\n5. Provide User with a Reply\n\nBy breaking the problem down into smaller parts, you create sub-problems that are easy to solve and combined together, they can solve a much more complicated problem.\n\n###\n\n","completion":" Question: What would be printed the first time printGreeting was called from main?\n\npublic class Greeting\n{\n    private static String greet = \"Hi there!\";\n\n    public static void printGreeting()\n    {\n        String phrase = \"Hello!\";\n        System.out.println(phrase);\n        phrase = \"Hola!\";\n    }\n}\nCorrect: Hello!\nIncorrect: Hi there!\nIncorrect: Hola!\nIncorrect: Hi There!Hello!END"}
{"prompt":"As discussed in the previous section, when you use a variable in a method or constructor that shares the same name as an instance variable, by default, the local variable in the method or constructor is used. What if you want to refer to the instance variable?\n\nIt can often be confusing to know whether a variable in a constructor is referring to an instance variable or a variable that was passed in as an argument to the constructor. One way around this is to use different variable names for the instance variables and parameters, however using different names can get a little confusing.\n\nFortunately, Java has a way of specifying when you are referring to the object itself: this.\n\nthis refers to the current object. The this keyword allows you to be very clear whether you are referring to the object’s instance variable or a parameter:\n\npublic class BMX\n{\n  private String frameSize;\n  private int numPegs;\n\n  public BMX(String frameSize, int numPegs)\n  {\n    this.frameSize = frameSize;\n    this.numPegs = numPegs;\n  }\n}\n\nNotice in the above example how you can use the same variable name. When the variable name is preceded by this., the variable is referring to the instance variable, otherwise it refers to the local variable.\n\nAs noted above, the this keyword is used to represent the current object. With that in mind, you can use this to represent the current object as needed.\n\npublic class Rectangle {\n  public int getArea(Rectangle rect) {\n    return rect.getWidth() * rect.getHeight();\n  }\n\n  public boolean hasGreaterArea(Rectangle otherRect)\n  {\n    return getArea(this) > getArea(otherRect);\n  }\n}\n\nNotice in the example above how the getArea method is called using this as an actual parameter for input into the getArea method.\n\n###\n\n","completion":" Question: Which of the following correctly uses the this keyword?\nCorrect: public boolean isEqual(Student other)\n{\n    return this.name.equals(other.name);\n}\nIncorrect: public boolean isEqual(Student other)\n{\n    return name.equals(this.other.name);\n}\nIncorrect: public boolean isEqual(Student other)\n{\n    return name.equals(this.name);\n}\nIncorrect: public boolean isEqual(Student other)\n{\n    return name.this.equals(other.name);\n}END"}
{"prompt":"In this lesson, you will look at the professional computing code of ethics, system reliability, legal issues and intellectual property concerns, and bias in computing.\n\nThis is a time of rapid advancements in technology and automation. Software and hardware engineers increasingly have significant impacts on everyday lives with the tools and applications that they create. You see software and hardware solutions in nearly every aspect of your lives, such as the cars you drive, your bank accounts, the electrical grid, and nearly all communication such as email, text, and phone calls. If these systems fail, your lives would be greatly impacted.\n\nPart of understanding the impact of these tools and applications is understanding system reliability. System reliability is when all programs and code will work as intended. Its challenging to ensure system reliability when there are many inputs, parameters and outputs in any given programming application. System reliability is limited and programmers should make an effort to maximize system reliability. Software and hardware engineers need to be aware of the legal, social and ethical implications of the hardware and programmatic systems that they create.\n\nWhile programs are designed to achieve a specific purpose, they may have unintended consequences. Computing systems have affected humans, society, economy, and culture in many ways, both positively and negatively.\n\nOne substantial impact of computing systems is the access to information. There are several open databases of scientific publications on the internet, some of which are free and some are subscription based. This allows scientific papers to be read by anyone, not just a graduate student at a research institution. Now anyone can read these cutting edge scientific publications.\n\nBut there’s a big question as to whether access to all information is actually a good thing. For example, there’s a website called Wikileaks that posts classified information that either governments or corporations are trying to keep secret. On one hand this is a good thing because it promotes the transparency of information. It makes it so corporations and the governments can’t keep secrets from its citizens. However, there’s potential danger in having classified secrets being public. For example, our military or national security could be at risk if someone posts our government secrets to the world.\n\nLegal issues and intellectual property concerns arise when creating programs. As programmers, you have a responsibility to make sure that our programs are socially, legally, and ethically acceptable.\n\nComputer science follows the following ACMs or Association for Computing Machinery professional code of ethics. ACM has professional principles as well, but they are beyond the scope of this course. According to the ACM, a computing professional should:\n\n- Contribute to society and to human well-being, acknowledging that all people are stakeholders in computing.\n- Avoid harm.\n- Be honest and trustworthy.\n- Be fair and take action not to discriminate.\n- Respect the work required to produce new ideas, inventions, creative works, and computing artifacts.\n- Respect privacy.\n- Honor confidentiality.\n\nRemember that knowledge is power as everyone lives together in our digital world. Use your knowledge of computing for good purposes so you and everyone else can be safe and enjoy the benefits of computing.\n\n###\n\n","completion":" Question: A computing system that is biased is likely to\nCorrect: give preferential treatment to some users\nIncorrect: be created by a small company\nIncorrect: treat all users the same\nIncorrect: operate slowerEND"}
{"prompt":"An array is a list of data. Arrays can store many different types of information. For example, if you had a shopping list, you could store the shopping list as an array.\n\nThe information stored in an array is kept in order. The items in an array are often referred to as members or elements of the array. What makes arrays unique is that they store a fixed number of elements. Once an array is created, the size of the array cannot be changed.\n\nIt is important to note that in computer science, we usually start counting from 0. So the first item in the array is actually at index position 0, the second item in the array is at index position 1, and so on.\n\nLet’s say our grocery list contained these items, in this order: apples, dog food, donuts, celery, and orange juice. If we were to draw out the array, it would look something like this:\n\nindex position:\t0\t1\t  2\t\t3\t4\nlist item:\t\tapples\tdog food  donuts\tcelery\torange juice\n\nWe can see that dog food is at index 1 and celery is at index 3.\n\nTo create an array in Java, you must first know what type of data you want to store and how many elements the array will hold. In the grocery list example above, we created an array of Strings, but it’s just as easy to create arrays of integers or any other data type. Arrays can store both primitive and object data types.\n\nThe format for creating an array is:\n\ntype[] arrayName = new type[numberOfElements];\n\nLet’s take apart the array declaration:\n\n- type[]: This tells us what type of data is being stored in the array. For example, a list of integers would be int[]. The brackets [] indicate that this is an array and not a single int.\n- arrayName: The name by which the array will be known. It’s best to pick a descriptive name, like groceryList instead of just things.\n- new: The new keyword indicates that a new array is being created.\n- type[numberOfElements]: The type of elements is mentioned again, as well as the number of items the array will store. For example, if an array int[6] were created, the array would store six int values. Once an array has been created, the number of items that can be stored in the array cannot change. This array will always store 6 items - no more, no less!\n\nFor example, if you wanted to create an array that contained 6 integers, the initialization of the array would look like this:\n\n\/\/ Create an empty array that will store 6 integers\nint[] newNumberList = new int[6];\n\nWhen an array is initially created, each index in the array is set to a default value. Java assigns a specific value for each item in the array depending on the type. int and doubles default to zero, booleans default to false, and objects (including strings) default to null.\n\nType\tDefault Value\nint\t0\ndouble\t0.0\nboolean false\nObjects null\n\nArrays can also be created and initialized with specific values. To do so, simply include the elements that will be stored in the array between curly braces in the initialization. Here’s a list of 6 numbers:\n\nint[] numberList = {10,20,30,40,50,60};\n\nElements in an array can be accessed using the index position of the array. Let’s create a new empty array of numbers, then add in two numbers:\n\n\/\/ Create an empty array that will store 6 integers\nint[] newNumberList = new int[6];\n\n\/\/ Add the number 11 to index position 0\nnewNumberList[0] = 11;\n\n\/\/ Add the number 13 to index position 1\nnewNumberList[1] = 13;\n\nThe array now contains two integers:\n\nIndex Position:\t0\t1\t2\t3\t4\t5\nArray Item:\t\t11\t13\t0\t0\t0\t0\n\nNotice that the rest of the indices in the array are set to the default value 0. The [] syntax can also be used to change elements in a list. Let’s change 13 to 21:\n\nnewNumberList[1] = 21;\n\nIndex Position:\t0\t1\t2\t3\t4\t5\nArray Item:\t\t11\t21\t0\t0\t0\t0\n\nAccessing an element in a list uses a similar syntax. We can get and store the number at index 0 into a variable:\n\n\/\/ This variable will contain the number 11\nint firstNumber = newNumberList[0];\n\n\/\/ Two ways to print out the number 11 to the console\nSystem.out.println(firstNumber);\nSystem.out.println(newNumberList[0]);\n\n\/\/ Now print out the number at index position 1 to the console\nSystem.out.println(newNumberList[1]);\n\nThe output from the code will be:\n\n11\n11\n21\n\nAccessing a value in an array that’s outside the current index value list will result in an ArrayIndexOutOfBoundsException. For example, a new double array is created with 5 values:\n\ndouble[] example = new double[5];\n\nBecause there are only five values in this array, attempting to access an index greater than or equal to five will throw an error:\n\ndouble value = example[6];   \/\/This results in an ArrayIndexOutOfBoundsException\n\nThis program would throw an ArrayIndexOutOfBoundsException, as index six is unavailable in this particular array. If you see this error in a program, it most likely means that you’re accessing an array incorrectly!\n\n###\n\n","completion":" Question: How do you initialize an array called arr of 10 double with default values?\nCorrect: double[] arr = new double[10];\nIncorrect: double[] arr = new double[11];\nIncorrect: double arr = new double[10];\nIncorrect: double arr = new double;END"}
{"prompt":"Arrays are utilized for many operations in various programs. Since arrays store data in order, you can iterate through them to access this data. Let’s say you are creating an online store that sells oranges. You would want to store the customer orders in an array so you can honor the first orders before the orders that come later.\n\nLet’s say you have an array that stores the order data from your market. Here is the array:\n\nIndex:\t\t0\t\t1\t\t2\t\t3\t\t4\t\t5\nOrders:\t10 Oranges\t3 Oranges\t6 Oranges\t4 Oranges\t5 Oranges\t1 Orange\nIn Java the array will look like this:\n\nint[] orangeOrders = {10, 3, 6, 4, 5, 1};\n\nIndividual elements can be accessed by using the [] notation:\n\nint orderOne = orangeOrders[0];  \/\/returns 10 to orderOne\n\nSince this list of orders is fairly small, it’s easy to access the individual orders that are being made, but oftentimes, arrays can have hundreds, thousands, or even millions of values. How is it possible to access all values when it’s not clear where a specific value might be stored? There needs to be a systematic way to access all of these values! Luckily, iteration, or traversing, an array can provide a simple solution.\n\nIn order to iterate through the items in an array, it’s absolutely necessary to know how many elements there are in the array - otherwise, how would you know how many elements you need to search through?\n\nFinding the size of an array is done by using the keyword .length. .length returns the current size of an array. An array with six values is considered an array of length 6. The length of an array corresponds to the number of elements in an array, not the last index value in an array.\n\nIf you recall, arrays start at index 0 - an array with six elements will start at 0 and end at index 5:\n\nIndex:\t\t0\t\t1\t\t2\t\t3\t\t4\t\t5\nOrders:\t10 Oranges\t3 Oranges\t6 Oranges\t4 Oranges\t5 Oranges\t1 Orange\n\nIterating over an array requires the use of a for or while loop:\n\nfor(int i = 0; i < orangeOrders.length; i++)\n{\n   \/\/ This prints out the ith element!\n   System.out.println(orangeOrders[i]);\n}\n\nThis for loop iterates through every value in the orangeOrders list, and prints out the value at every index.\n\nNotice that the for loop starts at the first element (zero) and ends at the last element (array.length - 1). The for loop is set to i < orangeOrders.length, so that the greatest value of i will always be one less than the length of the array. Therefore, the last index in an array will always be array.length - 1.\n\nEach time through the loop, the value of i accesses the element at index i. This simple for loop is able to loop through the array, regardless of how many items there are in the array.\n\nThis traversal can also be written using a while loop:\n\nint index = 0;\nwhile(index < orangeOrders.length)\n{\n   System.out.println(orangeOrders[index]);\n   index++;\n}\n\nNotice that the variable index is outside of the while loop. This ensures that the variable index isn’t reset to 0 every time the while loop starts a new iteration. The value of index is increased by one at the end of the while loop, ensuring that the next index in the array will be accessed.\n\nWhen developing iterative programs for use with arrays, it’s important to pay attention to which values are being set as the starting and ending indices. A common mistake programmers make is setting the ending index to the length of the array, not the last index value:\n\nint index = 0;\nwhile (index <=orangeOrders.length)\n{\n   System.out. println(orangeOrders[index]);\n   index++;\n}\n\nIn this example, the final value of index will be 6, even though the last index in orangeOrders is 5. As a result, this program will lead to an ArrayIndexOutOfBoundsError. This type of error is referred to as an “off by one” error, as the program iterates one too many times over the array.\n\n###\n\n","completion":" Question: What is the output after this code snippet runs?\n\ndouble[] prices = {3.45, 1.00, 2.25, 5.22, 4.50};\n\nfor (int i = 0; i < prices.length; i += 2)\n{\n       System.out.println(scores[i] = prices[i]  -  1);\n}\nCorrect: 2.45\n1.25\n3.50\nIncorrect: 2.45\n1.25\nIncorrect: 2.45\n0.00\n1.25\n4.22\n3.50\nIncorrect: 3.45\n2.25\n4.50END"}
{"prompt":"In both the for and while loop array traversals, a counter was used to determine the correct index at which an array element could be found:\n\n\/\/for loop\nfor(int i = 0; i < array.length; i++){\n   \/\/ Do something\n}  \n\n\/\/while loop\nint counter = 0;\nwhile(counter < array.length) { \n   \/\/ Do something\n   counter++;\n} \n\nArrays can also be traversed without the use of counters by using an enhanced for loop.\n\nEnhanced for loops are an alternate method of traversing an array:\n\nint[] numList = {5,6,7,4,2};\nfor(int number: numList)\n{\n   System.out. println(number);\n}\n\nInstead of initializing a variable for looping, the enhanced for loop header initializes a new variable, number known as the enhanced for loop variable. The type of this variable needs to match the value type of the array. In this example, since numList is an array of integers, number also needs to be an integer.\n\nAfter the enhanced for loop variable is defined, the header is completed by placing a colon and the name of the array being iterated on (numList).\n\nInside the loop, the enhanced for loop variable is assigned a copy of each value of the array without using the array index. On each iteration, the value of number changes to match an element in the array. The first value of number in this loop is 5. The second value will be 6, as it is the next item in the array. The enhanced for loop iterates in the order that the elements are found in the array, from first to last. Making changes to the enhanced for loop variable does not change the original value in the array.\n\nStandard for loops can be rewritten as enhanced for loops, and vice versa:\n\nString[] classroom = {\"julian\", \"larisa\", \"amada\", \"mikka\", \"jay\"};\n\n\/\/Enhanced For Loop:\nfor(String student : classroom)\n{\n   System.out.println(student);\n}\n\n\n\/\/Standard For Loop:\nfor(int i = 0; i < classroom.length; i ++)\n{\n    System.out.println(classroom[i]);\n}\n\nBoth standard and enhanced for loops are useful in different contexts. For example, since enhanced for loops make a copy of each element value, they are incapable of changing the value of the elements in an array. If elements need to be altered, standard for loops are more appropriate. In contrast, if elements just need to be accessed, enhanced for loops provide a more streamlined way to access elements without the need for a counter, or a potential ArrayIndexOutOfBounds error.\n\n###\n\n","completion":" Question: What is the output of the following code snippet?\n\nint[] temperatures = {80, 92, 91, 68, 88};\n\nfor(int temperature : temperatures)\n{\n    System.out.println(temperature);\n}\nCorrect: 80\n92\n91\n68\n88\nIncorrect: 80 92 91 68 88\nIncorrect: ArrayIndexOutOfBounds exception will be thrown\nIncorrect: temperatureEND"}
{"prompt":"Programmers use data structures to store data. Data is often stored so that it can be used or analyzed at some point in the future. Array traversals have several important applications in regards to how data is used and analyzed. They can be used in:\n\nMathematical Analysis\n- Determine a minimum or maximum value\n- Compute a sum, average, or mode\n\nAnalyzing Element Properties\n- Determine if at least one element has a particular property\n- Determine if all elements have a particular property\n- Access all consecutive pairs of elements\n- Determine the presence or absence of duplicate elements\n- Determine the number of elements meeting specific criteria\n\nReordering Elements\n- Shift or rotate elements left or right\n- Reverse the order of the elements\n\nEach of these subsets uses a distinct algorithm to analyze arrays.\n\nComputing mathematical results, such as the sum of integers in an array or finding the average of each value in an array requires the use of a similar algorithm:\n\nint[] scores = {80, 92, 91, 68, 88};\n\n\/\/Initialize value here\nint valueToFind = 0;\n\nfor (int i = 0; i < scores.length; i++){\n   \/\/Perform calculation on valueToFind\n}\n\n\/\/Report results of valueToFind\n\nIn each case, the algorithm requires the initialization of a value that will be used to store the result of a given computation outside of the for loop. Inside the loop, the initialized value, valueToFind, will be altered depending on the desired output, and the results will be displayed after the loop has terminated.\n\nFor a better understanding of this, consider this implementation of computing a sum:\n\nint[] scores = {80, 92, 91, 68, 88};\nint sum = 0;\nfor (int i = 0; i < scores.length; i++){\n   sum += scores[i];\n}\nSystem.out.println(sum);\n\nThe value of sum is changed each iteration through the for loop, adding the current score to the value of sum. This algorithm looks awfully similar to the one used to find the average value of an array:\n\nint[] scores = {80, 92, 91, 68, 88};\nint sum = 0;\nfor (int i = 0; i < scores.length; i++){\n   sum += scores[i];\n}\nSystem.out.println((double) sum \/ scores.length);\n\nIn both cases, the initialized value is declared before the for loop, used in mathematical computations within, and then displayed after its termination.\n\nTo determine if an element or a set of elements in an array meets specific criteria or has a specific set of properties, the following general algorithm can be used:\n\nString[] grades = {\"A\",\"C\",\"B\",\"A\",\"B\"};\n\n\/\/Initialize tracker variable\nfor (int i = 0; i < grades.length; i++){\n   \/\/Conditionally check properties\n}\n\n\/\/Report results here\n\nSimilar to mathematical analysis, property analysis sets an initial tracker variable before the start of the for loop, and checks through each iteration if the element at a specific index meets the criteria. It then reports the findings after the loop has terminated.\n\nIn the following example, the tracker variable checks how many A’s there are in the grade array:\n\nString[] grades = {\"A\",\"C\",\"B\",\"A\",\"B\"};\n\n\/\/Initialize tracker variable\nint numAs = 0;\n\nfor (int i = 0; i < grades.length; i++){\n\/\/Conditionally check properties\n   if (grades[i].equals(\"A\")){\n      numAs++;\n   }\n}\n\nSystem.out.print(\"Number of A's: \");\nSystem.out.println(numAs);\n\nIn this case, the value of the tracker variable numAs increments if the element at each index is an A. These tracker variables can also be used to store a single value that changes depending on the condition. For example, finding the minimum value of a list looks similar to the previous example, but only stores a single value:\n\nint[] scores = {80, 92, 91, 68, 88};\n\nint minIndex = 0;\n\nfor (int i = 1; i < scores.length; i++){\n   if (scores[i] < scores[minIndex]){\n      minIndex= i;\n   }\n}\nSystem.out.println(minIndex);\n\nRather than increment, this tracker keeps track of the current minimum value in the list. If the value at the current index is less than the existing minimum, then the tracker is changed to reflect that.\n\nAnother common array algorithm involves reordering or reversing our arrays. While this can be done in a few different ways, a common method is to create a new temporary array where a copy of the new order for values is stored. Once the new order is copied into the temporary array, it overwrites the original array with the temporary one:\n\nint[] numbers = {1, 2, 3, 4, 5};\nint[] temp = new int[numbers.length]; \/\/Create default array\n\n\/\/Loop, but stop at the last element (edge case)\nfor (int i = 0; i < numbers.length - 1; i++){\n    temp[i + 1] = numbers[i]; \n}\ntemp[0] = numbers[numbers.length - 1]; \/\/Edge case\nnumbers = temp; \/\/Copy over to the original array\n\nIn this example, the algorithm is shifting the values in the array to the right by one. Rather than move the values in the existing array, a new array is created to store the values in the specified order. This removes the possibility that the original array gets altered accidentally, and that changes to the new array do not impact the original.\n\n###\n\n","completion":" Question: What will the following code segment output?\n\nString[] grades = {\"A\",\"C\",\"B\",\"C\",\"B\", \"A\"};\n\nint mystery = 0;\n\nfor (int i = 0; i < grades.length; i++)\n{\n    if (grades[i].equals(\"B\")) \n    {\n        mystery ++;\n    }\n}\n\nSystem.out.println(mystery);\nCorrect: 2\nIncorrect: 0\nIncorrect: 1\nIncorrect: 3END"}
{"prompt":"In the last unit, you learned how to store data more efficiently using arrays. Arrays are able to store a list of values of the same type in one variable, making it easier to store and keep track of data that you need for your programs. One of the limitations of using arrays to store data is the fact that they have a fixed number of items that can be added or changed. Elements can only be added to an array by creating a new array of a different size and copying the data from the initial array to the new one:\n\nint[] setSize = new int[5];\nint[] newSize = new int[6];\nsetSize = newSize;\n\nThis process is tedious, and requires a high degree of difficulty, especially if the list being used is going to change in size often. A more convenient way to create adjustable arrays is by using the ArrayList class.\n\nArrayLists are similar to arrays, except that they are a mutable list of object references, meaning that the size of the list can be adjusted freely. Creating an ArrayList is as simple as initializing a new ArrayList in a program:\n\nimport java.util.ArrayList;\n\npublic static void main(String[] args)\n{\n  ArrayList<E> list = new ArrayList<E>();\n}\n\nIn order to use the ArrayList class, the ArrayList class needs to be imported from the java util package. This can be done by writing import java.util.ArrayList at the top of the class file.\n\nArrayList objects are created in the same fashion as other object classes. The primary difference with ArrayLists is that the element type of the ArrayList must be specified using angled bracket <>. In this example, E represents the data type that will be used in the ArrayList. This can be replaced by an object data type:\n\nArrayList<String> list = new ArrayList<String>();\n\nThe declaration type for an ArrayList must match the initialization type. In this case, both types reference the String data type.\n\nWhen this line of code is executed, the ArrayList list will store an empty ArrayList with no index values. Unlike arrays, the number of items that will be stored in an ArrayList does not need to be specified. Values can be added to the ArrayList after the ArrayList is initialized. This will be explored more in the next chapter.\n\nArrayLists can actually be declared without specifying the type that will be included in the ArrayList:\n\nArrayList list = new ArrayList();\n\nWhile this appears to be a simpler initialization process, specifying the data type is highly recommended because it allows the compiler to find errors before run time. This makes it easier to find errors, and program more efficiently, as the program will indicate if there is an issue before any code is run.\n\nWhile arrays and ArrayLists are fairly similar data structures, the key differences between them lie in their creation, mutability, and the types of data that they can store.\n\nArrays are a fixed size, whereas ArrayLists can contract and expand. ArrayLists are only able to store objects, whereas arrays can store both primitive and object values. Foruntuantley, autoboxing and unboxing allows you to send many primitive variables into an ArrayList, but the ArrayList still needs to be set up using the object type.\n\nWhen choosing to use a data structure, it’s important to know if the data being stored should be a fixed, or unfixed size in length. Which data structure you choose will depend on how frequently that data needs to be updated or accessed.\n\n###\n\n","completion":" Question: How do you create an ArrayList of integers?\nCorrect: ArrayList<Integer> list = new ArrayList<Integer>();\nIncorrect: int[] list = new int[];\nIncorrect: ArrayList<int> list = new ArrayList<int>();\nIncorrect: ArratList(int) list = new ArrayList(int);END"}
{"prompt":"ArrayLists provide flexibility and functionality that arrays do not. You can think of an ArrayList as a container that will resize as you add and remove objects from it. In order to do so, there are several helper methods that are used to alter the state of an ArrayList, and get information about its content.\n\nObjects can be added to an ArrayList using the add method. The add method has several method signatures:\n\nboolean add(E obj)\nvoid add(int index, E obj)\n\nThe single parameter add method will add an element to the end of the ArrayList:\n\nimport java.util.ArrayList;\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\n\nSince the ArrayList starts with no values, the call to add will add the element 5 to the 0th index of the ArrayList. If the call list.add(8) were added to this code segment, the element 8 would be added to the 1st index position. Like arrays, ArrayLists begin at index 0. The add method returns true if the element was successfully added to the ArrayList.\n\nThe second add method signature will add an element at a specified index:\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\nlist.add(1, 4);  \/\/Adds the value 4 at index 1.\n\nThe specified index must be between the value 0, and the current size of the ArrayList. To determine the size of the ArrayList, the method size can be used to return the current length of an ArrayList:\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\nSystem.out.println(list.size()); \/\/returns 1\nlist.add(1, 4);\nSystem.out.println(list.size()); \/\/returns 2\n\nNotice that the size of the ArrayList increases when a new value is added to the list. When add(int index, E obj) is called, the list items from index - size() shift up one index to allow the new value to slot in to the correct index position.\n\nElements in an ArrayList can be accessed using the get(int index) method:\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\nlist.add(3);\nlist.add(10);\nlist.add(4);\n\nint val = list.get(1);\nSystem.out.println(val); \/\/prints the value 3\n\nThe method get returns an element at the specified index. In this case, the value stores at index 1 (3), is being stored in the variable val, and printed to the console.\n\nIndividual elements in an ArrayList can be changed using the set(int index, E obj) method:\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\nlist.add(3);\nlist.add(10);\nlist.add(4);\n\nint val = list.get(2);\nSystem.out.println(val); \/\/prints the value 10\n\n\/\/change the value at index 2\nlist.set(2, 34);\nval = list.get(2);\nSystem.out.println(val); \/\/prints the value 34\n\nIn this example, the value at index 2 is changed from the value 10 to the value 34. It’s important to note that the values can only be changed to another value of the same data type.\n\nThe set method also returns the value that is being replaced to the existing program. The value that has been replaced can then be stored in a variable of its own:\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\nlist.add(3);\nlist.add(10);\nlist.add(4);\n\nint val = list.set(2, 34);\nSystem.out.println(val); \/\/prints the value 10\n\nint newVal = list.get(2);\nSystem.out.println(newVal); \/\/prints the value 34\n\nJust as elements can be added, they can be removed from an ArrayList using the remove(int index) method. Like the set method, the remove method also returns the value that is being removed from the specified index.\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\nlist.add(3);\nlist.add(10);\nlist.add(4);\nSystem.out.println(list.size()); \/\/ prints the value 4\n\nint val = list.remove(0);\nSystem.out.println(val); \/\/prints the value 5\n\nSystem.out.println(list.size()); \/\/ prints the value 3\n\nIn the program above, notice that the size of the ArrayList decreases by one when the element is removed from the ArrayList. All values at the index higher will move down one index once an element is removed from an ArrayList.\n\nMany of the methods used to access and manipulate ArrayLists are functionally similar in nature to arrays:\n\nFeature\tArrays\t\t\t\tArrayLists\nInitialize\tint[] arr = new int[5];\tArrayList array = new ArrayList();\nGet Value\tarr[index]\t\t\tarray.get(index)\nGet Size\tarr.length\t\t\tarray.size()\nSet Value\tarr[index] = value;\t\tarray.set(index, value)\n\nWhen considering which data structure to use, it’s important to determine early on if it’s necessary to add or remove values at future points in the program. If that’s the case, then ArrayLists may serve better.\n\n###\n\n","completion":" Question: What value will be printed in the console after this series of commands? Assume that the ArrayList package has been imported.\n\nArrayList<Integer> array = new ArrayList<Integer>();\narray.add(1);\narray.add(9);\narray.add(10);\narray.remove(1);\narray.add(1);\narray.set(0, 3);\nint num = array.get(1);\nSystem.out.println(num);\nCorrect: 10\nIncorrect: 9\nIncorrect: 3\nIncorrect: 1END"}
{"prompt":"As covered in Unit 6, traversing is the process of moving through all the items in an array or data structure. Loops can be used to traverse arrays by using the incremental variable to access each individual element in an array:\n\nint[] scores = {80, 92, 91, 68, 88};\nfor(int i = 0; i < scores.length; i++) \n{ \n    \/\/ This prints out the ith element! \n    System.out.println(scores[i]);\n}\n\nThe same process is applicable to traversing elements in an ArrayList:\n\nArrayList<Integer> scores = new ArrayList<Integer>();\n\nfor(int i = 0; i < scores.size(); i++)\n{\n    \/\/ This prints out the ith element!\n    System.out.println(scores.get(i));\n}\n\nThe primary difference between array and ArrayList traversal lies in the methods used to access each element. For ArrayLists, size is used to determine the number of iterations of the increment variable, and get is used to access the element at a given index. This same difference applies to ArrayList while loop traversals and enhanced for loops:\n\n\/\/ while loop traversal\nint i = 0;\nwhile(i < scores.size())\n{\n    System.out.println(scores.get(i));\n    i++;\n}\n\n\/\/ Enhanced for loop traversal\nfor(int score: scores)\n{\n    System.out.println(score);\n}\n\nBecause ArrayLists can change size, it’s necessary to take caution when traversing them, as the changing size of the ArrayList can affect which elements are being accessed.\n\nConsider the following list, and associated method:\n\nlist\n\n0\t1\t2\t3\t4\n“I”\t“am”\t“Andrew”\t“Aardvark”\t“Jr.”\n\/\/Removes all Strings from an ArrayList that begin with the letter 'A'\npublic void removeA(ArrayList<String> list)\n{\n  for(int i = 0; i < list.size(); i++)\n  {\n    if (list.get(i).startsWith(\"A\"))\n    {\n      list.remove(i);\n    }\n  }\n}\n\nThis method intends to remove each element in a list that starts with the letter A. The implementation of this however, has unintended consequences. When i = 2, the conditional if statement will remove the item at index 2 from the list. It then will return to the for loop header, and increment the value of i to i = 3.\n\nWhen remove is used on this list, each value in the list after index 2 shifts one space down in the ArrayList:\n\nlist\n\n0\t1\t2\t3\n“I”\t“am”\t“Aardvark”\t“Jr.”\nHowever, the value of i in the for loop header is now 3. When the conditional statement checks for a word that starts with “A” at index 3, there is none. The value “Aardvark” unintentionally stays in the list, even though the method was designed to remove all instances of words that start with “A”.\n\nThe solution to this problem is adding a decrement after the list item is removed:\n\n\/\/Removes all Strings from an ArrayList that begin with the letter 'A'\n\npublic void removeA(ArrayList<String> list)\n{\n  for(int i = 0; i < list.size(); i++)\n  {\n    if (list.get(i).startsWith(\"A\"))\n    {\n       list.remove(i);\n       i --; \/\/decrease the value of i by one!\n    }\n  }\n}\n\nNow when the list item is removed at index 2, the value of i is decreased to 1. When the for loop iterates again, the value of i will increase from 1 to 2 again, allowing the program to check the new value at index 2 after the elements shift position.\n\nWhen using these traversal methods, there are several common Exceptions that may occur if the traversal is implemented incorrectly:\n\n1. IndexOutOfBounds Exception:\n\nWhen iterating through an ArrayList, it’s common that the iteration includes an index that is outside of the current index range. For example, if the for loop conditional statement occurs from i = 0 to i <= list.size(), then the iteration will include one extra iteration that searches for an index at position list.get(list.size()), even though ArrayList indices only range from 0 - list.size() - 1. Accessing an index that is not within the range of the existing ArrayList will result in an IndexOutOfBounds Exception, commonly known as an “off by one” error.\n\n2. ConcurrentModification Exception\n\nThis exception occurs when attempting to remove an item from an ArrayList during an enhanced for loop. This error occurs when objects are being modified while they are being iterated on, which is what happens when enhanced loops are used on ArrayLists. Generally speaking, removing and adding items from an ArrayList should not be done while using enhanced for loops.\n\n###\n\n","completion":" Question: What is the standard method used to traverse an ArrayLists?\nCorrect: for(int index = 0; index < array.size(); index++)\n{\n     array.get(index);\n}\nIncorrect: for(int index = array.size(); index < 0; index++)\n{\n     array.get(index);\n}\nIncorrect: for(int index = 0; index <= array.length(); index++)\n{\n     array[index];\n}\nIncorrect: for(int index = 0; index <= array.size(); index++)\n{\n     array.get(index);\n}END"}
{"prompt":"Just as arrays have standard algorithms that can be applied in different situations, ArrayLists too, have standard algorithms.\n\nIn the last chapter, you learned of one such standard algorithm - the ability to remove an item from an ArrayList. While the example in the last chapter removed all elements from an ArrayList that started with the letter A, this algorithm can be repurposed for use with any condition:\n\npublic void removeElem(ArrayList<Type> list, E element)\n{\n    for(int i = 0; i < list.size(); i++)\n    {\n        if (list.get(i).equals(element))\n        {\n            list.remove(i);\n            i--;\n        }\n    }\n}\n\nIn this example, the variable element represents the property or value that is meant to be removed from the ArrayList. Remember that i-- must be included to ensure that all elements in the ArrayList are being evaluated.\n\nJust as elements can be removed from an ArrayList, they can also be added using a standard algorithm:\n\npublic void addElem(ArrayList<Type> list, E element)\n{\n    for(int index = 0; index < list.size(); index++)\n    {\n        if() \/\/Condition for adding element\n        {\n            list.add(index, element);\n            index++;\n        }\n    }\n}\n\nNotice in this case, that index is incremented when a new element is added to the list. Including this increment largely depends on the condition that is being set to add new elements to the ArrayList. For example, if a programmer were to add odd integers to an ArrayList of even integers {2,4,6,8} in the index position of the existing element, then the increment would be necessary to avoid an infinite loop.\n\nArrayList traversals have several important applications in regards to how data is used and analyzed.\n\nThese various applications generally belong to a larger subset of applications:\n\nMathematical Analysis\n- Determine a minimum or maximum value\n- Compute a sum, average, or mode\n\nAnalyzing Element Properties\n- Determine if at least one element has a particular property\n- Determine if all elements have a particular property\n- Access all consecutive pairs of elements\n- Determine the presence or absence of duplicate elements\n- Determine the number of elements meeting specific criteria\nReordering Elements\n- Shift or rotate elements left or right\n- Reverse the order of the elements\n\nEach of these subsets uses a distinct algorithm to analyze arrays.\n\nComputing mathematical results, such as the sum of integers in an array or finding the average of each value in an array requires the use of a similar algorithm:\n\nArrayList<Integer> scores = new ArrayList<Integer>();\n\/\/add values to scores\n\n\/\/Initialize value here\nint valueToFind = 0;\nfor (int i = 0; i < scores.size(); i++){\n    \/\/Perform calculation on valueToFind\n}\n\/\/Report results of valueToFind\n\nIn each case, the algorithm requires the initialization of a value that will be used to store the result of a given computation outside of the for loop. Inside the loop, the initialized value, valueToFind, will be altered depending on the desired output, and the results will be displayed after the loop has terminated.\n\nFor a better understanding of this, consider this implementation of computing a sum:\n\nArrayList<Integer> scores = new ArrayList<Integer>();\n\/\/add values to scores\n\nint sum = 0;\nfor (int i = 0; i < scores.size(); i++){\n    sum += scores.get(i);\n}\nSystem.out.println(sum);\n\nThe value of sum is changed each iteration through the for loop, adding the current score to the value of sum. This algorithm looks awfully similar to the one used to find the average value of an array:\n\nArrayList<Integer> scores = new ArrayList<Integer>();\n\/\/add values to scores\n\nint sum = 0;\nfor (int i = 0; i < scores.size(); i++){\n    sum += scores.get(i);\n}\nSystem.out.println((double) sum \/ scores.size());\n\nIn both cases, the initialized value is declared before the for loop, used in mathematical computations within, and then displayed after its termination.\n\nTo determine if an element, or a set of elements in an ArrayList meets a specific criteria or has a specific set of properties, the following general algorithm can be used:\n\nArrayList<String> grades = new ArrayList<String>();\n\/\/add values to grades\n\n\/\/Initialize tracker variable\nfor (int i = 0; i < grades.size(); i++){\n    \/\/Conditionally check properties\n}\n\/\/Report results here\n\nSimilar to mathematical analysis, property analysis sets an initial tracker variable before the start of the for loop, and checks through each iteration if the element at a specific index meets the criteria. It then reports the findings after the loop has terminated.\n\nIn the following example, the tracker variable checks how many A’s there are in the grade array:\n\nArrayList<String> grades = new ArrayList<String>();\n\/\/add values to grades\n\n\/\/Initialize tracker variable\nint numAs = 0;\n\nfor (int i = 0; i < grades.size(); i++){\n    \/\/Conditionally check properties\n    if (grades.get(i).equals(\"A\")) {\n        numAs++;\n    }\n}\n\nSystem.out.print(\"Number of A's: \");\nSystem.out.println(numAs);\n\nIn this case, the value of the tracker variable numAs increments if the element at each index is an A. These tracker variables can also be used to store a single value that changes depending on the condition. For example, finding the minimum value of a list looks similar to the previous example, but only stores a single value:\n\nArrayList<Integer> scores = new ArrayList<Integer>();\n\/\/add values to scores\n\nint minIndex = 0;\n\nfor (int i = 1; i < scores.size(); i++){\n    if (scores.get(i) < scores.get(minIndex) {\n        minIndex = i;\n    }\n}\nSystem.out.println(minIndex);\n\nRather than increment, this tracker keeps track of the current minimum value in the list. If the value at the current index is less than the existing minimum, then the tracker is changed to reflect that.\n\nAnother common ArrayList algorithm involves reordering or reversing our arrays. While this can be done in a few different ways, a common method is to create a new temporary array where a copy of the new order for values is stored. Once the new order is copied into the temporary array, it overwrites the original array with the temporary one:\n\nArrayList<Integer> numbers = new ArrayList<Integer>();\n\/\/add values to scores\n\nArrayList<Integer> temp = new ArrayList<Integer>();\n\/\/add values to scores\n\n\/\/Edge case\ntemp.add(numbers.get(numbers.size() - 1));\n\n\/\/Loop, but stop at the last element (edge case)\nfor (int i = 0; i < numbers.size() - 1; i++){\n    temp.add(i + 1, numbers.get(i));\n}\n\nnumbers = temp; \/\/Copy over to the original ArrayList\n\nIn this example, the algorithm is shifting the values in the array to the right by one. Rather than move the values in the existing ArrayList, a new ArrayList is created to store the values in the specified order. This removes the possibility that the original ArrayList gets altered accidentally, and that changes to the new ArrayList do not impact the original. Note that the edge case is added before the for loop. This ensures that the ArrayList add method will work, as it can only add values to index values from 0 - size().\n\nSome algorithms require ArrayLists to be traversed simultaneously. One such example would be if you wanted to sum the indices of two ArrayLists:\n\n0\t1\t2\t3\t4\n5\t2\t4\t5\t0\nlist1\n+\n\n0\t1\t2\t3\t4\n3\t5\t6\t9\t12\nlist2\n=\n\n0\t1\t2\t3\t4\n8\t7\t10\t14\t12\nsummedList\n\nCreating the summedList requires that both list1 and list2 are traversed simultaneously to access and sum the individual values at each index:\n\nArrayList<Integer> summedList = new ArrayList<Integer>();\nfor(int index = 0; index < list1.size(); index++)\n{\n    int sum = list1.get(index) + list2.get(index);\n    summedList.add(sum);\n}\n\n###\n\n","completion":" Question: Which of these method implementations would correctly insert an element into an ArrayList after every even index?\nCorrect: {\n   for(int index = 0; index < array.size(); index++)\n   {\n      if(index %2 == 0)\n      {\n         array.add(index + 1, element);\n         index++;\n      }\n   }\n}\nIncorrect: {\n   for(int index = 0; index < array.size(); index++)\n   {\n      if(index %2 == 0)\n      {\n         array.add(index, element);\n         index++;\n      }\n   }\n}\nIncorrect: {\n   for(int index = 0; index < array.size(); index++)\n   {\n      if(index %2 == 0)\n      {\n         array.add(index + 1, element);\n      }\n   }\n}\nIncorrect: {\n   for(int index = 0; index < array.size(); index++)\n   {\n      if(index %2 == 0)\n      {\n         array.add(index, element);\n      }\n   }\n}END"}
{"prompt":"As the amount of data stored in an array or ArrayList begins to grow, a common necessity is knowing where and if certain data can be found within a dataset. For example, a user is interested in buying a new car. They want to find a used car that is within their price range and a certain color. Given a database of cars, this user should be able to find the exact car that they are looking for, provided that the car exists in the database! This process of finding data, or pieces of data, that fit a specific criteria is called searching.\n\nA common way to search through a list of items is to start at the beginning of the list and continue through the list until the desired item is found. If the desired item is not found, then that means it is not in the list.\n\nSuppose that you are given a set of raffle tickets at a school raffle. Each ticket has its own number on it:\n\nTicket\t0\t1\t2\t3\t4\t5\nNumber\t44\t53\t12\t51\t64\t15\nThe 0th ticket has number 44, and the ticket at index 4 has raffle number 64. The school will randomly select a number between 1 and 100. If you have the ticket with that number, you win!\n\nWhat if the school picks 51 as the winning number? As a human, it’s easy to look over the whole list and see that you have the ticket with 51 on it, but computers need a more programmatic approach to looking through the list.\n\nThe process of searching each item in a list until the desired item is found is called linear, or sequential search.\n\nLinear search is fairly easy to implement. To programmatically search the list of raffle ticket numbers, you just need to iterate through the list one number at a time. At each new number, if the number matches the desired number, then the desired number is in the list, and the program can stop searching and return the index position of the number. If the program makes it all the way to the end of the list and hasn’t spotted the desired number, then that means it’s not in the list.\n\nHere’s what it looks like in pseudocode:\n\nfor every index in the list:\nget the current number at that index position\nif the current number matches our target number:\nreturn the index\nreturn not found\n\nThat pseudocode can be used to implement a working linear search:\n\npublic int linearSearch(int[] array, int key)\n{\n    for(int i = 0; i < array.length; i++)\n    {\n        int element = array[i];\n        if(element == key)\n        {\n            return i;\n        }\n    }\n    return -1;\n}\n\nIn the example above, key represents the value that is being searched for in the given list. If the key is an element in the list, then the index where that value can be found is returned to the program, otherwise, the value -1 will be returned.\n\nThis method can also be implemented using ArrayList:\n\npublic int linearSearch(ArrayList<Integer> arrayL, int key)\n{\n    for(int i = 0; i < arrayL.size(); i++)\n    {\n        int element = arrayL.get(i);\n        if(element == key)\n        {\n            return i;\n        }\n    }\n    return -1;\n}\n\nWhile linear search is a fairly easy algorithm to implement and understand, linear search is limited by the number of elements that are being searched. The longer the data set is, the longer linear search takes, as it must iterate through all values in order to find the correct one.\n\nSuppose the 1 millionth item in a data set were the element that you were looking for- linear search would have to iterate through the data set 1 million times in order to find it! When deciding how to search for values in a data set, it’s important to consider the pros and cons of using the search mechanism.\n\n###\n\n","completion":" Question: How does Linear Search work?\nCorrect: Linear Search traverses a list in order until the desired value is found, or until the end of the list.\nIncorrect: Linear Search uses a while loop to traverse a list for the desired value, or until the end of the array.\nIncorrect: Linear Search traverses a list from the last value to the first value until the desired value is found.\nIncorrect: Linear Search searches for desired values by searching the the next highest value in a list, and seeing if that is the desired value.END"}
{"prompt":"As datasets get larger, it’s important to be able to manage and sort through data to find results and values more quickly and efficiently. When data is disorganized, it can be hard to find values easily. To find values, it’s much easier to do so if they are in the correct order. That way, searches can be organized at specific points, which in turn can make sure that programs will look through less values as they search.\n\nTake this dataset for example:\n\n1\t2\t7\t44\t5\t76\t9\t0\t72\t4\t325\t2\t753\t345\t234\t53\nFinding the value 4 in this list requires you to search from the beginning all the way to the end - since the data isn’t in a particular order, there is no way of knowing for certain where the element 4 will be found.\n\nIf this list were organized by smallest number to greatest:\n\n0\t1\t2\t2\t4\t5\t7\t9\t44\t53\t72\t76\t234\t325\t345\t753\nThen finding 4 would be a much easier process, as you can search certain sections of the list for the element in question where it is most likely to be found.\n\nIn programming, there are standard algorithms that can be used to sort data in ways that make finding data more manageable. Two standards algorithms that will be explored in this chapter are Selection and Insertion Sort.\n\nSelection sort sorts arrays by repeatedly finding the minimum value in an array, and moving it to the front. Consider the following, unorganized array:\n\n5\t3\t4\t1\t6\t2\nUsing selection sort to sort this array, the first index in the array is picked to start.\n\n5\t3\t4\t1\t6\t2\nThen, the list is traversed to find the minimum value in the rest of the list, which in this case is 1. The value 1 is then swapped from its current position to the position where 5 was:\n\n1\t3\t4\t5\t6\t2\nNow the value 1 at index 0 is considered sorted, and the next unsorted element at index 1 will be chosen. The value at index 1 will be compared with the rest of the unsorted items until a minimum value is found. In this case, the value 2 at index 5 is the minimum value, and it is swapped with the value at index 1.\n\n1\t2\t4\t5\t6\t3\nThis process continues until the entire list is sorted from least - greatest.\n\nHere is what this process looks like in pseudocode:\n\ntraverse each index up to the second to last element\nfind the minimum in the rest of the list\nswap the index and minIndex\n\/\/ now everything up to curIndex is sorted\n\nThis can then be used to create a working algorithm for selection sort:\n\npublic static void selectionSort(int[] array)\n{\n    for(int index = 0; index < array.length - 1; index++)\n    {\n        int minIndex = index;\n        for(int i = index; i < array.length; i ++)\n        {\n            if(array[i] < array[minIndex])\n            {\n                minIndex = i;\n            }\n        }\n        int tempValue = array[index];\n        array[index] = array[minIndex];\n        array[minIndex] = tempValue;\n    }\n}\n\nThe initial traversal goes from the first element to the second to last element (array.length - 1) because the final element in the array is considered sorted if every other element in the array has been sorted correctly. The second traversal looks for the minimum value in the array from the current element until the end of the list. It does not search the list for already sorted elements. Once the minimum element is found, it swaps positions with the current element.\n\nSelection sort is a particularly useful sorting algorithm when the elements in a list are in reverse order:\n\n6\t5\t4\t3\t2\t1\nIn this case, the algorithm only needs to swap values a few times, as each swap successfully puts each element in its correct position.\n\nInsertion sort sorts an array by sorting each element compared to the elements already sorted to their left.\n\nGiven the same list as the previous example, insertion sort marks the first element in the list as sorted:\n\n5\t3\t4\t1\t6\t2\nThe next element, 3, is then selected as the next element to sort:\n\n5\t3\t4\t1\t6\t2\nRather than find the minimum value in the unsorted segment like selection sort, insertion sort compares unsorted elements to the sorted ones, placing the element in the correct position within the sorted list:\n\n3\t5\t4\t1\t6\t2\nThe element 3 is now considered sorted, and the sort continues on to the next element, 4, and sorts it within the already sorted list:\n\n3\t4\t5\t1\t6\t2\nThis continues until all elements in the list are sorted from least to greatest.\n\nHere is a pseudocode implementation of insertion sort:\n\ntraverse each element starting from index 1\ntraverse sorted elements to find current element position\nshift sorted elements to place current element\n\nThis can be used to create a working algorithm for insertion sort:\n\npublic static void insertionSort(int[] array)\n{\n    for(int index = 1; index < array.length; index++)\n    {\n        int currentIndexValue = array[index];\n        int sortedIndex = index - 1;\n\n        while(sortedIndex > -1 && array[sortedIndex] > currentIndexValue)\n        {\n            array[sortedIndex + 1] = array[sortedIndex];\n            sortedIndex--;\n        }\n\n        array[sortedIndex + 1] = currentIndexValue;\n    }\n}\n\nInsertion sort traverses all elements from index 1 until the end of the array. Each element then traverses the sorted segment of the array, looking for the correct place in the sorted list to go. This is done using a while loop, as the number of iterations depends largely on the content of the sorted list. As the element moves through the sorted list, each element it searches through is shifted one index higher. This ensures that the element can be placed in the correct index without removing any of the pre-sorted elements from the list.\n\nInsertion sort is most useful when a list is mostly sorted:\n\n1\t2\t3\t4\t6\t5\nWhen lists are almost sorted, the number of times that insertion sort needs to iterate through the list items is limited. In this case, the while loop will not execute for the first 5 index values in this array, limiting the execution count, and reducing the amount of time the algorithm spends sorting items.\n\nWhen choosing which sorting algorithm to use, it’s important to pay attention to the composition of the existing list, and determine which method will be most efficient, especially as the datasets grow.\n\n###\n\n","completion":" Question: When is it more appropriate to use Insertion Sort than Selection Sort?\nCorrect: When the array is already mostly sorted at the start.\nIncorrect: Insertion sort is always faster than selection sort, so any array is appropriate.\nIncorrect: When the array is sorted in reverse order.\nIncorrect: Insertion sort is always slower than selection sort, so no array is appropriate.END"}
{"prompt":"On a daily basis, humans are creating more data than ever before. This is creating new challenges around protecting and securing that data for individual users, large companies, banks, small startups, doctors, movie makers, and everyone in between. This means it’s more important than ever to be smart about security and privacy in the digital age of computing.\n\nIn order to understand the impact of data collection on privacy and security, it’s important to understand what each of these terms mean.\n\nPrivacy is the right to be free from unwarranted intrusion and to keep certain matters from public view.\n\nSecurity is the state of being free from danger or threat. Its the warm, fuzzy feeling you have when you don’t have to worry about feeling threatened by harm from others or things in the world around us!\n\nDigital technology has forever changed the way society is operating and the way people live. Everyday, there are new ways to work and to play which include new methods of interacting with one another. As people’s digital footprints grow, people form their own online identities.\n\nDigital security is the protection of these online identities.\n\nA digital footprint is the information about a particular person that exists on the Internet as a result of their online activity. This includes emails you send, comments you leave, pictures you post, your search history, and apps you use. Even your work on CodeHS is part of your digital footprint! All of these ways and more are the ways that you are sharing your own data! Any time you use the Internet you are building your digital footprint. Every time you use a device, your data can be collected!\n\nA lot of people think that hackers are going to steal their data, which they can and do, but truthfully, most people give up their data freely without thinking about it too much. It’s important to be aware of your own personal data and how you choose to share your data with others so that you can keep your data secure and private.\n\nHere are some quick tips to maintain your digital footprint and protect your personal data.\n\n- First, use privacy settings on apps and sites to limit your exposure.\n- Review posts that your friends tag you in and address questionable content.\n- Delete any old social media accounts you don’t really use.\n- Search yourself to see what other people see when they search for you on Google.\n- Use strong passwords for every account you have.\n- Stay on secure sites by sticking with httpS, not just http…if you see a site that starts with http, it is not a secure site!\n- Be sure to monitor your webcam and microphone use and make sure you don’t leave them on when you are not using them.\n- Be aware of your location sharing on apps like Find Friends or whenever Google or a site asks if you want to share your location.\n- Skim privacy policies and see if anything jumps out that concerns you about how the site or app shares or uses your data.\n- Watch for phishing attempts in emails. If someone you don’t know sends you an email that seems odd or sounds too good to be true, don’t click through any links or download any content until you’ve looked into it more.\n- Be careful logging into public computers like at a library, for example. Your data is logged on those devices and may not always be wiped to a clean state after you use it.\n- Stay up to date on the best web security practices like 2-factor authentication where you have to enter a code that is sent to your phone before you can proceed on an app or site. This code confirms you are who you say you are and not someone trying to pretend to be you!\n- If you think your personal data has been compromised, contact your parent or guardian, the company that owns the site or app, and\/or a school IT person so you can get help or advice.\n\nAll data is shared on the internet via what are called protocols. Protocols for data sharing on the internet are rules and conventions for communication between network devices.\n\nThe Internet is a packet-switched system through which digital data is sent by breaking the data into blocks of bits called packets. Packets contain both the data being transmitted and control information, or metadata, that helps route the data. It is only able to work because all machines have agreed to use the same protocols for creating and reading packets. Your computer and any server are able to share data because they use the same protocols. They are agreeing to talk in the same language.\n\nComputer use and the creation of programs have an impact on personal security that can be beneficial and\/or harmful.\n\nBeneficial Impacts:\n\n- Instant Communication: You share data whenever you email, make a video call, or post on social media. All of these have made it possible to communicate instantly with others and consume information at a very rapid pace.\n\n- Improved Collaboration: Sharing data enables collaborative problem solving on a very large scale. Foldit is an example of citizen science that harnesses the problem solving capacity from hundreds of thousands of citizens on the internet to solve really complicated problems. Foldit is an online game where players attempt to solve the folding structures of very important proteins. By determining the structures of these proteins, researchers are able to develop vaccines and understand diseases better. Once the foldit game went live on the internet, players were able to produce an accurate structure of an AIDs causing virus in only 10 days. This virus had been unsolved by computer simulations and researchers for 15 years!\n\n- Increased Access to Goods and Services: You share your data whenever you make an online purchase. Sharing data has provided online shopping that has enabled you to buy directly from retailers. You can easily purchase from other people who don’t have the funds to run a physical store. You are able to find the best product at the lowest price, rather than being disadvantaged by location or lack of knowledge because you can view ratings and reviews across all retailers.\n\n- Access to Information: Sharing data allows more access to information. Anyone on the internet can read cutting edge scientific publications now.\n\n- GPS and Location Sharing: GPS has completely changed how you navigate the world. You can leave your home with just your smartphone and you’ll generally have no problem finding the place that you need to be. You share your current location, which is data, and you are provided data around your position such as images and directions.\n\n- Entertainment: When you upload videos to YouTube, you share your data! There are also online gaming communities so you can play games with someone in another country who speaks a different language or you could be playing a video game with hundreds of other players simultaneously. You share things like your location and more with them, as well. When companies like NetFlix and Hulu stream videos to your home TV or device, theres a big exchange of data, too. They share digital content with you and your family must share payment information and device information to allow access.\n\nFor all of the amazing things that data sharing can provide, there are some substantial negative drawbacks as well.\n\nHarmful Impacts:\n\n- Access to Confidential Information: The website called Wikileaks posts classified information that either governments or corporations are trying to keep secret. On one hand, this is a good thing because it promotes the transparency of information. It makes it so corporations and the governments cant keep secrets from its citizens. However, there’s potential danger in having classified secrets being public, especially if that information is protecting people from harm or hiding their location purposefully.\n\n- Illegal Sharing\/Downloading: Peer-to-peer networks allow people to share content or data that they have on their computers. This is fine if the files are their own creation, but oftentimes shared content is NOT owned by the people sharing it. It’s easier than ever to distribute information or content that is not your own, such as copyrighted works of art or copyrighted software.\n\n- Anonymity: You can tell who internet users are by the data they share. How identifiable should Internet users be? On one hand, anonymity supports equality for all on the Internet. If all users are anonymous, users wont be targeted or discriminated against like for their gender or race, because that information won’t be available. However, having complete anonymity provides opportunities for cyber bullying. If all users are anonymous, no one is accountable for their actions.\n\nRegardless of the positive impacts that certain technologies might have on society, they can also have unintended consequences that have a negative impact on society, law, and ethics. Programmers have a responsibility to make sure that their programs are socially, legally, and ethically acceptable.\n\nA computing professional should:\n\n- Contribute to society and to human well-being, acknowledging that all people are stakeholders in computing.\n- Avoid harm.\n- Be honest and trustworthy.\n- Be fair and take action not to discriminate.\n- Respect the work required to produce new ideas, inventions, creative works, and computing artifacts.\n- Respect privacy.\n- Honor confidentiality.\n- Remember that knowledge is power as you live with others in this digital world. Use your knowledge of computing for good purposes so you and everyone else can be safe and enjoy the benefits of computing.\n\n###\n\n","completion":" Question: Which of the following are some good ways to protect your own personal data?\n\nI. Use privacy settings to limit exposure\nII. Post often on social media while traveling\nIII. Permanently delete old social media accounts you don’t use\nIV. Google yourself on a regular basis\nV. Use short, easy to remember passwords so you don’t have to write them down\nVi. Stay on sites with http:\/\/\nCorrect: Only I, III, IV, VI\nIncorrect: Only III, IV, V, VI\nIncorrect: Only I, III, IV, V, VI\nIncorrect: All of theseEND"}
{"prompt":"In Unit 6, you learned how to create arrays, which store a fixed number of elements of the same type in one variable. Arrays can store a series of data in list form to make it easier to access information. Imagine you were a teacher trying to keep track of student scores on exams. This could be done easily using an array:\n\nint[] exam1 = {90, 87, 86, 56, 96}; \nSystem.out.println(\"Student 1's score: \" + exam1[0]); \n\nEach index in exam1 corresponds to a different student in the class, allowing you as the teacher to access student scores. Even this process can become tedious if the amount of data begins to grow consistently. Suppose there were 20 exams in the school year - keeping track of exams 1-20 in 20 different variables can be tedious and can lead to careless mistakes if you aren’t careful.\n\nLuckily, there is a way to store all of this exam information in a single variable. Because arrays store elements of the same type, we can actually store an array of arrays:\n\nint[] exam1 = {90, 87, 86, 56, 96};\nint[] exam2 = {34, 25, 100, 56, 45};\nint[] exam3 = {65, 76, 34, 74, 90};\n\n\/\/An array that stores a list of int[] \nint[][] exams = {exam1, exam2, exam3}; \n\nArrays that store a list of arrays is referred to as a 2D array.\n\nAs noted above, 2D arrays can be declared by including an additional [] at the end of the declaration:\n\nint[][] exams;\n\nNotice that the type of the array still needs to be declared. Arrays can only store values of the same type, so a 2D array can only store arrays of the same type. This 2D array can only store integer arrays.\n\nTo initialize a 2D array, an additional [] also needs to be used to indicate the length of each array in the 2D array:\n\nint[][] exams = new int[3][3];\n\nThis indicates that a new 2D array of three integer arrays will be created that each store three integer values. This can be visualized as such:\n\nexams:\n\nint[]\t0\t0\t0\nint[]\t0\t0\t0\nint[]\t0\t0\t0\n2D arrays can also be initialized using array values, as demonstrated above:\n\nint[] exam1 = {90, 87, 86, 56, 96};\nint[] exam2 = {34, 25, 100, 56, 45};\nint[] exam3 = {65, 76, 34, 74, 90};\n\n\/\/An array that stores a list of int[] \nint[][] exams = {exam1, exam2, exam3};\n\nArrays that store arrays are referred to as 2D arrays because the way they store elements is akin to a two-dimensional shape. As discussed in unit 6, arrays can access elements in an array by using the [] notation:\n\nint[] exam1 = {90, 87, 86, 56, 96};\nSystem.out.println(\"Student 1's score: \" + exam1[0]);  \/\/prints out 90\n\nIn a 2D array, accessing an index will return an array:\n\nint[] exam1 = {90, 87, 86, 56, 96};\nint[] exam2 = {34, 25, 100, 56, 45};\nint[] exam3 = {65, 76, 34, 74, 90};\n\n\/\/An array that stores a list of int[] \nint[][] exams = {exam1, exam2, exam3};\nSystem.out.println(exams[0]); \/\/ will print a reference address for exam1\n\nThat array can then be indexed to return a particular element:\n\nint[] exam1 = {90, 87, 86, 56, 96};\nint[] exam2 = {34, 25, 100, 56, 45};\nint[] exam3 = {65, 76, 34, 74, 90};\n\n\/\/An array that stores a list of int[] \nint[][] exams = {exam1, exam2, exam3};\n\nSystem.out.println(exams[0][0]); \/\/will print 90\n\nTo access a single element in a 2D array, the specific list that the element is located in needs to be accessed, then the element itself needs to be accessed from that array:\n\nint score = exams[2][3];\nSystem.out.println(score);  \/\/ will print 74\n\nIndex Value\tArray\t0\t1\t2\t3\t4\n0\texam1\t90\t87\t86\t56\t96\n1\texam2\t34\t25\t100\t56\t45\n2\texam3\t65\t76\t34\t74\t90\nAs evident in the visualization, each list in the 2D array can be thought of as a row in the 2D array, and each element in a list can be thought of as a column. Thus, the general format for accessing an element in a 2D array is exams[row][column].\n\nElements in a 2D array can also be modified using the [row][column] notation. The second element in exam1, can be changed to 41 by writing:\n\nexams[0][1] = 41;\n\nNow, the 2D array has an updated value at index 1 of array exam1:\n\nIndex Value\tArray\t0\t1\t2\t3\t4\n0\texam1\t90\t41\t86\t56\t96\n1\texam2\t34\t25\t100\t56\t45\n2\texam3\t65\t76\t34\t74\t90\n\n###\n\n","completion":" Question: double[][] table = new double[3][4]\n\nWhat is the value of table[0].length?\nCorrect: 4\nIncorrect: 0\nIncorrect: 3\nIncorrect: 12END"}
{"prompt":"As discussed in the previous lesson, individual elements in a 2D array can be accessed using [row][column] indexing:\n\nString[][] cities = {{\"New York City\",\"Albany\", \"Ithaca\"},\n{\"Los Angeles\", \"San Francisco\", \"San Jose\"},\n{\"Houston\", \"Dallas\", \"San Antonio\"}}; \n\nSystem.out.println(cities[1][1]);  \/\/ prints San Francisco\n\nThe process of accessing an individual element can be used during a 2D array traversal, which can be used to return all elements in a 2D array.\n\nTraversing a 1D array required the use of a for loop to iterate through each element in the array:\n\nint[] nums = {1,2,3,4,5};\nfor(int index = 0; index < nums.length; index++)\n{\n   System.out.println(nums[index]);\n}\n\nFor a 2D array, this initial traversal is used to access each array in the 2D array, and a nested for loop is needed to access each element within the selected array:\n\nint[][] nums = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}};\nfor(int row = 0; row < nums.length; row++)\n{\n   for(int col = 0; col < nums[row].length; col++)\n   {\n      System.out.println(nums[row][col]);\n   }\n}\n\nThe outer for loop accesses each list in the 2D array nums, while the inner for loop accesses each value within the list. During the first iteration of the outer for loop, the value of row is 0. When the inner for loop iterates, the value of col will increase each time. The values nums[0][0], nums[0][1], nums[0][2], nums[0][3], nums[0][4] will all be printed to the console, and then the value of row will increase to 1. This process will continue until all values in the 2D array have been printed.\n\nNotice that the inner for loop uses the length of the individual list that is being accessed. This ensures that each element in the array will be iterated over.\n\nThis form of iteration is referred to as row-major order. Row-major order is the practice of iterating over each row in an array. In the example above, each list is searched from beginning to end before the next list is searched:\n\n2D arrays can also be searched in column-major order, where a single column in a 2D array is searched before the next column is iterated over:\n\nColumn major order requires a slight alteration to the row-major traversal algorithm:\n\n\/\/column-major order\nint[][] nums = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}};\nfor(int col = 0; col < nums[0].length; row++)\n{\n   for(int row = 0; row < nums.length; row++)\n   {\n      System.out.println(nums[row][col]);\n  }\n}\n\nFor column-major order, the inner for loop iterates through all row values, while the outer for loop iterates through each column. During the first iteration of the outer for loop, the value of col is 0. When the inner loop iterates, the value of row increases by one until the entire 2D array has been searched. The values num[0][0], nums[1][0], nums[2][0] will be printed to the console before the value of col increases to 1.\n\nWhile column-row major can be useful when iterating through 2D arrays, Java is more efficient at iterating over row-major order iterations. For smaller 2D arrays, this difference is inconsequential, but for larger 2D arrays, column-major order iteration may take a substantial amount of time compared to row-major iteration.\n\n2D arrays can also be iterated over using an enhanced for loop:\n\n\/\/enhanced for loop\nint[][] nums = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}};\nfor(int[] list: nums)\n{\n   for(int num: list)\n   {\n      System.out.println(num);\n   }\n}\n\nEnhanced for loops with 2D arrays still require the use of nested loops. In the outer for loop, the enhanced for loop is accessing each list in the 2D array. Notice that the data type int[] is included in the for loop call, indicating that the variable list in each iteration will be an array of integers. The inner for loop then iterates over each item in the list, and prints out the integer which has been stored in the variable num. The type of the variable in the inner for loop should match the same type of the array.\n\nBecause enhanced for loops iterate through each array in a 2D array, enhanced for loops always use row-major order to iterate through a 2D array.\n\nJust as arrays used linear search to find elements, 2D arrays can also use linear search to find values. Here is the general algorithm for searching a 2D array:\n\npublic String search(int[][] array2D, int key)\n{\n   for(int rowIndex = 0; rowIndex < array2D.length; rowIndex++)\n   {\n      for(int colIndex = 0; colIndex < array2D[rowIndex].length; colIndex++)\n      {\n         if(array2D[rowIndex][colIndex] == key) \n         {\n            return key + \" is located at: \" + rowIndex + \",\" + colIndex;\n         }\n      }\n   }\n   return key + \"is not in this 2D array.\";\n}\n\nIn the case of 2D arrays, each row needs to be searched individually. The outer loop simply accesses each individual row of the 2D array while the inner loop is applying search to the array. If the item is not found in any of the arrays, then the return value indicating that the key cannot be found should be placed outside of both for loops. This is to ensure that this only returns if none of the arrays in the 2D array contain that particular value.\n\n2D arrays have a series of standard algorithms that can be used to traverse their values:\n\nMathematical Analysis\n- Determine a minimum or maximum value\n- Compute a sum, average, or mode\n\nAnalyzing Element Properties\n- Determine if at least one element has a particular property\n- Determine if all elements have a particular property\n- Access all consecutive pairs of elements\n- Determine the presence or absence of duplicate elements\n- Determine the number of elements meeting specific criteria\n\nReordering Elements\n- Shift or rotate elements left or right\n- Reverse the order of the elements\n\nEach of these subsets uses a distinct algorithm to analyze arrays:\n\nMathematical Analysis\nMathematical analysis is done by initializing a value, like sum before the nested for loops, and then performing calculations on the array values within the inner for loop so that all values in the 2D array are added to the final calculation. The results can be reported after the nested loop is finished executing:\n\nint[][] scores = {{2,3,4,5,6},{7,6,5,4,3}}\n\n\/\/Initialize value here\nfor(int[] row : scores)\n{\n   for (int i = 0; i < row.length; i++){\n   \/\/Perform calculation here\n\n   }\n}\n\n\/\/Report results here\n\nAnalyzing Element Properties\nTo determine if elements have a particular property, initialize a tracker value before the nested for loop traversal, and then conditionally check for that tracker while traversing the array:\n\nint[][] scores = {{2,3,4,5,6},{7,6,5,4,3}}\n\n\/\/Initialize tracker variable\nfor(int[] row : scores)\n{\n   for (int i = 0; i < row.length; i++){\n      \/\/Conditionally check properties\n      if(condition){ ... }\n   }\n}\n\n\/\/Report results here\n\nReordering Elements\n\nTo make alterations to the list, such as reverse the order or shifting elements, the general format requires that a new 2D is created that will then hold the values in the order that they should be rearranged. Each iteration through the initial array will add a value from the initial array to the altered array:\n\nint[][] scores = {{2,3,4,5,6},{7,6,5,4,3}}\nint[][] alteredScores;\nfor(int row = 0; row < scores.length; row++)\n{\n   for (int col = 0; col < scores[row].length; col++){\n      \/\/add values from grade to alteredArray\n\n   }\n}\n\n\/\/Report results here\n\n###\n\n","completion":" Question: A 2D double array is declared and initialized to track the terrain of a city park. Each value in the 2D array represents the height of a particular latitude and longitude above sea level. Longitude is represented by the columns in the 2D array and latitude is represented by each row in the 2D array.\n\nThe creator of this 2D array would like to look at the height of the city park along the latitude 100.0 - which traversal method would make the most sense in order to do so?\nCorrect: Row-Major Order\nIncorrect: Column-Major Order\nIncorrect: Enhanced for loop\nIncorrect: This isn’t possible given the 2D array.END"}
{"prompt":"Large classes often rely on several different instance variables in order to successfully create comprehensive programming solutions. For example, a Person class might have several instance variables, like name or birthday. These instance variables are said to have a “Has-A” relationship to their class objects. A Person has a name, and has a birthday. Values that use a “has a” relationship represent instance variables in our projects.\n\nAnother type of relationship in object-oriented programming is the “Is-A” relationship. “Is-A” is used when one thing is a more specific version of another thing. As an example, think about the relationship of a Student to a Person. A Student does not have a Person, but rather, a Student is a Person. In this example, a Student is a more specific example of a Person. While it’s possible to say that every Student is a Person, it’s not possible to say that every Person is a Student. The Person class is a more general class and the Student class is a more specific class. Some other examples of is-a relationships are:\n\n- A Dog is an Animal.\n- A Square is a Rectangle.\n- San Francisco is a City.\n- Computer science is a Class.\n\nSince many classes, like Person and Student, have an is-a relationship, they share some common attributes. Just as a Person has a name, and a birthday, a Student has the same attributes. Since these two classes share many of the same attributes, there should be a way to consolidate these two classes so as to avoid writing the same attributes and instance variables in each class.\n\nIn Java, the is-a relationship is expressed in the form of superclasses and subclasses. A class hierarchy can be developed by putting common attributes and behaviors of related classes into a single class called a superclass. In the current example, the attributes name and birthday belong to both Person and Student, so they should be written in a superclass.\n\nSubclasses inherit the public attributes and behaviors from the superclass. As a result, a subclass object can use any public attribute or behavior without having to repeat these in its code. A superclass object does not have access to the attributes and behaviors of the subclass class. In this case, a Student object will have access to all the attributes and behaviors of both the Student class, like GPA and grade level, and the Person class, but the Person object will only have access to the attributes and behaviors of the Person class.\n\nTo create a superclass\/subclass relationship, the keyword extends is added to a class header followed by the name of the superclass:\n\npublic class Student extends Person\n{\n   \/\/Student class implementation\n\n}\n\nThis creates the subclass. Student, in this case, is a subclass of Person, which is the superclass. Subclasses are only capable of extending a single superclass. While a class can only extend one class, it can extend a class that has already been extended:\n\npublic class Person {\n   \/\/ Person class implementation\n}\n\npublic class Student extends Person {\n   \/\/ Student class implementation\n}\n\npublic class HighSchoolStudent extends Student {\n   \/\/ HighSchoolStudent class implementation\n}\n\nIn this case, a HighSchoolStudent object will have access to all the attributes and behaviors of the HighSchoolStudent class, the Student class, and the Person class.\n\nAs programs become more complicated, oftentimes creating a hierarchy of classes allows for the reuse of common attributes and behaviors. Figuring out which variables and methods are shared across class implementations is the first step to developing a successful hierarchical structure.\n\n###\n\n","completion":" Question: Which of the following best describes a Subclass \/ Superclass relationship?\nCorrect: Banana \/ Fruit\nIncorrect: Banana \/ Color\nIncorrect: Banana \/ Peel\nIncorrect: Banana \/ CountEND"}
{"prompt":"Classes can form a hierarchy where each of the subclasses has access to all of the public methods of a parent, or superclass. But what if a subclass doesn’t want to inherit a method from the superclass? For example, what if the Student class wants to use a different toString() method than the Person class to include additional pieces of information about the object?\n\nPerson Class:\n\npublic String toString()\n{\n   return name + \" was born \" + birthday;\n}\n\nStudent Class:\n\npublic String toString() {\n   return super.getName() + \" is in grade \" + grade; \n} \n\nClasses like Student are able to use their own toString method through a process called method overriding. In a method override, a subclass can redefine a method instead of inheriting that method from the superclass.\n\nA method override occurs when a public method in a subclass has the same method signature as a public method in the superclass. When something has the same method signature, it means that the methods have the same name and input parameters. In the example above, both toString() methods in Person and Student have the same name and input parameters - the Student toString(), when called in the Student class, will override the toString() method from Person.\n\nTo denote an override in Java, the best practice is to use the @Override keyword in the line above the method signature. It is important to note that a method overrides a superclass when it has the same method signature, not because it includes the @Override keyword.\n\nStudent Class:\n\n@Override\npublic String toString() {\n    return super.getName() + \" is in grade \" + grade;\n}\n\nIncluding @Override is not required, but is considered best practice for two main reasons. First, using the @Override signals to Java that you are trying to override a superclass method. The Java compiler will check to make sure it actually does override a method correctly and will throw an error if you do not override correctly. Second, it helps to make your code more readable by telling other programmers that a particular method is being used over a similar method in the superclass.\n\nWhen designing class hierarchies, methods and variables that will be used by all the classes are generally put in the superclass. Subclasses are built to add additional methods and instance variables for more specific classes.\n\nAs an example, consider the Person and Student classes again. The Person superclass will have name and birthday as the instance variables and may have a toString() and age() method.\n\nThe Student class would still need the name and birthday, but will also need a grade and GPA as instance variables. These are specific only to a student, so they are added to the subclass, not the superclass. Likewise, it may include a change grade method and a modified toString() method with an override.\n\nWhen calling methods for an object, Java starts by looking in that object class for that method signature. If it finds it there, it will use that particular method, otherwise, it will go to the superclass and look for the method. This will continue until it reaches the top of the class hierarchy. Any method that is called must be defined someplace in this class hierarchy, otherwise, Java will throw an error.\n\n###\n\n","completion":" Question: Why might we want to override a superclass method? Select the best option.\nCorrect: We override a method because a subclass needs to define a behavior in a different way than the superclass.\nIncorrect: We override methods so that we can see how a method is working within the class.\nIncorrect: We override methods because superclasses cannot correctly define most subclass behaviors.\nIncorrect: We override methods to make Java run more efficiently.END"}
{"prompt":"When a subclass object is created, a superclass object is created in the process. This is evident in the initial call to super that is made in the constructor:\n\npublic class Student extends Person { \n   private int grade;\n   private double gpa;\n\n   public Student (String name, String birthday, int grade, double gpa) {\n      super(name,birthday);\n      this.grade = grade; this.gpa = gpa;\n   }\n\n   public int getGrade(){\n      return grade;\n   }\n} \n\nIn addition to creating the superclass object, the super keyword can be used to reference the super object in other methods within the subclass.\n\nThe keyword super is similar to the keyword this. this refers to the current object, while super refers to the superclass object. Just as it’s possible to reference methods and pass parameters using the this keyword, methods can be referenced and passed parameters using the super keyword.\n\nsuper refers to the superclass object and can call methods using:\n\nsuper.methodName(parameters)\n\nHere is a sample superclass Animal:\n\npublic class Animal {\n\n   private String type;\n   private String sound;\n\n   public Animal (String type, String sound) {\n      this.type = type;\n      this.sound = sound;\n   }\n\n   public void speak(int number){\n      for (int i = 0; i < number; i++)\n         System.out.println(sound);\n      }\n   }\n\nThe Dog class extends the Animal class, inheriting its methods and instance variables:\n\npublic class Dog extends Animal {\n\n   public Dog () {\n      super(\"Dog\", \"Bark\");\n   }\n\n   public void bark(int number){\n      super.speak(number);\n   }\n\n}\n\nIn this example, the Dog subclass constructor uses the super keyword to call the Animal constructor. The Dog class bark() method also calls the superclass speak() method by passing it a parameter that will then get used in the speak() method.\n\n###\n\n","completion":" Question: Given the following code, what is the correct way for the subclass to call the speak method in the Person class?\n\npublic class Person {\n\n    public void speak(String sound) {\n        System.out.println(sound);\n    }\n}\n\npublic class EnglishSpeaker extends Person {\n\n    public void greet() {\n        \/* Missing code *\/\n    }\n}\nCorrect: super.speak(\"Hello\");\nIncorrect: super(\"Hello\");\nIncorrect: speak(\"Hello\");\nIncorrect: Person.speak(\"Hello\");END"}
{"prompt":"Up to this point, every object declaration and initialization that you’ve written has created objects where the Reference type matched the Object type.\n\nWhile this is often the way that objects should be written, the object type and reference type can be different. The Reference type of an object variable can be declared with a superclass, then instantiated with a subclass:\n\nPerson student1 = new Student();\n\nDoing so facilitates polymorphism. Polymorphism is the capability of a method to do different things depending on the object it is acting upon. In Java and other object-oriented programming languages, the concept of polymorphism means that an object can take on different forms depending on its implementation. Java can call the correct method even when an object is disguised as a more generic reference type.\n\nIn standard Java Documentation, superclasses are denoted with the letter T, while subclasses are denoted with the letter S. If class S is a class T, then S is a subclass to the T superclass.\n\nThis terminology will be used throughout this chapter to refer to the relationship between superclasses and subclasses.\n\nAs mentioned earlier, the superclass can be used as the reference type for an object instantiated with a subclass.\n\nPerson student1 = new Student();\n\nMore broadly, this means that when the Superclass is used as a reference type, then an object can be created as either the Superclass T, or any Subclass S. For example, the Person reference type can be used when instantiating an object as a Person, Student, or Worker, so long as the instantiated type is a subclass of the Person class:\n\nPerson student1 = new Person();\nPerson student1 = new Worker();\nPerson student1 = new Student();\n\nThe ability to declare an object with the superclass Reference type enables the use of polymorphism, where methods are able to change their behavior. This is most useful and evident in the following ways:\n\nIt enables the use of type T as a formal parameter in a method, which can then pass any object of type T or S.\nIt enables the creation of arrays and ArrayList of type T that stores any type T or S objects.\nFor the former, consider the following method:\n\npublic static void greeting(Person person)\n{\n    System.out.println(\"Hello \" + person.getName());\n}\n\nThe formal parameter in this method specifies that the object type that is being passed is of type Person. A Student object can still be passed to this method if it is declared with the Person reference type:\n\nPerson karel = new Student(\"Karel\");\ngreeting(karel); \/\/prints 'Hello Karel'\n\nThis same concept applies to storing values in an array or ArrayList. If an array is declared with type Person, then Student objects are still able to be added when declared as type Person:\n\nPerson karel = new Student(\"Karel\");\nPerson jeremy = new Person(\"Jeremy\");\nPerson[] people = {karel, jeremy};\n\nThis process illustrates how polymorphism can be used to broaden the use of methods and data structures to include objects of multiple classes within a hierarchy.\n\n###\n\n","completion":" Question: Given the following class structure:\n\npublic class Vehicle {\n   \/* implementation not shown *\/\n}\n\npublic class Truck extends Vehicle {\n   \/* implementation not shown *\/\n}\n\nWhich of the following objects can be created?\n\nVehicle obj1 = new Vehicle();\nVehicle obj2 = new Truck();\nTruck obj3 = new Truck();\nTruck obj4 = new Vehicle();\nCorrect: obj1, obj2, obj3\nIncorrect: obj3 & obj1\nIncorrect: obj1, obj3, obj4\nIncorrect: All of these are validEND"}
{"prompt":"As discussed in the previous chapter, polymorphism is the capability of a method to do different things depending on the object it is acting upon. This process allows for the declaration of objects using a superclass that can then be instantiated as a specific subclass. This enables Arrays and methods to utilize polymorphism.\n\nPolymorphism is also capable of calling the correct method for an object even when that object is disguised as a more generic reference type. This process is evident when looking at how object methods are called in compile time and run time.\n\nAt the time a program gets compiled, methods in or inherited by the declared type determine the correctness of a non-static method call. During the process of compiling a program, Java checks the declared type of an object to determine if all of the called methods exist:\n\nPerson person1 = new Student();\nperson1.getName();\n\nThe Java compiler will only check the Person class to see if the getName method exists. It will only successfully compile if it exists in the Person class, regardless of whether or not it exists in the Student class. This means that objects declared as a superclass type but instantiated as a subclass type can only call methods that exist in both classes.\n\nAt the time a program runs, the methods in the actual object type get executed. If the method doesn’t exist there, Java looks to the superclass for the method. From the previous example, at run time, Java will look for the getName method in the Student class first. If it doesn’t exist, it will look in the parent class.\n\n###\n\n","completion":" Question: In order for a program to compile, any method that an object uses …\nCorrect: Must be defined in the class where the object is declared.\nIncorrect: Must be defined in the class where the object is instantiated.\nIncorrect: Must be defined in both the class where the object is declared and where it is instantiated.\nIncorrect: Doesn’t have to be defined anywhere. Java only checks for the method at run time.END"}
{"prompt":"Classes can form a hierarchy where each of the subclasses has access to all of the public methods of a parent. At the top of the hierarchy is the Object class, which is a part of the built-in java.lang package. All other classes can use the Object class through inheritance.\n\nThe Object class contains several useful methods that are used and inherited by its subclasses. Two such methods are equals() and toString().\n\nThe equals method compares two objects and is often overridden by a subclass. Using the Object level version of the equals() method, Java returns true only if the two objects are represented by the same object in memory. This is often not very helpful, as == also returns the same result, which is why this method is often overridden by subclasses.\n\nOne example where equals() is overridden is the String class. The String class equals() method compares each character of the string to determine if they are the same, not just if they are the same objects.\n\nThe toString() method is another commonly used and commonly overridden method from the Object class. When an object name is called with no method, the toString() is returned as a String representation of the object. The generic toString() for an object is to return the object type followed by an @ symbol and then the unsigned hexadecimal representation of the object. This has limited value, which is why it is often overridden.\n\nObject obj1 = new Object();\nSystem.out.println(obj1);   \/\/prints java.lang.Object@27c170f0\n\nThere are many examples where the toString() method is overridden. For example, in the Person class you’ve created earlier in this chapter, the toString() method is overridden to return the name of the person:\n\nPerson person1 = new Person(\"Steve\");\nSystem.out.println(person1);  \/\/prints Steve\n\n###\n\n","completion":" Question: Which of the following methods would you find in the Object class?\nCorrect: toString\nIncorrect: comparesTo\nIncorrect: delete\nIncorrect: overrideEND"}
{"prompt":"As discussed in previous chapters, iteration is a useful programming tool that makes programs more efficient and readable. So far, you’ve used for loops and while loops to create iterative programs:\n\npublic int sum(int num)\n{\n    int sum = 0; \n    for(int i = 0; i <= num; i++)\n    {\n        sum += i;\n    }\n    return sum;\n}\n\nIn addition to these iterative control structures, iteration can be implemented in programs using a process called recursion.\n\nRecursion is an iterative approach where a method calls itself. Recursion is used to break a complex problem down into a slightly simpler version. This is done until the problem is so small that it is easily solvable.\n\nThe example summing algorithm written above can actually be written using a recursive algorithm. If the call sum(10) were made to the method, each value from 0 - 10 would be summed together:\n\nsum(10) = 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0\n\nWhen looking at the summation this way, a pattern begins to emerge. Within the call to sum(10) is actually a call to sum(9), as sum(9) will sum all values from 0 - 9.\n\nThus, we can rewrite our original summation as:\n\nsum(10) = 10 + sum(9)\n\nSince sum(9) is inherent in the sum of all values 0 - 10, sum(8) must be a part of the solution for sum(9). This pattern continues until the smallest value 0 is reached:\n\nsum(9) = 9 + sum(8)\nsum(8) = 8 + sum(7)\n…\nsum(1) = 1 + sum(0)\nsum(0) = 0\n\nEach time through, the problem gets a little simpler. When the process gets to the point where it can’t be simplified anymore, the final result is considered the base case. In this example, the base case is sum(0) = 0. If there isn’t a base case, then the recursion would continue on forever.\n\nAll of the other numbers can be represented generically with a formula such as the one below:\n\nsum(n) = n + sum(n - 1)\n\nThe generic formula is considered the recursive case. The recursive case is the step that the algorithm takes to make the problem one step smaller so that it moves towards the base case.\n\nIf the recursive case doesn’t simplify or make the program smaller, then the recursion would go on forever as well. The base case and the recursive case need to be designed in tandem so that they eventually lead to a method that terminates.\n\nThese two cases can be used to create a full recursive version of the sum method:\n\npublic static int sum(int n)\n{\n    if (n == 0)\n    {\n        return 0;\n    }\n\n    return n + sum(n - 1);\n}\n\nWhen the call sum(3) is made to this method, the first call to the method will return the value 3 + sum(2). This will call the sum method again, this time with the actual parameter of 2. The value returned by this call will be 2 + sum(1). This process continues until sum(0), when the value 0 will be returned to the program. When this call happens, all previous return values are returned to each call of the sum method, and the final result is returned:\n\nsum(3)\tsum(2)\tsum(1)\tsum(0)\nValue of num\t3\t2\t1\t0\nResult of num == 0\tFalse\tFalse\tFalse\tTrue\nreturn value\t3 + sum(2)\t2 + sum(1)\t1 + sum(0)\t0\n\nAs illustrated in the table above, each recursive call has its own set of local variables, including the formal parameters. These parameter values capture the progress of a recursive process, much like loop control variable values capture the progress of a loop. Just like the other iterative structures, recursion can be used to traverse Strings, arrays and ArrayLists.\n\n###\n\n","completion":" Question: Why do we use recursion?\nCorrect: We use it to break complex problems down into simpler problems that become easier to solve.\nIncorrect: Recursion is always a more efficient way to use iteration.\nIncorrect: Both of these\nIncorrect: Neither of theseEND"}
{"prompt":"As discussed in previous chapters, searching and sorting data is an integral part of data storage and management in Java. Searching algorithms, such as Insertion and Selection sort, rely on the use of iterative control structures, like for loops and while loops, to traverse data structures and find a desired value:\n\n\/\/Selection sort relies on iteration to traverse data structures\nfor(int index = 0; index < array.length - 1; index++)\n{\n    int minIndex = index;\n    for(int i = index; i < array.length; i ++)\n    {\n        if(array[i] < array[minIndex])\n        {\n            minIndex = i;\n        }\n    }\n    int tempValue = array[index]; array[index] = array[minIndex];\n    array[minIndex] = tempValue;\n}\n\nJust as for loops and while loops can be used for traversals, recursion too can be applied to searching algorithms.\n\nOne search method that relies on the use of recursion is binary search.\n\nA binary search finds the middle of an array and tests that point. If the target is greater than the midpoint value, then the search eliminates the lower half. Likewise, if the target is less than the midpoint value, the top half can be eliminated. This process is then repeated, finding a new midpoint each time. It’s important to note that the array must be sorted for a binary search to work properly.\n\nNotice how each iteration eliminates half of the values. While this process is slightly more efficient for smaller arrays, it is significantly more efficient for larger arrays. A linear search of 10,000 records could have a worst case scenario of 10,000 comparisons. With binary search, the worst case is only 15 comparisons to find the value.\n\nWhen comparing Linear Search to Binary Search, there are a few significant differences. First, binary searches are much more efficient than linear searches. Second, linear searches will work on any array, but binary searches only work on a sorted array. Finally, the algorithm for binary searches is a little more complex than our linear search.\n\nLinear\tBinary\nNot efficient\tVery efficient\nWorks on sorted or unsorted arrays.\tOnly works on sorted arrays.\nEasy to code\tSlightly more complex to code\n\nHere is a non-recursive implementation of binary search:\n\npublic int binaryLoop(int[] array, int target) {\n    int begin = 0;\n    int end = array.length - 1;\n\n    while (begin <= end) {\n        int mid = (begin + end) \/ 2;\n        if (target < array[mid]) {\n            end = mid - 1;\n        }\n        else if (target > array[mid]) {\n            begin = mid + 1;\n        }\n        else if (target == array[mid]) { \n            return mid;\n        }\n    }\n    return -1; \/\/ not found\n}\n\nNotice in the loop how the midpoint is calculated, then tested before updating the beginning and ending points each time based on the results. Initially, the array is passed to the method, where the values begin and end are set to the first index and the last index in the array. The while loop then checks that begin is less than end, and calculates the midpoint of the array. The method then checks if the target value is greater than, less than, or equal to the midpoint. If the target is greater than the midpoint, then the method removes the begin to midpoint values from the search. As noted earlier, this only works if the values are sorted before being searched. The method then returns to the beginning of the while loop, and finds a new midpoint between the new begin value and end. It does so until the target has been found, or the array has been fully halved and searched.\n\nThis method can also be written using recursion. Since recursion attempts to create a simpler version of a problem each time a recursive method is called, binary search lends itself well to its use, as the array is reduced in size each time, all the way to a single value at times. Here is the implementation of binary search with recursion:\n\npublic int binaryRec(int[] array, int target, int begin, int end) {\n    if (begin <= end)\n    {\n        int mid = (begin + end) \/ 2;\n\n        if (target == array[mid]) { \n            return mid; \/\/ Base Case\n        }\n\n        if (target < array[mid]) {\n            return binaryRec(array, target, begin, mid - 1);\n        }\n\n        if (target > array[mid]) {\n            return binaryRec(array, target, mid + 1, end);\n        }\n    }\n    return -1;  \/\/Alternate Base Case\n}\n\nThe biggest change at the start of this code is that the beginning and ending values are being passed into the method. From there, the midpoint is calculated the same way as before.\n\nThe base case is where the value is found. In the first iteration, the base case is skipped, and the recursive case is called. The recursive call passes the original array, the target value, but then updates the starting point as it makes the call. Once the value is found, the index value of the target is then returned back through each of the recursive return statements until it eventually gets back to the original call statement.\n\n###\n\n","completion":" Question: Using the binary search algorithm, what is the maximum number of iterations needed to find an element in an array containing 128 elements?\nCorrect: 7\nIncorrect: 6\nIncorrect: 64\nIncorrect: 128END"}
{"prompt":"Just as recursion can be used to search data structures, it can be used to sort them. One of the most common recursive sorting algorithms is called merge sort.\n\nA merge sort is a sort where the list is divided then merged back together in the correct order. This is done recursively as the list is repeatedly divided in half until it is only one item long. Then each of these lists gets combined back together in the correct order.\n\nMerge sort starts at the top with the entire list, then it breaks this list into two halves.\n\nIt continues this process on both of the halves by breaking it down further. The halves continue to break down until they get to individual items.\n\nOnce it gets broken down, it then starts putting it back together in the correct order.\n\nThis occurs on each halve in the order that they appear in the array.\n\nAs it runs through, note how it only works on a portion of the items in the list. You can see how it works on the first half of the data, segment by segment. After completing the first half, the process is repeated on the second half before finally joining the two pieces together. As it joins the two halves, it moves each value from one half or the other into its final sorted place.\n\nThe merge sort is generally more efficient than the insertion sort or selection sort, and its performance is independent of the initial state of our array. In other words, a randomly sorted array and a nearly sorted array perform at the same speed.\n\nThe downside to the merge sort is that the implementation uses a fairly complex recursive algorithm. The implementation usually involves two methods - the merge sort method to break down the array and a helper method to reassemble it in the correct order.\n\nHere is an implementation of mergeSort:\n\npublic static void mergeSort(int[] current, int length) {\n    if (length < 2) {\n      return;\n    }\n    int mid = length \/ 2;\n    int[] left = new int[mid];\n    int[] right = new int[length - mid];\n\n    for (int i = 0; i < mid; i++) {\n      left[i] = current[i];\n    }\n    for (int i = mid; i < length; i++) {\n      right[i - mid] = current[i];\n    }\n    mergeSort(left, mid);\n    mergeSort(right, length - mid);\n\n    merge(current, left, right);\n}\n\nThe main purpose of this method is to break the array into smaller pieces, then when it can’t go any further, this method calls the merge method to start combining arrays. Using recursion, the base case is when there is only one element in the array. If the base case is not called, the middle part of this method creates two arrays, a left and a right, and puts half the current array into each of these new arrays. A recursive call is made with each half of the array.\n\nWhen the base case is reached with an array length of 1, the recursive calls return. The method is then ready to combine the left and right array in the correct order. This is accomplished using the merge method:\n\npublic static void merge(\n  int[] current, int[] left, int[] right) {\n\n  int leftSize = left.length;\n  int rightSize = right.length;\n\n  int i = 0, j = 0, k = 0;\n  while (i < leftSize && j < rightSize) {\n    if (left[i] <= right[j]) {\n      current[k++] = left[i++];\n    }\n    else {\n      current[k++] = right[j++];\n    }\n  }\n  while (i < leftSize) {\n    current[k++] = left[i++];\n  }\n  while (j < rightSize) {\n    current[k++] = right[j++];\n  }\n}\n\nThe merge method takes the current array as well as the left and right arrays as input. It will then go through the two arrays to merge them. Notice that it doesn’t return anything. This is because the actual array object is passed to the method and updated. Changes can then be read in other methods.\n\nThe merge method walks through the next element in each array, determining if the left or right array has the smaller value, then inserting into the current array. Once it’s finished going through one of the arrays, there may still be elements remaining in either the left or right array. This last step adds any remaining elements to the end of the current array.\n\n###\n\n","completion":" Question: Which of the following is NOT true about a merge sort?\nCorrect: The merge sort code is not as complex as other sort codes\nIncorrect: Merge sorts work well on all different types of lists\nIncorrect: Merge sorts use recursion to make the process easier\nIncorrect: A merge sort works by dividing a list into parts, then merging it back together in the correct order.END"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Which of the following statements about recursion are true? \nI Every recursive algorithm can be written iteratively. \nII Tail recursion is always used in “divide-and-conquer” algorithms. \nIII In a recursive definition, a process is defined in terms of a simpler case of itself. \nCorrect: I and III only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: II and III only\n\nEND"}
{"prompt":"A common technique in designing recursive algorithms is to have a public nonrecursive driver method that calls a private recursive helper method to carry out the task. The main reasons for doing this are\n• To hide the implementation details of the recursion from the user.\n• To enhance the efficiency of the program.\n\nExample 1\nConsider the simple example of recursively finding the sum of the first n positive integers.\n\/** @param n a positive integer\n* @return 1 + 2 + 3 + ... + n\n*\/\npublic static int sum(int n)\n{\n    if (n == 1)\n        return 1;\n    else\n        return n + sum(n - 1);\n}\n\nNotice that you get infinite recursion if n ≤ 0. Suppose you want to include a test for n > 0 before you execute the algorithm. Placing this test in the recursive method is inefficient because if n is initially positive, it will remain positive in subsequent recursive calls. You can avoid this problem by using a driver method called getSum, which does the test on n just once. The recursive method sum becomes a private helper method.\npublic class FindSum {\n    \/**\n     * Private recursive helper method.\n     *\n     * @param n a positive integer\n     * @return 1 + 2 + 3 + ... + n\n     *\/\n    private static int sum(int n) {\n        if (n == 1)\n            return 1;\n        else\n            return n + sum(n - 1);\n    }\n\n    \/* Driver method *\/\n    public static int getSum(int n) {\n        if (n > 0)\n            return sum(n);\n        else {\n            throw new IllegalArgumentException(\"Error: n must be positive\");\n        }\n    }\n}\n\nNOTE\nThis is a trivial method used to illustrate a private recursive helper method. In practice, you would never use recursion to find a simple sum!\n\n\n###\n\n","completion":" Question: Which of the following, when used as the \/* body *\/ of method sum, will enable that method to compute 1 + 2 + ... + n correctly for any n > 0? \n\n\/** @param n a positive integer \n* @return 1 + 2 + ... + n \n*\/ \npublic int sum(int n) \n{ \n    \/* body *\/ \n} \n\nI return n + sum(n - 1); \nII if (n == 1) \n    return 1; \nelse \n    return n + sum(n - 1); \nIII if (n == 1) \n    return 1; \nelse \n    return sum(n) + sum(n - 1); \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"A recursive method is a method that calls itself. For example, here is a program that calls a recursive method stackWords.\npublic class WordPlay {\n    public static void stackWords() {\n        String word = IO.readString(); \/\/ read user input\n        if (word.equals(\".\"))\n            System.out.println();\n        else\n            stackWords();\n        System.out.println(word);\n    }\n\n    public static void main(String args[]) {\n        System.out.println(\"Enter list of words, one per line.\");\n        System.out.println(\"Final word should be a period (.)\");\n        stackWords();\n    }\n}\n\nHere is the output if you enter\nhold\nmy\nhand\n.\n\nYou get\n.\nhand\nmy\nhold\n\nThe program reads in a list of words terminated with a period, and prints the list in reverse order, starting with the period. How does this happen?\nEach time the recursive call to stackWords() is made, execution goes back to the start of a new method call. The computer must remember to complete all the pending calls to the method. It does this by stacking the statements that must still be executed as follows: The first time stackWords() is called, the word \"hold\" is read and tested for being a period. No it’s not, so stackWords() is called again. The statement to output \"hold\" (which has not yet been executed) goes on a stack, and execution goes to the start of the method. The word \"my\" is read. No, it’s not a period, so the command to output \"my\" goes on the stack. And so on. The stack looks something like this before the recursive call in which the period is read:\nSystem.out.println(\"hand\");\nSystem.out.println(\"my\");\nSystem.out.println(\"hold\");\n\nImagine that these statements are stacked like plates. In the final stackWords() call, word has the value \".\". Yes, it is a period, so the stackWords() line is skipped, the period is printed on the screen, and the method call terminates. The computer now completes each of the previous method calls in turn by “popping” the statements off the top of the stack. It prints \"hand\", then \"my\", then \"hold\", and execution of method stackWords() is complete.1\n\nNOTE\n1. Each time stackWords() is called, a new local variable word is created.\n2. The first time the method actually terminates, the program returns to complete the most recently invoked previous call. That’s why the words get reversed in this example.\nEvery recursive method has two distinct parts:\n• A base case or termination condition that causes the method to end.\n• A nonbase case whose actions move the algorithm toward the base case and termination.\n\nHere is the framework for a simple recursive method that has no specific return type.\npublic void recursiveMeth( ... )\n{\n    if (base case)\n        < Perform some action >\n    else\n    {\n        < Perform some other action >\n        recursiveMeth( ... ); \/\/recursive method call\n    }\n}\n\nThe base case typically occurs for the simplest case of the problem, such as when an integer has a value of 0 or 1. Other examples of base cases are when some key is found, or an end-of-file is reached. A recursive algorithm can have more than one base case.\nIn the else or nonbase case of the framework shown, the code fragment < Perform some other action > and the method call recursiveMeth can sometimes be interchanged without altering the net effect of the algorithm. Be careful though, because what does change is the order of executing statements. This can sometimes be disastrous. (See the eraseBlob example on p. 299.)\n\nExample 1\npublic void drawLine(int n)\n{\n    if (n == 0)\n        System.out.println(\"That’s all, folks!\");\n    else\n    {\n        for (int i = 1; i <= n; i++)\n            System.out.print(\"*\");\n        System.out.println();\n        drawLine(n - 1);\n    }\n}\n\nThe method call drawLine(3) produces this output:\n***\n**\n*\nThat’s all, folks!\n\nNOTE\n1. A method that has no pending statements following the recursive call is an example of tail recursion. Method drawLine is such a case, but stackWords is not.\n2. The base case in the drawLine example is n == 0. Notice that each subsequent call, drawLine(n - 1), makes progress toward termination of the method. If your method has no base case, or if you never reach the base case, you will create infinite recursion. This is a catastrophic error that will cause your computer eventually to run out of memory and give you heart-stopping messages like java.lang.StackOverflowError\n\nExample 2\n\/\/Illustrates infinite recursion.\npublic void catastrophe(int n)\n{\n    System.out.println(n);\n    catastrophe(n);\n}\n\nTry running the case catastrophe(1) if you have lots of time to waste! A recursive method must have a base case.\n\n\n###\n\n","completion":" Question: Refer to the method stringRecur: \n\npublic void stringRecur(String s) \n{ \n    if (s.length() < 15) \n        System.out.println(s); \n    stringRecur(s + \"*\"); \n} \n\nWhen will method stringRecur terminate without error? \nCorrect: For no string inputs\n\n\nIncorrect: Only when the length of the input string is less than 15\nIncorrect: Only when the length of the input string is greater than or equal to 15\nIncorrect: Only when an empty string is input\nIncorrect: For all string inputsEND"}
{"prompt":"A recursive method is a method that calls itself. For example, here is a program that calls a recursive method stackWords.\npublic class WordPlay {\n    public static void stackWords() {\n        String word = IO.readString(); \/\/ read user input\n        if (word.equals(\".\"))\n            System.out.println();\n        else\n            stackWords();\n        System.out.println(word);\n    }\n\n    public static void main(String args[]) {\n        System.out.println(\"Enter list of words, one per line.\");\n        System.out.println(\"Final word should be a period (.)\");\n        stackWords();\n    }\n}\n\nHere is the output if you enter\nhold\nmy\nhand\n.\n\nYou get\n.\nhand\nmy\nhold\n\nThe program reads in a list of words terminated with a period, and prints the list in reverse order, starting with the period. How does this happen?\nEach time the recursive call to stackWords() is made, execution goes back to the start of a new method call. The computer must remember to complete all the pending calls to the method. It does this by stacking the statements that must still be executed as follows: The first time stackWords() is called, the word \"hold\" is read and tested for being a period. No it’s not, so stackWords() is called again. The statement to output \"hold\" (which has not yet been executed) goes on a stack, and execution goes to the start of the method. The word \"my\" is read. No, it’s not a period, so the command to output \"my\" goes on the stack. And so on. The stack looks something like this before the recursive call in which the period is read:\nSystem.out.println(\"hand\");\nSystem.out.println(\"my\");\nSystem.out.println(\"hold\");\n\nImagine that these statements are stacked like plates. In the final stackWords() call, word has the value \".\". Yes, it is a period, so the stackWords() line is skipped, the period is printed on the screen, and the method call terminates. The computer now completes each of the previous method calls in turn by “popping” the statements off the top of the stack. It prints \"hand\", then \"my\", then \"hold\", and execution of method stackWords() is complete.1\n\nNOTE\n1. Each time stackWords() is called, a new local variable word is created.\n2. The first time the method actually terminates, the program returns to complete the most recently invoked previous call. That’s why the words get reversed in this example.\nEvery recursive method has two distinct parts:\n• A base case or termination condition that causes the method to end.\n• A nonbase case whose actions move the algorithm toward the base case and termination.\n\nHere is the framework for a simple recursive method that has no specific return type.\npublic void recursiveMeth( ... )\n{\n    if (base case)\n        < Perform some action >\n    else\n    {\n        < Perform some other action >\n        recursiveMeth( ... ); \/\/recursive method call\n    }\n}\n\nThe base case typically occurs for the simplest case of the problem, such as when an integer has a value of 0 or 1. Other examples of base cases are when some key is found, or an end-of-file is reached. A recursive algorithm can have more than one base case.\nIn the else or nonbase case of the framework shown, the code fragment < Perform some other action > and the method call recursiveMeth can sometimes be interchanged without altering the net effect of the algorithm. Be careful though, because what does change is the order of executing statements. This can sometimes be disastrous. (See the eraseBlob example on p. 299.)\n\nExample 1\npublic void drawLine(int n)\n{\n    if (n == 0)\n        System.out.println(\"That’s all, folks!\");\n    else\n    {\n        for (int i = 1; i <= n; i++)\n            System.out.print(\"*\");\n        System.out.println();\n        drawLine(n - 1);\n    }\n}\n\nThe method call drawLine(3) produces this output:\n***\n**\n*\nThat’s all, folks!\n\nNOTE\n1. A method that has no pending statements following the recursive call is an example of tail recursion. Method drawLine is such a case, but stackWords is not.\n2. The base case in the drawLine example is n == 0. Notice that each subsequent call, drawLine(n - 1), makes progress toward termination of the method. If your method has no base case, or if you never reach the base case, you will create infinite recursion. This is a catastrophic error that will cause your computer eventually to run out of memory and give you heart-stopping messages like java.lang.StackOverflowError\n\nExample 2\n\/\/Illustrates infinite recursion.\npublic void catastrophe(int n)\n{\n    System.out.println(n);\n    catastrophe(n);\n}\n\nTry running the case catastrophe(1) if you have lots of time to waste! A recursive method must have a base case.\n\n\n###\n\n","completion":" Question: Refer to method strRecur: \n\npublic void strRecur(String s) \n{ \n    if (s.length() < 15) \n    { \n        System.out.println(s); \n        strRecur(s + \"*\"); \n    } \n} \n\nWhen will method strRecur terminate without error? \nCorrect: For all string inputs\nIncorrect: Only when the length of the input string is less than 15\nIncorrect: Only when the length of the input string is greater than or equal to 15\nIncorrect: Only when an empty string is input\nIncorrect: For no string inputs\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Refer to method result:\n\npublic int result(int n) \n{ \n    if (n == 1) \n        return 2; \n    else \n        return 2 * result(n - 1); \n} \n\nWhat value does result(5) return? \nCorrect: 32\nIncorrect: 64\nIncorrect: 16\nIncorrect: 8\nIncorrect: 2\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Refer to method result:\n\npublic int result(int n) \n{ \n    if (n == 1) \n        return 2; \n    else \n        return 2 * result(n - 1); \n} \n\nIf n > 0, how many times will result be called to evaluate result(n) (including the initial call)? \nCorrect: n\nIncorrect: 2\nIncorrect: 2n\nIncorrect: 2n\nIncorrect: n2\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Refer to method mystery: \n\npublic int mystery(int n, int a, int d) \n{ \n    if (n == 1) \n        return a; \n    else \n        return d + mystery(n - 1, a, d); \n} \n\nWhat value is returned by the call mystery(3, 2, 6)? \nCorrect: 14\nIncorrect: 20\nIncorrect: 10\nIncorrect: 8\nIncorrect: 2\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Refer to method f: \n\npublic int f(int k, int n) \n{ \n    if (n == k) \n        return k; \n    else \n        if (n > k) \n            return f(k, n - k); \n    else \n        return f(k - n, n); \n} \n\nWhat value is returned by the call f(6, 8)? \nCorrect: 2\nIncorrect: 8\nIncorrect: 4\nIncorrect: 3\nIncorrect: 1\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: What does method recur do? \n\n\/** @param x an array of n integers \n* @param n a positive integer \n*\/ \npublic int recur(int[] x, int n) \n{ \n    int t; \n    if (n == 1) \n        return x[0]; \n    else \n    { \n        t = recur(x, n - 1); \n        if (x[n-1] > t) \n            return x[n-1]; \n        else \n            return t; \n    } \n} \n\nCorrect: It finds the largest value in x and leaves x unchanged.\nIncorrect: It finds the smallest value in x and leaves x unchanged.\nIncorrect: It sorts x in ascending order and returns the largest value in x.\nIncorrect: It sorts x in descending order and returns the largest value in x.\nIncorrect: It returns x[0] or x[n-1], whichever is larger.\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Which best describes what the printString method below does? \n\npublic void printString(String s) \n{ \n    if (s.length() > 0) \n    { \n        printString(s.substring(1)); \n        System.out.print(s.substring(0, 1)); \n    } \n} \n\nCorrect: It prints string s in reverse order.\nIncorrect: It prints string s.\nIncorrect: It prints only the first character of string s.\nIncorrect: It prints only the first two characters of string s.\nIncorrect: It prints only the last character of string s.\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Refer to the method power: \n\n\/** @param base a nonzero real number \n* @param expo an integer \n* @return base raised to the expo power \n*\/ \npublic double power(double base, int expo) \n{ \n    if (expo == 0) \n        return 1; \n    else if (expo > 0) \n        return base * power(base, expo - 1); \n    else \n        return \/* code *\/; \n} \n\nWhich \/* code *\/ correctly completes method power? (Recall that a^−n = 1\/a^n, a != 0; for example, 2^−3 = 1\/2^3 = 1\/8.) \nCorrect: (1 \/ base) * power(base, expo + 1)\nIncorrect: (1 \/ base) * power(base, expo - 1)\nIncorrect: base * power(base, expo + 1)\nIncorrect: base * power(base, expo - 1)\nIncorrect: (1 \/ base) * power(base, expo)\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Consider the following method: \n\npublic void doSomething(int n) \n{ \n    if (n > 0) \n    { \n        doSomething(n - 1); \n        System.out.print(n); \n        doSomething(n - 1); \n    } \n} \n\nWhat would be output following the call doSomething(3)? \nCorrect: 1213121\nIncorrect: 3211211\nIncorrect: 1121213\nIncorrect: 1211213\nIncorrect: 1123211\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: A user enters several positive integers at the keyboard and terminates the list with a sentinel (-999). A writeEven method reads those integers and outputs the even integers only, in the reverse order that they are read. Thus, if the user enters \n3 5 14 6 1 8 -999 \nthe output for the writeEven method will be \n8 6 14 \n\nAssume that the user enters at least one positive integer and terminates the list with −999. Here is the method: \n\n\/** Postcondition: All even integers in the list are output in \n* reverse order. \n*\/ \npublic static void writeEven() \n{ \n    int num = IO.readInt(); \/\/read user input \n    if (num != -999) \n    { \n        \/* code *\/ \n    } \n} \n\nWhich \/* code *\/ satisfies the postcondition of method writeEven? \nI if (num % 2 == 0) \n    System.out.print(num + \" \"); \nwriteEven(); \nII if (num % 2 == 0) \n    writeEven(); \nSystem.out.print(num + \" \"); \nIII writeEven(); \nif (num % 2 == 0) \n    System.out.print(num + \" \"); \nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Refer to the following recursive method. \n\npublic int mystery(int n) \n{ \n    if (n < 0) \n        return 2; \n    else \n        return mystery(n - 1) + mystery(n - 3); \n} \n\nWhat value is returned by the call mystery(3)? \nCorrect: 12\nIncorrect: 10\nIncorrect: 8\nIncorrect: 6\nIncorrect: 4\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Consider the method t:\n\n\/** @param n a positive integer *\/ \npublic int t(int n) \n{ \n    if (n == 1 || n == 2) \n        return 2 * n; \n    else \n        return t(n - 1) - t(n - 2); \n} \n\nWhat will be returned by t(5)? \nCorrect: −4\n\n\nIncorrect: 4\nIncorrect: 2\nIncorrect: 0\nIncorrect: −2END"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Consider the method t:\n\n\/** @param n a positive integer *\/ \npublic int t(int n) \n{ \n    if (n == 1 || n == 2) \n        return 2 * n; \n    else \n        return t(n - 1) - t(n - 2); \n} \n\nFor the method call t(6), how many calls to t will be made, including the original call? \nCorrect: 15\nIncorrect: 6\nIncorrect: 7\nIncorrect: 11\nIncorrect: 25\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: This question refers to methods f1 and f2 that are in the same class: \npublic int f1(int a, int b) \n{ \n    if (a == b) \n        return b; \n    else \n        return a + f2(a - 1, b); \n} \n\npublic int f2(int p, int q) \n{ \n    if (p < q) \n        return p + q; \n    else \n        return p + f1(p - 2, q); \n} \n\nWhat value will be returned by a call to f1(5, 3)? \nCorrect: 15\n\n\nIncorrect: 5\nIncorrect: 6\nIncorrect: 7\nIncorrect: 12END"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Consider method foo: \n\npublic int foo(int x) \n{ \n    if (x == 1 || x == 3) \n        return x; \n    else \n        return x * foo(x - 1); \n} \n\nAssuming no possibility of integer overflow, what will be the value of z after execution of the following statement? \nint z = foo(foo(3) + foo(4)); \nCorrect: (15!)\/(2!)\nIncorrect: 3! + 4!\nIncorrect: (7!)!\nIncorrect: (3! + 4!)!\nIncorrect: 15\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Consider the IntFormatter class defined below:\n\npublic class IntFormatter {\n    \/**\n     * Write 3 digits adjacent to each other.\n     * \n     * @param n a nonnegative integer\n     *\/\n    public static void writeThreeDigits(int n) {\n        System.out.print(n \/ 100);\n        System.out.print((n \/ 10) % 10);\n        System.out.print(n % 10);\n    }\n\n    \/**\n     * Insert commas in n, every 3 digits starting at the right.\n     * \n     * @param n a nonnegative integer\n     *\/\n    public static void writeWithCommas(int n) {\n        if (n < 1000)\n            System.out.print(n);\n        else {\n            writeThreeDigits(n % 1000);\n            System.out.print(\",\");\n            writeWithCommas(n \/ 1000);\n        }\n    }\n}\n\nThe method writeWithCommas is supposed to print its nonnegative int argument with commas properly inserted (every three digits, starting at the right). For example, the integer 27048621 should be printed as 27,048,621. Method writeWithCommas does not always work as intended, however. Assuming no integer overflow, which of the following integer arguments will not be printed correctly? \nCorrect: 365051\nIncorrect: 896\nIncorrect: 251462251\nIncorrect: 278278\nIncorrect: 4\n\nEND"}
{"prompt":"To come up with a recursive algorithm, you have to be able to frame a process recursively (i.e., in terms of a simpler case of itself). This is different from framing it iteratively, which repeats a process until a final condition is met. A good strategy for writing recursive methods is to first state the algorithm recursively in words.\n\nExample 1\nWrite a method that returns n! (n factorial).\nn! defined iteratively n! defined recursively\n0! = 1 0! = 1\n1! = 1 1! = (1)(0!)\n2! = (2)(1) 2! = (2)(1!)\n3! = (3)(2)(1) 3! = (3)(2!)\n. . . . . .\n\nThe general recursive definition for n! is\nn! = (1: n = 0) | (n(n - 1)!: n > 0)\n\nThe definition seems to be circular until you realize that if 0! is defined, all higher factorials are defined. Code for the recursive method follows directly from the recursive definition:\n\/** Compute n! recursively.\n* @param n a nonnegative integer\n* @return n!\n*\/\npublic static int factorial(int n)\n{\n    if (n == 0) \/\/base case\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nExample 2\nWrite a recursive method revDigs that outputs its integer parameter with the digits reversed. For example,\nrevDigs(147) outputs 741\nrevDigs(4) outputs 4\n\nFirst, describe the process recursively: Output the rightmost digit. Then, if there are still digits left in the remaining number n\/10, reverse its digits. Repeat this until n\/10 is 0. Here is the method:\n\/** @param n a nonnegative integer\n* @return n with its digits reversed\n*\/\npublic static void revDigs(int n)\n{\n    System.out.print(n % 10); \/\/rightmost digit\n    if (n \/ 10 != 0) \/\/base case\n        revDigs(n \/ 10);\n}\n\nNOTE\nOn the AP exam, you are expected to “understand and evaluate” recursive methods. This means that you would not be asked to come up with the code for methods such as factorial and revDigs (as shown above). You could, however, be asked to identify output for any given call to factorial or revDigs.\nRecall the Fibonacci sequence 1, 1, 2, 3, 5, 8, 13, ... . The nth Fibonacci number equals the sum of the previous two numbers if n ≥ 3. Recursively,\nFib(n) = (1: n = 1, 2) | (Fib(n − 1) + Fib(n − 2): n ≥ 3)\n\nHere is the method:\n\/** @param n a positive integer\n* @return the nth Fibonacci number\n*\/\npublic static int fib(int n)\n{\n    if (n == 1 || n == 2)\n        return 1;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nNotice that there are two recursive calls in the last line of the method. So to find Fib(5), for example, takes eight recursive calls to fib!\nIn general, each call to fib makes two more calls, which is the tipoff for an exponential algorithm (i.e., one that is very inefficient). This is much slower than the run time of the corresponding iterative algorithm (see Chapter 5, Question 13).\nYou may ask: Since every recursive algorithm can be written iteratively, when should programmers use recursion? Bear in mind that recursive algorithms can incur extra run time and memory. Their major plus is elegance and simplicity of code.\n\nGeneral Rules for Recursion\n1. Avoid recursion for algorithms that involve large local arrays—too many recursive calls can cause memory over flow.\n2. Use recursion when it significantly simplifies code.\n3. Avoid recursion for simple iterative methods like factorial, Fibonacci, and the linear search on the next page.\n4. Recursion is especially useful for\n• Branching processes like traversing trees or directories.\n• Divide-and-conquer algorithms like mergesort and binary search.\n\nMergesort and quicksort are discussed in Chapter 8.\n\n\n###\n\n","completion":" Question: Consider the IntFormatter class defined below:\n\npublic class IntFormatter {\n    \/**\n     * Write 3 digits adjacent to each other.\n     * \n     * @param n a nonnegative integer\n     *\/\n    public static void writeThreeDigits(int n) {\n        System.out.print(n \/ 100);\n        System.out.print((n \/ 10) % 10);\n        System.out.print(n % 10);\n    }\n\n    \/**\n     * Insert commas in n, every 3 digits starting at the right.\n     * \n     * @param n a nonnegative integer\n     *\/\n    public static void writeWithCommas(int n) {\n        if (n < 1000)\n            System.out.print(n);\n        else {\n            writeThreeDigits(n % 1000);\n            System.out.print(\",\");\n            writeWithCommas(n \/ 1000);\n        }\n    }\n}\n\nWhich change in the code of the given methods will cause method writeWithCommas to work as intended? \nCorrect: Interchange the lines writeThreeDigits(n % 1000) and writeWithCommas(n \/ 1000) in method writeWithCommas.\nIncorrect: Interchange the lines System.out.print(n \/ 100) and System.out.print(n % 10) in method writeThreeDigits.\nIncorrect: Change the test in writeWithCommas to if (n > 1000).\nIncorrect: In the method writeWithCommas, change the line writeThreeDigits(n % 1000) to writeThreeDigits(n \/ 1000).\nIncorrect: In the method writeWithCommas, change the recursive call writeWithCommas(n \/ 1000) to writeWithCommas(n % 1000).\nEND"}
{"prompt":"An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (“subscripts”) go from 0 to N − 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k ≥ N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java’s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; \/\/declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; \/\/reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n\/\/loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); \/\/assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n\/** @return the number of even integers in array arr of integers *\/ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) \/\/num is even\n            count++;\n    return count;\n}\nExample 2\n\/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*\/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\n###\n\n","completion":" Question: Which of the following correctly initializes an array arr to contain four elements each with value 0? \nI int[] arr = {0, 0, 0, 0}; \nII int[] arr = new int[4]; \nIII int[] arr = new int[4]; \nfor (int i = 0; i < arr.length; i++) \n    arr[i] = 0; \nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and III only\nIncorrect: II and III onlyEND"}
{"prompt":"An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (“subscripts”) go from 0 to N − 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k ≥ N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java’s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; \/\/declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; \/\/reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n\/\/loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); \/\/assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n\/** @return the number of even integers in array arr of integers *\/ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) \/\/num is even\n            count++;\n    return count;\n}\nExample 2\n\/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*\/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\n###\n\n","completion":" Question: The following program segment is intended to find the index of the first negative integer in arr[0] . . . arr[N-1], where arr is an array of N integers. \n\nint i = 0; \nwhile (arr[i] >= 0) \n{ \n    i++; \n} \nlocation = i; \n\nThis segment will work as intended \nCorrect: whenever arr contains at least one negative integer.\nIncorrect: always.\nIncorrect: never.\nIncorrect: whenever arr contains at least one nonnegative integer.\nIncorrect: whenever arr contains no negative integers.\n\nEND"}
{"prompt":"An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (“subscripts”) go from 0 to N − 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k ≥ N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java’s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; \/\/declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; \/\/reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n\/\/loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); \/\/assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n\/** @return the number of even integers in array arr of integers *\/ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) \/\/num is even\n            count++;\n    return count;\n}\nExample 2\n\/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*\/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\n###\n\n","completion":" Question: Refer to the following code segment. You may assume that arr is an array of int values. \n\nint sum = arr[0], i = 0; \nwhile (i < arr.length) \n{ \n    i++; \n    sum += arr[i]; \n} \n\nWhich of the following will be the result of executing the segment? \nCorrect: A run-time error will occur.\n\n\nIncorrect: Sum of arr[0], arr[1], . . . , arr[arr.length-1] will be stored in sum.\nIncorrect: Sum of arr[1], arr[2], . . . , arr[arr.length-1] will be stored in sum.\nIncorrect: Sum of arr[0], arr[1], . . . , arr[arr.length] will be stored in sum.\nIncorrect: An infinite loop will occur.END"}
{"prompt":"An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (“subscripts”) go from 0 to N − 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k ≥ N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java’s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; \/\/declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; \/\/reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n\/\/loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); \/\/assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n\/** @return the number of even integers in array arr of integers *\/ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) \/\/num is even\n            count++;\n    return count;\n}\nExample 2\n\/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*\/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\n###\n\n","completion":" Question: Refer to the following code segment. You may assume that array arr1 contains elements arr1[0], arr1[1], . . . , arr1[N-1], where N = arr1.length. \n\nint count = 0; \nfor (int i = 0; i < N; i++) \n    if (arr1[i] != 0) \n    { \n        arr1[count] = arr1[i]; \n        count++; \n    } \n\nint[] arr2 = new int[count]; \nfor (int i = 0; i < count; i++) \n    arr2[i] = arr1[i]; \n\nIf array arr1 initially contains the elements 0, 6, 0, 4, 0, 0, 2 in this order, what will arr2 contain after execution of the code segment? \nCorrect: 6, 4, 2\nIncorrect: 0, 0, 0, 0, 6, 4, 2\nIncorrect: 6, 4, 2, 4, 0, 0, 2\nIncorrect: 0, 6, 0, 4, 0, 0, 2\nIncorrect: 6, 4, 2, 0, 0, 0, 0\n\nEND"}
{"prompt":"An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (“subscripts”) go from 0 to N − 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k ≥ N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java’s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; \/\/declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; \/\/reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n\/\/loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); \/\/assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n\/** @return the number of even integers in array arr of integers *\/ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) \/\/num is even\n            count++;\n    return count;\n}\nExample 2\n\/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*\/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\n###\n\n","completion":" Question: Consider this program segment: \n\nfor (int i = 2; i <= k; i++) \n    if (arr[i] < someValue) \n        System.out.print(\"SMALL\"); \n\nWhat is the maximum number of times that SMALL can be printed? \nCorrect: k - 1\nIncorrect: 0\nIncorrect: 1\nIncorrect: k - 2\nIncorrect: k\n\nEND"}
{"prompt":"An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (“subscripts”) go from 0 to N − 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k ≥ N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java’s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; \/\/declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; \/\/reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n\/\/loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); \/\/assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n\/** @return the number of even integers in array arr of integers *\/ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) \/\/num is even\n            count++;\n    return count;\n}\nExample 2\n\/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*\/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\n###\n\n","completion":" Question: What will be output from the following code segment, assuming it is in the same class as the doSomething method? \n\nint[] arr = {1, 2, 3, 4}; \ndoSomething(arr); \nSystem.out.print(arr[1] + \" \"); \nSystem.out.print(arr[3]); \n... \npublic void doSomething(int[] list) \n{ \n    int[] b = list; \n    for (int i = 0; i < b.length; i++) \n        b[i] = i; \n}\nCorrect: 1 3\nIncorrect: 0 0\nIncorrect: 2 4\nIncorrect: 0 2\nIncorrect: 0 3\n\nEND"}
{"prompt":"Example 1\nDiscuss the efficiency of the countNegs method below. What are the best and worst case configurations of the data?\n\/** Precondition: arr[0],...,arr[arr.length-1] contain integers.\n* @return the number of negative values in arr\n*\/\npublic static int countNegs(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if (num < 0)\n            count++;\n    return count;\n}\n\nSolution:\nThis algorithm sequentially examines each element in the array. In the best case, there are no negative elements, and count++ is never executed. In the worst case, all the elements are negative, and count++ is executed in each pass of the for loop.\n\nExample 2\nThe code fragment below inserts a value, num, into its correct position in a sorted array of integers. Discuss the efficiency of the algorithm.\n\n\/** Precondition:\n* - arr[0],...,arr[n-1] contain integers sorted in increasing order.\n* - n < arr.length.\n* Postcondition: num has been inserted in its correct position.\n*\/\n{\n    \/\/find insertion point\n    int i = 0;\n    while (i < n && num > arr[i])\n    i++;\n    \/\/if necessary, move elements arr[i]...arr[n-1] up 1 slot\n    for (int j = n; j >= i + 1; j--)\n    arr[j] = arr[j-1];\n    \/\/insert num in i-th slot and update n\n    arr[i] = num;\n    n++;\n}\n\nSolution:\nIn the best case, num is greater than all the elements in the array: Because it gets inserted at the end of the list, no elements must be moved to create a slot for it. The worst case has num less than all the elements in the array. In this case, num must be inserted in the first slot, arr[0], and every element in the array must be moved up one position to create a slot.\nThis algorithm illustrates a disadvantage of arrays: Insertion and deletion of an ele ment in an ordered list is inefficient, since, in the worst case, it may involve moving all the elements in the list.\nAn ArrayList provides an alternative way of storing a list of objects and has the fol lowing advantages over an array:\n• An ArrayList shrinks and grows as needed in a program, whereas an array has a fixed length that is set when the array is created.\n• In an ArrayList list, the last slot is always list.size()-1, whereas in a partially filled array, you, the programmer, must keep track of the last slot currently in use.\n• For an ArrayList, you can do insertion or deletion with just a single statement. Any shifting of elements is handled automatically. In an array, however, insertion or deletion requires you to write the code that shifts the elements.\n\nThe Collections API\nThe ArrayList class is in the Collections API (Application Programming Interface), which is a library provided by Java. Most of the API is in java.util. This library gives the programmer access to prepackaged data structures and the methods to manipulate them. The implementations of these container classes are invisible and should not be of concern to the programmer. The code works. And it is reusable.\nAll of the collections classes, including ArrayList, have the following features in common:\n• They are designed to be both memory and run-time efficient.\n• They provide methods for insertion and removal of items (i.e., they can grow and shrink).\n• They provide for iteration over the entire collection.\n\nInheritance is a defining feature of the Collections API. The interfaces that are used to manipulate the collections specify the operations that must be defined for any con tainer class that implements that interface.\n\nCollections and Generics\nThe collections classes are generic, with type parameters. Thus, List<E> and ArrayList<E> contain elements of type E. When a generic class is declared, the type parameter is replaced by an actual object type. For example,\nprivate ArrayList<Clown> clowns;\n\nNOTE\n1. The clowns list must contain only Clown objects. An attempt to add an Acrobat to the list, for example, will cause a compile-time error.\n2. Since the type of objects in a generic class is restricted, the elements can be accessed without casting.\n3. All of the type information in a program with generic classes is examined at compile time. After compilation the type information is erased. This feature of generic classes is known as erasure. During execution of the program, any attempt at incorrect casting will lead to a ClassCastException.\nThere are no primitive types in collections classes. An ArrayList must contain objects, not types like double and int. Numbers must therefore be boxed—placed in wrapper classes like Integer and Double—before insertion into an ArrayList.\nAuto-boxing is the automatic wrapping of primitive types in their wrapper classes.\nTo retrieve the numerical value of an Integer (or Double) stored in an ArrayList, the intValue() (or doubleValue()) method must be invoked (unwrapping). Auto unboxing is the automatic conversion of a wrapper class to its corresponding primitive type. This means that you don’t need to explicitly call the intValue() or doubleValue() methods. Be aware that if a program tries to auto-unbox null, the method will throw a NullPointerException.\nNote that while auto-boxing and -unboxing cut down on code clutter, these oper ations must still be performed behind the scenes, leading to decreased run-time effi ciency. It is much more efficient to assign and access primitive types in an array than an ArrayList. You should therefore consider using an array for a program that manip ulates sequences of numbers and does not need to use objects.\n\nNOTE\nAuto-boxing and -unboxing is a feature in Java 5.0 and later versions and will not be tested on the AP exam. It is OK, however, to use this convenient feature in code that you write in the free-response questions.\n\n\n###\n\n","completion":" Question: Consider writing a program that reads the lines of any text file into a sequential list of lines. Which of the following is a good reason to implement the list with an ArrayList of String objects rather than an array of String objects? \nCorrect: If any particular text file is unexpectedly long, the ArrayList will automatically be resized. The array, by contrast, may go out of bounds.\nIncorrect: The get and set methods of ArrayList are more convenient than the [] notation for arrays.\nIncorrect: The size method of ArrayList provides instant access to the length of the list.\nIncorrect: An ArrayList can contain objects of any type, which leads to greater generality.\nIncorrect: The String methods are easier to use with an ArrayList than with an array.\n\nEND"}
{"prompt":"Example 1\nDiscuss the efficiency of the countNegs method below. What are the best and worst case configurations of the data?\n\/** Precondition: arr[0],...,arr[arr.length-1] contain integers.\n* @return the number of negative values in arr\n*\/\npublic static int countNegs(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if (num < 0)\n            count++;\n    return count;\n}\n\nSolution:\nThis algorithm sequentially examines each element in the array. In the best case, there are no negative elements, and count++ is never executed. In the worst case, all the elements are negative, and count++ is executed in each pass of the for loop.\n\nExample 2\nThe code fragment below inserts a value, num, into its correct position in a sorted array of integers. Discuss the efficiency of the algorithm.\n\n\/** Precondition:\n* - arr[0],...,arr[n-1] contain integers sorted in increasing order.\n* - n < arr.length.\n* Postcondition: num has been inserted in its correct position.\n*\/\n{\n    \/\/find insertion point\n    int i = 0;\n    while (i < n && num > arr[i])\n    i++;\n    \/\/if necessary, move elements arr[i]...arr[n-1] up 1 slot\n    for (int j = n; j >= i + 1; j--)\n    arr[j] = arr[j-1];\n    \/\/insert num in i-th slot and update n\n    arr[i] = num;\n    n++;\n}\n\nSolution:\nIn the best case, num is greater than all the elements in the array: Because it gets inserted at the end of the list, no elements must be moved to create a slot for it. The worst case has num less than all the elements in the array. In this case, num must be inserted in the first slot, arr[0], and every element in the array must be moved up one position to create a slot.\nThis algorithm illustrates a disadvantage of arrays: Insertion and deletion of an ele ment in an ordered list is inefficient, since, in the worst case, it may involve moving all the elements in the list.\nAn ArrayList provides an alternative way of storing a list of objects and has the fol lowing advantages over an array:\n• An ArrayList shrinks and grows as needed in a program, whereas an array has a fixed length that is set when the array is created.\n• In an ArrayList list, the last slot is always list.size()-1, whereas in a partially filled array, you, the programmer, must keep track of the last slot currently in use.\n• For an ArrayList, you can do insertion or deletion with just a single statement. Any shifting of elements is handled automatically. In an array, however, insertion or deletion requires you to write the code that shifts the elements.\n\nThe Collections API\nThe ArrayList class is in the Collections API (Application Programming Interface), which is a library provided by Java. Most of the API is in java.util. This library gives the programmer access to prepackaged data structures and the methods to manipulate them. The implementations of these container classes are invisible and should not be of concern to the programmer. The code works. And it is reusable.\nAll of the collections classes, including ArrayList, have the following features in common:\n• They are designed to be both memory and run-time efficient.\n• They provide methods for insertion and removal of items (i.e., they can grow and shrink).\n• They provide for iteration over the entire collection.\n\nInheritance is a defining feature of the Collections API. The interfaces that are used to manipulate the collections specify the operations that must be defined for any con tainer class that implements that interface.\n\nCollections and Generics\nThe collections classes are generic, with type parameters. Thus, List<E> and ArrayList<E> contain elements of type E. When a generic class is declared, the type parameter is replaced by an actual object type. For example,\nprivate ArrayList<Clown> clowns;\n\nNOTE\n1. The clowns list must contain only Clown objects. An attempt to add an Acrobat to the list, for example, will cause a compile-time error.\n2. Since the type of objects in a generic class is restricted, the elements can be accessed without casting.\n3. All of the type information in a program with generic classes is examined at compile time. After compilation the type information is erased. This feature of generic classes is known as erasure. During execution of the program, any attempt at incorrect casting will lead to a ClassCastException.\nThere are no primitive types in collections classes. An ArrayList must contain objects, not types like double and int. Numbers must therefore be boxed—placed in wrapper classes like Integer and Double—before insertion into an ArrayList.\nAuto-boxing is the automatic wrapping of primitive types in their wrapper classes.\nTo retrieve the numerical value of an Integer (or Double) stored in an ArrayList, the intValue() (or doubleValue()) method must be invoked (unwrapping). Auto unboxing is the automatic conversion of a wrapper class to its corresponding primitive type. This means that you don’t need to explicitly call the intValue() or doubleValue() methods. Be aware that if a program tries to auto-unbox null, the method will throw a NullPointerException.\nNote that while auto-boxing and -unboxing cut down on code clutter, these oper ations must still be performed behind the scenes, leading to decreased run-time effi ciency. It is much more efficient to assign and access primitive types in an array than an ArrayList. You should therefore consider using an array for a program that manip ulates sequences of numbers and does not need to use objects.\n\nNOTE\nAuto-boxing and -unboxing is a feature in Java 5.0 and later versions and will not be tested on the AP exam. It is OK, however, to use this convenient feature in code that you write in the free-response questions.\n\n\n###\n\n","completion":" Question: Consider writing a program that produces statistics for long lists of numerical data. Which of the following is the best reason to implement each list with an array of int (or double), rather than an ArrayList of Integer (or Double) objects? \nCorrect: An array of primitive number types is more efficient to manipulate than an ArrayList of wrapper objects that contain numbers.\nIncorrect: Insertion of new elements into a list is easier to code for an array than for an ArrayList.\nIncorrect: Removal of elements from a list is easier to code for an array than for an ArrayList.\nIncorrect: Accessing individual elements in the middle of a list is easier for an array than for an ArrayList.\nIncorrect: Accessing all the elements is more efficient in an array than in an ArrayList.\n\nEND"}
{"prompt":"Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    \/** constructor *\/\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    \/** Write contents of Deck. *\/\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    \/** Swap arr[i] and arr[j] in array arr. *\/\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    \/**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     *\/\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            \/\/ generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards—deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    \/** constructor *\/\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    \/** Shuffle the Decks. *\/\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    \/** Write contents of all the Decks. *\/\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it’s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\n###\n\n","completion":" Question: Consider the following classes:\n\npublic class Address {\n    private String name;\n    private String street;\n    private String city;\n    private String state;\n    private String zip;\n    \/\/ constructors\n    ...\n\n    \/\/ accessors\n    public String getName() { return name; }\n\n    public String getStreet() { return street; }\n\n    public String getCity() { return city; }\n\n    public String getState() { return state; }\n\n    public String getZip() { return zip; }\n}\n\npublic class Student {\n    private int idNum;\n    private double gpa;\n    private Address address;\n    \/\/ constructors\n    ...\n\n    \/\/ accessors\n    public Address getAddress() { return address; }\n\n    public int getIdNum() { return idNum; }\n\n    public double getGpa() { return gpa; }\n}\n\nA client method has this declaration, followed by code to initialize the list: \nAddress[] list = new Address[100]; \n\nHere is a code segment to generate a list of names only. \nfor (Address a : list) \n    \/* line of code *\/ \n\nWhich is a correct \/* line of code *\/? \nCorrect: System.out.println(a.getName());\nIncorrect: System.out.println(Address[i].getName());\nIncorrect: System.out.println(list[i].getName());\nIncorrect: System.out.println(a[i].getName());\nIncorrect: System.out.println(list.getName());\n\nEND"}
{"prompt":"Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    \/** constructor *\/\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    \/** Write contents of Deck. *\/\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    \/** Swap arr[i] and arr[j] in array arr. *\/\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    \/**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     *\/\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            \/\/ generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards—deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    \/** constructor *\/\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    \/** Shuffle the Decks. *\/\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    \/** Write contents of all the Decks. *\/\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it’s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\n###\n\n","completion":" Question: Consider the following classes:\n\npublic class Address {\n    private String name;\n    private String street;\n    private String city;\n    private String state;\n    private String zip;\n    \/\/ constructors\n    ...\n\n    \/\/ accessors\n    public String getName() { return name; }\n\n    public String getStreet() { return street; }\n\n    public String getCity() { return city; }\n\n    public String getState() { return state; }\n\n    public String getZip() { return zip; }\n}\n\npublic class Student {\n    private int idNum;\n    private double gpa;\n    private Address address;\n    \/\/ constructors\n    ...\n\n    \/\/ accessors\n    public Address getAddress() { return address; }\n\n    public int getIdNum() { return idNum; }\n\n    public double getGpa() { return gpa; }\n}\n\nThe following code segment is to print out a list of addresses: \nfor (Address addr : list) \n{ \n    \/* more code *\/ \n} \n\nWhich is a correct replacement for \/* more code *\/? \nI System.out.println(list[i].getName()); \nSystem.out.println(list[i].getStreet()); \nSystem.out.print(list[i].getCity() + \", \"); \nSystem.out.print(list[i].getState() + \" \"); \nSystem.out.println(list[i].getZip()); \nII System.out.println(addr.getName()); \nSystem.out.println(addr.getStreet()); \nSystem.out.print(addr.getCity() + \", \"); \nSystem.out.print(addr.getState() + \" \"); \nSystem.out.println(addr.getZip()); \nIII System.out.println(addr); \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    \/** constructor *\/\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    \/** Write contents of Deck. *\/\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    \/** Swap arr[i] and arr[j] in array arr. *\/\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    \/**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     *\/\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            \/\/ generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards—deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    \/** constructor *\/\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    \/** Shuffle the Decks. *\/\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    \/** Write contents of all the Decks. *\/\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it’s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\n###\n\n","completion":" Question: Consider the following classes:\n\npublic class Address {\n    private String name;\n    private String street;\n    private String city;\n    private String state;\n    private String zip;\n    \/\/ constructors\n    ...\n\n    \/\/ accessors\n    public String getName() { return name; }\n\n    public String getStreet() { return street; }\n\n    public String getCity() { return city; }\n\n    public String getState() { return state; }\n\n    public String getZip() { return zip; }\n}\n\npublic class Student {\n    private int idNum;\n    private double gpa;\n    private Address address;\n    \/\/ constructors\n    ...\n\n    \/\/ accessors\n    public Address getAddress() { return address; }\n\n    public int getIdNum() { return idNum; }\n\n    public double getGpa() { return gpa; }\n}\n\nA client method has this declaration: \n\nStudent[] allStudents = new Student[NUM_STUDS]; \/\/NUM_STUDS is an int constant \n\nHere is a code segment to generate a list of Student names only. (You may assume that allStudents has been initialized.) \n\nfor (Student student : allStudents) \n    \/* code to print list of names *\/ \n\nWhich is a correct replacement for \/* code to print list of names *\/? \nCorrect: System.out.println(student.getAddress().getName());\nIncorrect: System.out.println(allStudents.getName());\nIncorrect: System.out.println(student.getName());\nIncorrect: System.out.println(allStudents.getAddress().getName());\nIncorrect: System.out.println(student[i].getAddress().getName());\n\nEND"}
{"prompt":"Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    \/** constructor *\/\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    \/** Write contents of Deck. *\/\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    \/** Swap arr[i] and arr[j] in array arr. *\/\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    \/**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     *\/\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            \/\/ generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards—deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    \/** constructor *\/\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    \/** Shuffle the Decks. *\/\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    \/** Write contents of all the Decks. *\/\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it’s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\n###\n\n","completion":" Question: Consider the following classes:\n\npublic class Address {\n    private String name;\n    private String street;\n    private String city;\n    private String state;\n    private String zip;\n    \/\/ constructors\n    ...\n\n    \/\/ accessors\n    public String getName() { return name; }\n\n    public String getStreet() { return street; }\n\n    public String getCity() { return city; }\n\n    public String getState() { return state; }\n\n    public String getZip() { return zip; }\n}\n\npublic class Student {\n    private int idNum;\n    private double gpa;\n    private Address address;\n    \/\/ constructors\n    ...\n\n    \/\/ accessors\n    public Address getAddress() { return address; }\n\n    public int getIdNum() { return idNum; }\n\n    public double getGpa() { return gpa; }\n}\n\nHere is a method that locates the Student with the highest idNum: \n\n\/** Precondition: Array stuArr of Student is initialized. \n* @return Student with highest idNum \n*\/ \npublic static Student locate(Student[] stuArr) \n{ \n    \/* method body *\/ \n} \n\nWhich of the following could replace \/* method body *\/ so that the method works as intended? \nI int max = stuArr[0].getIdNum(); \nfor (Student student : stuArr) \n    if (student.getIdNum() > max) \n    { \n        max = student.getIdNum(); \n        return student; \n    } \nreturn stuArr[0]; \nII Student highestSoFar = stuArr[0]; \nint max = stuArr[0].getIdNum(); \nfor (Student student : stuArr) \n    if(student.getIdNum() > max) \n    { \n        max = student.getIdNum(); \n        highestSoFar = student; \n    } \nreturn highestSoFar; \nIII int maxPos = 0; \nfor(int i = 1; i < stuArr.length; i++) \n    if(stuArr[i].getIdNum() > stuArr[maxPos].getIdNum()) \n        maxPos = i; \nreturn stuArr[maxPos]; \nCorrect: II and III only\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and III onlyEND"}
{"prompt":"Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    \/** constructor *\/\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    \/** Write contents of Deck. *\/\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    \/** Swap arr[i] and arr[j] in array arr. *\/\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    \/**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     *\/\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            \/\/ generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards—deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    \/** constructor *\/\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    \/** Shuffle the Decks. *\/\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    \/** Write contents of all the Decks. *\/\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it’s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\n###\n\n","completion":" Question: Consider the Ticket and Transaction classes defined below:\n\npublic class Ticket \n{ \n    private String row; \n    private int seat; \n    private double price; \n\n    \/\/constructor \n    public Ticket(String aRow, int aSeat, double aPrice) \n    { \n        row = aRow; \n        seat = aSeat; \n        price = aPrice; \n    } \n\n    \/\/accessors getRow(), getSeat(), and getPrice() \n    ... \n}\n\npublic class Transaction {\n    private int numTickets;\n    private Ticket[] tickList;\n\n    \/\/ constructor\n    public Transaction(int numTicks) \n    { \n        numTickets = numTicks; \n        tickList = new Ticket[numTicks]; \n        String theRow; \n        int theSeat; \n        double thePrice; \n        for (int i = 0; i < numTicks; i++) \n        { \n            < read user input for theRow, theSeat, and thePrice > \n            ... \n            \/* more code *\/ \n        } \n    }\n\n    \/** @return total amount paid for this transaction *\/\n    public double totalPaid() {\n        double total = 0.0;\n        \/* code to calculate amount *\/\n        return total;\n    }\n}\n\nWhich of the following correctly replaces \/* more code *\/ in the Transaction constructor to initialize the tickList array? \nCorrect: tickList[i] = new Ticket(theRow, theSeat, thePrice);\nIncorrect: tickList[i] = new Ticket(getRow(), getSeat(), getPrice());\nIncorrect: tickList[i] = new tickList(getRow(), getSeat(), getPrice());\nIncorrect: tickList[i] = new tickList(theRow, theSeat, thePrice);\nIncorrect: tickList[i] = new tickList(numTicks);\n\nEND"}
{"prompt":"Example 1\nDiscuss the efficiency of the countNegs method below. What are the best and worst case configurations of the data?\n\/** Precondition: arr[0],...,arr[arr.length-1] contain integers.\n* @return the number of negative values in arr\n*\/\npublic static int countNegs(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if (num < 0)\n            count++;\n    return count;\n}\n\nSolution:\nThis algorithm sequentially examines each element in the array. In the best case, there are no negative elements, and count++ is never executed. In the worst case, all the elements are negative, and count++ is executed in each pass of the for loop.\n\nExample 2\nThe code fragment below inserts a value, num, into its correct position in a sorted array of integers. Discuss the efficiency of the algorithm.\n\n\/** Precondition:\n* - arr[0],...,arr[n-1] contain integers sorted in increasing order.\n* - n < arr.length.\n* Postcondition: num has been inserted in its correct position.\n*\/\n{\n    \/\/find insertion point\n    int i = 0;\n    while (i < n && num > arr[i])\n    i++;\n    \/\/if necessary, move elements arr[i]...arr[n-1] up 1 slot\n    for (int j = n; j >= i + 1; j--)\n    arr[j] = arr[j-1];\n    \/\/insert num in i-th slot and update n\n    arr[i] = num;\n    n++;\n}\n\nSolution:\nIn the best case, num is greater than all the elements in the array: Because it gets inserted at the end of the list, no elements must be moved to create a slot for it. The worst case has num less than all the elements in the array. In this case, num must be inserted in the first slot, arr[0], and every element in the array must be moved up one position to create a slot.\nThis algorithm illustrates a disadvantage of arrays: Insertion and deletion of an ele ment in an ordered list is inefficient, since, in the worst case, it may involve moving all the elements in the list.\nAn ArrayList provides an alternative way of storing a list of objects and has the fol lowing advantages over an array:\n• An ArrayList shrinks and grows as needed in a program, whereas an array has a fixed length that is set when the array is created.\n• In an ArrayList list, the last slot is always list.size()-1, whereas in a partially filled array, you, the programmer, must keep track of the last slot currently in use.\n• For an ArrayList, you can do insertion or deletion with just a single statement. Any shifting of elements is handled automatically. In an array, however, insertion or deletion requires you to write the code that shifts the elements.\n\nThe Collections API\nThe ArrayList class is in the Collections API (Application Programming Interface), which is a library provided by Java. Most of the API is in java.util. This library gives the programmer access to prepackaged data structures and the methods to manipulate them. The implementations of these container classes are invisible and should not be of concern to the programmer. The code works. And it is reusable.\nAll of the collections classes, including ArrayList, have the following features in common:\n• They are designed to be both memory and run-time efficient.\n• They provide methods for insertion and removal of items (i.e., they can grow and shrink).\n• They provide for iteration over the entire collection.\n\nInheritance is a defining feature of the Collections API. The interfaces that are used to manipulate the collections specify the operations that must be defined for any con tainer class that implements that interface.\n\nCollections and Generics\nThe collections classes are generic, with type parameters. Thus, List<E> and ArrayList<E> contain elements of type E. When a generic class is declared, the type parameter is replaced by an actual object type. For example,\nprivate ArrayList<Clown> clowns;\n\nNOTE\n1. The clowns list must contain only Clown objects. An attempt to add an Acrobat to the list, for example, will cause a compile-time error.\n2. Since the type of objects in a generic class is restricted, the elements can be accessed without casting.\n3. All of the type information in a program with generic classes is examined at compile time. After compilation the type information is erased. This feature of generic classes is known as erasure. During execution of the program, any attempt at incorrect casting will lead to a ClassCastException.\nThere are no primitive types in collections classes. An ArrayList must contain objects, not types like double and int. Numbers must therefore be boxed—placed in wrapper classes like Integer and Double—before insertion into an ArrayList.\nAuto-boxing is the automatic wrapping of primitive types in their wrapper classes.\nTo retrieve the numerical value of an Integer (or Double) stored in an ArrayList, the intValue() (or doubleValue()) method must be invoked (unwrapping). Auto unboxing is the automatic conversion of a wrapper class to its corresponding primitive type. This means that you don’t need to explicitly call the intValue() or doubleValue() methods. Be aware that if a program tries to auto-unbox null, the method will throw a NullPointerException.\nNote that while auto-boxing and -unboxing cut down on code clutter, these oper ations must still be performed behind the scenes, leading to decreased run-time effi ciency. It is much more efficient to assign and access primitive types in an array than an ArrayList. You should therefore consider using an array for a program that manip ulates sequences of numbers and does not need to use objects.\n\nNOTE\nAuto-boxing and -unboxing is a feature in Java 5.0 and later versions and will not be tested on the AP exam. It is OK, however, to use this convenient feature in code that you write in the free-response questions.\n\n\n###\n\n","completion":" Question: Consider the Ticket and Transaction classes defined below:\n\npublic class Ticket \n{ \n    private String row; \n    private int seat; \n    private double price; \n\n    \/\/constructor \n    public Ticket(String aRow, int aSeat, double aPrice) \n    { \n        row = aRow; \n        seat = aSeat; \n        price = aPrice; \n    } \n\n    \/\/accessors getRow(), getSeat(), and getPrice() \n    ... \n}\n\npublic class Transaction {\n    private int numTickets;\n    private Ticket[] tickList;\n\n    \/\/ constructor\n    public Transaction(int numTicks) \n    { \n        numTickets = numTicks; \n        tickList = new Ticket[numTicks]; \n        String theRow; \n        int theSeat; \n        double thePrice; \n        for (int i = 0; i < numTicks; i++) \n        { \n            < read user input for theRow, theSeat, and thePrice > \n            ... \n            \/* more code *\/ \n        } \n    }\n\n    \/** @return total amount paid for this transaction *\/\n    public double totalPaid() {\n        double total = 0.0;\n        \/* code to calculate amount *\/\n        return total;\n    }\n}\n\nWhich represents correct \/* code to calculate amount *\/ in the totalPaid method? \nCorrect: for (Ticket t : tickList)\n    total += t.getPrice(); \nIncorrect: for (Ticket t : tickList)\n    total += t.price; \nIncorrect: for (Ticket t : tickList)\n    total += tickList.getPrice(); \nIncorrect: Transaction T;\nfor (Ticket t : T) \n    total += t.getPrice(); \nIncorrect: Transaction T;\nfor (Ticket t : T) \n    total += t.price; \n\nEND"}
{"prompt":"Example 1\nDiscuss the efficiency of the countNegs method below. What are the best and worst case configurations of the data?\n\/** Precondition: arr[0],...,arr[arr.length-1] contain integers.\n* @return the number of negative values in arr\n*\/\npublic static int countNegs(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if (num < 0)\n            count++;\n    return count;\n}\n\nSolution:\nThis algorithm sequentially examines each element in the array. In the best case, there are no negative elements, and count++ is never executed. In the worst case, all the elements are negative, and count++ is executed in each pass of the for loop.\n\nExample 2\nThe code fragment below inserts a value, num, into its correct position in a sorted array of integers. Discuss the efficiency of the algorithm.\n\n\/** Precondition:\n* - arr[0],...,arr[n-1] contain integers sorted in increasing order.\n* - n < arr.length.\n* Postcondition: num has been inserted in its correct position.\n*\/\n{\n    \/\/find insertion point\n    int i = 0;\n    while (i < n && num > arr[i])\n    i++;\n    \/\/if necessary, move elements arr[i]...arr[n-1] up 1 slot\n    for (int j = n; j >= i + 1; j--)\n    arr[j] = arr[j-1];\n    \/\/insert num in i-th slot and update n\n    arr[i] = num;\n    n++;\n}\n\nSolution:\nIn the best case, num is greater than all the elements in the array: Because it gets inserted at the end of the list, no elements must be moved to create a slot for it. The worst case has num less than all the elements in the array. In this case, num must be inserted in the first slot, arr[0], and every element in the array must be moved up one position to create a slot.\nThis algorithm illustrates a disadvantage of arrays: Insertion and deletion of an ele ment in an ordered list is inefficient, since, in the worst case, it may involve moving all the elements in the list.\nAn ArrayList provides an alternative way of storing a list of objects and has the fol lowing advantages over an array:\n• An ArrayList shrinks and grows as needed in a program, whereas an array has a fixed length that is set when the array is created.\n• In an ArrayList list, the last slot is always list.size()-1, whereas in a partially filled array, you, the programmer, must keep track of the last slot currently in use.\n• For an ArrayList, you can do insertion or deletion with just a single statement. Any shifting of elements is handled automatically. In an array, however, insertion or deletion requires you to write the code that shifts the elements.\n\nThe Collections API\nThe ArrayList class is in the Collections API (Application Programming Interface), which is a library provided by Java. Most of the API is in java.util. This library gives the programmer access to prepackaged data structures and the methods to manipulate them. The implementations of these container classes are invisible and should not be of concern to the programmer. The code works. And it is reusable.\nAll of the collections classes, including ArrayList, have the following features in common:\n• They are designed to be both memory and run-time efficient.\n• They provide methods for insertion and removal of items (i.e., they can grow and shrink).\n• They provide for iteration over the entire collection.\n\nInheritance is a defining feature of the Collections API. The interfaces that are used to manipulate the collections specify the operations that must be defined for any con tainer class that implements that interface.\n\nCollections and Generics\nThe collections classes are generic, with type parameters. Thus, List<E> and ArrayList<E> contain elements of type E. When a generic class is declared, the type parameter is replaced by an actual object type. For example,\nprivate ArrayList<Clown> clowns;\n\nNOTE\n1. The clowns list must contain only Clown objects. An attempt to add an Acrobat to the list, for example, will cause a compile-time error.\n2. Since the type of objects in a generic class is restricted, the elements can be accessed without casting.\n3. All of the type information in a program with generic classes is examined at compile time. After compilation the type information is erased. This feature of generic classes is known as erasure. During execution of the program, any attempt at incorrect casting will lead to a ClassCastException.\nThere are no primitive types in collections classes. An ArrayList must contain objects, not types like double and int. Numbers must therefore be boxed—placed in wrapper classes like Integer and Double—before insertion into an ArrayList.\nAuto-boxing is the automatic wrapping of primitive types in their wrapper classes.\nTo retrieve the numerical value of an Integer (or Double) stored in an ArrayList, the intValue() (or doubleValue()) method must be invoked (unwrapping). Auto unboxing is the automatic conversion of a wrapper class to its corresponding primitive type. This means that you don’t need to explicitly call the intValue() or doubleValue() methods. Be aware that if a program tries to auto-unbox null, the method will throw a NullPointerException.\nNote that while auto-boxing and -unboxing cut down on code clutter, these oper ations must still be performed behind the scenes, leading to decreased run-time effi ciency. It is much more efficient to assign and access primitive types in an array than an ArrayList. You should therefore consider using an array for a program that manip ulates sequences of numbers and does not need to use objects.\n\nNOTE\nAuto-boxing and -unboxing is a feature in Java 5.0 and later versions and will not be tested on the AP exam. It is OK, however, to use this convenient feature in code that you write in the free-response questions.\n\n\n###\n\n","completion":" Question: Consider the Ticket and Transaction classes defined below:\n\npublic class Ticket \n{ \n    private String row; \n    private int seat; \n    private double price; \n\n    \/\/constructor \n    public Ticket(String aRow, int aSeat, double aPrice) \n    { \n        row = aRow; \n        seat = aSeat; \n        price = aPrice; \n    } \n\n    \/\/accessors getRow(), getSeat(), and getPrice() \n    ... \n}\n\npublic class Transaction {\n    private int numTickets;\n    private Ticket[] tickList;\n\n    \/\/ constructor\n    public Transaction(int numTicks) \n    { \n        numTickets = numTicks; \n        tickList = new Ticket[numTicks]; \n        String theRow; \n        int theSeat; \n        double thePrice; \n        for (int i = 0; i < numTicks; i++) \n        { \n            < read user input for theRow, theSeat, and thePrice > \n            ... \n            \/* more code *\/ \n        } \n    }\n\n    \/** @return total amount paid for this transaction *\/\n    public double totalPaid() {\n        double total = 0.0;\n        \/* code to calculate amount *\/\n        return total;\n    }\n}\n\nSuppose it is necessary to keep a list of all ticket transactions. Assuming that there are NUMSALES transactions, a suitable declaration would be \nCorrect: Transaction[] listOfSales = new Transaction[NUMSALES];\nIncorrect: Transaction[] listOfSales = new Ticket[NUMSALES];\nIncorrect: Ticket[] listOfSales = new Transaction[NUMSALES];\nIncorrect: Ticket[] listOfSales = new Ticket[NUMSALES];\nIncorrect: Transaction[] Ticket = new listOfSales[NUMSALES];\n\nEND"}
{"prompt":"An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (“subscripts”) go from 0 to N − 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k ≥ N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java’s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; \/\/declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; \/\/reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n\/\/loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); \/\/assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n\/** @return the number of even integers in array arr of integers *\/ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) \/\/num is even\n            count++;\n    return count;\n}\nExample 2\n\/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*\/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\n###\n\n","completion":" Question: The following code fragment is intended to find the smallest value in arr[0] . . . arr[n-1]. \n\n\/** Precondition: \n* - arr is an array, arr.length = n. \n* - arr[0]...arr[n-1] initialized with integers. \n* Postcondition: min = smallest value in arr[0]...arr[n-1]. \n*\/ \nint min = arr[0]; \nint i = 1; \nwhile (i < n) \n{ \n    i++; \n    if (arr[i] < min) \n    min = arr[i]; \n} \n\nThis code is incorrect. For the segment to work as intended, which of the following modifications could be made? \nI Change the line \nint i = 1; \nto \nint i = 0; \nMake no other changes. \nII Change the body of the while loop to \n{ \n    if (arr[i] < min) \n    min = arr[i]; \n    i++; \n} \nMake no other changes. \nIII Change the test for the while loop as follows: \nwhile (i <= n) \nMake no other changes. \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"An array is a data structure used to implement a list object, where the elements in the list are of the same type; for example, a class list of 25 test scores, a membership list of 100 names, or a store inventory of 500 items.\nFor an array of N elements in Java, index values (“subscripts”) go from 0 to N − 1. Individual elements are accessed as follows: If arr is the name of the array, the elements are arr[0], arr[1], . . . , arr[N-1]. If a negative subscript is used, or a subscript k where k ≥ N, an ArrayIndexOutOfBoundsException is thrown.\n\nInitialization\nIn Java, an array is an object; therefore, the keyword new must be used in its creation. The size of an array remains fixed once it has been created. As with String objects, however, an array reference may be reassigned to a new array of a different size.\n\nExample\nAll of the following are equivalent. Each creates an array of 25 double values and assigns the reference data to this array.\n1. double[] data = new double[25];\n2. double data[] = new double[25];\n3. double[] data;\ndata = new double[25];\n\nA subsequent statement like\ndata = new double[40];\nreassigns data to a new array of length 40. The memory allocated for the previous data array is recycled by Java’s automatic garbage collection system.\nWhen arrays are declared, the elements are automatically initialized to zero for the primitive numeric data types (int and double), to false for boolean variables, or to null for object references.\nIt is possible to declare several arrays in a single statement. For example,\nint[] intList1, intList2; \/\/declares intList1 and intList2 to contain int values\nint[] arr1 = new int[15], arr2 = new int[30]; \/\/reserves 15 slots for arr1, 30 for arr2\n\nSmall arrays whose values are known can be declared with an initializer list. For example, instead of writing\nint[] coins = new int[4];\ncoins[0] = 1;\ncoins[1] = 5;\ncoins[2] = 10;\ncoins[3] = 25;\nyou can write\nint[] coins = {1, 5, 10, 25};\nThis construction is the one case where new is not required to create an array.\n\nA Java array has a final public instance variable (i.e., a constant), length, which can be accessed when you need the number of elements in the array. For example,\nString[] names = new String[25];\n< code to initialize names >\n\n\/\/loop to process all names in array\nfor (int i = 0; i < names.length; i++)\n< process names >\n\nNOTE\n1. The array subscripts go from 0 to names.length-1; therefore, the test on i in the for loop must be strictly less than names.length.\n2. length is not a method and therefore is not followed by parentheses. Contrast this with String objects, where length is a method and must be followed by parentheses. For example,\nString s = \"Confusing syntax!\";\nint size = s.length(); \/\/assigns 17 to size\nUse a for-each loop whenever you need access to every element in an array without replacing or removing any elements. Use a for loop in all other cases: to access the index of any element, to replace or remove elements, or to access just some of the elements. Note that if you have an array of objects (not primitive types), you can use the for each loop and mutator methods of the object to modify the fields of any instance (see the shuffleAll method on p. 239).\n\nExample 1\n\/** @return the number of even integers in array arr of integers *\/ public static int countEven(int[] arr)\n{\n    int count = 0;\n    for (int num : arr)\n        if ( num % 2 == 0) \/\/num is even\n            count++;\n    return count;\n}\nExample 2\n\/** Change each even-indexed element in array arr to 0.\n* Precondition: arr contains integers.\n* Postcondition: arr[0], arr[2], arr[4], ... have value 0.\n*\/\npublic static void changeEven(int[] arr)\n{\n    for (int i = 0; i < arr.length; i += 2)\n        arr[i] = 0;\n}\n\n\n###\n\n","completion":" Question: Refer to method match below: \n\n\/** @param v an array of int sorted in increasing order \n* @param w an array of int sorted in increasing order \n* @param N the number of elements in array v \n* @param M the number of elements in array w \n* @return true if there is an integer k that occurs \n* in both arrays; otherwise returns false \n* Precondition: \n* v[0]..v[N-1] and w[0]..w[M-1] initialized with integers. \n* v[0] < v[1] < .. < v[N-1] and w[0] < w[1] < .. < w[M-1]. \n*\/ \npublic static boolean match(int[] v, int[] w, int N, int M) \n{ \n    int vIndex = 0, wIndex = 0; \n    while (vIndex < N && wIndex < M) \n    { \n        if (v[vIndex] == w[wIndex]) \n            return true; \n        else if (v[vIndex] < w[wIndex]) \n            vIndex++; \n        else \n            wIndex++; \n    } \n    return false; \n} \n\nAssuming that the method has not been exited, which assertion is true at the end of every execution of the while loop? \nCorrect: v[0]..v[vIndex-1] and w[0]..w[wIndex-1] contain no common value,\nvIndex ≤ N and wIndex ≤ M. \nIncorrect: v[0]..v[vIndex] and w[0]..w[wIndex] contain no common value,\nvIndex ≤ N and wIndex ≤ M. \nIncorrect: v[0]..v[vIndex-1] and w[0]..w[wIndex-1] contain no common value,\nvIndex ≤ N-1 and wIndex ≤ M-1. \nIncorrect: v[0]..v[vIndex] and w[0]..w[wIndex] contain no common value,\nvIndex ≤ N-1 and wIndex ≤ M-1. \nIncorrect: v[0]..v[N-1] and w[0]..w[M-1] contain no common value,\nvIndex ≤ N and wIndex ≤ M.\n\nEND"}
{"prompt":"Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    \/** constructor *\/\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    \/** Write contents of Deck. *\/\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    \/** Swap arr[i] and arr[j] in array arr. *\/\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    \/**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     *\/\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            \/\/ generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards—deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    \/** constructor *\/\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    \/** Shuffle the Decks. *\/\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    \/** Write contents of all the Decks. *\/\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it’s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\n###\n\n","completion":" Question: Consider this class: \n\npublic class Book {\n    private String title;\n    private String author;\n    private boolean checkoutStatus;\n\n    public Book(String bookTitle, String bookAuthor) {\n        title = bookTitle;\n        author = bookAuthor;\n        checkoutStatus = false;\n    }\n\n    \/** Change checkout status. *\/\n    public void changeStatus() {\n        checkoutStatus = !checkoutStatus;\n    }\n    \n    \/\/ Other methods are not shown.\n}\n\nA client program has this declaration: \n\nBook[] bookList = new Book[SOME_NUMBER]; \n\nSuppose bookList is initialized so that each Book in the list has a title, author, and checkout status. The following piece of code is written, whose intent is to change the checkout status of each book in bookList. \n\nfor (Book b : bookList) \n    b.changeStatus(); \n\nWhich is true about this code? \nCorrect: Each book in the bookList array will have its checkout status changed, as intended.\nIncorrect: The bookList array will remain unchanged after execution.\nIncorrect: A NullPointerException may occur.\nIncorrect: A run-time error will occur because it is not possible to modify objects using the for-each loop.\nIncorrect: A logic error will occur because it is not possible to modify objects in an array without accessing the indexes of the objects.\n\nEND"}
{"prompt":"Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    \/** constructor *\/\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    \/** Write contents of Deck. *\/\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    \/** Swap arr[i] and arr[j] in array arr. *\/\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    \/**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     *\/\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            \/\/ generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards—deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    \/** constructor *\/\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    \/** Shuffle the Decks. *\/\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    \/** Write contents of all the Decks. *\/\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it’s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\n###\n\n","completion":" Question: Consider the BingoCard class defined below:\n\npublic class BingoCard {\n    private int[] card;\n\n    \/**\n     * Default constructor: Creates BingoCard with\n     * 20 random digits in the range 1 - 90.\n     *\/\n    public BingoCard() { \/* implementation not shown *\/ }\n\n    \/* Display BingoCard. *\/\n    public void display() { \/* implementation not shown *\/ }\n    \n    ...\n}\n\nA program that simulates a bingo game declares an array of BingoCard. The array has NUMPLAYERS elements, where each element represents the card of a different player. Here is a code segment that creates all the bingo cards in the game: \n\/* declare array of BingoCard *\/ \n\/* construct each BingoCard *\/ \n\nWhich of the following is a correct replacement for \n\/* declare array of BingoCard *\/? \nCorrect: BingoCard[] players = new BingoCard[NUMPLAYERS];\nIncorrect: int[] BingoCard = new BingoCard[NUMPLAYERS];\nIncorrect: BingoCard[] players = new int[NUMPLAYERS];\nIncorrect: BingoCard[] players = new BingoCard[20];\nIncorrect: int[] players = new BingoCard[NUMPLAYERS];\n\nEND"}
{"prompt":"Consider a simple Deck class in which a deck of cards is represented by the integers 0 to 51.\n\npublic class Deck {\n    private int[] deck;\n    public static final int NUMCARDS = 52;\n\n    \/** constructor *\/\n    public Deck() {\n        deck = new int[NUMCARDS];\n        for (int i = 0; i < NUMCARDS; i++)\n            deck[i] = i;\n    }\n\n    \/** Write contents of Deck. *\/\n    public void writeDeck() {\n        for (int card : deck)\n            System.out.print(card + \" \");\n        System.out.println();\n        System.out.println();\n    }\n\n    \/** Swap arr[i] and arr[j] in array arr. *\/\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    \/**\n     * Shuffle Deck: Generate a random permutation by picking a\n     * random card from those remaining and putting it in the\n     * next slot, starting from the right.\n     *\/\n    public void shuffle() {\n        int index;\n        for (int i = NUMCARDS - 1; i > 0; i--) {\n            \/\/ generate an int from 0 to i\n            index = (int) (Math.random() * (i + 1));\n            swap(deck, i, index);\n        }\n    }\n}\n\nHere is a simple driver class that tests the Deck class:\n\npublic class DeckMain {\n    public static void main(String args[]) {\n        Deck d = new Deck();\n        d.shuffle();\n        d.writeDeck();\n    }\n}\n\nNOTE\nThere is no evidence of the array that holds the deck of cards—deck is a private instance variable and is therefore invisible to clients of the Deck class.\nSuppose a large card tournament needs to keep track of many decks. The code to do this could be implemented with an array of Deck:\n\npublic class ManyDecks {\n    private Deck[] allDecks;\n    public static final int NUMDECKS = 500;\n\n    \/** constructor *\/\n    public ManyDecks() {\n        allDecks = new Deck[NUMDECKS];\n        for (int i = 0; i < NUMDECKS; i++)\n            allDecks[i] = new Deck();\n    }\n\n    \/** Shuffle the Decks. *\/\n    public void shuffleAll() {\n        for (Deck d : allDecks)\n            d.shuffle();\n    }\n\n    \/** Write contents of all the Decks. *\/\n    public void printDecks() {\n        for (Deck d : allDecks)\n            d.writeDeck();\n    }\n}\n\nNOTE\n1. The statement\nallDecks = new Deck[NUMDECKS];\ncreates an array, allDecks, of 500 Deck objects. The default initialization for these Deck objects is null. In order to initialize them with actual decks, the Deck constructor must be called for each array element. This is achieved with the for loop of the ManyDecks constructor.\n2. In the shuffleAll method, it’s OK to use a for-each loop to modify each deck in the array with the mutator method shuffle.\n\n\n###\n\n","completion":" Question: Consider the BingoCard class defined below:\n\npublic class BingoCard {\n    private int[] card;\n\n    \/**\n     * Default constructor: Creates BingoCard with\n     * 20 random digits in the range 1 - 90.\n     *\/\n    public BingoCard() { \/* implementation not shown *\/ }\n\n    \/* Display BingoCard. *\/\n    public void display() { \/* implementation not shown *\/ }\n    \n    ...\n}\n\nA program that simulates a bingo game declares an array of BingoCard. The array has NUMPLAYERS elements, where each element represents the card of a different player. Here is a code segment that creates all the bingo cards in the game: \n\/* declare array of BingoCard *\/ \n\/* construct each BingoCard *\/ \n\nAssuming that players has been declared as an array of BingoCard, which of the following is a correct replacement for \n\/* construct each BingoCard *\/ \nI for (BingoCard card : players) \n    card = new BingoCard(); \nII for (BingoCard card : players) \n    players[card] = new BingoCard(); \nIII for (int i = 0; i < players.length; i++) \n    players[i] = new BingoCard(); \nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"A class that implements the List<E> interface—ArrayList<E>, for example—is a list of elements of type E. In a list, duplicate elements are allowed. The elements of the list are indexed, with 0 being the index of the first element.\nA list allows you to\n• Access an element at any position in the list using its integer index.\n• Insert an element anywhere in the list.\n• Iterate over all elements using ListIterator or Iterator (not in the AP subset).\n\nHere are the methods you should know.\nboolean add(E obj)\nAppends obj to the end of the list. Always returns true. If the specified element is not of type E, throws a ClassCastException.\nint size()\nReturns the number of elements in the list.\nE get(int index)\nReturns the element at the specified index in the list.\nE set(int index, E element)\nReplaces item at specified index in the list with specified element. Returns the element that was previously at index. Throws a ClassCastException if the specified element is not of type E.\nvoid add(int index, E element)\nInserts element at specified index. Elements from position index and higher have 1 added to their indices. Size of list is incremented by 1.\nE remove(int index)\nRemoves and returns the element at the specified index. Elements to the right of position index have 1 subtracted from their indices. Size of list is decreased by 1.\nIterator<E> iterator()\nReturns an iterator over the elements in the list, in proper sequence, starting at the first element.\n\n\n###\n\n","completion":" Question: Which declaration will cause an error? \nI List<String> stringList = new ArrayList<String>(); \nII List<int> intList = new ArrayList<int>(); \nIII ArrayList<String> compList = new ArrayList<String>(); \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and III only\nIncorrect: II and III only\n\nEND"}
{"prompt":"A class that implements the List<E> interface—ArrayList<E>, for example—is a list of elements of type E. In a list, duplicate elements are allowed. The elements of the list are indexed, with 0 being the index of the first element.\nA list allows you to\n• Access an element at any position in the list using its integer index.\n• Insert an element anywhere in the list.\n• Iterate over all elements using ListIterator or Iterator (not in the AP subset).\n\nHere are the methods you should know.\nboolean add(E obj)\nAppends obj to the end of the list. Always returns true. If the specified element is not of type E, throws a ClassCastException.\nint size()\nReturns the number of elements in the list.\nE get(int index)\nReturns the element at the specified index in the list.\nE set(int index, E element)\nReplaces item at specified index in the list with specified element. Returns the element that was previously at index. Throws a ClassCastException if the specified element is not of type E.\nvoid add(int index, E element)\nInserts element at specified index. Elements from position index and higher have 1 added to their indices. Size of list is incremented by 1.\nE remove(int index)\nRemoves and returns the element at the specified index. Elements to the right of position index have 1 subtracted from their indices. Size of list is decreased by 1.\nIterator<E> iterator()\nReturns an iterator over the elements in the list, in proper sequence, starting at the first element.\n\n\n###\n\n","completion":" Question: Consider these declarations: \n\nList<String> strList = new ArrayList<String>(); \nString ch = \" \"; \nInteger intOb = new Integer(5); \n\nWhich statement will cause an error? \nCorrect: strList.add(intOb + 8);\n\n\nIncorrect: strList.add(ch);\nIncorrect: strList.add(new String(\"handy andy\"));\nIncorrect: strList.add(intOb.toString());\nIncorrect: strList.add(ch + 8);END"}
{"prompt":"This is an array implementation of the List<E> interface. The main difference between an array and an ArrayList is that an ArrayList is resizable during run time, whereas an array has a fixed size at construction.\nShifting of elements, if any, caused by insertion or deletion, is handled automatically by ArrayList. Operations to insert or delete at the end of the list are very efficient. Be aware, however, that at some point there will be a resizing; but, on average, over time, an insertion at the end of the list is a single, quick operation. In general, insertion or deletion in the middle of an ArrayList requires elements to be shifted to accommodate a new element (add), or to close a “hole” (remove).\n\nTHE METHODS OF ArrayList<E>\nIn addition to the two add methods, and size, get, set, and remove, you must know the following constructor.\nArrayList()\nConstructs an empty list.\n\nNOTE\nEach method above that has an index parameter—add, get, remove, and set—throws an IndexOutOfBoundsException if index is out of range. For get, remove, and set, index is out of range if\nindex < 0 || index >= size()\nFor add, however, it is OK to add an element at the end of the list. Therefore index is out of range if\nindex < 0 || index > size()\n\nUsing ArrayList<E>\nExample 1\n\/\/Create an ArrayList containing 0 1 4 9.\nList<Integer> list = new ArrayList<Integer>(); \/\/An ArrayList is-a List\nfor (int i = 0; i < 4; i++)\n    list.add(i * i); \/\/example of auto-boxing\n\/\/i*i wrapped in an Integer before insertion\nInteger intOb = list.get(2); \/\/assigns Integer with value 4 to intOb.\n\/\/Leaves list unchanged.\nint n = list.get(3); \/\/example of auto-unboxing\n\/\/Integer is retrieved and converted to int\n\/\/n contains 9\nInteger x = list.set(3, 5); \/\/list is 0 1 4 5\n\/\/x contains Integer with value 9\nx = list.remove(2);\n\/\/list is 0 1 5\n\/\/x contains Integer with value 4\nlist.add(1, 7);\n\/\/list is 0 7 1 5\nlist.add(2, 8);\n\/\/list is 0 7 8 1 5\n\nExample 2\n\/\/Traversing an ArrayList of Integer.\n\/\/Print the elements of list, one per line.\nfor (Integer num : list)\n    System.out.println(num);\n\nExample 3\n\/** Precondition: List list is an ArrayList that contains Integer\n* values sorted in increasing order.\n* Postcondition: value inserted in its correct position in list.\n*\/\npublic static void insert(List<Integer> list, Integer value)\n{\n    int index = 0;\n    \/\/find insertion point\n    while (index < list.size() &&\n        value.compareTo(list.get(index)) > 0)\n        index++;\n    \/\/insert value\n    list.add(index, value);\n}\n\nNOTE\nSuppose value is larger than all the elements in list. Then the insert method will throw an IndexOutOfBoundsException if the first part of the test is omitted, namely index < list.size().\n\nExample 4\n\/** @return an ArrayList of random integers from 0 to 100 *\/\npublic static List<Integer> getRandomIntList()\n{\n    List<Integer> list = new ArrayList<Integer>();\n    System.out.print(\"How many integers? \");\n    int length = IO.readInt(); \/\/read user input\n    for (int i = 0; i < length; i++)\n    {\n        int newNum = (int) (Math.random() * 101);\n        list.add(new Integer(newNum));\n    }\n    return list;\n}\n\nNOTE\n1. The variable list is declared to be of type List<Integer> (the interface) but is instantiated as type ArrayList<Integer> (the implementation).\n2. The add method in getRandomIntList is the List method that appends its parameter to the end of the list.\n\nExample 5\n\/** Swap two values in list, indexed at i and j. *\/\npublic static void swap(List<E> list, int i, int j)\n{\n    E temp = list.get(i);\n    list.set(i, list.get(j));\n    list.set(j, temp);\n}\n\nExample 6\n\/** Print all negatives in list a.\n* Precondition: a contains Integer values.\n*\/\npublic static void printNegs(List<Integer> a)\n{\n    System.out.println(\"The negative values in the list are: \");\n    for (Integer i : a)\n        if (i.intValue() < 0)\n            System.out.println(i);\n}\n\nExample 7\n\/** Change every even-indexed element of strList to the empty string.\n* Precondition: strList contains String values.\n*\/\npublic static void changeEvenToEmpty(List<String> strList)\n{\n    boolean even = true;\n    int index = 0;\n    while (index < strList.size())\n    {\n        if (even)\n            strList.set(index, \"\");\n        index++;\n        even = !even;\n    }\n}\n\n\n###\n\n","completion":" Question: Let list be an ArrayList<Integer> containing these elements: \n2 5 7 6 0 1 \nWhich of the following statements would not cause an error to occur? Assume that each statement applies to the given list, independent of the other statements. \nCorrect: list.add(6, 9);\nIncorrect: Object ob = list.get(6);\nIncorrect: Integer intOb = list.add(3.4);\nIncorrect: Object x = list.remove(6);\nIncorrect: Object y = list.set(6, 8);\n\nEND"}
{"prompt":"A class that implements the List<E> interface—ArrayList<E>, for example—is a list of elements of type E. In a list, duplicate elements are allowed. The elements of the list are indexed, with 0 being the index of the first element.\nA list allows you to\n• Access an element at any position in the list using its integer index.\n• Insert an element anywhere in the list.\n• Iterate over all elements using ListIterator or Iterator (not in the AP subset).\n\nHere are the methods you should know.\nboolean add(E obj)\nAppends obj to the end of the list. Always returns true. If the specified element is not of type E, throws a ClassCastException.\nint size()\nReturns the number of elements in the list.\nE get(int index)\nReturns the element at the specified index in the list.\nE set(int index, E element)\nReplaces item at specified index in the list with specified element. Returns the element that was previously at index. Throws a ClassCastException if the specified element is not of type E.\nvoid add(int index, E element)\nInserts element at specified index. Elements from position index and higher have 1 added to their indices. Size of list is incremented by 1.\nE remove(int index)\nRemoves and returns the element at the specified index. Elements to the right of position index have 1 subtracted from their indices. Size of list is decreased by 1.\nIterator<E> iterator()\nReturns an iterator over the elements in the list, in proper sequence, starting at the first element.\n\n\n###\n\n","completion":" Question: Refer to method insert below: \n\n\/** @param list an ArrayList of String objects \n* @param element a String object \n* Precondition: list contains String values sorted \n* in decreasing order. \n* Postcondition: element inserted in its correct position in list. \n*\/ \npublic void insert(List<String> list, String element) \n{ \n    int index = 0; \n    while (element.compareTo(list.get(index)) < 0) \n        index++; \n    list.add(index, element); \n} \n\nAssuming that the type of element is compatible with the objects in the list, which is a true statement about the insert method? \nCorrect: It fails if element is smaller than the last item in list and works in all other cases.\nIncorrect: It works as intended for all values of element.\nIncorrect: It fails for all values of element.\nIncorrect: It fails if element is greater than the first item in list and works in all other cases.\nIncorrect: It fails if element is either greater than the first item or smaller than the last item in list and works in all other cases.\n\nEND"}
{"prompt":"This is an array implementation of the List<E> interface. The main difference between an array and an ArrayList is that an ArrayList is resizable during run time, whereas an array has a fixed size at construction.\nShifting of elements, if any, caused by insertion or deletion, is handled automatically by ArrayList. Operations to insert or delete at the end of the list are very efficient. Be aware, however, that at some point there will be a resizing; but, on average, over time, an insertion at the end of the list is a single, quick operation. In general, insertion or deletion in the middle of an ArrayList requires elements to be shifted to accommodate a new element (add), or to close a “hole” (remove).\n\nTHE METHODS OF ArrayList<E>\nIn addition to the two add methods, and size, get, set, and remove, you must know the following constructor.\nArrayList()\nConstructs an empty list.\n\nNOTE\nEach method above that has an index parameter—add, get, remove, and set—throws an IndexOutOfBoundsException if index is out of range. For get, remove, and set, index is out of range if\nindex < 0 || index >= size()\nFor add, however, it is OK to add an element at the end of the list. Therefore index is out of range if\nindex < 0 || index > size()\n\nUsing ArrayList<E>\nExample 1\n\/\/Create an ArrayList containing 0 1 4 9.\nList<Integer> list = new ArrayList<Integer>(); \/\/An ArrayList is-a List\nfor (int i = 0; i < 4; i++)\n    list.add(i * i); \/\/example of auto-boxing\n\/\/i*i wrapped in an Integer before insertion\nInteger intOb = list.get(2); \/\/assigns Integer with value 4 to intOb.\n\/\/Leaves list unchanged.\nint n = list.get(3); \/\/example of auto-unboxing\n\/\/Integer is retrieved and converted to int\n\/\/n contains 9\nInteger x = list.set(3, 5); \/\/list is 0 1 4 5\n\/\/x contains Integer with value 9\nx = list.remove(2);\n\/\/list is 0 1 5\n\/\/x contains Integer with value 4\nlist.add(1, 7);\n\/\/list is 0 7 1 5\nlist.add(2, 8);\n\/\/list is 0 7 8 1 5\n\nExample 2\n\/\/Traversing an ArrayList of Integer.\n\/\/Print the elements of list, one per line.\nfor (Integer num : list)\n    System.out.println(num);\n\nExample 3\n\/** Precondition: List list is an ArrayList that contains Integer\n* values sorted in increasing order.\n* Postcondition: value inserted in its correct position in list.\n*\/\npublic static void insert(List<Integer> list, Integer value)\n{\n    int index = 0;\n    \/\/find insertion point\n    while (index < list.size() &&\n        value.compareTo(list.get(index)) > 0)\n        index++;\n    \/\/insert value\n    list.add(index, value);\n}\n\nNOTE\nSuppose value is larger than all the elements in list. Then the insert method will throw an IndexOutOfBoundsException if the first part of the test is omitted, namely index < list.size().\n\nExample 4\n\/** @return an ArrayList of random integers from 0 to 100 *\/\npublic static List<Integer> getRandomIntList()\n{\n    List<Integer> list = new ArrayList<Integer>();\n    System.out.print(\"How many integers? \");\n    int length = IO.readInt(); \/\/read user input\n    for (int i = 0; i < length; i++)\n    {\n        int newNum = (int) (Math.random() * 101);\n        list.add(new Integer(newNum));\n    }\n    return list;\n}\n\nNOTE\n1. The variable list is declared to be of type List<Integer> (the interface) but is instantiated as type ArrayList<Integer> (the implementation).\n2. The add method in getRandomIntList is the List method that appends its parameter to the end of the list.\n\nExample 5\n\/** Swap two values in list, indexed at i and j. *\/\npublic static void swap(List<E> list, int i, int j)\n{\n    E temp = list.get(i);\n    list.set(i, list.get(j));\n    list.set(j, temp);\n}\n\nExample 6\n\/** Print all negatives in list a.\n* Precondition: a contains Integer values.\n*\/\npublic static void printNegs(List<Integer> a)\n{\n    System.out.println(\"The negative values in the list are: \");\n    for (Integer i : a)\n        if (i.intValue() < 0)\n            System.out.println(i);\n}\n\nExample 7\n\/** Change every even-indexed element of strList to the empty string.\n* Precondition: strList contains String values.\n*\/\npublic static void changeEvenToEmpty(List<String> strList)\n{\n    boolean even = true;\n    int index = 0;\n    while (index < strList.size())\n    {\n        if (even)\n            strList.set(index, \"\");\n        index++;\n        even = !even;\n    }\n}\n\n\n###\n\n","completion":" Question: Consider the following code segment, applied to list, an ArrayList of Integer values. \n\nint len = list.size(); \nfor (int i = 0; i < len; i++) \n{ \n    list.add(i + 1, new Integer(i)); \n    Object x = list.set(i, new Integer(i + 2)); \n} \n\nIf list is initially 6 1 8, what will it be following execution of the code segment? \nCorrect: 2 3 4 2 1 8\nIncorrect: 2 3 4 6 2 2 0 1 8\nIncorrect: 2 3 4 0 1 2\nIncorrect: 2 3 4 6 1 8\nIncorrect: 2 3 3 2\n\nEND"}
{"prompt":"This is an array implementation of the List<E> interface. The main difference between an array and an ArrayList is that an ArrayList is resizable during run time, whereas an array has a fixed size at construction.\nShifting of elements, if any, caused by insertion or deletion, is handled automatically by ArrayList. Operations to insert or delete at the end of the list are very efficient. Be aware, however, that at some point there will be a resizing; but, on average, over time, an insertion at the end of the list is a single, quick operation. In general, insertion or deletion in the middle of an ArrayList requires elements to be shifted to accommodate a new element (add), or to close a “hole” (remove).\n\nTHE METHODS OF ArrayList<E>\nIn addition to the two add methods, and size, get, set, and remove, you must know the following constructor.\nArrayList()\nConstructs an empty list.\n\nNOTE\nEach method above that has an index parameter—add, get, remove, and set—throws an IndexOutOfBoundsException if index is out of range. For get, remove, and set, index is out of range if\nindex < 0 || index >= size()\nFor add, however, it is OK to add an element at the end of the list. Therefore index is out of range if\nindex < 0 || index > size()\n\nUsing ArrayList<E>\nExample 1\n\/\/Create an ArrayList containing 0 1 4 9.\nList<Integer> list = new ArrayList<Integer>(); \/\/An ArrayList is-a List\nfor (int i = 0; i < 4; i++)\n    list.add(i * i); \/\/example of auto-boxing\n\/\/i*i wrapped in an Integer before insertion\nInteger intOb = list.get(2); \/\/assigns Integer with value 4 to intOb.\n\/\/Leaves list unchanged.\nint n = list.get(3); \/\/example of auto-unboxing\n\/\/Integer is retrieved and converted to int\n\/\/n contains 9\nInteger x = list.set(3, 5); \/\/list is 0 1 4 5\n\/\/x contains Integer with value 9\nx = list.remove(2);\n\/\/list is 0 1 5\n\/\/x contains Integer with value 4\nlist.add(1, 7);\n\/\/list is 0 7 1 5\nlist.add(2, 8);\n\/\/list is 0 7 8 1 5\n\nExample 2\n\/\/Traversing an ArrayList of Integer.\n\/\/Print the elements of list, one per line.\nfor (Integer num : list)\n    System.out.println(num);\n\nExample 3\n\/** Precondition: List list is an ArrayList that contains Integer\n* values sorted in increasing order.\n* Postcondition: value inserted in its correct position in list.\n*\/\npublic static void insert(List<Integer> list, Integer value)\n{\n    int index = 0;\n    \/\/find insertion point\n    while (index < list.size() &&\n        value.compareTo(list.get(index)) > 0)\n        index++;\n    \/\/insert value\n    list.add(index, value);\n}\n\nNOTE\nSuppose value is larger than all the elements in list. Then the insert method will throw an IndexOutOfBoundsException if the first part of the test is omitted, namely index < list.size().\n\nExample 4\n\/** @return an ArrayList of random integers from 0 to 100 *\/\npublic static List<Integer> getRandomIntList()\n{\n    List<Integer> list = new ArrayList<Integer>();\n    System.out.print(\"How many integers? \");\n    int length = IO.readInt(); \/\/read user input\n    for (int i = 0; i < length; i++)\n    {\n        int newNum = (int) (Math.random() * 101);\n        list.add(new Integer(newNum));\n    }\n    return list;\n}\n\nNOTE\n1. The variable list is declared to be of type List<Integer> (the interface) but is instantiated as type ArrayList<Integer> (the implementation).\n2. The add method in getRandomIntList is the List method that appends its parameter to the end of the list.\n\nExample 5\n\/** Swap two values in list, indexed at i and j. *\/\npublic static void swap(List<E> list, int i, int j)\n{\n    E temp = list.get(i);\n    list.set(i, list.get(j));\n    list.set(j, temp);\n}\n\nExample 6\n\/** Print all negatives in list a.\n* Precondition: a contains Integer values.\n*\/\npublic static void printNegs(List<Integer> a)\n{\n    System.out.println(\"The negative values in the list are: \");\n    for (Integer i : a)\n        if (i.intValue() < 0)\n            System.out.println(i);\n}\n\nExample 7\n\/** Change every even-indexed element of strList to the empty string.\n* Precondition: strList contains String values.\n*\/\npublic static void changeEvenToEmpty(List<String> strList)\n{\n    boolean even = true;\n    int index = 0;\n    while (index < strList.size())\n    {\n        if (even)\n            strList.set(index, \"\");\n        index++;\n        even = !even;\n    }\n}\n\n\n###\n\n","completion":" Question: Consider the Coin and Purse classes defined below:\n\n\/* A simple coin class *\/\npublic class Coin {\n    private double value;\n    private String name;\n\n    \/\/ constructor\n    public Coin(double coinValue, String coinName) {\n        value = coinValue;\n        name = coinName;\n    }\n\n    \/** @return the value of this coin *\/\n    public double getValue() { return value; }\n\n    \/** @return the name of this coin *\/\n    public String getName() { return name; }\n\n    \/**\n     * @param obj a Coin object\n     * @return true if this coin equals obj; otherwise false\n     *\/\n    public boolean equals(Object obj) { return name.equals(((Coin) obj).name); }\n    \n    \/\/ Other methods are not shown.\n}\n\n\/* A purse holds a collection of coins *\/\npublic class Purse {\n    private List<Coin> coins;\n\n    \/** Creates an empty purse. *\/\n    public Purse() { coins = new ArrayList<Coin>(); }\n\n    \/**\n     * Adds aCoin to the purse.\n     * \n     * @param aCoin the coin to be added to the purse\n     *\/\n    public void add(Coin aCoin) { coins.add(aCoin); }\n\n    \/** @return the total value of coins in purse *\/\n    public double getTotal() { \/* implementation not shown *\/ }\n}\n\nHere is the getTotal method from the Purse class: \n\n\/** @return the total value of coins in purse *\/ \npublic double getTotal() \n    { \n    double total = 0; \n    \/* more code *\/ \n    return total; \n} \n\nWhich of the following is a correct replacement for \/* more code *\/? \nCorrect: for (Coin c : coins)\n{ \n    total += c.getValue(); \n}\n\n\nIncorrect: for (Coin c : coins)\n{ \n    c = coins.get(i); \n    total += c.getValue(); \n} \nIncorrect: for (Coin c : coins)\n{ \n    Coin value = c.getValue(); \n    total += value; \n} \nIncorrect: for (Coin c : coins)\n{ \n    Coin c = coins.get(i); \n    total += c.getValue(); \n} \nIncorrect: for (Coin c : coins)\n{ \n    total += coins.getValue(); \n} END"}
{"prompt":"This is an array implementation of the List<E> interface. The main difference between an array and an ArrayList is that an ArrayList is resizable during run time, whereas an array has a fixed size at construction.\nShifting of elements, if any, caused by insertion or deletion, is handled automatically by ArrayList. Operations to insert or delete at the end of the list are very efficient. Be aware, however, that at some point there will be a resizing; but, on average, over time, an insertion at the end of the list is a single, quick operation. In general, insertion or deletion in the middle of an ArrayList requires elements to be shifted to accommodate a new element (add), or to close a “hole” (remove).\n\nTHE METHODS OF ArrayList<E>\nIn addition to the two add methods, and size, get, set, and remove, you must know the following constructor.\nArrayList()\nConstructs an empty list.\n\nNOTE\nEach method above that has an index parameter—add, get, remove, and set—throws an IndexOutOfBoundsException if index is out of range. For get, remove, and set, index is out of range if\nindex < 0 || index >= size()\nFor add, however, it is OK to add an element at the end of the list. Therefore index is out of range if\nindex < 0 || index > size()\n\nUsing ArrayList<E>\nExample 1\n\/\/Create an ArrayList containing 0 1 4 9.\nList<Integer> list = new ArrayList<Integer>(); \/\/An ArrayList is-a List\nfor (int i = 0; i < 4; i++)\n    list.add(i * i); \/\/example of auto-boxing\n\/\/i*i wrapped in an Integer before insertion\nInteger intOb = list.get(2); \/\/assigns Integer with value 4 to intOb.\n\/\/Leaves list unchanged.\nint n = list.get(3); \/\/example of auto-unboxing\n\/\/Integer is retrieved and converted to int\n\/\/n contains 9\nInteger x = list.set(3, 5); \/\/list is 0 1 4 5\n\/\/x contains Integer with value 9\nx = list.remove(2);\n\/\/list is 0 1 5\n\/\/x contains Integer with value 4\nlist.add(1, 7);\n\/\/list is 0 7 1 5\nlist.add(2, 8);\n\/\/list is 0 7 8 1 5\n\nExample 2\n\/\/Traversing an ArrayList of Integer.\n\/\/Print the elements of list, one per line.\nfor (Integer num : list)\n    System.out.println(num);\n\nExample 3\n\/** Precondition: List list is an ArrayList that contains Integer\n* values sorted in increasing order.\n* Postcondition: value inserted in its correct position in list.\n*\/\npublic static void insert(List<Integer> list, Integer value)\n{\n    int index = 0;\n    \/\/find insertion point\n    while (index < list.size() &&\n        value.compareTo(list.get(index)) > 0)\n        index++;\n    \/\/insert value\n    list.add(index, value);\n}\n\nNOTE\nSuppose value is larger than all the elements in list. Then the insert method will throw an IndexOutOfBoundsException if the first part of the test is omitted, namely index < list.size().\n\nExample 4\n\/** @return an ArrayList of random integers from 0 to 100 *\/\npublic static List<Integer> getRandomIntList()\n{\n    List<Integer> list = new ArrayList<Integer>();\n    System.out.print(\"How many integers? \");\n    int length = IO.readInt(); \/\/read user input\n    for (int i = 0; i < length; i++)\n    {\n        int newNum = (int) (Math.random() * 101);\n        list.add(new Integer(newNum));\n    }\n    return list;\n}\n\nNOTE\n1. The variable list is declared to be of type List<Integer> (the interface) but is instantiated as type ArrayList<Integer> (the implementation).\n2. The add method in getRandomIntList is the List method that appends its parameter to the end of the list.\n\nExample 5\n\/** Swap two values in list, indexed at i and j. *\/\npublic static void swap(List<E> list, int i, int j)\n{\n    E temp = list.get(i);\n    list.set(i, list.get(j));\n    list.set(j, temp);\n}\n\nExample 6\n\/** Print all negatives in list a.\n* Precondition: a contains Integer values.\n*\/\npublic static void printNegs(List<Integer> a)\n{\n    System.out.println(\"The negative values in the list are: \");\n    for (Integer i : a)\n        if (i.intValue() < 0)\n            System.out.println(i);\n}\n\nExample 7\n\/** Change every even-indexed element of strList to the empty string.\n* Precondition: strList contains String values.\n*\/\npublic static void changeEvenToEmpty(List<String> strList)\n{\n    boolean even = true;\n    int index = 0;\n    while (index < strList.size())\n    {\n        if (even)\n            strList.set(index, \"\");\n        index++;\n        even = !even;\n    }\n}\n\n\n###\n\n","completion":" Question: Consider the Coin and Purse classes defined below:\n\n\/* A simple coin class *\/\npublic class Coin {\n    private double value;\n    private String name;\n\n    \/\/ constructor\n    public Coin(double coinValue, String coinName) {\n        value = coinValue;\n        name = coinName;\n    }\n\n    \/** @return the value of this coin *\/\n    public double getValue() { return value; }\n\n    \/** @return the name of this coin *\/\n    public String getName() { return name; }\n\n    \/**\n     * @param obj a Coin object\n     * @return true if this coin equals obj; otherwise false\n     *\/\n    public boolean equals(Object obj) { return name.equals(((Coin) obj).name); }\n    \n    \/\/ Other methods are not shown.\n}\n\n\/* A purse holds a collection of coins *\/\npublic class Purse {\n    private List<Coin> coins;\n\n    \/** Creates an empty purse. *\/\n    public Purse() { coins = new ArrayList<Coin>(); }\n\n    \/**\n     * Adds aCoin to the purse.\n     * \n     * @param aCoin the coin to be added to the purse\n     *\/\n    public void add(Coin aCoin) { coins.add(aCoin); }\n\n    \/** @return the total value of coins in purse *\/\n    public double getTotal() { \/* implementation not shown *\/ }\n}\n\nTwo coins are said to match each other if they have the same name or the same value. You may assume that coins with the same name have the same value and coins with the same value have the same name. A boolean method find is added to the Purse class: \n\n\/** @return true if the purse has a coin that matches aCoin, \n* false otherwise \n*\/ \npublic boolean find(Coin aCoin) \n{ \n    for (Coin c : coins) \n    { \n        \/* code to find match *\/ \n    } \n    return false; \n} \n\nWhich is a correct replacement for \/* code to find match *\/? \nI if (c.equals(aCoin)) \n    return true; \nII if ((c.getName()).equals(aCoin.getName())) \n    return true; \nIII if ((c.getValue()).equals(aCoin.getValue())) \n    return true; \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"A two-dimensional array (matrix) is often the data structure of choice for objects like board games, tables of values, theater seats, and mazes.\nLook at the following 3 × 4 matrix:\n2 6 8 7\n1 5 4 0\n9 3 2 8\n\nIf mat is the matrix variable, the row subscripts go from 0 to 2 and the column sub scripts go from 0 to 3. The element mat[1][2] is 4, whereas mat[0][2] and mat[2][3] are both 8. As with one-dimensional arrays, if the subscripts are out of range, an ArrayIndexOutOfBoundsException is thrown.\n\nEach of the following declares a two-dimensional array:\nint[][] table; \/\/table can reference a 2-D array of integers\n\/\/table is currently a null reference\ndouble[][] matrix = new double[3][4]; \/\/matrix references a 3 × 4\n\/\/array of real numbers.\n\/\/Each element has value 0.0\nString[][] strs = new String[2][5]; \/\/strs references a 2 × 5\n\/\/array of String objects.\n\/\/Each element is null\nAn initializer list can be used to specify a two-dimensional array:\nint[][] mat = { {3, 4, 5}, \/\/row 0\n{6, 7, 8} }; \/\/row 1\nThis defines a 2×3 rectangular array (i.e., one in which each row has the same number of elements).\nThe initializer list is a list of lists in which each inside list represents a row of the matrix.\nA matrix is implemented as an array of rows, where each row is a one-dimensional array of elements. Suppose mat is the 3 × 4 matrix\n2 6 8 7\n1 5 4 0\n9 3 2 8\nThen mat is an array of three arrays:\nmat[0] contains {2, 6, 8, 7}\nmat[1] contains {1, 5, 4, 0}\nmat[2] contains {9, 3, 2, 8}\nThe quantity mat.length represents the number of rows. In this case it equals 3 because there are three row-arrays in mat. For any given row k, where 0 ≤ k < mat.length, the quantity mat[k].length represents the number of elements in that row, namely the number of columns. ( Java allows a variable number of elements in each row. Since these “jagged arrays” are not part of the AP Java subset, you can assume that mat[k].length is the same for all rows k of the matrix, i.e., that the matrix is rectangular.)\n\n\n###\n\n","completion":" Question: Which of the following initializes an 8 × 10 matrix with integer values that are perfect squares? (0 is a perfect square.) \nI int[][] mat = new int[8][10]; \nII int[][] mat = new int[8][10]; \nfor (int r = 0; r < mat.length; r++) \n    for (int c = 0; c < mat[r].length; c++) \n        mat[r][c] = r * r; \nIII int[][] mat = new int[8][10]; \nfor (int c = 0; c < mat[r].length; c++) \n    for (int r = 0; r < mat.length; r++) \n        mat[r][c] = c * c; \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"There are three common ways to traverse a two-dimensional array:\n• row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n• for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n• row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n\/** Precondition: mat is initialized with integer values. *\/\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) \/\/for each row array in mat\n    for (int element : row) \/\/for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n\/** @return the sum of integers in arr *\/\npublic int sumArray(int[] arr)\n{ \/* implementation not shown *\/ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) \/\/for each row in mat,\n    sum += sumArray(mat[row]); \/\/add that row’s total to sum\n\nNote how, since mat[row] is an array of int for 0 ≤ row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 ≤ k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n\/** Add 10 to each int in arr *\/\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) \/\/for each row array in cardMatrix,\n    for (Card c : row) \/\/for each Card in that row,\n        c.changeValue(v); \/\/change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can’t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; \/\/SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; \/\/major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; \/\/minor diagonal\n\n\n###\n\n","completion":" Question: Consider a class that has this private instance variable: \nprivate int[][] mat; \n\nThe class has the following method, alter. \npublic void alter(int c) \n{ \n    for (int i = 0; i < mat.length; i++) \n        for (int j = c + 1; j < mat[0].length; j++) \n            mat[i][j-1] = mat[i][j]; \n} \n\nIf a 3 × 4 matrix mat is \n1 3 5 7 \n2 4 6 8 \n3 5 7 9 \n\nthen alter(1) will change mat to \nCorrect: 1 5 7 7\n2 6 8 8 \n3 7 9 9 \nIncorrect: 1 5 7\n2 6 8 \n3 7 9 \nIncorrect: 1 3 5 7\n3 5 7 9 \nIncorrect: 1 3 5 7\n3 5 7 9 \n3 5 7 9 \nIncorrect: 1 7 7 7\n2 8 8 8 \n3 9 9 9\n\nEND"}
{"prompt":"There are three common ways to traverse a two-dimensional array:\n• row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n• for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n• row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n\/** Precondition: mat is initialized with integer values. *\/\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) \/\/for each row array in mat\n    for (int element : row) \/\/for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n\/** @return the sum of integers in arr *\/\npublic int sumArray(int[] arr)\n{ \/* implementation not shown *\/ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) \/\/for each row in mat,\n    sum += sumArray(mat[row]); \/\/add that row’s total to sum\n\nNote how, since mat[row] is an array of int for 0 ≤ row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 ≤ k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n\/** Add 10 to each int in arr *\/\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) \/\/for each row array in cardMatrix,\n    for (Card c : row) \/\/for each Card in that row,\n        c.changeValue(v); \/\/change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can’t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; \/\/SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; \/\/major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; \/\/minor diagonal\n\n\n###\n\n","completion":" Question: Consider the following method that will alter the matrix mat:\n\n\/** @param mat the initialized matrix \n* @param row the row number \n*\/ \npublic static void matStuff(int[][] mat, int row) \n{ \n    int numCols = mat[0].length; \n    for (int col = 0; col < numCols; col++) \n        mat[row][col] = row; \n} \n\nSuppose mat is originally \n1 4 9 0 \n2 7 8 6 \n5 1 4 3 \n\nAfter the method call matStuff(mat,2), matrix mat will be \nCorrect: 1 4 9 0\n2 7 8 6 \n2 2 2 2 \nIncorrect: 1 4 9 0\n2 2 2 2 \n5 1 4 3 \nIncorrect: 2 2 2 2\n2 2 2 2 \n2 2 2 2 \nIncorrect: 1 4 2 0\n2 7 2 6 \n5 1 2 3 \nIncorrect: 1 2 9 0\n2 2 8 6 \n5 2 4 3\n\nEND"}
{"prompt":"There are three common ways to traverse a two-dimensional array:\n• row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n• for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n• row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n\/** Precondition: mat is initialized with integer values. *\/\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) \/\/for each row array in mat\n    for (int element : row) \/\/for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n\/** @return the sum of integers in arr *\/\npublic int sumArray(int[] arr)\n{ \/* implementation not shown *\/ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) \/\/for each row in mat,\n    sum += sumArray(mat[row]); \/\/add that row’s total to sum\n\nNote how, since mat[row] is an array of int for 0 ≤ row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 ≤ k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n\/** Add 10 to each int in arr *\/\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) \/\/for each row array in cardMatrix,\n    for (Card c : row) \/\/for each Card in that row,\n        c.changeValue(v); \/\/change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can’t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; \/\/SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; \/\/major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; \/\/minor diagonal\n\n\n###\n\n","completion":" Question: Assume that a square matrix mat is defined by \n\nint[][] mat = new int[SIZE][SIZE]; \n\/\/SIZE is an integer constant >= 2 \n\nWhat does the following code segment do? \n\nfor (int i = 0; i < SIZE - 1; i++) \n    for (int j = 0; j < SIZE - i - 1; j++) \n        swap(mat, i, j, SIZE - j - 1, SIZE - i - 1); \n\nYou may assume the existence of this swap method: \n\n\/** Interchange mat[a][b] and mat[c][d]. *\/ \npublic void swap(int[][] mat, int a, int b, int c, int d) \n\nCorrect: Reflects mat through its minor diagonal. For example,\n2 6 3 6 → 4 3 4 2 \nIncorrect: Reflects mat through its major diagonal. For example,\n2 6 2 4 → 4 3 6 3 \nIncorrect: Reflects mat through a horizontal line of symmetry. For example,\n2 6 4 3 → 4 3 2 6 \nIncorrect: Reflects mat through a vertical line of symmetry. For example,\n2 6 6 2 → 4 3 3 4 \nIncorrect: Leaves mat unchanged\n\nEND"}
{"prompt":"There are three common ways to traverse a two-dimensional array:\n• row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n• for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n• row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n\/** Precondition: mat is initialized with integer values. *\/\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) \/\/for each row array in mat\n    for (int element : row) \/\/for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n\/** @return the sum of integers in arr *\/\npublic int sumArray(int[] arr)\n{ \/* implementation not shown *\/ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) \/\/for each row in mat,\n    sum += sumArray(mat[row]); \/\/add that row’s total to sum\n\nNote how, since mat[row] is an array of int for 0 ≤ row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 ≤ k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n\/** Add 10 to each int in arr *\/\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) \/\/for each row array in cardMatrix,\n    for (Card c : row) \/\/for each Card in that row,\n        c.changeValue(v); \/\/change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can’t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; \/\/SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; \/\/major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; \/\/minor diagonal\n\n\n###\n\n","completion":" Question: Consider a class MatrixStuff that has a private instance variable: \nprivate int[][] mat; \n\nRefer to method alter below that occurs in the MatrixStuff class. (The lines are numbered for reference.) \nLine 1: \/** @param mat the matrix initialized with integers \nLine 2: * @param c the column to be removed \nLine 3: * Postcondition: \nLine 4: * - Column c has been removed. \nLine 5: * - The last column is filled with zeros. \nLine 6: *\/ \nLine 7: public void alter(int[][] mat, int c) \nLine 8: { \nLine 9:     for (int i = 0; i < mat.length; i++) \nLine 10:        for (int j = c; j < mat[0].length; j++) \nLine 11:            mat[i][j] = mat[i][j+1]; \nLine 12:    \/\/code to insert zeros in rightmost column \nLine 13:    ... \nLine 14: } \n\nThe intent of the method alter is to remove column c. Thus, if the input matrix mat is \n2 6 8 9 \n1 5 4 3 \n0 7 3 2 \n\nthe method call alter(mat, 1) should change mat to \n2 8 9 0 \n1 4 3 0 \n0 3 2 0 \n\nThe method does not work as intended. Which of the following changes will correct the problem? \nI Change line 10 to \nfor (int j = c; j < mat[0].length - 1; j++) \nand make no other changes. \nII Change lines 10 and 11 to \nfor (int j = c + 1; j < mat[0].length; j++) \n    mat[i][j-1] = mat[i][j]; \nand make no other changes. \nIII Change lines 10 and 11 to \nfor (int j = mat[0].length - 1; j > c; j--) \n    mat[i][j-1] = mat[i][j]; \nand make no other changes. \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"There are three common ways to traverse a two-dimensional array:\n• row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n• for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n• row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n\/** Precondition: mat is initialized with integer values. *\/\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) \/\/for each row array in mat\n    for (int element : row) \/\/for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n\/** @return the sum of integers in arr *\/\npublic int sumArray(int[] arr)\n{ \/* implementation not shown *\/ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) \/\/for each row in mat,\n    sum += sumArray(mat[row]); \/\/add that row’s total to sum\n\nNote how, since mat[row] is an array of int for 0 ≤ row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 ≤ k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n\/** Add 10 to each int in arr *\/\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) \/\/for each row array in cardMatrix,\n    for (Card c : row) \/\/for each Card in that row,\n        c.changeValue(v); \/\/change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can’t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; \/\/SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; \/\/major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; \/\/minor diagonal\n\n\n###\n\n","completion":" Question: This question refers to the following method: \n\npublic static boolean isThere(String[][] mat, int row, int col, String symbol) \n{ \n    boolean yes; \n    int i, count = 0; \n    for (i = 0; i < SIZE; i++) \n        if (mat[i][col].equals(symbol)) \n            count++; \n    yes = (count == SIZE); \n    count = 0; \n    for (i = 0; i < SIZE; i++) \n        if (mat[row][i].equals(symbol)) \n            count++; \n    return (yes || count == SIZE); \n} \n\nNow consider this code segment:\n\npublic final int SIZE = 8; \nString[][] mat = new String[SIZE][SIZE]; \n\nWhich of the following conditions on a matrix mat of the type declared in the code segment will by itself guarantee that \nisThere(mat, 2, 2, \"$\") \nwill have the value true when evaluated? \nI The element in row 2 and column 2 is \"$\" \nII All elements in both diagonals are \"$\" \nIII All elements in column 2 are \"$\" \nCorrect: III only\nIncorrect: I only\nIncorrect: I and II only\nIncorrect: I and III only\nIncorrect: II and III only\n\nEND"}
{"prompt":"There are three common ways to traverse a two-dimensional array:\n• row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n• for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n• row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n\/** Precondition: mat is initialized with integer values. *\/\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) \/\/for each row array in mat\n    for (int element : row) \/\/for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n\/** @return the sum of integers in arr *\/\npublic int sumArray(int[] arr)\n{ \/* implementation not shown *\/ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) \/\/for each row in mat,\n    sum += sumArray(mat[row]); \/\/add that row’s total to sum\n\nNote how, since mat[row] is an array of int for 0 ≤ row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 ≤ k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n\/** Add 10 to each int in arr *\/\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) \/\/for each row array in cardMatrix,\n    for (Card c : row) \/\/for each Card in that row,\n        c.changeValue(v); \/\/change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can’t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; \/\/SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; \/\/major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; \/\/minor diagonal\n\n\n###\n\n","completion":" Question: The method changeNegs below should replace every occurrence of a negative integer in its matrix parameter with 0. \n\n\/** @param mat the matrix \n* Precondition: mat is initialized with integers. \n* Postcondition: All negative values in mat replaced with 0. \n*\/ \npublic static void changeNegs(int[][] mat) \n{ \n    \/* code *\/ \n} \n\nWhich is correct replacement for \/* code *\/? \nI for (int r = 0; r < mat.length; r++) \n    for (int c = 0; c < mat[r].length; c++) \n        if (mat[r][c] < 0) \n            mat[r][c] = 0; \nII for (int c = 0; c < mat[0].length; c++) \n    for (int r = 0; r < mat.length; r++) \n        if (mat[r][c] < 0) \n            mat[r][c] = 0; \nIII for (int[] row : mat) \n    for (int element : row) \n        if (element < 0) \n            element = 0; \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"There are three common ways to traverse a two-dimensional array:\n• row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n• for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n• row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n\/** Precondition: mat is initialized with integer values. *\/\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) \/\/for each row array in mat\n    for (int element : row) \/\/for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n\/** @return the sum of integers in arr *\/\npublic int sumArray(int[] arr)\n{ \/* implementation not shown *\/ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) \/\/for each row in mat,\n    sum += sumArray(mat[row]); \/\/add that row’s total to sum\n\nNote how, since mat[row] is an array of int for 0 ≤ row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 ≤ k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n\/** Add 10 to each int in arr *\/\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) \/\/for each row array in cardMatrix,\n    for (Card c : row) \/\/for each Card in that row,\n        c.changeValue(v); \/\/change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can’t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; \/\/SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; \/\/major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; \/\/minor diagonal\n\n\n###\n\n","completion":" Question: A two-dimensional array of double, rainfall, will be used to represent the daily rainfall for a given year. In this scheme, rainfall[month][day] represents the amount of rain on the given day and month. For example, \nrainfall[1][15] is the amount of rain on Jan. 15 \nrainfall[12][25] is the amount of rain on Dec. 25 \n\nThe array can be declared as follows: \ndouble[][] rainfall = new double[13][32]; \n\nThis creates 13 rows indexed from 0 to 12 and 32 columns indexed from 0 to 31, all initialized to 0.0. Row 0 and column 0 will be ignored. Column 31 in row 4 will be ignored, since April 31 is not a valid day. In years that are not leap years, columns 29, 30, and 31 in row 2 will be ignored since Feb. 29, 30, and 31 are not valid days. \nConsider the method averageRainfall below: \n\n\/** Precondition: \n* - rainfall is initialized with values representing amounts \n* of rain on all valid days. \n* - Invalid days are initialized to 0.0. \n* - Feb 29 is not a valid day. \n* Postcondition: Returns average rainfall for the year. \n*\/ \npublic double averageRainfall(double rainfall[][]) \n{ \n    double total = 0.0; \n    \/* more code *\/ \n} \n\nWhich of the following is a correct replacement for \/* more code *\/ so that the postcondition for the method is satisfied? \nI for (int month = 1; month < rainfall.length; month++) \n    for (int day = 1; day < rainfall[month].length; day++) \n        total += rainfall[month][day]; \nreturn total \/ (13 * 32); \nII for (int month = 1; month < rainfall.length; month++) \n    for (int day = 1; day < rainfall[month].length; day++) \n        total += rainfall[month][day]; \nreturn total \/ 365; \nIII for (double[] month : rainfall) \n    for (double rainAmt : month) \n        total += rainAmt; \nreturn total \/ 365; \nCorrect: II and III only\n\n\nIncorrect: None\nIncorrect: I only\nIncorrect: II only\nIncorrect: III onlyEND"}
{"prompt":"There are three common ways to traverse a two-dimensional array:\n• row-column (for accessing elements, modifying elements that are class objects, or replacing elements)\n• for-each loop (for accessing elements or modifying elements that are class objects, but no replacement)\n• row-by-row array processing (for accessing, modifying, or replacement)\n\nExample 1\nFind the sum of all elements in a matrix mat. Here is a row-column traversal.\n\/** Precondition: mat is initialized with integer values. *\/\nint sum = 0;\nfor (int r = 0; r < mat.length; r++)\n    for (int c = 0; c < mat[r].length; c++)\n        sum += mat[r][c];\n\nNOTE\n1. mat[r][c] represents the rth row and the cth column.\n2. Rows are numbered from 0 to mat.length-1, and columns are numbered from 0 to mat[r].length-1. Any index that is outside these bounds will generate an ArrayIndexOutOfBoundsException.\nSince elements are not being replaced, nested for-each loops can be used instead:\nfor (int[] row : mat) \/\/for each row array in mat\n    for (int element : row) \/\/for each element in this row\n            sum += element;\n\nNOTE\nStarting in 2015, you will need to know how to use a nested for-each traversal. You will also need to know how to process a matrix as shown below, using the third type of traversal, row-by-row array processing. This traversal assumes access to a method that processes an array. So, continuing with the example to find the sum of all elements in mat: In the class where mat is defined, suppose you have the method sumArray.\n\/** @return the sum of integers in arr *\/\npublic int sumArray(int[] arr)\n{ \/* implementation not shown *\/ }\n\nYou could use this method to sum all the elements in mat as follows:\nint sum = 0;\nfor (int row = 0; row < mat.length; row++) \/\/for each row in mat,\n    sum += sumArray(mat[row]); \/\/add that row’s total to sum\n\nNote how, since mat[row] is an array of int for 0 ≤ row < mat.length, you can use the sumArray method for each row in mat.\n\nExample 2\nAdd 10 to each element in row 2 of matrix mat.\nfor (int c = 0; c < mat[2].length; c++)\n    mat[2][c] += 10;\n\nNOTE\n1. In the for loop, you can use c < mat[k].length, where 0 ≤ k < mat.length, since each row has the same number of elements.\n2. You cannot use a for-each loop here because elements are being replaced.\n3. You can, however, use row-by-row array processing. Suppose you have method addTen shown below.\n\/** Add 10 to each int in arr *\/\npublic void addTen(int[] arr)\n{\n    for (int i = 0; i < arr.length; i++)\n        arr[i] += 10;\n}\n\nYou could add 10 to each element in row 2 with the single statement\naddTen(mat[2]);\nYou could also add 10 to every element in mat:\nfor (int row = 0; row < mat.length; row++)\n    addTen(mat[row]);\n\nExample 3\nSuppose Card objects have a mutator method changeValue:\npublic void changeValue(int newValue)\n{ value = newValue; }\n\nNow consider the declaration\nCard[][] cardMatrix;\n\nSuppose cardMatrix is initialized with Card objects. A piece of code that traverses the cardMatrix and changes the value of each Card to v is\nfor (Card[] row : cardMatrix) \/\/for each row array in cardMatrix,\n    for (Card c : row) \/\/for each Card in that row,\n        c.changeValue(v); \/\/change the value of that card\n\nAlternatively:\nfor (int row = 0; row < cardMatrix.length; row++)\n    for (int col = 0; col < cardMatrix[0].length; col++)\n    cardMatrix[row][col].changeValue(v);\n\nNOTE\nThe use of the nested for-each loop is OK. Modifying the objects in the matrix with a mutator method is fine. What you can’t do is replace the Card objects with new Cards.\n\nExample 4\nYou can process the major and minor diagonals of a square matrix as follows:\nint[][] mat = new int[SIZE][SIZE]; \/\/SIZE is a constant int value\nfor (int i = 0; i < SIZE; i++)\n    Process mat[i][i]; \/\/major diagonal\n    OR\n    Process mat[i][SIZE - i - 1]; \/\/minor diagonal\n\n\n###\n\n","completion":" Question: This question is based on the Point class below: \n\npublic class Point {\n    \/** The coordinates. *\/\n    private int x;\n    private int y;\n\n    public Point(int xValue, int yValue) {\n        x = xValue;\n        y = yValue;\n    }\n\n    \/** @return the x-coordinate of this point *\/\n    public int getx() { return x; }\n\n    \/** @return the y-coordinate of this point *\/\n    public int gety() { return y; }\n\n    \/** Set x and y to new_x and new_y. *\/\n    public void setPoint(int new_x, int new_y) {\n        x = new_x;\n        y = new_y;\n    }\n\n    \/\/ Other methods are not shown.\n}\n\nThe method changeNegs below takes a matrix of Point objects as parameter and replaces every Point that has as least one negative coordinate with the Point (0,0). \n\n\/** @param pointMat the matrix of points \n* Precondition: pointMat is initialized with Point objects. \n* Postcondition: Every point with at least one negative coordinate \n* has been changed to have both coordinates \n* equal to zero. \n*\/ \npublic static void changeNegs (Point [][] pointMat) \n{ \n    \/* code *\/ \n}\n\nWhich is a correct replacement for \/* code *\/? \nI for (int r = 0; r < pointMat.length; r++) \n    for (int c = 0; c < pointMat[r].length; c++) \n        if (pointMat[r][c].getx() < 0 || pointMat[r][c].gety() < 0) \n            pointMat[r][c].setPoint(0, 0); \nII for (int c = 0; c < pointMat[0].length; c++) \n    for (int r = 0; r < pointMat.length; r++) \n        if (pointMat[r][c].getx() < 0 || pointMat[r][c].gety() < 0) \n            pointMat[r][c].setPoint(0, 0); \nIII for (Point[] row : pointMat) \n    for (Point p : row) \n        if (p.getx() < 0 || p.gety() < 0) \n            p.setPoint(0, 0); \nCorrect: I, II, and III\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II onlyEND"}
{"prompt":"This class implements standard mathematical functions such as absolute value, square root, trigonometric functions, the log function, the power function, and so on. It also contains mathematical constants such as π and e.\n\nHere are the functions you should know for the AP exam:\nstatic int abs(int x)\nReturns the absolute value of integer x.\nstatic double abs(double x)\nReturns the absolute value of real number x.\nstatic double pow(double base, double exp)\nReturns base^exp. Assumes base > 0, or base = 0 and exp > 0, or base < 0 and exp is an integer.\nstatic double sqrt(double x)\nReturns sqrt(x), x ≥ 0.\nstatic double random()\nReturns a random number r, where 0.0 ≤ r < 1.0. (See the next section, Random Numbers.)\nAll of the functions and constants are implemented as static methods and variables, which means that there are no instances of Math objects. The methods are invoked using the class name, Math, followed by the dot operator.\n\nHere are some examples of mathematical formulas and the equivalent Java statements.\n1. The relationship between the radius and area of a circle:\nradius = Math.sqrt(area \/ Math.PI);\n2. The amount of money A in an account after ten years, given an original deposit of P and an interest rate of 5% compounded annually, is\nA= P(1.05)10\nIn code:\na = p * Math.pow(1.05, 10);\n3. The distance D between two points P(xP, y) and Q(xQ, y) on the same hori zontal line is\nD = |xP − xQ|\nIn code:\nd = Math.abs(xp - xq);\n\nNOTE\nThe static import construct allows you to use the static members of a class without the class name prefix. For example, the statement\nimport static java.lang.Math.*;\nallows use of all Math methods and constants without the Math prefix. Thus, the statement in formula 1 above could be written\nradius = sqrt(area \/ PI);\nStatic imports are not part of the AP subset.\n\nThe statement\ndouble r = Math.random();\nproduces a random real number in the range 0.0 to 1.0, where 0.0 is included and 1.0 is not.\nThis range can be scaled and shifted. On the AP exam you will be expected to write algebraic expressions involving Math.random() that represent linear transformations of the original interval 0.0 ≤ x < 1.0.\n\nExample 1\nProduce a random real value x in the range 0.0 ≤ x < 6.0.\ndouble x = 6 * Math.random();\nExample 2\nProduce a random real value x in the range 2.0 ≤ x < 3.0.\ndouble x = Math.random() + 2;\nExample 3\nProduce a random real value x in the range 4.0 ≤ x < 6.0.\ndouble x = 2 * Math.random() + 4;\nIn general, to produce a random real value in the range lowValue ≤ x < highValue: double x = (highValue - lowValue) * Math.random() + lowValue;\n\nUsing a cast to int, a scaling factor, and a shifting value, Math.random() can be used to produce random integers in any range.\nExample 1\nProduce a random integer, from 0 to 99.\nint num = (int) (Math.random() * 100);\nIn general, the expression\n(int) (Math.random() * k)\nproduces a random int in the range 0,1,..., k − 1, where k is called the scaling factor. Note that the cast to int truncates the real number Math.random() * k.\nExample 2\nProduce a random integer, from 1 to 100.\nint num = (int) (Math.random() * 100) + 1;\nIn general, if k is a scaling factor, and p is a shifting value, the statement\nint n = (int) (Math.random() * k) + p;\nproduces a random integer n in the range p, p + 1,..., p + (k − 1).\nExample 3\nProduce a random integer from 5 to 24.\nint num = (int) (Math.random() * 20) + 5;\nNote that there are 20 possible integers from 5 to 24, inclusive.\nNOTE\nThere is further discussion of strings and random numbers, plus additional questions, in Chapter 9 (The AP Computer Science Labs).\n\n\n###\n\n","completion":" Question: Here is a program segment to find the quantity base^exp. Both base and exp are entered at the keyboard. \n\nSystem.out.println(\"Enter base and exponent: \"); \ndouble base = IO.readDouble(); \/\/read user input \ndouble exp = IO.readDouble(); \/\/read user input \n\/* code to find power, which equals baseexp *\/ \nSystem.out.print(base + \" raised to the power \" + exp); \nSystem.out.println(\" equals \" + power); \n\nWhich is a correct replacement for \n\/* code to find power, which equals base^exp *\/? \nI double power; \nMath m = new Math(); \npower = m.pow(base, exp); \nII double power; \npower = Math.pow(base, exp); \nIII int power; \npower = Math.pow(base, exp); \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I and III only\n\nEND"}
{"prompt":"This class implements standard mathematical functions such as absolute value, square root, trigonometric functions, the log function, the power function, and so on. It also contains mathematical constants such as π and e.\n\nHere are the functions you should know for the AP exam:\nstatic int abs(int x)\nReturns the absolute value of integer x.\nstatic double abs(double x)\nReturns the absolute value of real number x.\nstatic double pow(double base, double exp)\nReturns base^exp. Assumes base > 0, or base = 0 and exp > 0, or base < 0 and exp is an integer.\nstatic double sqrt(double x)\nReturns sqrt(x), x ≥ 0.\nstatic double random()\nReturns a random number r, where 0.0 ≤ r < 1.0. (See the next section, Random Numbers.)\nAll of the functions and constants are implemented as static methods and variables, which means that there are no instances of Math objects. The methods are invoked using the class name, Math, followed by the dot operator.\n\nHere are some examples of mathematical formulas and the equivalent Java statements.\n1. The relationship between the radius and area of a circle:\nradius = Math.sqrt(area \/ Math.PI);\n2. The amount of money A in an account after ten years, given an original deposit of P and an interest rate of 5% compounded annually, is\nA= P(1.05)10\nIn code:\na = p * Math.pow(1.05, 10);\n3. The distance D between two points P(xP, y) and Q(xQ, y) on the same hori zontal line is\nD = |xP − xQ|\nIn code:\nd = Math.abs(xp - xq);\n\nNOTE\nThe static import construct allows you to use the static members of a class without the class name prefix. For example, the statement\nimport static java.lang.Math.*;\nallows use of all Math methods and constants without the Math prefix. Thus, the statement in formula 1 above could be written\nradius = sqrt(area \/ PI);\nStatic imports are not part of the AP subset.\n\nThe statement\ndouble r = Math.random();\nproduces a random real number in the range 0.0 to 1.0, where 0.0 is included and 1.0 is not.\nThis range can be scaled and shifted. On the AP exam you will be expected to write algebraic expressions involving Math.random() that represent linear transformations of the original interval 0.0 ≤ x < 1.0.\n\nExample 1\nProduce a random real value x in the range 0.0 ≤ x < 6.0.\ndouble x = 6 * Math.random();\nExample 2\nProduce a random real value x in the range 2.0 ≤ x < 3.0.\ndouble x = Math.random() + 2;\nExample 3\nProduce a random real value x in the range 4.0 ≤ x < 6.0.\ndouble x = 2 * Math.random() + 4;\nIn general, to produce a random real value in the range lowValue ≤ x < highValue: double x = (highValue - lowValue) * Math.random() + lowValue;\n\nUsing a cast to int, a scaling factor, and a shifting value, Math.random() can be used to produce random integers in any range.\nExample 1\nProduce a random integer, from 0 to 99.\nint num = (int) (Math.random() * 100);\nIn general, the expression\n(int) (Math.random() * k)\nproduces a random int in the range 0,1,..., k − 1, where k is called the scaling factor. Note that the cast to int truncates the real number Math.random() * k.\nExample 2\nProduce a random integer, from 1 to 100.\nint num = (int) (Math.random() * 100) + 1;\nIn general, if k is a scaling factor, and p is a shifting value, the statement\nint n = (int) (Math.random() * k) + p;\nproduces a random integer n in the range p, p + 1,..., p + (k − 1).\nExample 3\nProduce a random integer from 5 to 24.\nint num = (int) (Math.random() * 20) + 5;\nNote that there are 20 possible integers from 5 to 24, inclusive.\nNOTE\nThere is further discussion of strings and random numbers, plus additional questions, in Chapter 9 (The AP Computer Science Labs).\n\n\n###\n\n","completion":" Question: Consider the squareRoot method defined below: \n\n\/** @param d a real number such that d >= 0 \n* Postcondition: Returns a Double whose value is the square \n* root of the value represented by d. \n*\/ \npublic Double squareRoot(Double d) \n{ \n    \/* implementation code *\/ \n} \n\nWhich \/* implementation code *\/ satisfies the postcondition? \nI double x = d.doubleValue(); \nx = Math.sqrt(x); \nreturn new Double(x); \nII return new Double(Math.sqrt(d.doubleValue())); \nIII return (Double) Math.sqrt(d.doubleValue()); \nCorrect: I and II only\nIncorrect: I only\nIncorrect: I and III only\nIncorrect: II and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"This class implements standard mathematical functions such as absolute value, square root, trigonometric functions, the log function, the power function, and so on. It also contains mathematical constants such as π and e.\n\nHere are the functions you should know for the AP exam:\nstatic int abs(int x)\nReturns the absolute value of integer x.\nstatic double abs(double x)\nReturns the absolute value of real number x.\nstatic double pow(double base, double exp)\nReturns base^exp. Assumes base > 0, or base = 0 and exp > 0, or base < 0 and exp is an integer.\nstatic double sqrt(double x)\nReturns sqrt(x), x ≥ 0.\nstatic double random()\nReturns a random number r, where 0.0 ≤ r < 1.0. (See the next section, Random Numbers.)\nAll of the functions and constants are implemented as static methods and variables, which means that there are no instances of Math objects. The methods are invoked using the class name, Math, followed by the dot operator.\n\nHere are some examples of mathematical formulas and the equivalent Java statements.\n1. The relationship between the radius and area of a circle:\nradius = Math.sqrt(area \/ Math.PI);\n2. The amount of money A in an account after ten years, given an original deposit of P and an interest rate of 5% compounded annually, is\nA= P(1.05)10\nIn code:\na = p * Math.pow(1.05, 10);\n3. The distance D between two points P(xP, y) and Q(xQ, y) on the same hori zontal line is\nD = |xP − xQ|\nIn code:\nd = Math.abs(xp - xq);\n\nNOTE\nThe static import construct allows you to use the static members of a class without the class name prefix. For example, the statement\nimport static java.lang.Math.*;\nallows use of all Math methods and constants without the Math prefix. Thus, the statement in formula 1 above could be written\nradius = sqrt(area \/ PI);\nStatic imports are not part of the AP subset.\n\nThe statement\ndouble r = Math.random();\nproduces a random real number in the range 0.0 to 1.0, where 0.0 is included and 1.0 is not.\nThis range can be scaled and shifted. On the AP exam you will be expected to write algebraic expressions involving Math.random() that represent linear transformations of the original interval 0.0 ≤ x < 1.0.\n\nExample 1\nProduce a random real value x in the range 0.0 ≤ x < 6.0.\ndouble x = 6 * Math.random();\nExample 2\nProduce a random real value x in the range 2.0 ≤ x < 3.0.\ndouble x = Math.random() + 2;\nExample 3\nProduce a random real value x in the range 4.0 ≤ x < 6.0.\ndouble x = 2 * Math.random() + 4;\nIn general, to produce a random real value in the range lowValue ≤ x < highValue: double x = (highValue - lowValue) * Math.random() + lowValue;\n\nUsing a cast to int, a scaling factor, and a shifting value, Math.random() can be used to produce random integers in any range.\nExample 1\nProduce a random integer, from 0 to 99.\nint num = (int) (Math.random() * 100);\nIn general, the expression\n(int) (Math.random() * k)\nproduces a random int in the range 0,1,..., k − 1, where k is called the scaling factor. Note that the cast to int truncates the real number Math.random() * k.\nExample 2\nProduce a random integer, from 1 to 100.\nint num = (int) (Math.random() * 100) + 1;\nIn general, if k is a scaling factor, and p is a shifting value, the statement\nint n = (int) (Math.random() * k) + p;\nproduces a random integer n in the range p, p + 1,..., p + (k − 1).\nExample 3\nProduce a random integer from 5 to 24.\nint num = (int) (Math.random() * 20) + 5;\nNote that there are 20 possible integers from 5 to 24, inclusive.\nNOTE\nThere is further discussion of strings and random numbers, plus additional questions, in Chapter 9 (The AP Computer Science Labs).\n\n\n###\n\n","completion":" Question: Here are some examples of negative numbers rounded to the nearest integer. \n\n−3.5 -> −4 \n−8.97 -> −9 \n−5.0 -> −5 \n−2.487 -> −2 \n−0.2 -> 0 \n\nRefer to the declaration \ndouble d = -4.67; \nWhich of the following correctly rounds d to the nearest integer? \nCorrect: int rounded = (int) (d - 0.5);\nIncorrect: int rounded = Math.abs(d);\nIncorrect: int rounded = (int) (Math.random() * d);\nIncorrect: int rounded = (int) (d + 0.5);\nIncorrect: int rounded = Math.abs((int) (d - 0.5));\n\nEND"}
{"prompt":"This class implements standard mathematical functions such as absolute value, square root, trigonometric functions, the log function, the power function, and so on. It also contains mathematical constants such as π and e.\n\nHere are the functions you should know for the AP exam:\nstatic int abs(int x)\nReturns the absolute value of integer x.\nstatic double abs(double x)\nReturns the absolute value of real number x.\nstatic double pow(double base, double exp)\nReturns base^exp. Assumes base > 0, or base = 0 and exp > 0, or base < 0 and exp is an integer.\nstatic double sqrt(double x)\nReturns sqrt(x), x ≥ 0.\nstatic double random()\nReturns a random number r, where 0.0 ≤ r < 1.0. (See the next section, Random Numbers.)\nAll of the functions and constants are implemented as static methods and variables, which means that there are no instances of Math objects. The methods are invoked using the class name, Math, followed by the dot operator.\n\nHere are some examples of mathematical formulas and the equivalent Java statements.\n1. The relationship between the radius and area of a circle:\nradius = Math.sqrt(area \/ Math.PI);\n2. The amount of money A in an account after ten years, given an original deposit of P and an interest rate of 5% compounded annually, is\nA= P(1.05)10\nIn code:\na = p * Math.pow(1.05, 10);\n3. The distance D between two points P(xP, y) and Q(xQ, y) on the same hori zontal line is\nD = |xP − xQ|\nIn code:\nd = Math.abs(xp - xq);\n\nNOTE\nThe static import construct allows you to use the static members of a class without the class name prefix. For example, the statement\nimport static java.lang.Math.*;\nallows use of all Math methods and constants without the Math prefix. Thus, the statement in formula 1 above could be written\nradius = sqrt(area \/ PI);\nStatic imports are not part of the AP subset.\n\nThe statement\ndouble r = Math.random();\nproduces a random real number in the range 0.0 to 1.0, where 0.0 is included and 1.0 is not.\nThis range can be scaled and shifted. On the AP exam you will be expected to write algebraic expressions involving Math.random() that represent linear transformations of the original interval 0.0 ≤ x < 1.0.\n\nExample 1\nProduce a random real value x in the range 0.0 ≤ x < 6.0.\ndouble x = 6 * Math.random();\nExample 2\nProduce a random real value x in the range 2.0 ≤ x < 3.0.\ndouble x = Math.random() + 2;\nExample 3\nProduce a random real value x in the range 4.0 ≤ x < 6.0.\ndouble x = 2 * Math.random() + 4;\nIn general, to produce a random real value in the range lowValue ≤ x < highValue: double x = (highValue - lowValue) * Math.random() + lowValue;\n\nUsing a cast to int, a scaling factor, and a shifting value, Math.random() can be used to produce random integers in any range.\nExample 1\nProduce a random integer, from 0 to 99.\nint num = (int) (Math.random() * 100);\nIn general, the expression\n(int) (Math.random() * k)\nproduces a random int in the range 0,1,..., k − 1, where k is called the scaling factor. Note that the cast to int truncates the real number Math.random() * k.\nExample 2\nProduce a random integer, from 1 to 100.\nint num = (int) (Math.random() * 100) + 1;\nIn general, if k is a scaling factor, and p is a shifting value, the statement\nint n = (int) (Math.random() * k) + p;\nproduces a random integer n in the range p, p + 1,..., p + (k − 1).\nExample 3\nProduce a random integer from 5 to 24.\nint num = (int) (Math.random() * 20) + 5;\nNote that there are 20 possible integers from 5 to 24, inclusive.\nNOTE\nThere is further discussion of strings and random numbers, plus additional questions, in Chapter 9 (The AP Computer Science Labs).\n\n\n###\n\n","completion":" Question: A program is to simulate plant life under harsh conditions. In the program, plants die randomly according to some probability. Here is part of a Plant class defined in the program. \n\npublic class Plant {\n    \/** probability that plant dies, a real number between 0 and 1 *\/\n    private double probDeath;\n\n    public Plant(double plantProbDeath, < other parameters >) \n    { \n        probDeath = plantProbDeath; \n        < initialization of other instance variables > \n    }\n\n    \/** Plant lives or dies. *\/ \n    public void liveOrDie() \n    { \n        \/* statement to generate random number *\/ \n        if (\/* test to determine if plant dies *\/) \n            < code to implement plant’s death > \n        else \n            < code to make plant continue living > \n    }\n    \/\/ Other variables and methods are not shown.\n}\n\nWhich of the following are correct replacements for \n(1) \/* statement to generate random number *\/ and \n(2) \/* test to determine if plant dies *\/? \nCorrect: (1) double x = Math.random();\n(2) x < probDeath \nIncorrect: (1) double x = Math.random();\n(2) x == probDeath \nIncorrect: (1) double x = (int) (Math.random());\n(2) x > probDeath \nIncorrect: (1) int x = (int) (Math.random() * 100);\n(2) x < (int) probDeath \nIncorrect: (1) int x = (int) (Math.random() * 100) + 1;\n(2) x == (int) probDeath \n\nEND"}
{"prompt":"This class implements standard mathematical functions such as absolute value, square root, trigonometric functions, the log function, the power function, and so on. It also contains mathematical constants such as π and e.\n\nHere are the functions you should know for the AP exam:\nstatic int abs(int x)\nReturns the absolute value of integer x.\nstatic double abs(double x)\nReturns the absolute value of real number x.\nstatic double pow(double base, double exp)\nReturns base^exp. Assumes base > 0, or base = 0 and exp > 0, or base < 0 and exp is an integer.\nstatic double sqrt(double x)\nReturns sqrt(x), x ≥ 0.\nstatic double random()\nReturns a random number r, where 0.0 ≤ r < 1.0. (See the next section, Random Numbers.)\nAll of the functions and constants are implemented as static methods and variables, which means that there are no instances of Math objects. The methods are invoked using the class name, Math, followed by the dot operator.\n\nHere are some examples of mathematical formulas and the equivalent Java statements.\n1. The relationship between the radius and area of a circle:\nradius = Math.sqrt(area \/ Math.PI);\n2. The amount of money A in an account after ten years, given an original deposit of P and an interest rate of 5% compounded annually, is\nA= P(1.05)10\nIn code:\na = p * Math.pow(1.05, 10);\n3. The distance D between two points P(xP, y) and Q(xQ, y) on the same hori zontal line is\nD = |xP − xQ|\nIn code:\nd = Math.abs(xp - xq);\n\nNOTE\nThe static import construct allows you to use the static members of a class without the class name prefix. For example, the statement\nimport static java.lang.Math.*;\nallows use of all Math methods and constants without the Math prefix. Thus, the statement in formula 1 above could be written\nradius = sqrt(area \/ PI);\nStatic imports are not part of the AP subset.\n\nThe statement\ndouble r = Math.random();\nproduces a random real number in the range 0.0 to 1.0, where 0.0 is included and 1.0 is not.\nThis range can be scaled and shifted. On the AP exam you will be expected to write algebraic expressions involving Math.random() that represent linear transformations of the original interval 0.0 ≤ x < 1.0.\n\nExample 1\nProduce a random real value x in the range 0.0 ≤ x < 6.0.\ndouble x = 6 * Math.random();\nExample 2\nProduce a random real value x in the range 2.0 ≤ x < 3.0.\ndouble x = Math.random() + 2;\nExample 3\nProduce a random real value x in the range 4.0 ≤ x < 6.0.\ndouble x = 2 * Math.random() + 4;\nIn general, to produce a random real value in the range lowValue ≤ x < highValue: double x = (highValue - lowValue) * Math.random() + lowValue;\n\nUsing a cast to int, a scaling factor, and a shifting value, Math.random() can be used to produce random integers in any range.\nExample 1\nProduce a random integer, from 0 to 99.\nint num = (int) (Math.random() * 100);\nIn general, the expression\n(int) (Math.random() * k)\nproduces a random int in the range 0,1,..., k − 1, where k is called the scaling factor. Note that the cast to int truncates the real number Math.random() * k.\nExample 2\nProduce a random integer, from 1 to 100.\nint num = (int) (Math.random() * 100) + 1;\nIn general, if k is a scaling factor, and p is a shifting value, the statement\nint n = (int) (Math.random() * k) + p;\nproduces a random integer n in the range p, p + 1,..., p + (k − 1).\nExample 3\nProduce a random integer from 5 to 24.\nint num = (int) (Math.random() * 20) + 5;\nNote that there are 20 possible integers from 5 to 24, inclusive.\nNOTE\nThere is further discussion of strings and random numbers, plus additional questions, in Chapter 9 (The AP Computer Science Labs).\n\n\n###\n\n","completion":" Question: A program simulates fifty slips of paper, numbered 1 through 50, placed in a bowl for a raffle drawing. Which of the following statements stores in winner a random integer from 1 to 50? \nCorrect: int winner = (int) (Math.random() * 50) + 1;\nIncorrect: int winner = (int) (Math.random() * 50);\nIncorrect: int winner = (int) (Math.random() * 51);\nIncorrect: int winner = (int) (Math.random() * 51) + 1;\nIncorrect: int winner = (int) (1 + Math.random() * 49);\n\nEND"}
{"prompt":"A wrapper class takes either an existing object or a value of primitive type, “wraps” or “boxes” it in an object, and provides a new set of methods for that type. The point of a wrapper class is to provide extended capabilities for the boxed quantity:\n• It can be used in generic Java methods that require objects as parameters.\n• It can be used in Java container classes that require the items be objects (see p. 242).\n\nIn each case, the wrapper class allows\n1. Construction of an object from a single value (wrapping or boxing the primitive in a wrapper object).\n2. Retrieval of the primitive value (unwrapping or unboxing from the wrapper object).\nJava provides a wrapper class for each of its primitive types. The two that you should know for the AP exam are the Integer and Double classes.\n\nThe Integer class wraps a value of type int in an object. An object of type Integer contains just one instance variable whose type is int.\nHere are the Integer methods you should know for the AP exam:\nInteger(int value)\nConstructs an Integer object from an int. (Boxing.)\nint compareTo(Integer other)\nReturns 0 if the value of this Integer is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nint intValue()\nReturns the value of this Integer as an int. (Unboxing.)\nboolean equals(Object obj)\nReturns true if and only if this Integer has the same int value as obj.\nNOTE\n1. This method overrides equals in class Object.\n2. This method throws a ClassCastException if obj is not an Integer.\nString toString()\nReturns a String representing the value of this Integer.\nHere are some examples to illustrate the Integer methods:\nInteger intObj = new Integer(6); \/\/boxes 6 in Integer object\nint j = intObj.intValue(); \/\/unboxes 6 from Integer object\nSystem.out.println(\"Integer value is \" + intObj);\n\/\/calls toString() for intObj\n\/\/output is\n\/\/Integer value is 6\nObject object = new Integer(5); \/\/Integer is a subclass of Object\nInteger intObj2 = new Integer(3);\nint k = intObj2.intValue();\nif (intObj.equals(intObj2)) \/\/OK, evaluates to false\n...\nif (intObj.intValue() == intObj2.intValue())\n... \/\/OK, since comparing primitive types\nif (k.equals(j)) \/\/error, k and j not objects\n...\nif ((intObj.intValue()).compareTo(intObj2.intValue()) < 0)\n... \/\/error, can’t use compareTo on primitive types\nif (intObj.compareTo(object) < 0) \/\/Error. Parameter needs Integer cast if (intObj.compareTo((Integer) object) < 0) \/\/OK\n...\nif (object.compareTo(intObj) < 0) \/\/error, no compareTo in Object\n...\nif (((Integer) object).compareTo(intObj) < 0) \/\/OK\n...\n\nThe Double class wraps a value of type double in an object. An object of type Double contains just one instance variable whose type is double.\nThe methods you should know for the AP exam are analogous to those for type\nInteger.\nDouble(double value)\nConstructs a Double object from a double. (Boxing.)\ndouble doubleValue()\nReturns the value of this Double as a double. (Unboxing.)\nint compareTo(Double other)\nReturns 0 if the value of this Double is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nboolean equals(Object obj)\nThis method overrides equals in class Object and throws a ClassCastException if obj is not a Double. Otherwise it returns true if and only if this Double has the same double value as obj.\nString toString()\nReturns a String representing the value of this Double.\n\nHere are some examples:\nDouble dObj = new Double(2.5); \/\/boxes 2.5 in Double object\ndouble d = dObj.doubleValue(); \/\/unboxes 2.5 from Double object\nObject object = new Double(7.3); \/\/Double is a subclass of Object\nObject intObj = new Integer(4);\nif (dObj.compareTo(object) > 0) \/\/Error. Parameter needs cast to Double\nif (dObj.compareTo((Double) object) > 0) \/\/OK\n...\nif (dObj.compareTo(intObj) > 0) \/\/ClassCastException\n... \/\/can’t compare Integer to Double\n\nNOTE\n1. Integer and Double objects are immutable: There are no mutator methods in the classes.\n2. See p. 242 for a discussion of auto-boxing and -unboxing. This useful feature will not be tested on the AP exam.\n\n\n###\n\n","completion":" Question: Consider the code segment \n\nInteger i = new Integer(20); \n\/* more code *\/ \n\nWhich of the following replacements for \/* more code *\/ correctly sets i to have an integer value of 25? \nI i = new Integer(25); \nII i.intValue() = 25; \nIII Integer j = new Integer(25); \ni = j; \nCorrect: I and III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: II and III only\n\nEND"}
{"prompt":"A wrapper class takes either an existing object or a value of primitive type, “wraps” or “boxes” it in an object, and provides a new set of methods for that type. The point of a wrapper class is to provide extended capabilities for the boxed quantity:\n• It can be used in generic Java methods that require objects as parameters.\n• It can be used in Java container classes that require the items be objects (see p. 242).\n\nIn each case, the wrapper class allows\n1. Construction of an object from a single value (wrapping or boxing the primitive in a wrapper object).\n2. Retrieval of the primitive value (unwrapping or unboxing from the wrapper object).\nJava provides a wrapper class for each of its primitive types. The two that you should know for the AP exam are the Integer and Double classes.\n\nThe Integer class wraps a value of type int in an object. An object of type Integer contains just one instance variable whose type is int.\nHere are the Integer methods you should know for the AP exam:\nInteger(int value)\nConstructs an Integer object from an int. (Boxing.)\nint compareTo(Integer other)\nReturns 0 if the value of this Integer is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nint intValue()\nReturns the value of this Integer as an int. (Unboxing.)\nboolean equals(Object obj)\nReturns true if and only if this Integer has the same int value as obj.\nNOTE\n1. This method overrides equals in class Object.\n2. This method throws a ClassCastException if obj is not an Integer.\nString toString()\nReturns a String representing the value of this Integer.\nHere are some examples to illustrate the Integer methods:\nInteger intObj = new Integer(6); \/\/boxes 6 in Integer object\nint j = intObj.intValue(); \/\/unboxes 6 from Integer object\nSystem.out.println(\"Integer value is \" + intObj);\n\/\/calls toString() for intObj\n\/\/output is\n\/\/Integer value is 6\nObject object = new Integer(5); \/\/Integer is a subclass of Object\nInteger intObj2 = new Integer(3);\nint k = intObj2.intValue();\nif (intObj.equals(intObj2)) \/\/OK, evaluates to false\n...\nif (intObj.intValue() == intObj2.intValue())\n... \/\/OK, since comparing primitive types\nif (k.equals(j)) \/\/error, k and j not objects\n...\nif ((intObj.intValue()).compareTo(intObj2.intValue()) < 0)\n... \/\/error, can’t use compareTo on primitive types\nif (intObj.compareTo(object) < 0) \/\/Error. Parameter needs Integer cast if (intObj.compareTo((Integer) object) < 0) \/\/OK\n...\nif (object.compareTo(intObj) < 0) \/\/error, no compareTo in Object\n...\nif (((Integer) object).compareTo(intObj) < 0) \/\/OK\n...\n\nThe Double class wraps a value of type double in an object. An object of type Double contains just one instance variable whose type is double.\nThe methods you should know for the AP exam are analogous to those for type\nInteger.\nDouble(double value)\nConstructs a Double object from a double. (Boxing.)\ndouble doubleValue()\nReturns the value of this Double as a double. (Unboxing.)\nint compareTo(Double other)\nReturns 0 if the value of this Double is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nboolean equals(Object obj)\nThis method overrides equals in class Object and throws a ClassCastException if obj is not a Double. Otherwise it returns true if and only if this Double has the same double value as obj.\nString toString()\nReturns a String representing the value of this Double.\n\nHere are some examples:\nDouble dObj = new Double(2.5); \/\/boxes 2.5 in Double object\ndouble d = dObj.doubleValue(); \/\/unboxes 2.5 from Double object\nObject object = new Double(7.3); \/\/Double is a subclass of Object\nObject intObj = new Integer(4);\nif (dObj.compareTo(object) > 0) \/\/Error. Parameter needs cast to Double\nif (dObj.compareTo((Double) object) > 0) \/\/OK\n...\nif (dObj.compareTo(intObj) > 0) \/\/ClassCastException\n... \/\/can’t compare Integer to Double\n\nNOTE\n1. Integer and Double objects are immutable: There are no mutator methods in the classes.\n2. See p. 242 for a discussion of auto-boxing and -unboxing. This useful feature will not be tested on the AP exam.\n\n\n###\n\n","completion":" Question: Consider these declarations:\n\nInteger intOb = new Integer(3); \nObject ob = new Integer(4); \nDouble doubOb = new Double(3.0); \n\nWhich of the following will not cause an error? \nCorrect: if (intOb.compareTo((Integer) ob) < 0) ...\n\n\nIncorrect: if ((Integer) ob.compareTo(intOb) < 0) ...\nIncorrect: if (ob.compareTo(intOb) < 0) ...\nIncorrect: if (intOb.compareTo(doubOb) < 0) ...\nIncorrect: if (intOb.compareTo(ob) < 0) ...END"}
{"prompt":"A wrapper class takes either an existing object or a value of primitive type, “wraps” or “boxes” it in an object, and provides a new set of methods for that type. The point of a wrapper class is to provide extended capabilities for the boxed quantity:\n• It can be used in generic Java methods that require objects as parameters.\n• It can be used in Java container classes that require the items be objects (see p. 242).\n\nIn each case, the wrapper class allows\n1. Construction of an object from a single value (wrapping or boxing the primitive in a wrapper object).\n2. Retrieval of the primitive value (unwrapping or unboxing from the wrapper object).\nJava provides a wrapper class for each of its primitive types. The two that you should know for the AP exam are the Integer and Double classes.\n\nThe Integer class wraps a value of type int in an object. An object of type Integer contains just one instance variable whose type is int.\nHere are the Integer methods you should know for the AP exam:\nInteger(int value)\nConstructs an Integer object from an int. (Boxing.)\nint compareTo(Integer other)\nReturns 0 if the value of this Integer is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nint intValue()\nReturns the value of this Integer as an int. (Unboxing.)\nboolean equals(Object obj)\nReturns true if and only if this Integer has the same int value as obj.\nNOTE\n1. This method overrides equals in class Object.\n2. This method throws a ClassCastException if obj is not an Integer.\nString toString()\nReturns a String representing the value of this Integer.\nHere are some examples to illustrate the Integer methods:\nInteger intObj = new Integer(6); \/\/boxes 6 in Integer object\nint j = intObj.intValue(); \/\/unboxes 6 from Integer object\nSystem.out.println(\"Integer value is \" + intObj);\n\/\/calls toString() for intObj\n\/\/output is\n\/\/Integer value is 6\nObject object = new Integer(5); \/\/Integer is a subclass of Object\nInteger intObj2 = new Integer(3);\nint k = intObj2.intValue();\nif (intObj.equals(intObj2)) \/\/OK, evaluates to false\n...\nif (intObj.intValue() == intObj2.intValue())\n... \/\/OK, since comparing primitive types\nif (k.equals(j)) \/\/error, k and j not objects\n...\nif ((intObj.intValue()).compareTo(intObj2.intValue()) < 0)\n... \/\/error, can’t use compareTo on primitive types\nif (intObj.compareTo(object) < 0) \/\/Error. Parameter needs Integer cast if (intObj.compareTo((Integer) object) < 0) \/\/OK\n...\nif (object.compareTo(intObj) < 0) \/\/error, no compareTo in Object\n...\nif (((Integer) object).compareTo(intObj) < 0) \/\/OK\n...\n\nThe Double class wraps a value of type double in an object. An object of type Double contains just one instance variable whose type is double.\nThe methods you should know for the AP exam are analogous to those for type\nInteger.\nDouble(double value)\nConstructs a Double object from a double. (Boxing.)\ndouble doubleValue()\nReturns the value of this Double as a double. (Unboxing.)\nint compareTo(Double other)\nReturns 0 if the value of this Double is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nboolean equals(Object obj)\nThis method overrides equals in class Object and throws a ClassCastException if obj is not a Double. Otherwise it returns true if and only if this Double has the same double value as obj.\nString toString()\nReturns a String representing the value of this Double.\n\nHere are some examples:\nDouble dObj = new Double(2.5); \/\/boxes 2.5 in Double object\ndouble d = dObj.doubleValue(); \/\/unboxes 2.5 from Double object\nObject object = new Double(7.3); \/\/Double is a subclass of Object\nObject intObj = new Integer(4);\nif (dObj.compareTo(object) > 0) \/\/Error. Parameter needs cast to Double\nif (dObj.compareTo((Double) object) > 0) \/\/OK\n...\nif (dObj.compareTo(intObj) > 0) \/\/ClassCastException\n... \/\/can’t compare Integer to Double\n\nNOTE\n1. Integer and Double objects are immutable: There are no mutator methods in the classes.\n2. See p. 242 for a discussion of auto-boxing and -unboxing. This useful feature will not be tested on the AP exam.\n\n\n###\n\n","completion":" Question: Refer to these declarations: \n\nInteger k = new Integer(8); \nInteger m = new Integer(4); \n\nWhich test will not generate an error? \nI if (k.intValue() == m.intValue())... \nII if ((k.intValue()).equals(m.intValue()))... \nIII if ((k.toString()).equals(m.toString()))... \nCorrect: I and III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"A wrapper class takes either an existing object or a value of primitive type, “wraps” or “boxes” it in an object, and provides a new set of methods for that type. The point of a wrapper class is to provide extended capabilities for the boxed quantity:\n• It can be used in generic Java methods that require objects as parameters.\n• It can be used in Java container classes that require the items be objects (see p. 242).\n\nIn each case, the wrapper class allows\n1. Construction of an object from a single value (wrapping or boxing the primitive in a wrapper object).\n2. Retrieval of the primitive value (unwrapping or unboxing from the wrapper object).\nJava provides a wrapper class for each of its primitive types. The two that you should know for the AP exam are the Integer and Double classes.\n\nThe Integer class wraps a value of type int in an object. An object of type Integer contains just one instance variable whose type is int.\nHere are the Integer methods you should know for the AP exam:\nInteger(int value)\nConstructs an Integer object from an int. (Boxing.)\nint compareTo(Integer other)\nReturns 0 if the value of this Integer is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nint intValue()\nReturns the value of this Integer as an int. (Unboxing.)\nboolean equals(Object obj)\nReturns true if and only if this Integer has the same int value as obj.\nNOTE\n1. This method overrides equals in class Object.\n2. This method throws a ClassCastException if obj is not an Integer.\nString toString()\nReturns a String representing the value of this Integer.\nHere are some examples to illustrate the Integer methods:\nInteger intObj = new Integer(6); \/\/boxes 6 in Integer object\nint j = intObj.intValue(); \/\/unboxes 6 from Integer object\nSystem.out.println(\"Integer value is \" + intObj);\n\/\/calls toString() for intObj\n\/\/output is\n\/\/Integer value is 6\nObject object = new Integer(5); \/\/Integer is a subclass of Object\nInteger intObj2 = new Integer(3);\nint k = intObj2.intValue();\nif (intObj.equals(intObj2)) \/\/OK, evaluates to false\n...\nif (intObj.intValue() == intObj2.intValue())\n... \/\/OK, since comparing primitive types\nif (k.equals(j)) \/\/error, k and j not objects\n...\nif ((intObj.intValue()).compareTo(intObj2.intValue()) < 0)\n... \/\/error, can’t use compareTo on primitive types\nif (intObj.compareTo(object) < 0) \/\/Error. Parameter needs Integer cast if (intObj.compareTo((Integer) object) < 0) \/\/OK\n...\nif (object.compareTo(intObj) < 0) \/\/error, no compareTo in Object\n...\nif (((Integer) object).compareTo(intObj) < 0) \/\/OK\n...\n\nThe Double class wraps a value of type double in an object. An object of type Double contains just one instance variable whose type is double.\nThe methods you should know for the AP exam are analogous to those for type\nInteger.\nDouble(double value)\nConstructs a Double object from a double. (Boxing.)\ndouble doubleValue()\nReturns the value of this Double as a double. (Unboxing.)\nint compareTo(Double other)\nReturns 0 if the value of this Double is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nboolean equals(Object obj)\nThis method overrides equals in class Object and throws a ClassCastException if obj is not a Double. Otherwise it returns true if and only if this Double has the same double value as obj.\nString toString()\nReturns a String representing the value of this Double.\n\nHere are some examples:\nDouble dObj = new Double(2.5); \/\/boxes 2.5 in Double object\ndouble d = dObj.doubleValue(); \/\/unboxes 2.5 from Double object\nObject object = new Double(7.3); \/\/Double is a subclass of Object\nObject intObj = new Integer(4);\nif (dObj.compareTo(object) > 0) \/\/Error. Parameter needs cast to Double\nif (dObj.compareTo((Double) object) > 0) \/\/OK\n...\nif (dObj.compareTo(intObj) > 0) \/\/ClassCastException\n... \/\/can’t compare Integer to Double\n\nNOTE\n1. Integer and Double objects are immutable: There are no mutator methods in the classes.\n2. See p. 242 for a discussion of auto-boxing and -unboxing. This useful feature will not be tested on the AP exam.\n\n\n###\n\n","completion":" Question: Consider the code fragment \n\nObject intObj = new Integer(9); \nSystem.out.println((String) intObj); \n\nWhat will be output as a result of running the fragment? \nCorrect: No output. A ClassCastException will be thrown.\nIncorrect: No output. An ArithmeticException will be thrown.\nIncorrect: 9\nIncorrect: \"9\"\nIncorrect: nine\n\nEND"}
{"prompt":"There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n• If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n• If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n• If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) \/\/true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) \/\/false, \"H\" comes before \"d\"\nDon’t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you’re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don’t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) \/\/returns \"happy\"\n\"cold\".substring(4) \/\/returns \"\" (empty string)\n\"cold\".substring(5) \/\/StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) \/\/returns \"be\"\n\"crayfish\".substring(4,8) \/\/returns \"fish\"\n\"crayfish\".substring(4,9) \/\/StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) \/\/StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); \/\/x has value 5\nx = s.indexOf(\"farmer\"); \/\/x has value -1\nint y = s.length(); \/\/y has value 9\n\n\n###\n\n","completion":" Question: Consider these declarations: \n\nString s1 = \"crab\"; \nString s2 = new String(\"crab\"); \nString s3 = s1; \n\nWhich expression involving these strings evaluates to true? \nI s1 == s2 \nII s1.equals(s2) \nIII s3.equals(s2) \nCorrect: II and III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n• If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n• If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n• If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) \/\/true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) \/\/false, \"H\" comes before \"d\"\nDon’t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you’re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don’t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) \/\/returns \"happy\"\n\"cold\".substring(4) \/\/returns \"\" (empty string)\n\"cold\".substring(5) \/\/StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) \/\/returns \"be\"\n\"crayfish\".substring(4,8) \/\/returns \"fish\"\n\"crayfish\".substring(4,9) \/\/StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) \/\/StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); \/\/x has value 5\nx = s.indexOf(\"farmer\"); \/\/x has value -1\nint y = s.length(); \/\/y has value 9\n\n\n###\n\n","completion":" Question: Suppose that strA = \"TOMATO\", strB = \"tomato\", and strC = \"tom\". Given that \"A\" comes before \"a\" in dictionary order, which is true? \nCorrect: !(strA.equals(strB)) && strC.compareTo(strB) < 0\nIncorrect: strA.compareTo(strB) < 0 && strB.compareTo(strC) < 0\nIncorrect: strB.compareTo(strA) < 0 || strC.compareTo(strA) < 0\nIncorrect: strC.compareTo(strA) < 0 && strA.compareTo(strB) < 0\nIncorrect: !(strA.equals(strB)) && strC.compareTo(strA) < 0\n\nEND"}
{"prompt":"There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n• If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n• If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n• If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) \/\/true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) \/\/false, \"H\" comes before \"d\"\nDon’t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you’re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don’t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) \/\/returns \"happy\"\n\"cold\".substring(4) \/\/returns \"\" (empty string)\n\"cold\".substring(5) \/\/StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) \/\/returns \"be\"\n\"crayfish\".substring(4,8) \/\/returns \"fish\"\n\"crayfish\".substring(4,9) \/\/StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) \/\/StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); \/\/x has value 5\nx = s.indexOf(\"farmer\"); \/\/x has value -1\nint y = s.length(); \/\/y has value 9\n\n\n###\n\n","completion":" Question: This question refers to the following declaration: \n\nString line = \"Some more silly stuff on strings!\"; \n\/\/the words are separated by a single space \n\nWhat string will str refer to after execution of the following? \n\nint x = line.indexOf(\"m\"); \nString str = line.substring(10, 15) + line.substring(25, 25 + x); \n\nCorrect: \"sillyst\"\nIncorrect: \"sillystr\"\nIncorrect: \"silly st\"\nIncorrect: \"silly str\"\nIncorrect: \"sillystrin\"\n\nEND"}
{"prompt":"There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n• If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n• If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n• If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) \/\/true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) \/\/false, \"H\" comes before \"d\"\nDon’t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you’re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don’t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) \/\/returns \"happy\"\n\"cold\".substring(4) \/\/returns \"\" (empty string)\n\"cold\".substring(5) \/\/StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) \/\/returns \"be\"\n\"crayfish\".substring(4,8) \/\/returns \"fish\"\n\"crayfish\".substring(4,9) \/\/StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) \/\/StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); \/\/x has value 5\nx = s.indexOf(\"farmer\"); \/\/x has value -1\nint y = s.length(); \/\/y has value 9\n\n\n###\n\n","completion":" Question: A program has a String variable fullName that stores a first name, followed by a space, followed by a last name. There are no spaces in either the first or last names. Here are some examples of fullName values: \"Anthony Coppola\", \"Jimmy Carroll\", and \"Tom DeWire\". Consider this code segment that extracts the last name from a fullName variable, and stores it in lastName with no surrounding blanks: \n\nint k = fullName.indexOf(\" \"); \/\/find index of blank \nString lastName = \/* expression *\/ \n\nWhich is a correct replacement for \/* expression *\/? \nI fullName.substring(k); \nII fullName.substring(k + 1); \nIII fullName.substring(k + 1, fullName.length()); \nCorrect: II and III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and III only\n\nEND"}
{"prompt":"There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n• If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n• If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n• If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) \/\/true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) \/\/false, \"H\" comes before \"d\"\nDon’t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you’re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don’t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) \/\/returns \"happy\"\n\"cold\".substring(4) \/\/returns \"\" (empty string)\n\"cold\".substring(5) \/\/StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) \/\/returns \"be\"\n\"crayfish\".substring(4,8) \/\/returns \"fish\"\n\"crayfish\".substring(4,9) \/\/StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) \/\/StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); \/\/x has value 5\nx = s.indexOf(\"farmer\"); \/\/x has value -1\nint y = s.length(); \/\/y has value 9\n\n\n###\n\n","completion":" Question: One of the rules for converting English to Pig Latin states: If a word begins with a consonant, move the consonant to the end of the word and add “ay”. Thus “dog” becomes “ogday,” and “crisp” becomes “rispcay”. Suppose s is a String containing an English word that begins with a consonant. Which of the following creates the correct corresponding word in Pig Latin? Assume the declarations \n\nString ayString = \"ay\"; \nString pigString; \n\nCorrect: pigString = s.substring(1, s.length()) + s.substring(0,1) + ayString;\n\n\nIncorrect: pigString = s.substring(0, s.length()) + s.substring(0,1) + ayString;\nIncorrect: pigString = s.substring(1, s.length()) + s.substring(0,0) + ayString;\nIncorrect: pigString = s.substring(0, s.length()-1) + s.substring(0,1) + ayString;\nIncorrect: pigString = s.substring(1, s.length()-1) + s.substring(0,0) + ayString;END"}
{"prompt":"There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n• If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n• If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n• If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) \/\/true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) \/\/false, \"H\" comes before \"d\"\nDon’t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you’re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don’t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) \/\/returns \"happy\"\n\"cold\".substring(4) \/\/returns \"\" (empty string)\n\"cold\".substring(5) \/\/StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) \/\/returns \"be\"\n\"crayfish\".substring(4,8) \/\/returns \"fish\"\n\"crayfish\".substring(4,9) \/\/StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) \/\/StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); \/\/x has value 5\nx = s.indexOf(\"farmer\"); \/\/x has value -1\nint y = s.length(); \/\/y has value 9\n\n\n###\n\n","completion":" Question: This question refers to the getString method shown below: \n\npublic static String getString(String s1, String s2) \n{ \n    int index = s1.indexOf(s2); \n    return s1.substring(index, index + s2.length()); \n} \n\nWhich is true about getString? It may return a string that \nI Is equal to s2. \nII Has no characters in common with s2. \nIII Is equal to s1. \nCorrect: I and III only\nIncorrect: II and III only\nIncorrect: I and II only\nIncorrect: I, II, and III\nIncorrect: None is true.\n\nEND"}
{"prompt":"There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n• If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n• If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n• If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) \/\/true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) \/\/false, \"H\" comes before \"d\"\nDon’t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you’re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don’t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) \/\/returns \"happy\"\n\"cold\".substring(4) \/\/returns \"\" (empty string)\n\"cold\".substring(5) \/\/StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) \/\/returns \"be\"\n\"crayfish\".substring(4,8) \/\/returns \"fish\"\n\"crayfish\".substring(4,9) \/\/StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) \/\/StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); \/\/x has value 5\nx = s.indexOf(\"farmer\"); \/\/x has value -1\nint y = s.length(); \/\/y has value 9\n\n\n###\n\n","completion":" Question: Consider this method: \n\npublic static String doSomething(String s) \n{ \n    final String BLANK = \" \"; \/\/BLANK contains a single space \n    String str = \"\"; \/\/empty string \n    String temp; \n    for (int i = 0; i < s.length(); i++) \n    { \n        temp = s.substring(i, i + 1); \n        if (!(temp.equals(BLANK))) \n            str += temp; \n    } \n    return str; \n} \n\nWhich of the following is the most precise description of what doSomething does? \nCorrect: It returns a String that is equivalent to s with all its blanks removed.\nIncorrect: It returns s unchanged.\nIncorrect: It returns s with all its blanks removed.\nIncorrect: It returns a String that is an exact copy of s.\nIncorrect: It returns a String that contains s.length() blanks.\n\nEND"}
{"prompt":"A wrapper class takes either an existing object or a value of primitive type, “wraps” or “boxes” it in an object, and provides a new set of methods for that type. The point of a wrapper class is to provide extended capabilities for the boxed quantity:\n• It can be used in generic Java methods that require objects as parameters.\n• It can be used in Java container classes that require the items be objects (see p. 242).\n\nIn each case, the wrapper class allows\n1. Construction of an object from a single value (wrapping or boxing the primitive in a wrapper object).\n2. Retrieval of the primitive value (unwrapping or unboxing from the wrapper object).\nJava provides a wrapper class for each of its primitive types. The two that you should know for the AP exam are the Integer and Double classes.\n\nThe Integer class wraps a value of type int in an object. An object of type Integer contains just one instance variable whose type is int.\nHere are the Integer methods you should know for the AP exam:\nInteger(int value)\nConstructs an Integer object from an int. (Boxing.)\nint compareTo(Integer other)\nReturns 0 if the value of this Integer is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nint intValue()\nReturns the value of this Integer as an int. (Unboxing.)\nboolean equals(Object obj)\nReturns true if and only if this Integer has the same int value as obj.\nNOTE\n1. This method overrides equals in class Object.\n2. This method throws a ClassCastException if obj is not an Integer.\nString toString()\nReturns a String representing the value of this Integer.\nHere are some examples to illustrate the Integer methods:\nInteger intObj = new Integer(6); \/\/boxes 6 in Integer object\nint j = intObj.intValue(); \/\/unboxes 6 from Integer object\nSystem.out.println(\"Integer value is \" + intObj);\n\/\/calls toString() for intObj\n\/\/output is\n\/\/Integer value is 6\nObject object = new Integer(5); \/\/Integer is a subclass of Object\nInteger intObj2 = new Integer(3);\nint k = intObj2.intValue();\nif (intObj.equals(intObj2)) \/\/OK, evaluates to false\n...\nif (intObj.intValue() == intObj2.intValue())\n... \/\/OK, since comparing primitive types\nif (k.equals(j)) \/\/error, k and j not objects\n...\nif ((intObj.intValue()).compareTo(intObj2.intValue()) < 0)\n... \/\/error, can’t use compareTo on primitive types\nif (intObj.compareTo(object) < 0) \/\/Error. Parameter needs Integer cast if (intObj.compareTo((Integer) object) < 0) \/\/OK\n...\nif (object.compareTo(intObj) < 0) \/\/error, no compareTo in Object\n...\nif (((Integer) object).compareTo(intObj) < 0) \/\/OK\n...\n\nThe Double class wraps a value of type double in an object. An object of type Double contains just one instance variable whose type is double.\nThe methods you should know for the AP exam are analogous to those for type\nInteger.\nDouble(double value)\nConstructs a Double object from a double. (Boxing.)\ndouble doubleValue()\nReturns the value of this Double as a double. (Unboxing.)\nint compareTo(Double other)\nReturns 0 if the value of this Double is equal to the value of other, a negative integer if it is less than the value of other, and a positive integer if it is greater than the value of other.\nboolean equals(Object obj)\nThis method overrides equals in class Object and throws a ClassCastException if obj is not a Double. Otherwise it returns true if and only if this Double has the same double value as obj.\nString toString()\nReturns a String representing the value of this Double.\n\nHere are some examples:\nDouble dObj = new Double(2.5); \/\/boxes 2.5 in Double object\ndouble d = dObj.doubleValue(); \/\/unboxes 2.5 from Double object\nObject object = new Double(7.3); \/\/Double is a subclass of Object\nObject intObj = new Integer(4);\nif (dObj.compareTo(object) > 0) \/\/Error. Parameter needs cast to Double\nif (dObj.compareTo((Double) object) > 0) \/\/OK\n...\nif (dObj.compareTo(intObj) > 0) \/\/ClassCastException\n... \/\/can’t compare Integer to Double\n\nNOTE\n1. Integer and Double objects are immutable: There are no mutator methods in the classes.\n2. See p. 242 for a discussion of auto-boxing and -unboxing. This useful feature will not be tested on the AP exam.\n\n\n###\n\n","completion":" Question: The following question deals with the problem of swapping two integer values. Three methods are proposed to solve the problem, using primitive int types, Integer objects, and IntPair objects, where IntPair is defined as follows: \n\npublic class IntPair {\n    private int firstValue;\n    private int secondValue;\n\n    public IntPair(int first, int second) {\n        firstValue = first;\n        secondValue = second;\n    }\n\n    public int getFirst() {\n        return firstValue;\n    }\n\n    public int getSecond() {\n        return secondValue;\n    }\n\n    public void setFirst(int a) {\n        firstValue = a;\n    }\n\n    public void setSecond(int b) {\n        secondValue = b;\n    }\n}\n\nHere are three different swap methods, each intended for use in a client program.\nI public static void swap(int a, int b) \n{ \n    int temp = a; \n    a = b; \n    b = temp; \n} \nII public static void swap(Integer obj_a, Integer obj_b) \n{ \n    Integer temp = new Integer(obj_a.intValue()); \n    obj_a = obj_b; \n    obj_b = temp; \n} \nIII public static void swap(IntPair pair) \n{ \n    int temp = pair.getFirst(); \n    pair.setFirst(pair.getSecond()); \n    pair.setSecond(temp); \n} \nWhen correctly used in a client program with appropriate parameters, which method will swap two integers, as intended? \nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: II and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n• If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n• If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n• If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) \/\/true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) \/\/false, \"H\" comes before \"d\"\nDon’t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you’re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don’t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) \/\/returns \"happy\"\n\"cold\".substring(4) \/\/returns \"\" (empty string)\n\"cold\".substring(5) \/\/StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) \/\/returns \"be\"\n\"crayfish\".substring(4,8) \/\/returns \"fish\"\n\"crayfish\".substring(4,9) \/\/StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) \/\/StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); \/\/x has value 5\nx = s.indexOf(\"farmer\"); \/\/x has value -1\nint y = s.length(); \/\/y has value 9\n\n\n###\n\n","completion":" Question: Consider the Name class defined below:\n\npublic class Name {\n    private String firstName;\n    private String lastName;\n\n    public Name(String first, String last) \/\/ constructor\n    {\n        firstName = first;\n        lastName = last;\n    }\n\n    public String toString() {\n        return firstName + \" \" + lastName;\n    }\n\n    public boolean equals(Object obj) {\n        Name n = (Name) obj;\n        return n.firstName.equals(firstName) && n.lastName.equals(lastName);\n    }\n\n    public int hashCode() { \/* implementation not shown *\/ }\n\n    public int compareTo(Name n) { \/* more code *\/ }\n}\n\nThe compareTo method implements the standard name-ordering algorithm where last names take precedence over first names. Lexicographic or dictionary ordering of Strings is used. For example, the name Scott Dentes comes before Nick Elser, and Adam Cooper comes before Sara Cooper. \nWhich of the following is a correct replacement for \/* more code *\/? \nI int lastComp = lastName.compareTo(n.lastName); \nif (lastComp != 0) \n    return lastComp; \nelse \n    return firstName.compareTo(n.firstName); \nII if (lastName.equals(n.lastName)) \n    return firstName.compareTo(n.firstName); \nelse \n    return 0; \nIII if (!(lastName.equals(n.lastName))) \n    return firstName.compareTo(n.firstName); \nelse \n    return lastName.compareTo(n.lastName); \nCorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"There are two ways to compare String objects:\n1. Use the equals method that is inherited from the Object class and overridden to do the correct thing:\nif (string1.equals(string2)) ...\nThis returns true if string1 and string2 are identical strings, false otherwise.\n2. Use the compareTo method. The String class has a compareTo method:\nint compareTo(String otherString)\nIt compares strings in dictionary (lexicographical) order:\n• If string1.compareTo(string2) < 0, then string1 precedes string2 in the dictionary.\n• If string1.compareTo(string2) > 0, then string1 follows string2 in the dictionary.\n• If string1.compareTo(string2) == 0, then string1 and string2 are identical. (This test is an alternative to string1.equals(string2).)\nBe aware that Java is case-sensitive. Thus, if s1 is \"cat\" and s2 is \"Cat\", s1.equals(s2) will return false.\n\nCharacters are compared according to their position in the ASCII chart. All you need to know is that all digits precede all capital letters, which precede all lowercase letters. Thus \"5\" comes before \"R\", which comes before \"a\". Two strings are com pared as follows: Start at the left end of each string and do a character-by-character comparison until you reach the first character in which the strings differ, the kth char acter, say. If the kth character of s1 comes before the kth character of s2, then s1 will come before s2, and vice versa. If the strings have identical characters, except that s1 terminates before s2, then s1 comes before s2. Here are some examples:\nString s1 = \"HOT\", s2 = \"HOTEL\", s3 = \"dog\";\nif (s1.compareTo(s2) < 0)) \/\/true, s1 terminates first\n...\nif (s1.compareTo(s3) > 0)) \/\/false, \"H\" comes before \"d\"\nDon’t Use == to Test Strings!\nThe expression if(string1 == string2) tests whether string1 and string2 are the same reference. It does not test the actual strings. Using == to compare strings may lead to unexpected results.\n\nExample 1\nString s = \"oh no!\";\nString t = \"oh no!\";\nif (s == t) ...\nThe test returns true even though it appears that s and t are different references. The reason is that for efficiency Java makes only one String object for equivalent string literals. This is safe in that a String cannot be altered.\nExample 2\nString s = \"oh no!\";\nString t = new String(\"oh no!\");\nif (s == t) ...\nThe test returns false because use of new creates a new object, and s and t are different references in this example!\nThe moral of the story? Use equals not == to test strings. It always does the right thing.\n\nThe Java String class provides many methods, only a small number of which are in the AP Java subset. In addition to the constructors, comparison methods, and concatenation operator + discussed so far, you should know the following methods:\nint length()\nReturns the length of this string.\nString substring(int startIndex)\nReturns a new string that is a substring of this string. The substring starts with the character at startIndex and extends to the end of the string. The first character is at index zero. The method throws an IndexOutOfBoundsException if startIndex is negative or larger than the length of the string. Note that if you’re using Java 7 or above, you will see the error StringIndexOutOfBoundsException. However, the AP Java subset lists only IndexOutOfBoundsException, which is what they will use on the AP exam.\nString substring(int startIndex, int endIndex)\nReturns a new string that is a substring of this string. The substring starts at index startIndex and extends to the character at endIndex-1. (Think of it this way: startIndex is the first character that you want; endIndex is the first character that you don’t want.) The method throws a StringIndexOutOfBoundsException if startIndex is negative, or endIndex is larger than the length of the string, or startIndex is larger than endIndex.\nint indexOf(String str)\nReturns the index of the first occurrence of str within this string. If str is not a substring of this string, -1 is returned. The method throws a NullPointerException if str is null.\nHere are some examples:\n\"unhappy\".substring(2) \/\/returns \"happy\"\n\"cold\".substring(4) \/\/returns \"\" (empty string)\n\"cold\".substring(5) \/\/StringIndexOutOfBoundsException\n\"strawberry\".substring(5,7) \/\/returns \"be\"\n\"crayfish\".substring(4,8) \/\/returns \"fish\"\n\"crayfish\".substring(4,9) \/\/StringIndexOutOfBoundsException\n\"crayfish\".substring(5,4) \/\/StringIndexOutOfBoundsException\nString s = \"funnyfarm\";\nint x = s.indexOf(\"farm\"); \/\/x has value 5\nx = s.indexOf(\"farmer\"); \/\/x has value -1\nint y = s.length(); \/\/y has value 9\n\n\n###\n\n","completion":" Question: Consider the Name class defined below:\n\npublic class Name {\n    private String firstName;\n    private String lastName;\n\n    public Name(String first, String last) \/\/ constructor\n    {\n        firstName = first;\n        lastName = last;\n    }\n\n    public String toString() {\n        return firstName + \" \" + lastName;\n    }\n\n    public boolean equals(Object obj) {\n        Name n = (Name) obj;\n        return n.firstName.equals(firstName) && n.lastName.equals(lastName);\n    }\n\n    public int hashCode() { \/* implementation not shown *\/ }\n\n    public int compareTo(Name n) { \/* more code *\/ }\n}\n\nWhich statement about the Name class is false? \nCorrect: Since the Name class has a compareTo method, it must provide an implementation for an equals method.\n\nIncorrect: Name objects are immutable.\nIncorrect: It is possible for the methods in Name to throw a NullPointerException.\nIncorrect: If n1 and n2 are Name objects in a client class, then the expressions\nn1.equals(n2) and n1.compareTo(n2) == 0 must have the same value. \nIncorrect: The compareTo method throws a run-time exception if the parameter is null.END"}
{"prompt":"The header of a method defines the parameters of that method. For example, consider the withdraw method of the BankAccount class:\npublic class BankAccount\n{ ...\n    public void withdraw(String acctPassword, double amount) ...\n\nThis method has two explicit parameters, acctPassword and amount. These are dummy or formal parameters. Think of them as placeholders for the pair of actual parameters or arguments that will be supplied by a particular method call in a client program. For example,\nDo not make a method call with an object whose value is null.\n\nBankAccount b = new BankAccount(\"TimB\", 1000);\nb.withdraw(\"TimB\", 250);\n\nHere \"TimB\" and 250 are the actual parameters that match up with acctPassword and amount for the withdraw method.\n\n1. The number of arguments in the method call must equal the number of param eters in the method header, and the type of each argument must be compatible with the type of each corresponding parameter.\n2. In addition to its explicit parameters, the withdraw method has an implicit parameter, this, the BankAccount from which money will be withdrawn. In the method call\nb.withdraw(\"TimB\", 250);\nthe actual parameter that matches up with this is the object reference b.\n\nParameters are passed by value. For primitive types this means that when a method is called, a new memory slot is allocated for each parameter. The value of each argument is copied into the newly created memory slot corresponding to each parameter.\nDuring execution of the method, the parameters are local to that method. Any changes made to the parameters will not affect the values of the arguments in the calling program. When the method is exited, the local memory slots for the parameters are erased.\nHere’s an example: What will the output be?\n\npublic class ParamTest {\n    public static void foo(int x, double y) {\n        x = 3;\n        y = 2.5;\n    }\n\n    public static void main(String[] args) {\n        int a = 7;\n        double b = 6.5;\n        foo(a, b);\n        System.out.println(a + \" \" + b);\n    }\n}\n\nThe output will be\n7 6.5\nThe arguments a and b remain unchanged, despite the method call!\nThis can be understood by picturing the state of the memory slots during execution of the program.\n\n\n###\n\n","completion":" Question: Which statement about parameters is false?\nCorrect: Two overloaded methods in the same class must have parameters with different names.\nIncorrect: The scope of parameters is the method in which they are defined.\nIncorrect: Static methods have no implicit parameter this.\nIncorrect: All parameters in Java are passed by value.\nIncorrect: Two different constructors in a given class can have the same number of parameters.\n\nEND"}
{"prompt":"A constructor creates an object of the class. You can recognize a constructor by its name—always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n\/** Default constructor.\n* Constructs a bank account with default values. *\/\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address—we say “b is a reference to the object.”\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n\/** Constructor. Constructs a bank account with\n* specified password and balance. *\/\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n\/** @return the balance of this account *\/\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n\/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*\/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n        balance += amount;\n}\n\/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*\/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n    {\n        balance -= amount; \/\/allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\n###\n\n","completion":" Question: Consider the Time class defined below:\n\npublic class Time\n{\n\tprivate int hrs;\n\tprivate int mins;\n\tprivate int secs;\n\n\tpublic Time()\n\t{ \/* implementation not shown *\/ }\n\n\tpublic Time(int h, int m, int s)\n\t{ \/* implementation not shown *\/ }\n\n\t\/** Resets time to hrs = h, mins = m, secs = s. *\/\n\tpublic void resetTime(int h, int m, int s)\n\t{ \/* implementation not shown *\/ }\n\n\t\/** Advances time by one second. *\/\n\tpublic void increment()\n\t{ \/* implementation not shown *\/ }\n\n\t\/** @return true if this time equals t, false otherwise *\/\n\tpublic boolean equals(Time t)\n\t{ \/* implementation not shown *\/ }\n\n\t\/** @return true if this time is earlier than t, false otherwise *\/\n\tpublic boolean lessThan(Time t)\n\t{ \/* implementation not shown *\/ }\n\n\t\/** @return a String with the time in the form hrs:mins:secs *\/\n\tpublic String toString()\n\t{ \/* implementation not shown *\/ }\n}\n\nWhich of the following is a false statement about the methods?\nCorrect: The Time class has three constructors.\nIncorrect: equals, lessThan, and toString are all accessor methods.\nIncorrect: increment is a mutator method.\nIncorrect: Time() is the default constructor.\nIncorrect: There are no static methods in this class.\n\nEND"}
{"prompt":"Every program that you write involves at least one thing that is being created or manipulated by the program. This thing, together with the operations that manipulate it, is called an object.\nConsider, for example, a program that must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. Rules for validity are provided. The object is a four-digit code number. Some of the operations to manipulate the object could be readNumber, getSeparateDigits, testValidity, and writeNumber.\nAny given program can have several different types of objects. For example, a pro gram that maintains a database of all books in a library has at least two objects:\n1. A Book object, with operations like getTitle, isOnShelf, isFiction, and goOutOfPrint.\n2. A ListOfBooks object, with operations like search, addBook, removeBook, and sortByAuthor.\nAn object is characterized by its state and behavior. For example, a book has a state described by its title, author, whether it’s on the shelf, and so on. It also has behavior, like going out of print.\nNotice that an object is an idea, separate from the concrete details of a programming language. It corresponds to some real-world object that is being represented by the program.\nAll object-oriented programming languages have a way to represent an object as a variable in a program. In Java, a variable that represents an object is called an object reference.\nA class is a software blueprint for implementing objects of a given type. An object is a single instance of the class. In a program there will often be several different instances of a given class type.\nThe current state of a given object is maintained in its data fields orinstance variables, provided by the class. The methods of the class provide both the behaviors exhibited by the object and the operations that manipulate the object. Combining an object’s data and methods into a single unit called a class is known as encapsulation.\nHere is the framework for a simple bank account class:\n\npublic class BankAccount {\n    private String password;\n    private double balance;\n    public static final double OVERDRAWN_PENALTY = 20.00;\n\n    \/\/ constructors\n    \/**\n     * Default constructor.\n     * Constructs bank account with default values.\n     *\/\n    public BankAccount() {\n        \/* implementation code *\/ }\n\n    \/** Constructs bank account with specified password and balance. *\/\n    public BankAccount(String acctPassword, double acctBalance) {\n        \/* implementation code *\/ }\n\n    \/\/ accessor\n    \/** @return balance of this account *\/\n    public double getBalance() {\n        \/* implementation code *\/ }\n\n    \/\/ mutators\n    \/**\n     * Deposits amount in bank account with given password.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be deposited\n     *\/\n    public void deposit(String acctPassword, double amount) {\n        \/* implementation code *\/ }\n\n    \/**\n     * Withdraws amount from bank account with given password.\n     * Assesses penalty if balance is less than amount.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be withdrawn\n     *\/\n    public void withdraw(String acctPassword, double amount) {\n        \/* implementation code *\/ }\n}\nThe keyword public preceding the class declaration signals that the class is usable by all client programs. If a class is not public, it can be used only by classes in its own package. In the AP Java subset, all classes are public.\nSimilarly, public methods are accessible to all client programs. Clients, however, are not privy to the class implementation and may not access the private instance variables and private methods of the class. Restriction of access is known as information hiding. In Java, this is implemented by using the keyword private. Private methods and vari ables in a class can be accessed only by methods of that class. Even though Java allows public instance variables, in the AP Java subset all instance variables are private.\nA static variable (class variable) contains a value that is shared by all instances of the class. “Static” means that memory allocation happens once.\nTypical uses of a static variable are to\n• keep track of statistics for objects of the class.\n• accumulate a total.\n• provide a new identity number for each new object of the class.\nFor example:\n\npublic class Employee\n{\n    private String name;\n    private static int employeeCount = 0; \/\/number of employees\n    public Employee( < parameter list > )\n    {\n        < initialization of private instance variables >\n        employeeCount++; \/\/increment count of all employees\n    }\n\n    ...\n}\n\nNotice that the static variable was initialized outside the constructor and that its value can be changed.\nStatic final variables (constants) in a class cannot be changed. They are often de clared public (see some examples of Math class constants on p. 183). The variable OVERDRAWN_PENALTY is an example in the BankAccount class. Since the variable is public, it can be used in any client method. The keyword static indicates that there is a single value of the variable that applies to the whole class, rather than a new instance for each object of the class. A client method would refer to the vari able as BankAccount.OVERDRAWN_PENALTY. In its own class it is referred to as simply OVERDRAWN_PENALTY.\nSee p. 97 for static methods.\nAll method headers, with the exception of constructors (see below) and static methods (p. 97), look like this:\naccess specifier, return type, method name, parameter list\n\n1. The access specifier tells which other methods can call this method (see Public, Private, and Static on the previous page).\n2. A return type of void signals that the method does not return a value. 3. Items in the parameter list are separated by commas.\nThe implementation of the method directly follows the header, enclosed in a {} block.\n\n\n###\n\n","completion":" Question: Consider the Time class defined below:\n\npublic class Time\n{\n\tprivate int hrs;\n\tprivate int mins;\n\tprivate int secs;\n\n\tpublic Time()\n\t{ \/* implementation not shown *\/ }\n\n\tpublic Time(int h, int m, int s)\n\t{ \/* implementation not shown *\/ }\n\n\t\/** Resets time to hrs = h, mins = m, secs = s. *\/\n\tpublic void resetTime(int h, int m, int s)\n\t{ \/* implementation not shown *\/ }\n\n\t\/** Advances time by one second. *\/\n\tpublic void increment()\n\t{ \/* implementation not shown *\/ }\n\n\t\/** @return true if this time equals t, false otherwise *\/\n\tpublic boolean equals(Time t)\n\t{ \/* implementation not shown *\/ }\n\n\t\/** @return true if this time is earlier than t, false otherwise *\/\n\tpublic boolean lessThan(Time t)\n\t{ \/* implementation not shown *\/ }\n\n\t\/** @return a String with the time in the form hrs:mins:secs *\/\n\tpublic String toString()\n\t{ \/* implementation not shown *\/ }\n}\n\nWhich of the following represents correct implementation code for the constructor with parameters?\nCorrect: hrs = h;\nmins = m;\nsecs = s;\nIncorrect: hrs = 0;\nmins = 0;\nsecs = 0;\nIncorrect: resetTime(hrs, mins, secs);\nIncorrect: h = hrs;\nm = mins;\ns = secs;\nIncorrect: Time = new Time(h, m, s);\n\nEND"}
{"prompt":"Every program that you write involves at least one thing that is being created or manipulated by the program. This thing, together with the operations that manipulate it, is called an object.\nConsider, for example, a program that must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. Rules for validity are provided. The object is a four-digit code number. Some of the operations to manipulate the object could be readNumber, getSeparateDigits, testValidity, and writeNumber.\nAny given program can have several different types of objects. For example, a pro gram that maintains a database of all books in a library has at least two objects:\n1. A Book object, with operations like getTitle, isOnShelf, isFiction, and goOutOfPrint.\n2. A ListOfBooks object, with operations like search, addBook, removeBook, and sortByAuthor.\nAn object is characterized by its state and behavior. For example, a book has a state described by its title, author, whether it’s on the shelf, and so on. It also has behavior, like going out of print.\nNotice that an object is an idea, separate from the concrete details of a programming language. It corresponds to some real-world object that is being represented by the program.\nAll object-oriented programming languages have a way to represent an object as a variable in a program. In Java, a variable that represents an object is called an object reference.\nA class is a software blueprint for implementing objects of a given type. An object is a single instance of the class. In a program there will often be several different instances of a given class type.\nThe current state of a given object is maintained in its data fields orinstance variables, provided by the class. The methods of the class provide both the behaviors exhibited by the object and the operations that manipulate the object. Combining an object’s data and methods into a single unit called a class is known as encapsulation.\nHere is the framework for a simple bank account class:\n\npublic class BankAccount {\n    private String password;\n    private double balance;\n    public static final double OVERDRAWN_PENALTY = 20.00;\n\n    \/\/ constructors\n    \/**\n     * Default constructor.\n     * Constructs bank account with default values.\n     *\/\n    public BankAccount() {\n        \/* implementation code *\/ }\n\n    \/** Constructs bank account with specified password and balance. *\/\n    public BankAccount(String acctPassword, double acctBalance) {\n        \/* implementation code *\/ }\n\n    \/\/ accessor\n    \/** @return balance of this account *\/\n    public double getBalance() {\n        \/* implementation code *\/ }\n\n    \/\/ mutators\n    \/**\n     * Deposits amount in bank account with given password.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be deposited\n     *\/\n    public void deposit(String acctPassword, double amount) {\n        \/* implementation code *\/ }\n\n    \/**\n     * Withdraws amount from bank account with given password.\n     * Assesses penalty if balance is less than amount.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be withdrawn\n     *\/\n    public void withdraw(String acctPassword, double amount) {\n        \/* implementation code *\/ }\n}\nThe keyword public preceding the class declaration signals that the class is usable by all client programs. If a class is not public, it can be used only by classes in its own package. In the AP Java subset, all classes are public.\nSimilarly, public methods are accessible to all client programs. Clients, however, are not privy to the class implementation and may not access the private instance variables and private methods of the class. Restriction of access is known as information hiding. In Java, this is implemented by using the keyword private. Private methods and vari ables in a class can be accessed only by methods of that class. Even though Java allows public instance variables, in the AP Java subset all instance variables are private.\nA static variable (class variable) contains a value that is shared by all instances of the class. “Static” means that memory allocation happens once.\nTypical uses of a static variable are to\n• keep track of statistics for objects of the class.\n• accumulate a total.\n• provide a new identity number for each new object of the class.\nFor example:\n\npublic class Employee\n{\n    private String name;\n    private static int employeeCount = 0; \/\/number of employees\n    public Employee( < parameter list > )\n    {\n        < initialization of private instance variables >\n        employeeCount++; \/\/increment count of all employees\n    }\n\n    ...\n}\n\nNotice that the static variable was initialized outside the constructor and that its value can be changed.\nStatic final variables (constants) in a class cannot be changed. They are often de clared public (see some examples of Math class constants on p. 183). The variable OVERDRAWN_PENALTY is an example in the BankAccount class. Since the variable is public, it can be used in any client method. The keyword static indicates that there is a single value of the variable that applies to the whole class, rather than a new instance for each object of the class. A client method would refer to the vari able as BankAccount.OVERDRAWN_PENALTY. In its own class it is referred to as simply OVERDRAWN_PENALTY.\nSee p. 97 for static methods.\nAll method headers, with the exception of constructors (see below) and static methods (p. 97), look like this:\naccess specifier, return type, method name, parameter list\n\n1. The access specifier tells which other methods can call this method (see Public, Private, and Static on the previous page).\n2. A return type of void signals that the method does not return a value. 3. Items in the parameter list are separated by commas.\nThe implementation of the method directly follows the header, enclosed in a {} block.\n\n\n###\n\n","completion":" Question: Consider the Time class defined below:\n\npublic class Time\n{\n\tprivate int hrs;\n\tprivate int mins;\n\tprivate int secs;\n\n\tpublic Time()\n\t{ \/* implementation not shown *\/ }\n\n\tpublic Time(int h, int m, int s)\n\t{ \/* implementation not shown *\/ }\n\n\t\/** Resets time to hrs = h, mins = m, secs = s. *\/\n\tpublic void resetTime(int h, int m, int s)\n\t{ \/* implementation not shown *\/ }\n\n\t\/** Advances time by one second. *\/\n\tpublic void increment()\n\t{ \/* implementation not shown *\/ }\n\n\t\/** @return true if this time equals t, false otherwise *\/\n\tpublic boolean equals(Time t)\n\t{ \/* implementation not shown *\/ }\n\n\t\/** @return true if this time is earlier than t, false otherwise *\/\n\tpublic boolean lessThan(Time t)\n\t{ \/* implementation not shown *\/ }\n\n\t\/** @return a String with the time in the form hrs:mins:secs *\/\n\tpublic String toString()\n\t{ \/* implementation not shown *\/ }\n}\n\nA client class has a display method that writes the time represented by its parameter:\n\/** Outputs time t in the form hrs:mins:secs.\n* @param t the time\n*\/\npublic void display (Time t)\n{\n\t\/* method body *\/\n}\nWhich of the following are correct replacements for \/* method body *\/?\nI Time T = new Time(h, m, s);\nSystem.out.println(T);\nII System.out.println(t.hrs + \":\" + t.mins + \":\" + t.secs);\nIII System.out.println(t);\nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: II and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"A constructor creates an object of the class. You can recognize a constructor by its name—always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n\/** Default constructor.\n* Constructs a bank account with default values. *\/\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address—we say “b is a reference to the object.”\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n\/** Constructor. Constructs a bank account with\n* specified password and balance. *\/\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n\/** @return the balance of this account *\/\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n\/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*\/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n        balance += amount;\n}\n\/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*\/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n    {\n        balance -= amount; \/\/allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\n###\n\n","completion":" Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() \/\/default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) \/\/constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() \/\/returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() \/\/returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() \/\/returns year of Date\n\t{\n\t\t...\n\t}\n\n\t\t\/\/ Returns String representation of Date as \"m\/d\/y\", e.g. 4\/18\/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nWhich of the following correctly constructs a Date object in a client class?\nCorrect: Date d = new Date(2, 13, 1947);\nIncorrect: Date d = new (2, 13, 1947);\nIncorrect: Date d;\nd = new (2, 13, 1947);\nIncorrect: Date d;\nd = Date(2, 13, 1947);\nIncorrect: Date d = Date(2, 13, 1947);\n\nEND"}
{"prompt":"The scope of a variable or method is the region in which that variable or method is visible and can be accessed.\nThe instance variables, static variables, and methods of a class belong to that class’s scope, which extends from the opening brace to the closing brace of the class definition. Within the class all instance variables and methods are accessible and can be referred to simply by name (no dot operator!).\nA local variable is defined inside a method. It can even be defined inside a statement. Its scope extends from the point where it is declared to the end of the block in which its declaration occurs. A block is a piece of code enclosed in a {} pair. When a block is exited, the memory for a local variable is automatically recycled.\nLocal variables take precedence over instance variables with the same name. (Using the same name, however, creates ambiguity for the programmer, leading to errors. You should avoid the practice.)\n\nAn instance method is always called for a particular object. This object is an implicit parameter for the method and is referred to with the keyword this. You are expected to know this vocabulary for the exam.\nIn the implementation of instance methods, all instance variables can be written with the prefix this followed by the dot operator.\n\nExample 1\nIn the method call obj.doSomething(\"Mary\",num), where obj is some class object and doSomething is a method of that class, \"Mary\" and num, the parameters in parentheses, are explicit parameters, whereas obj is an implicit parameter.\nExample 2\nHere’s an example where this is used as a parameter.\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person(String aName, int anAge) {\n        name = aName;\n        age = anAge;\n    }\n\n    \/** @return the String form of this person *\/\n    public String toString() {\n        return name + \" \" + age;\n    }\n\n    public void printPerson() {\n        System.out.println(this);\n    }\n    \/\/ Other variables and methods are not shown.\n}\n\nSuppose a client class has these lines of code:\nPerson p = new Person(\"Dan\", 10);\np.printPerson();\nThe statement\nSystem.out.println(this);\nin the printPerson method means “print the current Person object.” The output should be: Dan 10. Note that System.out.println invokes the toString method of the Person class.\n\nThe deposit method of the BankAccount class can refer to balance as follows:\npublic void deposit(String acctPassword, double amount)\n{\n    this.balance += amount;\n}\nThe use of this is unnecessary in the above example.\n\nConsider a rational number class called Rational, which has two private instance variables:\nprivate int num; \/\/numerator\nprivate int denom; \/\/denominator\nNow consider a constructor for the Rational class:\npublic Rational(int num, int denom)\n{\n    this.num = num;\n    this.denom = denom;\n}\nIt is definitely not a good idea to use the same name for the explicit parameters and the private instance variables. But if you do, you can avoid errors by referring to this.num and this.denom for the current object that is being constructed. (This particular use of this will not be tested on the exam.)\nAll of the numerical data types, like double and int, as well as types char and boolean, are primitive data types. All objects are reference data types. The difference lies in the way they are stored.\nConsider the statements\nint num1 = 3;\nint num2 = num1;\n\nThe variables num1 and num2 can be thought of as memory slots, labeled num1 and num2, respectively\nIf either of the above variables is now changed, the other is not affected. Each has its own memory slot.\nContrast this with the declaration of a reference data type. Recall that an object is created using new:\nDate d = new Date(2, 17, 1948);\nThis declaration creates a reference variable d that refers to a Date object. The value of d is the address in memory of that object\n\nSuppose the following declaration is now made:\nDate birthday = d;\nThis statement creates the reference variable birthday, which contains the same address as d\n\nHaving two references for the same object is known as aliasing. Aliasing can cause unintended problems for the programmer. The statement\nd.changeDate();\nwill automatically change the object referred to by birthday as well. What the programmer probably intended was to create a second object called birthday whose attributes exactly matched those of d. This cannot be accomplished without using new. For example,\nDate birthday = new Date(d.getMonth(), d.getDay(), d.getYear()); The statement d.changeDate() will now leave the birthday object unchanged.\nThe declaration\nBankAccount b;\ndefines a reference b that is uninitialized. (To construct the object that b refers to requires the new operator and a BankAccount constructor.) An uninitialized object variable is called a null reference or null pointer. You can test whether a variable refers to an object or is uninitialized by using the keyword null:\nif (b == null)\nIf a reference is not null, it can be set to null with the statement\nb = null;\nAn attempt to invoke an instance method with a null reference may cause your program to terminate with a NullPointerException. For example,\n\npublic class PersonalFinances\n{\n    BankAccount b; \/\/b is a null reference\n    ...\n    b.withdraw(acctPassword, amt); \/\/throws a NullPointerException\n    ... \/\/if b not constructed with new\n\nIf you fail to initialize a local variable in a method before you use it, you will get a compile-time error. If you make the same mistake with an instance variable of a class, the compiler provides reasonable default values for primitive variables (0 for numbers,\n\nfalse for booleans), and the code may run without error. However, if you don’t initialize reference instance variables in a class, as in the above example, the compiler will set them to null. Any method call for an object of the class that tries to access the null reference will cause a run-time error: The program will terminate with a NullPointerException.\n\n\n###\n\n","completion":" Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() \/\/default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) \/\/constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() \/\/returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() \/\/returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() \/\/returns year of Date\n\t{\n\t\t...\n\t}\n\n\t\t\/\/ Returns String representation of Date as \"m\/d\/y\", e.g. 4\/18\/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nWhich of the following will cause an error message?\nI Date d1 = new Date(8, 2, 1947);\nDate d2 = d1;\nII Date d1 = null;\nDate d2 = d1;\nIII Date d = null;\nint x = d.year();\nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: II and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"Every program that you write involves at least one thing that is being created or manipulated by the program. This thing, together with the operations that manipulate it, is called an object.\nConsider, for example, a program that must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. Rules for validity are provided. The object is a four-digit code number. Some of the operations to manipulate the object could be readNumber, getSeparateDigits, testValidity, and writeNumber.\nAny given program can have several different types of objects. For example, a pro gram that maintains a database of all books in a library has at least two objects:\n1. A Book object, with operations like getTitle, isOnShelf, isFiction, and goOutOfPrint.\n2. A ListOfBooks object, with operations like search, addBook, removeBook, and sortByAuthor.\nAn object is characterized by its state and behavior. For example, a book has a state described by its title, author, whether it’s on the shelf, and so on. It also has behavior, like going out of print.\nNotice that an object is an idea, separate from the concrete details of a programming language. It corresponds to some real-world object that is being represented by the program.\nAll object-oriented programming languages have a way to represent an object as a variable in a program. In Java, a variable that represents an object is called an object reference.\nA class is a software blueprint for implementing objects of a given type. An object is a single instance of the class. In a program there will often be several different instances of a given class type.\nThe current state of a given object is maintained in its data fields orinstance variables, provided by the class. The methods of the class provide both the behaviors exhibited by the object and the operations that manipulate the object. Combining an object’s data and methods into a single unit called a class is known as encapsulation.\nHere is the framework for a simple bank account class:\n\npublic class BankAccount {\n    private String password;\n    private double balance;\n    public static final double OVERDRAWN_PENALTY = 20.00;\n\n    \/\/ constructors\n    \/**\n     * Default constructor.\n     * Constructs bank account with default values.\n     *\/\n    public BankAccount() {\n        \/* implementation code *\/ }\n\n    \/** Constructs bank account with specified password and balance. *\/\n    public BankAccount(String acctPassword, double acctBalance) {\n        \/* implementation code *\/ }\n\n    \/\/ accessor\n    \/** @return balance of this account *\/\n    public double getBalance() {\n        \/* implementation code *\/ }\n\n    \/\/ mutators\n    \/**\n     * Deposits amount in bank account with given password.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be deposited\n     *\/\n    public void deposit(String acctPassword, double amount) {\n        \/* implementation code *\/ }\n\n    \/**\n     * Withdraws amount from bank account with given password.\n     * Assesses penalty if balance is less than amount.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be withdrawn\n     *\/\n    public void withdraw(String acctPassword, double amount) {\n        \/* implementation code *\/ }\n}\nThe keyword public preceding the class declaration signals that the class is usable by all client programs. If a class is not public, it can be used only by classes in its own package. In the AP Java subset, all classes are public.\nSimilarly, public methods are accessible to all client programs. Clients, however, are not privy to the class implementation and may not access the private instance variables and private methods of the class. Restriction of access is known as information hiding. In Java, this is implemented by using the keyword private. Private methods and vari ables in a class can be accessed only by methods of that class. Even though Java allows public instance variables, in the AP Java subset all instance variables are private.\nA static variable (class variable) contains a value that is shared by all instances of the class. “Static” means that memory allocation happens once.\nTypical uses of a static variable are to\n• keep track of statistics for objects of the class.\n• accumulate a total.\n• provide a new identity number for each new object of the class.\nFor example:\n\npublic class Employee\n{\n    private String name;\n    private static int employeeCount = 0; \/\/number of employees\n    public Employee( < parameter list > )\n    {\n        < initialization of private instance variables >\n        employeeCount++; \/\/increment count of all employees\n    }\n\n    ...\n}\n\nNotice that the static variable was initialized outside the constructor and that its value can be changed.\nStatic final variables (constants) in a class cannot be changed. They are often de clared public (see some examples of Math class constants on p. 183). The variable OVERDRAWN_PENALTY is an example in the BankAccount class. Since the variable is public, it can be used in any client method. The keyword static indicates that there is a single value of the variable that applies to the whole class, rather than a new instance for each object of the class. A client method would refer to the vari able as BankAccount.OVERDRAWN_PENALTY. In its own class it is referred to as simply OVERDRAWN_PENALTY.\nSee p. 97 for static methods.\nAll method headers, with the exception of constructors (see below) and static methods (p. 97), look like this:\naccess specifier, return type, method name, parameter list\n\n1. The access specifier tells which other methods can call this method (see Public, Private, and Static on the previous page).\n2. A return type of void signals that the method does not return a value. 3. Items in the parameter list are separated by commas.\nThe implementation of the method directly follows the header, enclosed in a {} block.\n\n\n###\n\n","completion":" Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() \/\/default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) \/\/constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() \/\/returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() \/\/returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() \/\/returns year of Date\n\t{\n\t\t...\n\t}\n\n\t\t\/\/ Returns String representation of Date as \"m\/d\/y\", e.g. 4\/18\/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nA client program creates a Date object as follows:\nDate d = new Date(1, 13, 2002);\nWhich of the following subsequent code segments will cause an error?\nCorrect: int y = d.year;\n\n\nIncorrect: String s = d.toString();\nIncorrect: int x = d.day();\nIncorrect: Date e = d;\nIncorrect: Date e = new Date(1, 13, 2002);END"}
{"prompt":"Every program that you write involves at least one thing that is being created or manipulated by the program. This thing, together with the operations that manipulate it, is called an object.\nConsider, for example, a program that must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. Rules for validity are provided. The object is a four-digit code number. Some of the operations to manipulate the object could be readNumber, getSeparateDigits, testValidity, and writeNumber.\nAny given program can have several different types of objects. For example, a pro gram that maintains a database of all books in a library has at least two objects:\n1. A Book object, with operations like getTitle, isOnShelf, isFiction, and goOutOfPrint.\n2. A ListOfBooks object, with operations like search, addBook, removeBook, and sortByAuthor.\nAn object is characterized by its state and behavior. For example, a book has a state described by its title, author, whether it’s on the shelf, and so on. It also has behavior, like going out of print.\nNotice that an object is an idea, separate from the concrete details of a programming language. It corresponds to some real-world object that is being represented by the program.\nAll object-oriented programming languages have a way to represent an object as a variable in a program. In Java, a variable that represents an object is called an object reference.\nA class is a software blueprint for implementing objects of a given type. An object is a single instance of the class. In a program there will often be several different instances of a given class type.\nThe current state of a given object is maintained in its data fields orinstance variables, provided by the class. The methods of the class provide both the behaviors exhibited by the object and the operations that manipulate the object. Combining an object’s data and methods into a single unit called a class is known as encapsulation.\nHere is the framework for a simple bank account class:\n\npublic class BankAccount {\n    private String password;\n    private double balance;\n    public static final double OVERDRAWN_PENALTY = 20.00;\n\n    \/\/ constructors\n    \/**\n     * Default constructor.\n     * Constructs bank account with default values.\n     *\/\n    public BankAccount() {\n        \/* implementation code *\/ }\n\n    \/** Constructs bank account with specified password and balance. *\/\n    public BankAccount(String acctPassword, double acctBalance) {\n        \/* implementation code *\/ }\n\n    \/\/ accessor\n    \/** @return balance of this account *\/\n    public double getBalance() {\n        \/* implementation code *\/ }\n\n    \/\/ mutators\n    \/**\n     * Deposits amount in bank account with given password.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be deposited\n     *\/\n    public void deposit(String acctPassword, double amount) {\n        \/* implementation code *\/ }\n\n    \/**\n     * Withdraws amount from bank account with given password.\n     * Assesses penalty if balance is less than amount.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be withdrawn\n     *\/\n    public void withdraw(String acctPassword, double amount) {\n        \/* implementation code *\/ }\n}\nThe keyword public preceding the class declaration signals that the class is usable by all client programs. If a class is not public, it can be used only by classes in its own package. In the AP Java subset, all classes are public.\nSimilarly, public methods are accessible to all client programs. Clients, however, are not privy to the class implementation and may not access the private instance variables and private methods of the class. Restriction of access is known as information hiding. In Java, this is implemented by using the keyword private. Private methods and vari ables in a class can be accessed only by methods of that class. Even though Java allows public instance variables, in the AP Java subset all instance variables are private.\nA static variable (class variable) contains a value that is shared by all instances of the class. “Static” means that memory allocation happens once.\nTypical uses of a static variable are to\n• keep track of statistics for objects of the class.\n• accumulate a total.\n• provide a new identity number for each new object of the class.\nFor example:\n\npublic class Employee\n{\n    private String name;\n    private static int employeeCount = 0; \/\/number of employees\n    public Employee( < parameter list > )\n    {\n        < initialization of private instance variables >\n        employeeCount++; \/\/increment count of all employees\n    }\n\n    ...\n}\n\nNotice that the static variable was initialized outside the constructor and that its value can be changed.\nStatic final variables (constants) in a class cannot be changed. They are often de clared public (see some examples of Math class constants on p. 183). The variable OVERDRAWN_PENALTY is an example in the BankAccount class. Since the variable is public, it can be used in any client method. The keyword static indicates that there is a single value of the variable that applies to the whole class, rather than a new instance for each object of the class. A client method would refer to the vari able as BankAccount.OVERDRAWN_PENALTY. In its own class it is referred to as simply OVERDRAWN_PENALTY.\nSee p. 97 for static methods.\nAll method headers, with the exception of constructors (see below) and static methods (p. 97), look like this:\naccess specifier, return type, method name, parameter list\n\n1. The access specifier tells which other methods can call this method (see Public, Private, and Static on the previous page).\n2. A return type of void signals that the method does not return a value. 3. Items in the parameter list are separated by commas.\nThe implementation of the method directly follows the header, enclosed in a {} block.\n\n\n###\n\n","completion":" Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() \/\/default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) \/\/constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() \/\/returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() \/\/returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() \/\/returns year of Date\n\t{\n\t\t...\n\t}\n\n\t\t\/\/ Returns String representation of Date as \"m\/d\/y\", e.g. 4\/18\/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nConsider the implementation of a write() method that is added to the Date class:\n\n\/** Write the date in the form m\/d\/y, for example 2\/17\/1948. *\/\npublic void write()\n{\n\t\/* implementation code *\/\n}\nWhich of the following could be used as \/* implementation code *\/?\nI System.out.println(month + \"\/\" + day + \"\/\" + year);\nII System.out.println(month() + \"\/\" + day() + \"\/\" + year());\nIII System.out.println(this);\nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: II and III onlyEND"}
{"prompt":"A constructor creates an object of the class. You can recognize a constructor by its name—always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n\/** Default constructor.\n* Constructs a bank account with default values. *\/\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address—we say “b is a reference to the object.”\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n\/** Constructor. Constructs a bank account with\n* specified password and balance. *\/\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n\/** @return the balance of this account *\/\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n\/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*\/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n        balance += amount;\n}\n\/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*\/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n    {\n        balance -= amount; \/\/allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\n###\n\n","completion":" Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() \/\/default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) \/\/constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() \/\/returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() \/\/returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() \/\/returns year of Date\n\t{\n\t\t...\n\t}\n\n\t\t\/\/ Returns String representation of Date as \"m\/d\/y\", e.g. 4\/18\/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nHere is a client program that uses Date objects:\n\npublic class BirthdayStuff\n{\n\tpublic static Date findBirthdate()\n\t{\n\t\t\/* code to get birthDate *\/\n\t\treturn birthDate;\n\t}\n\tpublic static void main(String[] args)\n\t{\n\t\tDate d = findBirthdate();\n\t\t...\n\t}\n}\n\nWhich of the following is a correct replacement for\n\/* code to get birthDate *\/?\nI System.out.println(\"Enter birthdate: mo, day, yr: \");\nint m = IO.readInt(); \/\/read user input\nint d = IO.readInt(); \/\/read user input\nint y = IO.readInt(); \/\/read user input\nDate birthDate = new Date(m, d, y);\nII System.out.println(\"Enter birthdate: mo, day, yr: \");\nint birthDate.month() = IO.readInt(); \/\/read user input\nint birthDate.day() = IO.readInt(); \/\/read user input\nint birthDate.year() = IO.readInt(); \/\/read user input\nDate birthDate = new Date(birthDate.month(), birthDate.day(), birthDate.year());\nIII System.out.println(\"Enter birthdate: mo, day, yr: \");\nint birthDate.month = IO.readInt(); \/\/read user input\nint birthDate.day = IO.readInt(); \/\/read user input\nint birthDate.year = IO.readInt(); \/\/read user input\nDate birthDate = new Date(birthDate.month, birthDate.day, birthDate.year);\nCorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I and III only\n\nEND"}
{"prompt":"The scope of a variable or method is the region in which that variable or method is visible and can be accessed.\nThe instance variables, static variables, and methods of a class belong to that class’s scope, which extends from the opening brace to the closing brace of the class definition. Within the class all instance variables and methods are accessible and can be referred to simply by name (no dot operator!).\nA local variable is defined inside a method. It can even be defined inside a statement. Its scope extends from the point where it is declared to the end of the block in which its declaration occurs. A block is a piece of code enclosed in a {} pair. When a block is exited, the memory for a local variable is automatically recycled.\nLocal variables take precedence over instance variables with the same name. (Using the same name, however, creates ambiguity for the programmer, leading to errors. You should avoid the practice.)\n\nAn instance method is always called for a particular object. This object is an implicit parameter for the method and is referred to with the keyword this. You are expected to know this vocabulary for the exam.\nIn the implementation of instance methods, all instance variables can be written with the prefix this followed by the dot operator.\n\nExample 1\nIn the method call obj.doSomething(\"Mary\",num), where obj is some class object and doSomething is a method of that class, \"Mary\" and num, the parameters in parentheses, are explicit parameters, whereas obj is an implicit parameter.\nExample 2\nHere’s an example where this is used as a parameter.\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person(String aName, int anAge) {\n        name = aName;\n        age = anAge;\n    }\n\n    \/** @return the String form of this person *\/\n    public String toString() {\n        return name + \" \" + age;\n    }\n\n    public void printPerson() {\n        System.out.println(this);\n    }\n    \/\/ Other variables and methods are not shown.\n}\n\nSuppose a client class has these lines of code:\nPerson p = new Person(\"Dan\", 10);\np.printPerson();\nThe statement\nSystem.out.println(this);\nin the printPerson method means “print the current Person object.” The output should be: Dan 10. Note that System.out.println invokes the toString method of the Person class.\n\nThe deposit method of the BankAccount class can refer to balance as follows:\npublic void deposit(String acctPassword, double amount)\n{\n    this.balance += amount;\n}\nThe use of this is unnecessary in the above example.\n\nConsider a rational number class called Rational, which has two private instance variables:\nprivate int num; \/\/numerator\nprivate int denom; \/\/denominator\nNow consider a constructor for the Rational class:\npublic Rational(int num, int denom)\n{\n    this.num = num;\n    this.denom = denom;\n}\nIt is definitely not a good idea to use the same name for the explicit parameters and the private instance variables. But if you do, you can avoid errors by referring to this.num and this.denom for the current object that is being constructed. (This particular use of this will not be tested on the exam.)\nAll of the numerical data types, like double and int, as well as types char and boolean, are primitive data types. All objects are reference data types. The difference lies in the way they are stored.\nConsider the statements\nint num1 = 3;\nint num2 = num1;\n\nThe variables num1 and num2 can be thought of as memory slots, labeled num1 and num2, respectively\nIf either of the above variables is now changed, the other is not affected. Each has its own memory slot.\nContrast this with the declaration of a reference data type. Recall that an object is created using new:\nDate d = new Date(2, 17, 1948);\nThis declaration creates a reference variable d that refers to a Date object. The value of d is the address in memory of that object\n\nSuppose the following declaration is now made:\nDate birthday = d;\nThis statement creates the reference variable birthday, which contains the same address as d\n\nHaving two references for the same object is known as aliasing. Aliasing can cause unintended problems for the programmer. The statement\nd.changeDate();\nwill automatically change the object referred to by birthday as well. What the programmer probably intended was to create a second object called birthday whose attributes exactly matched those of d. This cannot be accomplished without using new. For example,\nDate birthday = new Date(d.getMonth(), d.getDay(), d.getYear()); The statement d.changeDate() will now leave the birthday object unchanged.\nThe declaration\nBankAccount b;\ndefines a reference b that is uninitialized. (To construct the object that b refers to requires the new operator and a BankAccount constructor.) An uninitialized object variable is called a null reference or null pointer. You can test whether a variable refers to an object or is uninitialized by using the keyword null:\nif (b == null)\nIf a reference is not null, it can be set to null with the statement\nb = null;\nAn attempt to invoke an instance method with a null reference may cause your program to terminate with a NullPointerException. For example,\n\npublic class PersonalFinances\n{\n    BankAccount b; \/\/b is a null reference\n    ...\n    b.withdraw(acctPassword, amt); \/\/throws a NullPointerException\n    ... \/\/if b not constructed with new\n\nIf you fail to initialize a local variable in a method before you use it, you will get a compile-time error. If you make the same mistake with an instance variable of a class, the compiler provides reasonable default values for primitive variables (0 for numbers,\n\nfalse for booleans), and the code may run without error. However, if you don’t initialize reference instance variables in a class, as in the above example, the compiler will set them to null. Any method call for an object of the class that tries to access the null reference will cause a run-time error: The program will terminate with a NullPointerException.\n\n\n###\n\n","completion":" Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() \/\/default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) \/\/constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() \/\/returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() \/\/returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() \/\/returns year of Date\n\t{\n\t\t...\n\t}\n\n\t\t\/\/ Returns String representation of Date as \"m\/d\/y\", e.g. 4\/18\/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nA method in a client program for the Date class has this declaration:\n\nDate d1 = new Date(mo, da, yr);\n\nwhere mo, da, and yr are previously defined integer variables. The same method now creates a second Date object d2 that is an exact copy of the object d1 refers to. Which of the following code segments will not do this correctly?\nI Date d2 = d1;\nII Date d2 = new Date(mo, da, yr);\nIII Date d2 = new Date(d1.month(), d1.day(), d1.year());\nCorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: II and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"A constructor creates an object of the class. You can recognize a constructor by its name—always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n\/** Default constructor.\n* Constructs a bank account with default values. *\/\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address—we say “b is a reference to the object.”\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n\/** Constructor. Constructs a bank account with\n* specified password and balance. *\/\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n\/** @return the balance of this account *\/\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n\/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*\/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n        balance += amount;\n}\n\/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*\/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n    {\n        balance -= amount; \/\/allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\n###\n\n","completion":" Question: Consider the Date class defined below:\n\npublic class Date {\n\tprivate int day;\n\tprivate int month;\n\tprivate int year;\n\n\tpublic Date() \/\/default constructor\n\t{\n\t\t...\n\t}\n\n\tpublic Date(int mo, int da, int yr) \/\/constructor\n\t{\n\t\t...\n\t}\n\n\tpublic int month() \/\/returns month of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int day() \/\/returns day of Date\n\t{\n\t\t...\n\t}\n\n\tpublic int year() \/\/returns year of Date\n\t{\n\t\t...\n\t}\n\n\t\t\/\/ Returns String representation of Date as \"m\/d\/y\", e.g. 4\/18\/1985.\n\tpublic String toString()\n\t{\n\t\t...\n\t}\n}\n\nThe Date class is modified by adding the following mutator method:\n\npublic void addYears(int n) \/\/add n years to date\n\nHere is part of a poorly coded client program that uses the Date class:\n\npublic static void addCentury(Date recent, Date old)\n{\n\told.addYears(100);\n\trecent = old;\n}\n\npublic static void main(String[] args)\n{\n\tDate oldDate = new Date(1, 13, 1900);\n\tDate recentDate = null;\n\taddCentury(recentDate, oldDate);\n\t...\n}\n\nWhich will be true after executing this code?\nCorrect: recentDate is a null reference.\nIncorrect: A NullPointerException is thrown.\nIncorrect: The oldDate object remains unchanged.\nIncorrect: recentDate refers to the same object as oldDate.\nIncorrect: recentDate refers to a separate object whose contents are the same as those of oldDate.\n\nEND"}
{"prompt":"The methods discussed in the preceding sections—constructors, accessors, and mutators—all operate on individual objects of a class. They are called instance methods. A method that performs an operation for the entire class, not its individual objects, is called a static method (sometimes called a class method).\nThe implementation of a static method uses the keyword static in its header. There is no implied object in the code (as there is in an instance method). Thus, if the code tries to call an instance method or invoke a private instance variable for this nonexistent object, a syntax error will occur. A static method can, however, use a static variable in its code. For example, in the Employee example on p. 94, you could add a static method that returns the employeeCount:\n\npublic static int getEmployeeCount()\n{ return employeeCount; }\n\nHere’s an example of a static method that might be used in the BankAccount class. Suppose the class has a static variable intRate, declared as follows:\n\nprivate static double intRate;\n\nThe static method getInterestRate may be as follows:\n\npublic static double getInterestRate()\n{\n    System.out.println(\"Enter interest rate for bank account\");\n    System.out.println(\"Enter in decimal form:\");\n    intRate = IO.readDouble(); \/\/ read user input\n    return intRate;\n}\n\nSince the rate that’s read in by this method applies to all bank accounts in the class, not to any particular BankAccount object, it’s appropriate that the method should be static.\nRecall that an instance method is invoked in a client program by using an object variable followed by the dot operator followed by the method name:\n\nBankAccount b = new BankAccount(); \/\/invokes the deposit method for\nb.deposit(acctPassword, amount); \/\/BankAccount object b\n\nA static method, by contrast, is invoked by using the class name with the dot operator: double interestRate = BankAccount.getInterestRate();\nOften a class that contains the main() method is used as a driver program to test other classes. Usually such a class creates no objects of the class. So all the methods in the class must be static. Note that at the start of program execution, no objects exist yet. So the main() method must always be static.\nFor example, here is a program that tests a class for reading integers entered at the keyboard.\n\nimport java.util.*;\n\npublic class GetListTest {\n    \/** @return a list of integers from the keyboard *\/\n    public static List<Integer> getList()\n    {\n        List<Integer> a = new ArrayList<Integer>();\n        < code to read integers into a>\n        return a;\n    }\n\n    \/**\n     * Write contents of List a.\n     *\n     * @param a the list\n     *\/\n    public static void writeList(List<Integer> a) {\n        System.out.println(\"List is : \" + a);\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list = getList();\n        writeList(list);\n    }\n}\n\n1. The calls to writeList(list) and getList() do not need to be preceded by\nGetListTest plus a dot because main is not a client program: It is in the same\nclass as getList and writeList.\n2. If you omit the keyword static from the getList or writeList header, you\nget an error message like the following:\nCan’t make static reference to method getList()\nin class GetListTest\n\nThe compiler has recognized that there was no object variable preceding the\nmethod call, which means that the methods were static and should have been\ndeclared as such.\nOverloaded methods are two or more methods in the same class that have the same name but different parameter lists. For example,\n\npublic class DoOperations\n{\n    public int product(int n) { return n * n; }\n    public double product(double x) { return x * x; }\n    public double product(int x, int y) { return x * y; }\n    ...\n\nThe compiler figures out which method to call by examining the method’s signature. The signature of a method consists of the method’s name and a list of the parameter types. Thus, the signatures of the overloaded product methods are\nproduct(int)\nproduct(double)\nproduct(int, int)\nNote that for overloading purposes, the return type of the method is irrelevant. You can’t have two methods with identical signatures but different return types. The compiler will complain that the method call is ambiguous.\nHaving more than one constructor in the same class is an example of overloading. Overloaded constructors provide a choice of ways to initialize objects of the class.\n\n\n###\n\n","completion":" Question: Here are the private instance variables for a Frog object:\n\npublic class Frog\n{\n\tprivate String species;\n\tprivate int age;\n\tprivate double weight;\n\tprivate Position position; \/\/position (x,y) in pond\n\tprivate boolean amAlive;\n\t...\n\nWhich of the following methods in the Frog class is the best candidate for being a static method?\nCorrect: getPondTemperature \/\/returns temperature of pond\nIncorrect: swim \/\/frog swims to new position in pond\nIncorrect: eat \/\/frog eats and gains weight\nIncorrect: getWeight \/\/returns weight of frog\nIncorrect: die \/\/frog dies with some probability based\n\/\/on frog’s age and pond temperature\n\nEND"}
{"prompt":"The header of a method defines the parameters of that method. For example, consider the withdraw method of the BankAccount class:\npublic class BankAccount\n{ ...\n    public void withdraw(String acctPassword, double amount) ...\n\nThis method has two explicit parameters, acctPassword and amount. These are dummy or formal parameters. Think of them as placeholders for the pair of actual parameters or arguments that will be supplied by a particular method call in a client program. For example,\nDo not make a method call with an object whose value is null.\n\nBankAccount b = new BankAccount(\"TimB\", 1000);\nb.withdraw(\"TimB\", 250);\n\nHere \"TimB\" and 250 are the actual parameters that match up with acctPassword and amount for the withdraw method.\n\n1. The number of arguments in the method call must equal the number of param eters in the method header, and the type of each argument must be compatible with the type of each corresponding parameter.\n2. In addition to its explicit parameters, the withdraw method has an implicit parameter, this, the BankAccount from which money will be withdrawn. In the method call\nb.withdraw(\"TimB\", 250);\nthe actual parameter that matches up with this is the object reference b.\n\nParameters are passed by value. For primitive types this means that when a method is called, a new memory slot is allocated for each parameter. The value of each argument is copied into the newly created memory slot corresponding to each parameter.\nDuring execution of the method, the parameters are local to that method. Any changes made to the parameters will not affect the values of the arguments in the calling program. When the method is exited, the local memory slots for the parameters are erased.\nHere’s an example: What will the output be?\n\npublic class ParamTest {\n    public static void foo(int x, double y) {\n        x = 3;\n        y = 2.5;\n    }\n\n    public static void main(String[] args) {\n        int a = 7;\n        double b = 6.5;\n        foo(a, b);\n        System.out.println(a + \" \" + b);\n    }\n}\n\nThe output will be\n7 6.5\nThe arguments a and b remain unchanged, despite the method call!\nThis can be understood by picturing the state of the memory slots during execution of the program.\n\n\n###\n\n","completion":" Question: What output will be produced by this program?\n\npublic class Mystery\n{\n\tpublic static void strangeMethod(int x, int y)\n\t{\n\t\tx += y;\n\t\ty *= x;\n\t\tSystem.out.println(x + \" \" + y);\n\t}\n\n\tpublic static void main(String[] args)\n\t{\n\t\tint a = 6, b = 3;\n\t\tstrangeMethod(a, b);\n\t\tSystem.out.println(a + \" \" + b);\n\t}\n}\n\nCorrect: 9 27\n6 3\n\n\nIncorrect: 36\n9\nIncorrect: 3 6\n9\nIncorrect: 9 27\n9 27\nIncorrect: 6 3\n9 27END"}
{"prompt":"Every program that you write involves at least one thing that is being created or manipulated by the program. This thing, together with the operations that manipulate it, is called an object.\nConsider, for example, a program that must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. Rules for validity are provided. The object is a four-digit code number. Some of the operations to manipulate the object could be readNumber, getSeparateDigits, testValidity, and writeNumber.\nAny given program can have several different types of objects. For example, a pro gram that maintains a database of all books in a library has at least two objects:\n1. A Book object, with operations like getTitle, isOnShelf, isFiction, and goOutOfPrint.\n2. A ListOfBooks object, with operations like search, addBook, removeBook, and sortByAuthor.\nAn object is characterized by its state and behavior. For example, a book has a state described by its title, author, whether it’s on the shelf, and so on. It also has behavior, like going out of print.\nNotice that an object is an idea, separate from the concrete details of a programming language. It corresponds to some real-world object that is being represented by the program.\nAll object-oriented programming languages have a way to represent an object as a variable in a program. In Java, a variable that represents an object is called an object reference.\nA class is a software blueprint for implementing objects of a given type. An object is a single instance of the class. In a program there will often be several different instances of a given class type.\nThe current state of a given object is maintained in its data fields orinstance variables, provided by the class. The methods of the class provide both the behaviors exhibited by the object and the operations that manipulate the object. Combining an object’s data and methods into a single unit called a class is known as encapsulation.\nHere is the framework for a simple bank account class:\n\npublic class BankAccount {\n    private String password;\n    private double balance;\n    public static final double OVERDRAWN_PENALTY = 20.00;\n\n    \/\/ constructors\n    \/**\n     * Default constructor.\n     * Constructs bank account with default values.\n     *\/\n    public BankAccount() {\n        \/* implementation code *\/ }\n\n    \/** Constructs bank account with specified password and balance. *\/\n    public BankAccount(String acctPassword, double acctBalance) {\n        \/* implementation code *\/ }\n\n    \/\/ accessor\n    \/** @return balance of this account *\/\n    public double getBalance() {\n        \/* implementation code *\/ }\n\n    \/\/ mutators\n    \/**\n     * Deposits amount in bank account with given password.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be deposited\n     *\/\n    public void deposit(String acctPassword, double amount) {\n        \/* implementation code *\/ }\n\n    \/**\n     * Withdraws amount from bank account with given password.\n     * Assesses penalty if balance is less than amount.\n     *\n     * @param acctPassword the password of this bank account\n     * @param amount       the amount to be withdrawn\n     *\/\n    public void withdraw(String acctPassword, double amount) {\n        \/* implementation code *\/ }\n}\nThe keyword public preceding the class declaration signals that the class is usable by all client programs. If a class is not public, it can be used only by classes in its own package. In the AP Java subset, all classes are public.\nSimilarly, public methods are accessible to all client programs. Clients, however, are not privy to the class implementation and may not access the private instance variables and private methods of the class. Restriction of access is known as information hiding. In Java, this is implemented by using the keyword private. Private methods and vari ables in a class can be accessed only by methods of that class. Even though Java allows public instance variables, in the AP Java subset all instance variables are private.\nA static variable (class variable) contains a value that is shared by all instances of the class. “Static” means that memory allocation happens once.\nTypical uses of a static variable are to\n• keep track of statistics for objects of the class.\n• accumulate a total.\n• provide a new identity number for each new object of the class.\nFor example:\n\npublic class Employee\n{\n    private String name;\n    private static int employeeCount = 0; \/\/number of employees\n    public Employee( < parameter list > )\n    {\n        < initialization of private instance variables >\n        employeeCount++; \/\/increment count of all employees\n    }\n\n    ...\n}\n\nNotice that the static variable was initialized outside the constructor and that its value can be changed.\nStatic final variables (constants) in a class cannot be changed. They are often de clared public (see some examples of Math class constants on p. 183). The variable OVERDRAWN_PENALTY is an example in the BankAccount class. Since the variable is public, it can be used in any client method. The keyword static indicates that there is a single value of the variable that applies to the whole class, rather than a new instance for each object of the class. A client method would refer to the vari able as BankAccount.OVERDRAWN_PENALTY. In its own class it is referred to as simply OVERDRAWN_PENALTY.\nSee p. 97 for static methods.\nAll method headers, with the exception of constructors (see below) and static methods (p. 97), look like this:\naccess specifier, return type, method name, parameter list\n\n1. The access specifier tells which other methods can call this method (see Public, Private, and Static on the previous page).\n2. A return type of void signals that the method does not return a value. 3. Items in the parameter list are separated by commas.\nThe implementation of the method directly follows the header, enclosed in a {} block.\n\n\n###\n\n","completion":" Question: Consider the Rational class defined below:\n\npublic class Rational {\n\tprivate int numerator;\n\tprivate int denominator;\n\n\t\/** default constructor *\/\n\tRational() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Constructs a Rational with numerator n and\n\t * denominator 1.\n\t *\/\n\tRational(int n) { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Constructs a Rational with specified numerator and\n\t * denominator.\n\t *\/\n\tRational(int numer, int denom) { \/* implementation not shown *\/ }\n\n\t\/** @return numerator *\/\n\tint numerator() { \/* implementation not shown *\/ }\n\n\t\/** @return denominator *\/\n\tint denominator() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Returns (this + r). Leaves this unchanged.\n\t *\n\t * @return this rational number plus r\n\t * @param r a rational number to be added to this Rational\n\t *\/\n\tpublic Rational plus(Rational r) { \/* implementation not shown *\/ }\n\n\t\/\/ Similarly for times, minus, divide ...\n\t\/** Ensures denominator > 0. *\/\n\tprivate void fixSigns() { \/* implementation not shown *\/ }\n\n\t\/** Ensures lowest terms. *\/\n\tprivate void reduce() { \/* implementation not shown *\/ }\n}\n\nThe method reduce() is not a public method because\nCorrect: the reduce() method is not intended for use by clients of the Rational class.\nIncorrect: methods whose return type is void cannot be public.\nIncorrect: methods that change this cannot be public.\nIncorrect: the reduce() method is intended for use only by clients of the Rational class.\nIncorrect: the reduce() method uses only the private data fields of the Rational class.\n\nEND"}
{"prompt":"A constructor creates an object of the class. You can recognize a constructor by its name—always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n\/** Default constructor.\n* Constructs a bank account with default values. *\/\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address—we say “b is a reference to the object.”\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n\/** Constructor. Constructs a bank account with\n* specified password and balance. *\/\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n\/** @return the balance of this account *\/\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n\/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*\/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n        balance += amount;\n}\n\/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*\/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n    {\n        balance -= amount; \/\/allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\n###\n\n","completion":" Question: Consider the Rational class defined below:\n\npublic class Rational {\n\tprivate int numerator;\n\tprivate int denominator;\n\n\t\/** default constructor *\/\n\tRational() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Constructs a Rational with numerator n and\n\t * denominator 1.\n\t *\/\n\tRational(int n) { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Constructs a Rational with specified numerator and\n\t * denominator.\n\t *\/\n\tRational(int numer, int denom) { \/* implementation not shown *\/ }\n\n\t\/** @return numerator *\/\n\tint numerator() { \/* implementation not shown *\/ }\n\n\t\/** @return denominator *\/\n\tint denominator() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Returns (this + r). Leaves this unchanged.\n\t *\n\t * @return this rational number plus r\n\t * @param r a rational number to be added to this Rational\n\t *\/\n\tpublic Rational plus(Rational r) { \/* implementation not shown *\/ }\n\n\t\/\/ Similarly for times, minus, divide ...\n\t\/** Ensures denominator > 0. *\/\n\tprivate void fixSigns() { \/* implementation not shown *\/ }\n\n\t\/** Ensures lowest terms. *\/\n\tprivate void reduce() { \/* implementation not shown *\/ }\n}\n\nThe constructors in the Rational class allow initialization of Rational objects in several different ways. Which of the following will cause an error? \nCorrect: Rational r4 = new Rational(3.5);\nIncorrect: Rational r1 = new Rational();\nIncorrect: Rational r2 = r1;\nIncorrect: Rational r3 = new Rational(2,-3);\nIncorrect: Rational r5 = new Rational(10);\n\nEND"}
{"prompt":"A constructor creates an object of the class. You can recognize a constructor by its name—always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n\/** Default constructor.\n* Constructs a bank account with default values. *\/\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address—we say “b is a reference to the object.”\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n\/** Constructor. Constructs a bank account with\n* specified password and balance. *\/\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n\/** @return the balance of this account *\/\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n\/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*\/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n        balance += amount;\n}\n\/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*\/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n    {\n        balance -= amount; \/\/allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\n###\n\n","completion":" Question: Consider the Rational class defined below:\n\npublic class Rational {\n\tprivate int numerator;\n\tprivate int denominator;\n\n\t\/** default constructor *\/\n\tRational() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Constructs a Rational with numerator n and\n\t * denominator 1.\n\t *\/\n\tRational(int n) { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Constructs a Rational with specified numerator and\n\t * denominator.\n\t *\/\n\tRational(int numer, int denom) { \/* implementation not shown *\/ }\n\n\t\/** @return numerator *\/\n\tint numerator() { \/* implementation not shown *\/ }\n\n\t\/** @return denominator *\/\n\tint denominator() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Returns (this + r). Leaves this unchanged.\n\t *\n\t * @return this rational number plus r\n\t * @param r a rational number to be added to this Rational\n\t *\/\n\tpublic Rational plus(Rational r) { \/* implementation not shown *\/ }\n\n\t\/\/ Similarly for times, minus, divide ...\n\t\/** Ensures denominator > 0. *\/\n\tprivate void fixSigns() { \/* implementation not shown *\/ }\n\n\t\/** Ensures lowest terms. *\/\n\tprivate void reduce() { \/* implementation not shown *\/ }\n}\n\nHere is the implementation code for the plus method: \n\n\/** Returns (this + r). Leaves this unchanged. \n* @return this rational number plus r \n* @param r a rational number to be added to this Rational \n*\/ \npublic Rational plus(Rational r) \n{ \n\tfixSigns(); \n\tr.fixSigns(); \n\tint denom = denominator * r.denominator; \n\tint numer = numerator * r.denominator + r.numerator * denominator; \n\t\/* more code *\/ \n} \n\nWhich of the following is a correct replacement for \/* more code *\/? \nCorrect: Rational rat = new Rational(numer, denom);\nrat.reduce(); \nreturn rat; \n\n\nIncorrect: Rational rat(numer, denom);\nrat.reduce(); \nreturn rat; \nIncorrect: return new Rational(numer, denom);\nIncorrect: reduce();\nRational rat = new Rational(numer, denom); \nreturn rat; \nIncorrect: Rational rat = new Rational(numer, denom);\nRational.reduce(); \nreturn rat; END"}
{"prompt":"A constructor creates an object of the class. You can recognize a constructor by its name—always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n\/** Default constructor.\n* Constructs a bank account with default values. *\/\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address—we say “b is a reference to the object.”\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n\/** Constructor. Constructs a bank account with\n* specified password and balance. *\/\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n\/** @return the balance of this account *\/\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n\/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*\/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n        balance += amount;\n}\n\/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*\/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n    {\n        balance -= amount; \/\/allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\n###\n\n","completion":" Question: Consider the Rational class defined below:\n\npublic class Rational {\n\tprivate int numerator;\n\tprivate int denominator;\n\n\t\/** default constructor *\/\n\tRational() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Constructs a Rational with numerator n and\n\t * denominator 1.\n\t *\/\n\tRational(int n) { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Constructs a Rational with specified numerator and\n\t * denominator.\n\t *\/\n\tRational(int numer, int denom) { \/* implementation not shown *\/ }\n\n\t\/** @return numerator *\/\n\tint numerator() { \/* implementation not shown *\/ }\n\n\t\/** @return denominator *\/\n\tint denominator() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Returns (this + r). Leaves this unchanged.\n\t *\n\t * @return this rational number plus r\n\t * @param r a rational number to be added to this Rational\n\t *\/\n\tpublic Rational plus(Rational r) { \/* implementation not shown *\/ }\n\n\t\/\/ Similarly for times, minus, divide ...\n\t\/** Ensures denominator > 0. *\/\n\tprivate void fixSigns() { \/* implementation not shown *\/ }\n\n\t\/** Ensures lowest terms. *\/\n\tprivate void reduce() { \/* implementation not shown *\/ }\n}\n\nAssume these declarations: \n\nRational a = new Rational(); \nRational r = new Rational(numer, denom); \nint n = value; \n\/\/numer, denom, and value are valid integer values \n\nWhich of the following will cause a compile-time error? \nCorrect: a = n.plus(r);\nIncorrect: r = a.plus(r);\nIncorrect: a = r.plus(new Rational(n));\nIncorrect: r = r.plus(r);\nIncorrect: r = r.plus(new Rational(n));\n\nEND"}
{"prompt":"The scope of a variable or method is the region in which that variable or method is visible and can be accessed.\nThe instance variables, static variables, and methods of a class belong to that class’s scope, which extends from the opening brace to the closing brace of the class definition. Within the class all instance variables and methods are accessible and can be referred to simply by name (no dot operator!).\nA local variable is defined inside a method. It can even be defined inside a statement. Its scope extends from the point where it is declared to the end of the block in which its declaration occurs. A block is a piece of code enclosed in a {} pair. When a block is exited, the memory for a local variable is automatically recycled.\nLocal variables take precedence over instance variables with the same name. (Using the same name, however, creates ambiguity for the programmer, leading to errors. You should avoid the practice.)\n\nAn instance method is always called for a particular object. This object is an implicit parameter for the method and is referred to with the keyword this. You are expected to know this vocabulary for the exam.\nIn the implementation of instance methods, all instance variables can be written with the prefix this followed by the dot operator.\n\nExample 1\nIn the method call obj.doSomething(\"Mary\",num), where obj is some class object and doSomething is a method of that class, \"Mary\" and num, the parameters in parentheses, are explicit parameters, whereas obj is an implicit parameter.\nExample 2\nHere’s an example where this is used as a parameter.\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person(String aName, int anAge) {\n        name = aName;\n        age = anAge;\n    }\n\n    \/** @return the String form of this person *\/\n    public String toString() {\n        return name + \" \" + age;\n    }\n\n    public void printPerson() {\n        System.out.println(this);\n    }\n    \/\/ Other variables and methods are not shown.\n}\n\nSuppose a client class has these lines of code:\nPerson p = new Person(\"Dan\", 10);\np.printPerson();\nThe statement\nSystem.out.println(this);\nin the printPerson method means “print the current Person object.” The output should be: Dan 10. Note that System.out.println invokes the toString method of the Person class.\n\nThe deposit method of the BankAccount class can refer to balance as follows:\npublic void deposit(String acctPassword, double amount)\n{\n    this.balance += amount;\n}\nThe use of this is unnecessary in the above example.\n\nConsider a rational number class called Rational, which has two private instance variables:\nprivate int num; \/\/numerator\nprivate int denom; \/\/denominator\nNow consider a constructor for the Rational class:\npublic Rational(int num, int denom)\n{\n    this.num = num;\n    this.denom = denom;\n}\nIt is definitely not a good idea to use the same name for the explicit parameters and the private instance variables. But if you do, you can avoid errors by referring to this.num and this.denom for the current object that is being constructed. (This particular use of this will not be tested on the exam.)\nAll of the numerical data types, like double and int, as well as types char and boolean, are primitive data types. All objects are reference data types. The difference lies in the way they are stored.\nConsider the statements\nint num1 = 3;\nint num2 = num1;\n\nThe variables num1 and num2 can be thought of as memory slots, labeled num1 and num2, respectively\nIf either of the above variables is now changed, the other is not affected. Each has its own memory slot.\nContrast this with the declaration of a reference data type. Recall that an object is created using new:\nDate d = new Date(2, 17, 1948);\nThis declaration creates a reference variable d that refers to a Date object. The value of d is the address in memory of that object\n\nSuppose the following declaration is now made:\nDate birthday = d;\nThis statement creates the reference variable birthday, which contains the same address as d\n\nHaving two references for the same object is known as aliasing. Aliasing can cause unintended problems for the programmer. The statement\nd.changeDate();\nwill automatically change the object referred to by birthday as well. What the programmer probably intended was to create a second object called birthday whose attributes exactly matched those of d. This cannot be accomplished without using new. For example,\nDate birthday = new Date(d.getMonth(), d.getDay(), d.getYear()); The statement d.changeDate() will now leave the birthday object unchanged.\nThe declaration\nBankAccount b;\ndefines a reference b that is uninitialized. (To construct the object that b refers to requires the new operator and a BankAccount constructor.) An uninitialized object variable is called a null reference or null pointer. You can test whether a variable refers to an object or is uninitialized by using the keyword null:\nif (b == null)\nIf a reference is not null, it can be set to null with the statement\nb = null;\nAn attempt to invoke an instance method with a null reference may cause your program to terminate with a NullPointerException. For example,\n\npublic class PersonalFinances\n{\n    BankAccount b; \/\/b is a null reference\n    ...\n    b.withdraw(acctPassword, amt); \/\/throws a NullPointerException\n    ... \/\/if b not constructed with new\n\nIf you fail to initialize a local variable in a method before you use it, you will get a compile-time error. If you make the same mistake with an instance variable of a class, the compiler provides reasonable default values for primitive variables (0 for numbers,\n\nfalse for booleans), and the code may run without error. However, if you don’t initialize reference instance variables in a class, as in the above example, the compiler will set them to null. Any method call for an object of the class that tries to access the null reference will cause a run-time error: The program will terminate with a NullPointerException.\n\n\n###\n\n","completion":" Question: Consider the Temperature class defined below:\n\npublic class Temperature {\n\tprivate String scale; \/\/ valid values are \"F\" or \"C\"\n\tprivate double degrees;\n\n\t\/** constructor with specified degrees and scale *\/\n\tpublic Temperature(double tempDegrees, String tempScale) { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Mutator. Converts this Temperature to degrees Fahrenheit.\n\t * Precondition: Temperature is a valid temperature\n\t * in degrees Celsius.\n\t * \n\t * @return this temperature in degrees Fahrenheit\n\t *\/\n\tpublic Temperature toFahrenheit() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Mutator. Converts this Temperature to degrees Celsius.\n\t * Precondition: Temperature is a valid temperature\n\t * in degrees Fahrenheit.\n\t * \n\t * @return this temperature in degrees Celsius\n\t *\/\n\tpublic Temperature toCelsius() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Mutator.\n\t * \n\t * @param amt the number of degrees to raise this temperature\n\t * @return this temperature raised by amt degrees\n\t *\/\n\tpublic Temperature raise(double amt) { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Mutator.\n\t * \n\t * @param amt the number of degrees to lower this temperature\n\t * @return this temperature lowered by amt degrees\n\t *\/\n\tpublic Temperature lower(double amt) { \/* implementation not shown *\/ }\n\n\t\/**\n\t * @param tempDegrees the number of degrees\n\t * @param tempScale   the temperature scale\n\t * @return true if tempDegrees is a valid temperature\n\t *         in the given temperature scale, false otherwise\n\t *\/\n\tpublic static boolean isValidTemp(double tempDegrees,\n\t\t\tString tempScale) { \/* implementation not shown *\/ }\n\t\/\/ Other methods are not shown.\n}\n\nA client method contains this code segment: \n\nTemperature t1 = new Temperature(40, \"C\"); \nTemperature t2 = t1; \nTemperature t3 = t2.lower(20); \nTemperature t4 = t1.toFahrenheit(); \n\nWhich statement is true following execution of this segment? \nCorrect: t1, t2, t3, and t4 all represent the identical temperature, in degrees Fahrenheit.\nIncorrect: t1, t2, t3, and t4 all represent the identical temperature, in degrees Celsius.\nIncorrect: t4 represents a Fahrenheit temperature, while t1, t2, and t3 all represent degrees Celsius.\nIncorrect: t1 and t2 refer to the same Temperature object; t3 refers to a Temperature object that is 20 degrees lower than t1 and t2, while t4 refers to an object that is t1 converted to Fahrenheit.\nIncorrect: A NullPointerException was thrown.\n\nEND"}
{"prompt":"A constructor creates an object of the class. You can recognize a constructor by its name—always the same as the class. Also, a constructor has no return type. Having several constructors provides different ways of initializing class objects. For example, there are two constructors in the BankAccount class.\n1. The default constructor has no arguments. It provides reasonable initial values for an object. Here is its implementation:\n\/** Default constructor.\n* Constructs a bank account with default values. *\/\npublic BankAccount()\n{\n    password = \"\";\n    balance = 0.0;\n}\nIn a client method, the declaration\nBankAccount b = new BankAccount();\nconstructs a BankAccount object with a balance of zero and a password equal to the empty string. The new operator returns the address of this newly con structed object. The variable b is assigned the value of this address—we say “b is a reference to the object.”\n\n2. The constructor with parameters sets the instance variables of a BankAccount object to the values of those parameters.\nHere is the implementation:\n\/** Constructor. Constructs a bank account with\n* specified password and balance. *\/\npublic BankAccount(String acctPassword, double acctBalance) {\n    password = acctPassword;\n    balance = acctBalance;\n}\nIn a client program a declaration that uses this constructor needs matching parameters:\nBankAccount c = new BankAccount(\"KevinC\", 800.00);\n\nb and c are object variables that store the addresses of their respective BankAccount objects. They do not store the objects themselves (see References on p. 101).\nAn accessor method accesses a class object without altering the object. An accessor returns some information about the object.\nThe BankAccount class has a single accessor method, getBalance(). Here is its implementation:\n\/** @return the balance of this account *\/\npublic double getBalance()\n{ return balance; }\n\nA client program may use this method as follows:\nBankAccount b1 = new BankAccount(\"MattW\", 500.00);\nBankAccount b2 = new BankAccount(\"DannyB\", 650.50);\nif (b1.getBalance() > b2.getBalance())\n...\n\nThe . operator (dot operator) indicates that getBalance() is a method of the class to which b1 and b2 belong, namely the BankAccount class.\nA mutator method changes the state of an object by modifying at least one of its in stance variables.\nHere are the implementations of the deposit and withdraw methods, each of which alters the value of balance in the BankAccount class:\n\/** Deposits amount in a bank account with the given password.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be deposited\n*\/\npublic void deposit(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n        balance += amount;\n}\n\/** Withdraws amount from bank account with given password.\n* Assesses penalty if balance is less than amount.\n* @param acctPassword the password of this bank account\n* @param amount the amount to be withdrawn\n*\/\npublic void withdraw(String acctPassword, double amount)\n{\n    if (!acctPassword.equals(password))\n        \/* throw an exception *\/\n    else\n    {\n        balance -= amount; \/\/allows negative balance\n        if (balance < 0)\n        balance -= OVERDRAWN_PENALTY;\n    }\n}\n\nA mutator method in a client program is invoked in the same way as an accessor: us ing an object variable with the dot operator. For example, assuming valid BankAccount declarations for b1 and b2:\nb1.withdraw(\"MattW\", 200.00);\nb2.deposit(\"DannyB\", 35.68);\n\n\n###\n\n","completion":" Question: Consider the Temperature class defined below:\n\npublic class Temperature {\n\tprivate String scale; \/\/ valid values are \"F\" or \"C\"\n\tprivate double degrees;\n\n\t\/** constructor with specified degrees and scale *\/\n\tpublic Temperature(double tempDegrees, String tempScale) { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Mutator. Converts this Temperature to degrees Fahrenheit.\n\t * Precondition: Temperature is a valid temperature\n\t * in degrees Celsius.\n\t * \n\t * @return this temperature in degrees Fahrenheit\n\t *\/\n\tpublic Temperature toFahrenheit() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Mutator. Converts this Temperature to degrees Celsius.\n\t * Precondition: Temperature is a valid temperature\n\t * in degrees Fahrenheit.\n\t * \n\t * @return this temperature in degrees Celsius\n\t *\/\n\tpublic Temperature toCelsius() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Mutator.\n\t * \n\t * @param amt the number of degrees to raise this temperature\n\t * @return this temperature raised by amt degrees\n\t *\/\n\tpublic Temperature raise(double amt) { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Mutator.\n\t * \n\t * @param amt the number of degrees to lower this temperature\n\t * @return this temperature lowered by amt degrees\n\t *\/\n\tpublic Temperature lower(double amt) { \/* implementation not shown *\/ }\n\n\t\/**\n\t * @param tempDegrees the number of degrees\n\t * @param tempScale   the temperature scale\n\t * @return true if tempDegrees is a valid temperature\n\t *         in the given temperature scale, false otherwise\n\t *\/\n\tpublic static boolean isValidTemp(double tempDegrees,\n\t\t\tString tempScale) { \/* implementation not shown *\/ }\n\t\/\/ Other methods are not shown.\n}\n\nConsider the following code: \n\npublic class TempTest \n{ \n\tpublic static void main(String[] args) \n\t{ \n\t\tSystem.out.println(\"Enter temperature scale: \"); \n\t\tString tempScale = IO.readString(); \/\/read user input \n\t\tSystem.out.println(\"Enter number of degrees: \"); \n\t\tdouble tempDegrees = IO.readDouble(); \/\/read user input \n\t\t\/* code to construct a valid temperature from user input *\/ \n\t} \n} \n\nWhich is a correct replacement for \/* code to construct. . . *\/? \nI Temperature t = new Temperature(tempDegrees, tempScale); \nif (!t.isValidTemp(tempDegrees,tempScale)) \n\/* error message and exit program *\/ \nII if (isValidTemp(tempDegrees,tempScale)) \nTemperature t = new Temperature(tempDegrees, tempScale); \nelse \n\/* error message and exit program *\/ \nIII if (Temperature.isValidTemp(tempDegrees,tempScale)) \nTemperature t = new Temperature(tempDegrees, tempScale); \nelse \n\/* error message and exit program *\/ \nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: I and III only\n\nEND"}
{"prompt":"The methods discussed in the preceding sections—constructors, accessors, and mutators—all operate on individual objects of a class. They are called instance methods. A method that performs an operation for the entire class, not its individual objects, is called a static method (sometimes called a class method).\nThe implementation of a static method uses the keyword static in its header. There is no implied object in the code (as there is in an instance method). Thus, if the code tries to call an instance method or invoke a private instance variable for this nonexistent object, a syntax error will occur. A static method can, however, use a static variable in its code. For example, in the Employee example on p. 94, you could add a static method that returns the employeeCount:\n\npublic static int getEmployeeCount()\n{ return employeeCount; }\n\nHere’s an example of a static method that might be used in the BankAccount class. Suppose the class has a static variable intRate, declared as follows:\n\nprivate static double intRate;\n\nThe static method getInterestRate may be as follows:\n\npublic static double getInterestRate()\n{\n    System.out.println(\"Enter interest rate for bank account\");\n    System.out.println(\"Enter in decimal form:\");\n    intRate = IO.readDouble(); \/\/ read user input\n    return intRate;\n}\n\nSince the rate that’s read in by this method applies to all bank accounts in the class, not to any particular BankAccount object, it’s appropriate that the method should be static.\nRecall that an instance method is invoked in a client program by using an object variable followed by the dot operator followed by the method name:\n\nBankAccount b = new BankAccount(); \/\/invokes the deposit method for\nb.deposit(acctPassword, amount); \/\/BankAccount object b\n\nA static method, by contrast, is invoked by using the class name with the dot operator: double interestRate = BankAccount.getInterestRate();\nOften a class that contains the main() method is used as a driver program to test other classes. Usually such a class creates no objects of the class. So all the methods in the class must be static. Note that at the start of program execution, no objects exist yet. So the main() method must always be static.\nFor example, here is a program that tests a class for reading integers entered at the keyboard.\n\nimport java.util.*;\n\npublic class GetListTest {\n    \/** @return a list of integers from the keyboard *\/\n    public static List<Integer> getList()\n    {\n        List<Integer> a = new ArrayList<Integer>();\n        < code to read integers into a>\n        return a;\n    }\n\n    \/**\n     * Write contents of List a.\n     *\n     * @param a the list\n     *\/\n    public static void writeList(List<Integer> a) {\n        System.out.println(\"List is : \" + a);\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list = getList();\n        writeList(list);\n    }\n}\n\n1. The calls to writeList(list) and getList() do not need to be preceded by\nGetListTest plus a dot because main is not a client program: It is in the same\nclass as getList and writeList.\n2. If you omit the keyword static from the getList or writeList header, you\nget an error message like the following:\nCan’t make static reference to method getList()\nin class GetListTest\n\nThe compiler has recognized that there was no object variable preceding the\nmethod call, which means that the methods were static and should have been\ndeclared as such.\nOverloaded methods are two or more methods in the same class that have the same name but different parameter lists. For example,\n\npublic class DoOperations\n{\n    public int product(int n) { return n * n; }\n    public double product(double x) { return x * x; }\n    public double product(int x, int y) { return x * y; }\n    ...\n\nThe compiler figures out which method to call by examining the method’s signature. The signature of a method consists of the method’s name and a list of the parameter types. Thus, the signatures of the overloaded product methods are\nproduct(int)\nproduct(double)\nproduct(int, int)\nNote that for overloading purposes, the return type of the method is irrelevant. You can’t have two methods with identical signatures but different return types. The compiler will complain that the method call is ambiguous.\nHaving more than one constructor in the same class is an example of overloading. Overloaded constructors provide a choice of ways to initialize objects of the class.\n\n\n###\n\n","completion":" Question: Consider the Temperature class defined below:\n\npublic class Temperature {\n\tprivate String scale; \/\/ valid values are \"F\" or \"C\"\n\tprivate double degrees;\n\n\t\/** constructor with specified degrees and scale *\/\n\tpublic Temperature(double tempDegrees, String tempScale) { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Mutator. Converts this Temperature to degrees Fahrenheit.\n\t * Precondition: Temperature is a valid temperature\n\t * in degrees Celsius.\n\t * \n\t * @return this temperature in degrees Fahrenheit\n\t *\/\n\tpublic Temperature toFahrenheit() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Mutator. Converts this Temperature to degrees Celsius.\n\t * Precondition: Temperature is a valid temperature\n\t * in degrees Fahrenheit.\n\t * \n\t * @return this temperature in degrees Celsius\n\t *\/\n\tpublic Temperature toCelsius() { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Mutator.\n\t * \n\t * @param amt the number of degrees to raise this temperature\n\t * @return this temperature raised by amt degrees\n\t *\/\n\tpublic Temperature raise(double amt) { \/* implementation not shown *\/ }\n\n\t\/**\n\t * Mutator.\n\t * \n\t * @param amt the number of degrees to lower this temperature\n\t * @return this temperature lowered by amt degrees\n\t *\/\n\tpublic Temperature lower(double amt) { \/* implementation not shown *\/ }\n\n\t\/**\n\t * @param tempDegrees the number of degrees\n\t * @param tempScale   the temperature scale\n\t * @return true if tempDegrees is a valid temperature\n\t *         in the given temperature scale, false otherwise\n\t *\/\n\tpublic static boolean isValidTemp(double tempDegrees,\n\t\t\tString tempScale) { \/* implementation not shown *\/ }\n\t\/\/ Other methods are not shown.\n}\n\nThe formula to convert degrees Celsius C to Fahrenheit F is F = 1.8C + 32. For example, 30◦ C is equivalent to 86◦ F. An inFahrenheit() accessor method is added to the Temperature class. Here is its implementation: \n\/** Precondition: The temperature is a valid temperature \n* in degrees Celsius. \n* Postcondition: \n* - An equivalent temperature in degrees Fahrenheit has been \n* returned. \n* - Original temperature remains unchanged. \n* @return an equivalent temperature in degrees Fahrenheit \n*\/ \npublic Temperature inFahrenheit() \n{ \n\tTemperature result; \n\t\/* more code *\/ \n\treturn result; \n} \n\nWhich of the following correctly replaces \/* more code *\/ so that the postcondition is achieved? \nI result = new Temperature(degrees * 1.8 + 32, \"F\"); \nII result = new Temperature(degrees * 1.8, \"F\"); \nresult = result.raise(32); \nIII degrees *= 1.8; \nthis = this.raise(32); \nresult = new Temperature(degrees, \"F\"); \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"The scope of a variable or method is the region in which that variable or method is visible and can be accessed.\nThe instance variables, static variables, and methods of a class belong to that class’s scope, which extends from the opening brace to the closing brace of the class definition. Within the class all instance variables and methods are accessible and can be referred to simply by name (no dot operator!).\nA local variable is defined inside a method. It can even be defined inside a statement. Its scope extends from the point where it is declared to the end of the block in which its declaration occurs. A block is a piece of code enclosed in a {} pair. When a block is exited, the memory for a local variable is automatically recycled.\nLocal variables take precedence over instance variables with the same name. (Using the same name, however, creates ambiguity for the programmer, leading to errors. You should avoid the practice.)\n\nAn instance method is always called for a particular object. This object is an implicit parameter for the method and is referred to with the keyword this. You are expected to know this vocabulary for the exam.\nIn the implementation of instance methods, all instance variables can be written with the prefix this followed by the dot operator.\n\nExample 1\nIn the method call obj.doSomething(\"Mary\",num), where obj is some class object and doSomething is a method of that class, \"Mary\" and num, the parameters in parentheses, are explicit parameters, whereas obj is an implicit parameter.\nExample 2\nHere’s an example where this is used as a parameter.\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person(String aName, int anAge) {\n        name = aName;\n        age = anAge;\n    }\n\n    \/** @return the String form of this person *\/\n    public String toString() {\n        return name + \" \" + age;\n    }\n\n    public void printPerson() {\n        System.out.println(this);\n    }\n    \/\/ Other variables and methods are not shown.\n}\n\nSuppose a client class has these lines of code:\nPerson p = new Person(\"Dan\", 10);\np.printPerson();\nThe statement\nSystem.out.println(this);\nin the printPerson method means “print the current Person object.” The output should be: Dan 10. Note that System.out.println invokes the toString method of the Person class.\n\nThe deposit method of the BankAccount class can refer to balance as follows:\npublic void deposit(String acctPassword, double amount)\n{\n    this.balance += amount;\n}\nThe use of this is unnecessary in the above example.\n\nConsider a rational number class called Rational, which has two private instance variables:\nprivate int num; \/\/numerator\nprivate int denom; \/\/denominator\nNow consider a constructor for the Rational class:\npublic Rational(int num, int denom)\n{\n    this.num = num;\n    this.denom = denom;\n}\nIt is definitely not a good idea to use the same name for the explicit parameters and the private instance variables. But if you do, you can avoid errors by referring to this.num and this.denom for the current object that is being constructed. (This particular use of this will not be tested on the exam.)\nAll of the numerical data types, like double and int, as well as types char and boolean, are primitive data types. All objects are reference data types. The difference lies in the way they are stored.\nConsider the statements\nint num1 = 3;\nint num2 = num1;\n\nThe variables num1 and num2 can be thought of as memory slots, labeled num1 and num2, respectively\nIf either of the above variables is now changed, the other is not affected. Each has its own memory slot.\nContrast this with the declaration of a reference data type. Recall that an object is created using new:\nDate d = new Date(2, 17, 1948);\nThis declaration creates a reference variable d that refers to a Date object. The value of d is the address in memory of that object\n\nSuppose the following declaration is now made:\nDate birthday = d;\nThis statement creates the reference variable birthday, which contains the same address as d\n\nHaving two references for the same object is known as aliasing. Aliasing can cause unintended problems for the programmer. The statement\nd.changeDate();\nwill automatically change the object referred to by birthday as well. What the programmer probably intended was to create a second object called birthday whose attributes exactly matched those of d. This cannot be accomplished without using new. For example,\nDate birthday = new Date(d.getMonth(), d.getDay(), d.getYear()); The statement d.changeDate() will now leave the birthday object unchanged.\nThe declaration\nBankAccount b;\ndefines a reference b that is uninitialized. (To construct the object that b refers to requires the new operator and a BankAccount constructor.) An uninitialized object variable is called a null reference or null pointer. You can test whether a variable refers to an object or is uninitialized by using the keyword null:\nif (b == null)\nIf a reference is not null, it can be set to null with the statement\nb = null;\nAn attempt to invoke an instance method with a null reference may cause your program to terminate with a NullPointerException. For example,\n\npublic class PersonalFinances\n{\n    BankAccount b; \/\/b is a null reference\n    ...\n    b.withdraw(acctPassword, amt); \/\/throws a NullPointerException\n    ... \/\/if b not constructed with new\n\nIf you fail to initialize a local variable in a method before you use it, you will get a compile-time error. If you make the same mistake with an instance variable of a class, the compiler provides reasonable default values for primitive variables (0 for numbers,\n\nfalse for booleans), and the code may run without error. However, if you don’t initialize reference instance variables in a class, as in the above example, the compiler will set them to null. Any method call for an object of the class that tries to access the null reference will cause a run-time error: The program will terminate with a NullPointerException.\n\n\n###\n\n","completion":" Question: Consider this program: \n\npublic class CountStuff \n{ \n\tpublic static void doSomething() \n\t{ \n\t\tint count = 0; \n\t\t... \n\t\t\/\/code to do something - no screen output produced \n\t\tcount++; \n\t} \n\n\tpublic static void main(String[] args) \n\t{ \n\t\tint count = 0; \n\t\tSystem.out.println(\"How many iterations?\"); \n\t\tint n = IO.readInt(); \/\/read user input \n\t\tfor (int i = 1; i <= n; i++) \n\t\t{ \n\t\t\tdoSomething(); \n\t\t\tSystem.out.println(count); \n\t\t} \n\t} \n} \n\nIf the input value for n is 3, what screen output will this program subsequently produce? \nCorrect: 0\n0 \n0 \nIncorrect: 1\n2 \n3 \nIncorrect: 3\n3 \n3 \nIncorrect: ?\n? \n?where ? is some undefined value. \nIncorrect: No output will be produced.\n\nEND"}
{"prompt":"The scope of a variable or method is the region in which that variable or method is visible and can be accessed.\nThe instance variables, static variables, and methods of a class belong to that class’s scope, which extends from the opening brace to the closing brace of the class definition. Within the class all instance variables and methods are accessible and can be referred to simply by name (no dot operator!).\nA local variable is defined inside a method. It can even be defined inside a statement. Its scope extends from the point where it is declared to the end of the block in which its declaration occurs. A block is a piece of code enclosed in a {} pair. When a block is exited, the memory for a local variable is automatically recycled.\nLocal variables take precedence over instance variables with the same name. (Using the same name, however, creates ambiguity for the programmer, leading to errors. You should avoid the practice.)\n\nAn instance method is always called for a particular object. This object is an implicit parameter for the method and is referred to with the keyword this. You are expected to know this vocabulary for the exam.\nIn the implementation of instance methods, all instance variables can be written with the prefix this followed by the dot operator.\n\nExample 1\nIn the method call obj.doSomething(\"Mary\",num), where obj is some class object and doSomething is a method of that class, \"Mary\" and num, the parameters in parentheses, are explicit parameters, whereas obj is an implicit parameter.\nExample 2\nHere’s an example where this is used as a parameter.\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person(String aName, int anAge) {\n        name = aName;\n        age = anAge;\n    }\n\n    \/** @return the String form of this person *\/\n    public String toString() {\n        return name + \" \" + age;\n    }\n\n    public void printPerson() {\n        System.out.println(this);\n    }\n    \/\/ Other variables and methods are not shown.\n}\n\nSuppose a client class has these lines of code:\nPerson p = new Person(\"Dan\", 10);\np.printPerson();\nThe statement\nSystem.out.println(this);\nin the printPerson method means “print the current Person object.” The output should be: Dan 10. Note that System.out.println invokes the toString method of the Person class.\n\nThe deposit method of the BankAccount class can refer to balance as follows:\npublic void deposit(String acctPassword, double amount)\n{\n    this.balance += amount;\n}\nThe use of this is unnecessary in the above example.\n\nConsider a rational number class called Rational, which has two private instance variables:\nprivate int num; \/\/numerator\nprivate int denom; \/\/denominator\nNow consider a constructor for the Rational class:\npublic Rational(int num, int denom)\n{\n    this.num = num;\n    this.denom = denom;\n}\nIt is definitely not a good idea to use the same name for the explicit parameters and the private instance variables. But if you do, you can avoid errors by referring to this.num and this.denom for the current object that is being constructed. (This particular use of this will not be tested on the exam.)\nAll of the numerical data types, like double and int, as well as types char and boolean, are primitive data types. All objects are reference data types. The difference lies in the way they are stored.\nConsider the statements\nint num1 = 3;\nint num2 = num1;\n\nThe variables num1 and num2 can be thought of as memory slots, labeled num1 and num2, respectively\nIf either of the above variables is now changed, the other is not affected. Each has its own memory slot.\nContrast this with the declaration of a reference data type. Recall that an object is created using new:\nDate d = new Date(2, 17, 1948);\nThis declaration creates a reference variable d that refers to a Date object. The value of d is the address in memory of that object\n\nSuppose the following declaration is now made:\nDate birthday = d;\nThis statement creates the reference variable birthday, which contains the same address as d\n\nHaving two references for the same object is known as aliasing. Aliasing can cause unintended problems for the programmer. The statement\nd.changeDate();\nwill automatically change the object referred to by birthday as well. What the programmer probably intended was to create a second object called birthday whose attributes exactly matched those of d. This cannot be accomplished without using new. For example,\nDate birthday = new Date(d.getMonth(), d.getDay(), d.getYear()); The statement d.changeDate() will now leave the birthday object unchanged.\nThe declaration\nBankAccount b;\ndefines a reference b that is uninitialized. (To construct the object that b refers to requires the new operator and a BankAccount constructor.) An uninitialized object variable is called a null reference or null pointer. You can test whether a variable refers to an object or is uninitialized by using the keyword null:\nif (b == null)\nIf a reference is not null, it can be set to null with the statement\nb = null;\nAn attempt to invoke an instance method with a null reference may cause your program to terminate with a NullPointerException. For example,\n\npublic class PersonalFinances\n{\n    BankAccount b; \/\/b is a null reference\n    ...\n    b.withdraw(acctPassword, amt); \/\/throws a NullPointerException\n    ... \/\/if b not constructed with new\n\nIf you fail to initialize a local variable in a method before you use it, you will get a compile-time error. If you make the same mistake with an instance variable of a class, the compiler provides reasonable default values for primitive variables (0 for numbers,\n\nfalse for booleans), and the code may run without error. However, if you don’t initialize reference instance variables in a class, as in the above example, the compiler will set them to null. Any method call for an object of the class that tries to access the null reference will cause a run-time error: The program will terminate with a NullPointerException.\n\n\n###\n\n","completion":" Question: This question refers to the following class: \n\npublic class IntObject \n{ \n\tprivate int num; \n\n\tpublic IntObject() \/\/default constructor \n\t{ num = 0; } \n\n\tpublic IntObject(int n) \/\/constructor \n\t{ num = n; } \n\n\tpublic void increment() \/\/increment by 1 \n\t{ num++; } \n} \n\nHere is a client program that uses this class: \n\npublic class IntObjectTest \n{ \n\tpublic static IntObject someMethod(IntObject obj) \n\t{ \n\t\tIntObject ans = obj; \n\t\tans.increment(); \n\t\treturn ans; \n\t} \n\n\tpublic static void main(String[] args) \n\t{ \n\t\tIntObject x = new IntObject(2); \n\t\tIntObject y = new IntObject(7); \n\t\tIntObject a = y; \n\t\tx = someMethod(y); \n\t\ta = someMethod(x); \n\t} \n} \n\nJust before exiting this program, what are the object values of x, y, and a, respectively? \nCorrect: 9, 9, 9\nIncorrect: 2, 9, 9\nIncorrect: 2, 8, 9\nIncorrect: 3, 8, 9\nIncorrect: 7, 8, 9\n\nEND"}
{"prompt":"The scope of a variable or method is the region in which that variable or method is visible and can be accessed.\nThe instance variables, static variables, and methods of a class belong to that class’s scope, which extends from the opening brace to the closing brace of the class definition. Within the class all instance variables and methods are accessible and can be referred to simply by name (no dot operator!).\nA local variable is defined inside a method. It can even be defined inside a statement. Its scope extends from the point where it is declared to the end of the block in which its declaration occurs. A block is a piece of code enclosed in a {} pair. When a block is exited, the memory for a local variable is automatically recycled.\nLocal variables take precedence over instance variables with the same name. (Using the same name, however, creates ambiguity for the programmer, leading to errors. You should avoid the practice.)\n\nAn instance method is always called for a particular object. This object is an implicit parameter for the method and is referred to with the keyword this. You are expected to know this vocabulary for the exam.\nIn the implementation of instance methods, all instance variables can be written with the prefix this followed by the dot operator.\n\nExample 1\nIn the method call obj.doSomething(\"Mary\",num), where obj is some class object and doSomething is a method of that class, \"Mary\" and num, the parameters in parentheses, are explicit parameters, whereas obj is an implicit parameter.\nExample 2\nHere’s an example where this is used as a parameter.\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person(String aName, int anAge) {\n        name = aName;\n        age = anAge;\n    }\n\n    \/** @return the String form of this person *\/\n    public String toString() {\n        return name + \" \" + age;\n    }\n\n    public void printPerson() {\n        System.out.println(this);\n    }\n    \/\/ Other variables and methods are not shown.\n}\n\nSuppose a client class has these lines of code:\nPerson p = new Person(\"Dan\", 10);\np.printPerson();\nThe statement\nSystem.out.println(this);\nin the printPerson method means “print the current Person object.” The output should be: Dan 10. Note that System.out.println invokes the toString method of the Person class.\n\nThe deposit method of the BankAccount class can refer to balance as follows:\npublic void deposit(String acctPassword, double amount)\n{\n    this.balance += amount;\n}\nThe use of this is unnecessary in the above example.\n\nConsider a rational number class called Rational, which has two private instance variables:\nprivate int num; \/\/numerator\nprivate int denom; \/\/denominator\nNow consider a constructor for the Rational class:\npublic Rational(int num, int denom)\n{\n    this.num = num;\n    this.denom = denom;\n}\nIt is definitely not a good idea to use the same name for the explicit parameters and the private instance variables. But if you do, you can avoid errors by referring to this.num and this.denom for the current object that is being constructed. (This particular use of this will not be tested on the exam.)\nAll of the numerical data types, like double and int, as well as types char and boolean, are primitive data types. All objects are reference data types. The difference lies in the way they are stored.\nConsider the statements\nint num1 = 3;\nint num2 = num1;\n\nThe variables num1 and num2 can be thought of as memory slots, labeled num1 and num2, respectively\nIf either of the above variables is now changed, the other is not affected. Each has its own memory slot.\nContrast this with the declaration of a reference data type. Recall that an object is created using new:\nDate d = new Date(2, 17, 1948);\nThis declaration creates a reference variable d that refers to a Date object. The value of d is the address in memory of that object\n\nSuppose the following declaration is now made:\nDate birthday = d;\nThis statement creates the reference variable birthday, which contains the same address as d\n\nHaving two references for the same object is known as aliasing. Aliasing can cause unintended problems for the programmer. The statement\nd.changeDate();\nwill automatically change the object referred to by birthday as well. What the programmer probably intended was to create a second object called birthday whose attributes exactly matched those of d. This cannot be accomplished without using new. For example,\nDate birthday = new Date(d.getMonth(), d.getDay(), d.getYear()); The statement d.changeDate() will now leave the birthday object unchanged.\nThe declaration\nBankAccount b;\ndefines a reference b that is uninitialized. (To construct the object that b refers to requires the new operator and a BankAccount constructor.) An uninitialized object variable is called a null reference or null pointer. You can test whether a variable refers to an object or is uninitialized by using the keyword null:\nif (b == null)\nIf a reference is not null, it can be set to null with the statement\nb = null;\nAn attempt to invoke an instance method with a null reference may cause your program to terminate with a NullPointerException. For example,\n\npublic class PersonalFinances\n{\n    BankAccount b; \/\/b is a null reference\n    ...\n    b.withdraw(acctPassword, amt); \/\/throws a NullPointerException\n    ... \/\/if b not constructed with new\n\nIf you fail to initialize a local variable in a method before you use it, you will get a compile-time error. If you make the same mistake with an instance variable of a class, the compiler provides reasonable default values for primitive variables (0 for numbers,\n\nfalse for booleans), and the code may run without error. However, if you don’t initialize reference instance variables in a class, as in the above example, the compiler will set them to null. Any method call for an object of the class that tries to access the null reference will cause a run-time error: The program will terminate with a NullPointerException.\n\n\n###\n\n","completion":" Question: Consider the following program: \n\npublic class Tester \n{ \n\tpublic void someMethod(int a, int b) \n\t{ \n\t\tint temp = a; \n\t\ta = b; \n\t\tb = temp; \n\t} \n} \n\npublic class TesterMain \n{ \n\tpublic static void main(String[] args) \n\t{ \n\t\tint x = 6, y = 8; \n\t\tTester tester = new Tester(); \n\t\ttester.someMethod(x, y); \n\t} \n} \n\nJust before the end of execution of this program, what are the values of x, y, and temp, respectively? \nCorrect: 6, 8, ?, where ? means undefined\nIncorrect: 6, 8, 6\nIncorrect: 8, 6, 6\nIncorrect: 8, 6, ?, where ? means undefined\nIncorrect: 8, 6, 8\nEND"}
{"prompt":"Students of introductory computer science typically see themselves as programmers. They no sooner have a new programming project in their heads than they’re at the computer, typing madly to get some code up and running. (Is this you?) To succeed as a programmer, however, you have to combine the practical skills of a software engineer with the analytical mindset of a computer scientist. A software engineer oversees the life cycle of software development: initiation of the project, analysis of the specification, and design of the program, as well as implementation, testing, and maintenance of the final product. A computer scientist (among other things!) analyzes the implementation, correctness, and efficiency of algorithms. All these topics are tested on the APCS exam.\nThe Waterfall Model\nThe waterfall model of software development came about in the 1960s in order to bring structure and efficiency into the process of creating large programs.\nThe specification is a written description of the project. Typically it is based on a customer's requirements. The first step in writing a program is to analyze the specification, make sure you understand it, and clarify with the customer anything that is unclear.\nEven for a small-scale program a good design can save programming time and enhance the reliability of the final program. The design is a fairly detailed plan for solving the problem outlined in the specification. It should include all objects that will be used in the solution, the data structures that will implement them, plus a detailed list of the tasks to be performed by the program.\nA good design provides a fairly detailed overall plan at a glance, without including the minutiae of Java code.\nProgram implementation is the coding phase. Design and implementation are discussed in more detail on p. 210.\nTEST DATA\nNot every possible input value can be tested, so a programmer should be diligent in selecting a representative set of test data. Typical values in each part of a domain of the program should be selected, as well as endpoint values and out-of-range values. If only positive input is required, your test data should include a negative value just to check that your program handles it appropriately.\n\nExample\nA program must be written to insert a value into its correct position in this sorted list:\n2 5 9\nTest data should include\n• A value less than 2\n• A value between 2 and 5\n• A value between 5 and 9\n• A value greater than 9\n• 2, 5, and 9\n• A negative value\n\nTYPES OF ERRORS (BUGS)\n• A compile-time error occurs during compilation of the program. The compiler is unable to translate the program into bytecode and prints an appropriate error message. A syntax error is a compile-time error caused by violating the rules of the programming language. Some examples are omitting semicolons or braces, using undeclared identifiers, using keywords inappropriately, having parameters that don’t match in type and number, and invoking a method for an object whose class definition doesn’t contain that method.\n• A run-time error occurs during execution of the program. The Java run-time environment throws an exception, which means that it stops execution and prints an error message. Typical causes of run-time errors include attempting to divide an integer by zero, using an array index that is out of bounds, attempting to open a file that cannot be found, and so on. An error that causes a program to run forever (“infinite loop”) can also be regarded as a run-time error. (See also Errors and Exceptions, p. 74.)\n• An intent or logic error is one that fails to carry out the specification of the program. The program compiles and runs but does not do the job. These are sometimes the hardest types of errors to fix.\n\nROBUSTNESS\nAlways assume that any user of your program is not as smart as you are. You must therefore aim to write a robust program, namely one that\n• Won’t give inaccurate answers for some input data.\n• Won’t crash if the input data are invalid.\n• Won’t allow execution to proceed if invalid data are entered.\nExamples of bad input data include out-of-range numbers, characters instead of numerical data, and a response of “maybe” when “yes” or “no” was asked for.\nNote that bad input data that invalidates a computation won’t be detected by Java. Your program should include code that catches the error, allows the error to be fixed, and allows program execution to resume.\n\nProgram maintenance involves upgrading the code as circumstances change. New features may be added. New programmers may come on board. To make their task easier, the original program must have clear and precise documentation.\n\n\n###\n\n","completion":" Question: A program that reads in a five-digit identification number is to be written. The specification does not state whether zero can be entered as a first digit. The programmer should \nCorrect: check with the writer of the specification whether zero is acceptable as a first digit.\n\n\nIncorrect: write the code to accept zero as a first digit since zero is a valid digit.\nIncorrect: write the code to reject zero as a first digit since five-digit integers do not start with zero.\nIncorrect: eliminate zero as a possibility for any of the digits.\nIncorrect: treat the identification number as a four-digit number if the user enters a number starting with zero.END"}
{"prompt":"Object-oriented programming has been the dominant programming methodology since the mid 1990s. It uses an approach that blurs the lines of the waterfall model. Anal ysis of the problem, development of the design, and pieces of the implementation all overlap and influence one another.\nHere are the steps in object-oriented design:\n• Identify classes to be written.\n• Identify behaviors (i.e., methods) for each class.\n• Determine the relationships between classes.\n• Write the interface (public method headers) for each class.\n• Implement the methods.\n\nIdentify the objects in the program by picking out the nouns in the program speci fication. Ignore pronouns and nouns that refer to the user. Select those nouns that seem suitable as classes, the “big-picture” nouns that describe the major objects in the application. Some of the other nouns may end up as attributes of the classes.\nMany applications have similar object types: a low-level basic component; a collec\ntion of low-level components; a controlling object that puts everything together; and a display object that could be a GUI (graphical user interface) but doesn’t have to be.\n\nExample 1\nWrite a program that maintains an inventory of stock items for a small store.\nNouns to consider: inventory, item, store.\nBasic Object: StockItem\nCollection: Inventory (a list of StockItems)\nController: Store (has an Inventory, uses a StoreDisplay)\nDisplay: StoreDisplay (could be a GUI)\n\nExample 2\nWrite a program that simulates a game of bingo. There should be at least two play\ners, each of whom has a bingo card, and a caller who calls the numbers.\nNouns to consider: game, players, bingo card, caller.\nBasic Objects: BingoCard, Caller\nCollection: Players (each has a BingoCard)\nController: GameMaster (sets up the Players and Caller)\nDisplay: BingoDisplay (shows each player’s card and displays winners, etc.)\n\nExample 3\nWrite a program that creates random bridge deals and displays them in a specified format. (The specification defines a “deal” as consisting of four hands. It also describes a deck of cards, and shows how each card should be displayed.)\nNouns to consider: deal, hand, format, deck, card.\nBasic Object: Card\nCollection: Deck (has an array of Cards)\nHand (has an array of Cards)\nDeal (has an array of Hands)\nDealer (has a Deck, or several Decks)\nController: Formatter (has a Deal and a TableDisplay)\nDisplay: TableDisplay (could be a GUI)\n\nIdentifying Behaviors\nFind all verbs in the program description that help lead to the solution of the programming task. These are likely behaviors that will probably become the methods of the classes. Now decide which methods belong in which classes. Recall that the process of bundling a group of methods and data fields into a class is called encapsulation.\nThink carefully about who should do what. Do not ask a basic object to perform operations for the group. For example, a StockItem should keep track of its own details (price, description, how many on the shelf, etc.) but should not be required to search for another item. A Card should know its value and suit but should not be responsible for keeping track of how many cards are left in a deck. A Caller in a bingo game should be responsible for keeping track of the numbers called so far and for producing the next number but not for checking whether a player has bingo: That is the job of an individual player (element of Players) and his BingoCard.\nYou will also need to decide which data fields each class will need and which data structures should store them. For example, if an object represents a list of items, consider an array or ArrayList as the data structure.\n\nINHERITANCE RELATIONSHIPS\nLook for classes with common behaviors. This will help identify inheritance relationships. Recall the is-a relationship—if object1 is-a object2, then object2 is a candidate for a superclass.\nCOMPOSITION RELATIONSHIPS\nComposition relationships are defined by the has-a relationship. For example, a Nurse has-a Uniform. Typically, if two classes have a composition relationship, one of them contains an instance variable whose type is the other class.\nNote that a wrapper class always implements a has-a relationship with any objects that it wraps.\nAn excellent way to keep track of the relationships between classes and show the inheritance hierarchy in your programs is with a UML (Unified Modeling Language) diagram. This is a standard graphical scheme used by object-oriented programmers. Although it is not part of the AP subset, on the AP exam you may be expected to interpret simple UML diagrams and inheritance hierarchies.\nHere is a simplified version of the UML rules:\n• Represent classes with rectangles.\n• Use angle brackets with the word “abstract” or “interface” to indicate either an abstract class or interface.\n• Show the is-a relationship between classes with an open up-arrow.\n• Show the is-a relationship that involves an interface with an open, dotted up arrow.\n• Show the has-a relationship with a down arrow or sideways arrow (indicates composition).\n\n\n###\n\n","completion":" Question: Refer to the following three program descriptions: \nI Test whether there exists at least one three-digit integer whose value equals the sum of the squares of its digits. \nII Read in a three-digit code number and check if it is valid according to some given formula. \nIII Passwords consist of three digits and three capital letters in any order. Read in a password, and check if there are any repeated characters. \nFor which of the preceding program descriptions would a ThreeDigitNumber class be suitable? \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"For each method in a class, list all of the other classes needed to implement that particular method. These classes are called collaborators. A class that has no collaborators is independent.\nTo implement the classes, often an incremental, bottom-up approach is used. This means that independent classes are fully implemented and tested before being incorporated into the overall project. Typically, these are the basic objects of the program, like StockItem, Card, and BingoCard. Unrelated classes in a programming project can be implemented by different programmers.\nNote that a class can be tested using a dummy Tester class that will be discarded when the methods of the class are working. Constructors, then methods, should be added, and tested, one at a time. A driver class that contains a main method can be used to test the program as you go. The purpose of the driver is to test the class fully before incorporating it as an object in a new class.\nWhen each of the independent classes is working, classes that depend on just one other class are implemented and tested, and so on. This may lead to a working, bare bones version of the project. New features and enhancements can be added later.\nDesign flaws can be corrected at each stage of development. Remember, a design is never set in stone: It simply guides the implementation.\n\nIn a top-down design, the programmer starts with an overview of the program, selecting the highest-level controlling object and the tasks needed. During development of the program, subsidiary classes may be added to simplify existing classes.\nA good programmer avoids chunks of repeated code wherever possible. To this end, if several methods in a class require the same task, like a search or a swap, you should use helper methods. The reduce method in the Rational class on p. 118 is an example of such a method. Also, wherever possible you should enhance the readability of your code by using helper methods to break long methods into smaller tasks. The use of helper methods within a class is known as procedural abstraction and is an example of top-down development within a class. This process of breaking a long method into a sequence of smaller tasks is sometimes called stepwise refinement.\nInstance variables and helper methods are generally declared as private, which prevents client classes from accessing them. This strategy is called information hiding.\nSometimes it makes more sense in the development of a class to test a calling method before testing a method it invokes. A stub is a dummy method that stands in for a method until the actual method has been written and tested. A stub typically has an output statement to show that it was called in the correct place, or it may return some reasonable values if necessary.\nAn algorithm is a precise step-by-step procedure that solves a problem or achieves a goal. Don’t write any code for an algorithm in a method until the steps are completely clear to you.\n\nExample 1\nA program must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. The number is valid if the fourth digit equals the remainder when the sum of the first three digits is divided by seven.\nClasses in the program may include an IDNumber, the four-digit code; Display, which would handle input and output; and IDMain, the driver for the program. The data structure used to implement an IDNumber could be an instance variable of type int, or an instance variable of type String, or four instance variables of type int—one per digit, and so on.\nA top-down design for the program that tests the validity of the number is reflected in the steps of the main method of IDMain:\nCreate Display\nRead in IDNumber\nCheck validity\nPrint message\nEach method in this design is tested before the next method is added to main. If the display will be handled in a GUI (graphical user interface), stepwise refinement of the design might look like this:\nCreate Display\n    Construct a Display\n    Create window panels\n    Set up text fields\n    Add panels and fields to window\nRead in IDNumber\n    Prompt and read\nCheck validity of IDNumber\n    Check input\n        Check characters\n        Check range\n    Separate into digits\n    Check validity property\nPrint message\n    Write number\n    State if valid\n\nNOTE\n1. The IDNumber class, which contains the four-digit code, is responsible for the following operations:\n    Split value into separate digits\n    Check condition for validity\nThe Display class, which contains objects to read and display, must also contain an IDNumber object. It is responsible for the following operations:\n    Set up display\n    Read in code number\n    Display validity message\nCreating these two classes with their data fields (instance variables) and operations (methods) is an example of encapsulation.\n\n2. The Display method readCodeNumber needs private helper methods to check the input: checkCharacters and checkRange. This is an example of procedural abstraction (use of helper methods) and information hiding (making them private).\n3. Initially the programmer had just an IDNumber class and a driver class. The Display class was added as a refinement, when it was realized that handling the input and message display was separate from checking the validity of the IDNumber. This is an example of top-down development (adding an auxiliary class to clarify the code).\n4. The IDNumber class contains no data fields that are objects. It is therefore an in dependent class. The Display class, which contains an IDNumber data member, has a composition relationship with IDNumber (Display has-a IDNumber).\n5. When testing the final program, the programmer should be sure to include each of the following as a user-entered code number: a valid four-digit number, an invalid four-digit number, an n-digit number, where n 6= 4, and a “number” that contains a nondigit character. A robust program should be able to deal with all these cases.\n\nExample 2\nA program must create a teacher’s grade book. The program should maintain a class list of students for any number of classes in the teacher’s schedule. A menu should be provided that allows the teacher to\n• Create a new class of students.\n• Enter a set of scores for any class.\n• Correct any data that’s been entered.\n• Display the record of any student.\n• Calculate the final average and grade for all students in a class.\n• Print a class list, with or without grades.\n• Add a student, delete a student, or transfer a student to another class.\n• Save all the data in a file.\n\n\n###\n\n","completion":" Question: Top-down programming is illustrated by which of the following? \nCorrect: Writing the program in terms of the operations to be performed and then refining these operations by adding more detail\n\n\nIncorrect: Writing a program from top to bottom in Java\nIncorrect: Writing an essay describing how the program will work, without including any Java code\nIncorrect: Using driver programs to test all methods in the order that they’re called in the program\nIncorrect: Writing and testing the lowest level methods first and then combining them to form appropriate abstract operationsEND"}
{"prompt":"For each method in a class, list all of the other classes needed to implement that particular method. These classes are called collaborators. A class that has no collaborators is independent.\nTo implement the classes, often an incremental, bottom-up approach is used. This means that independent classes are fully implemented and tested before being incorporated into the overall project. Typically, these are the basic objects of the program, like StockItem, Card, and BingoCard. Unrelated classes in a programming project can be implemented by different programmers.\nNote that a class can be tested using a dummy Tester class that will be discarded when the methods of the class are working. Constructors, then methods, should be added, and tested, one at a time. A driver class that contains a main method can be used to test the program as you go. The purpose of the driver is to test the class fully before incorporating it as an object in a new class.\nWhen each of the independent classes is working, classes that depend on just one other class are implemented and tested, and so on. This may lead to a working, bare bones version of the project. New features and enhancements can be added later.\nDesign flaws can be corrected at each stage of development. Remember, a design is never set in stone: It simply guides the implementation.\n\nIn a top-down design, the programmer starts with an overview of the program, selecting the highest-level controlling object and the tasks needed. During development of the program, subsidiary classes may be added to simplify existing classes.\nA good programmer avoids chunks of repeated code wherever possible. To this end, if several methods in a class require the same task, like a search or a swap, you should use helper methods. The reduce method in the Rational class on p. 118 is an example of such a method. Also, wherever possible you should enhance the readability of your code by using helper methods to break long methods into smaller tasks. The use of helper methods within a class is known as procedural abstraction and is an example of top-down development within a class. This process of breaking a long method into a sequence of smaller tasks is sometimes called stepwise refinement.\nInstance variables and helper methods are generally declared as private, which prevents client classes from accessing them. This strategy is called information hiding.\nSometimes it makes more sense in the development of a class to test a calling method before testing a method it invokes. A stub is a dummy method that stands in for a method until the actual method has been written and tested. A stub typically has an output statement to show that it was called in the correct place, or it may return some reasonable values if necessary.\nAn algorithm is a precise step-by-step procedure that solves a problem or achieves a goal. Don’t write any code for an algorithm in a method until the steps are completely clear to you.\n\nExample 1\nA program must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. The number is valid if the fourth digit equals the remainder when the sum of the first three digits is divided by seven.\nClasses in the program may include an IDNumber, the four-digit code; Display, which would handle input and output; and IDMain, the driver for the program. The data structure used to implement an IDNumber could be an instance variable of type int, or an instance variable of type String, or four instance variables of type int—one per digit, and so on.\nA top-down design for the program that tests the validity of the number is reflected in the steps of the main method of IDMain:\nCreate Display\nRead in IDNumber\nCheck validity\nPrint message\nEach method in this design is tested before the next method is added to main. If the display will be handled in a GUI (graphical user interface), stepwise refinement of the design might look like this:\nCreate Display\n    Construct a Display\n    Create window panels\n    Set up text fields\n    Add panels and fields to window\nRead in IDNumber\n    Prompt and read\nCheck validity of IDNumber\n    Check input\n        Check characters\n        Check range\n    Separate into digits\n    Check validity property\nPrint message\n    Write number\n    State if valid\n\nNOTE\n1. The IDNumber class, which contains the four-digit code, is responsible for the following operations:\n    Split value into separate digits\n    Check condition for validity\nThe Display class, which contains objects to read and display, must also contain an IDNumber object. It is responsible for the following operations:\n    Set up display\n    Read in code number\n    Display validity message\nCreating these two classes with their data fields (instance variables) and operations (methods) is an example of encapsulation.\n\n2. The Display method readCodeNumber needs private helper methods to check the input: checkCharacters and checkRange. This is an example of procedural abstraction (use of helper methods) and information hiding (making them private).\n3. Initially the programmer had just an IDNumber class and a driver class. The Display class was added as a refinement, when it was realized that handling the input and message display was separate from checking the validity of the IDNumber. This is an example of top-down development (adding an auxiliary class to clarify the code).\n4. The IDNumber class contains no data fields that are objects. It is therefore an in dependent class. The Display class, which contains an IDNumber data member, has a composition relationship with IDNumber (Display has-a IDNumber).\n5. When testing the final program, the programmer should be sure to include each of the following as a user-entered code number: a valid four-digit number, an invalid four-digit number, an n-digit number, where n 6= 4, and a “number” that contains a nondigit character. A robust program should be able to deal with all these cases.\n\nExample 2\nA program must create a teacher’s grade book. The program should maintain a class list of students for any number of classes in the teacher’s schedule. A menu should be provided that allows the teacher to\n• Create a new class of students.\n• Enter a set of scores for any class.\n• Correct any data that’s been entered.\n• Display the record of any student.\n• Calculate the final average and grade for all students in a class.\n• Print a class list, with or without grades.\n• Add a student, delete a student, or transfer a student to another class.\n• Save all the data in a file.\n\n\n###\n\n","completion":" Question: Which of the following should influence your choice of a particular algorithm? \nI The run time of the algorithm \nII The memory requirements of the algorithm \nIII The ease with which the logic of the algorithm can be understood \nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and III only\nIncorrect: I and II onlyEND"}
{"prompt":"Use the verbs to identify key methods in the program: simulate<game>, place <ships>, shoot<at position>, call out<position>, respond<hit or miss>, sink <ship>, inform that<ship was sunk>, keep track of<hits or misses>, sink <opponent’s fleet>, win<game>.\nYou need to decide who will do what. There’s no definitive way of implementingthe program, but it seems clear that the GameManager should run the game and declare the winner. Should the GameManager also be in charge of announcing if a ship is sunk? It makes sense because the game manager can see both players’ grids. Each player should keep track of his calls, so that he can make an intelligent next call and also respond “hit” or “miss.” Will each player have a display? Or will the Display have both players? You have to set it up so that a player can’t see his opponent’s FleetGrid, but he can see his own and also a grid showing the state of the calls he has made. Should each player have a list of his ships, so he can keep track of the state of his fleet? And what about each ship in the fleet? Should a ship have a list of its positions, and should it keep track of if it’s hit or sunk?\nSaving and retrieving updated information is crucial to this program. It seems a bit overwhelming. Where should you start? The Ship classes are low-level classes, independent of the players and grids. Start with these and test that you can get accurate information about each ship. In your driver program create an ArrayList<Ship>. Have a loop that prints information about each ship. Polymorphism will take care of getting the correct information about each ship.\nNow try the Grid classes. This is a complicated program where each small piece should be coded and tested with simple output. For example, a Grid can be displayed with a two-dimensional array of 0’s and 1’s to show the positions of ships. Other symbols can be used to show what’s been hit and what’s been sunk.\nWhen everything is working with the grids, you could add a Display class that has Grid variables and a display method.\nTry a Player. Give him a list of ships, two grids and a Display.\nThen create a GameManager. Give her two Player variables and be sure she has a playGame method.\nThe program development shown above is an example of bottom-up development.\nProgram Correctness\nTesting that a program works does not prove that the program is correct. After all, you can hardly expect to test programs for every conceivable set of input data. Computer scientists have developed mathematical techniques to prove correctness in certain cases, but these are beyond the scope of the APCS course. Nevertheless, you are expected to be able to make assertions about the state of a program at various points during its execution.\n\nAssertions\nAn assertion is a precise statement about a program at any given point. The idea is that if an assertion is proved to be true, then the program is working correctly at that point.\nAn informal step on the way to writing correct algorithms is to be able to make different kinds of assertions about your code.\n\nPRECONDITION\nThe precondition for any piece of code, whether it is a method, loop, or block, is a statement of what is true immediately before execution of that code.\nPOSTCONDITION\nThe postcondition for a piece of code is a statement of what is true immediately after execution of that code.\n\nEfficiency\nAn efficient algorithm is one that is economical in the use of\n• CPU time. This refers to the number of machine operations required to carry out the algorithm (arithmetic operations, comparisons, data movements, etc.).\n• Memory. This refers to the number and complexity of the variables used.\n\nSome factors that affect run-time efficiency include unnecessary tests, excessive movement of data elements, and redundant computations, especially in loops.\nAlways aim for early detection of output conditions: Your sorting algorithm should halt when the list is sorted; your search should stop if the key element has been found. In discussing efficiency of an algorithm, we refer to the best case, worst case, and average case. The best case is a configuration of the data that causes the algorithm to run in the least possible amount of time. The worst case is a configuration that leads to the greatest possible run time. Typical configurations (i.e., not specially chosen data) give the average case. It is possible that best, worst, and average cases don’t differ much in their run times.\nFor example, suppose that a list of distinct random numbers must be searched for a given key value. The algorithm used is a sequential search starting at the beginning of the list. In the best case, the key will be found in the first position examined. In the worst case, it will be in the last position or not in the list at all. On average, the key will be somewhere in the middle of the list.\n\n\n###\n\n","completion":" Question: A list of numbers is stored in a sorted array. It is required that the list be maintained in sorted order. This requirement leads to inefficient execution for which of the following processes? \nI Summing the five smallest numbers in the list \nII Finding the maximum value in the list \nIII Inserting and deleting numbers \nCorrect: III only\nIncorrect: I only\nIncorrect: II and III only\nIncorrect: I and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"Students of introductory computer science typically see themselves as programmers. They no sooner have a new programming project in their heads than they’re at the computer, typing madly to get some code up and running. (Is this you?) To succeed as a programmer, however, you have to combine the practical skills of a software engineer with the analytical mindset of a computer scientist. A software engineer oversees the life cycle of software development: initiation of the project, analysis of the specification, and design of the program, as well as implementation, testing, and maintenance of the final product. A computer scientist (among other things!) analyzes the implementation, correctness, and efficiency of algorithms. All these topics are tested on the APCS exam.\nThe Waterfall Model\nThe waterfall model of software development came about in the 1960s in order to bring structure and efficiency into the process of creating large programs.\nThe specification is a written description of the project. Typically it is based on a customer's requirements. The first step in writing a program is to analyze the specification, make sure you understand it, and clarify with the customer anything that is unclear.\nEven for a small-scale program a good design can save programming time and enhance the reliability of the final program. The design is a fairly detailed plan for solving the problem outlined in the specification. It should include all objects that will be used in the solution, the data structures that will implement them, plus a detailed list of the tasks to be performed by the program.\nA good design provides a fairly detailed overall plan at a glance, without including the minutiae of Java code.\nProgram implementation is the coding phase. Design and implementation are discussed in more detail on p. 210.\nTEST DATA\nNot every possible input value can be tested, so a programmer should be diligent in selecting a representative set of test data. Typical values in each part of a domain of the program should be selected, as well as endpoint values and out-of-range values. If only positive input is required, your test data should include a negative value just to check that your program handles it appropriately.\n\nExample\nA program must be written to insert a value into its correct position in this sorted list:\n2 5 9\nTest data should include\n• A value less than 2\n• A value between 2 and 5\n• A value between 5 and 9\n• A value greater than 9\n• 2, 5, and 9\n• A negative value\n\nTYPES OF ERRORS (BUGS)\n• A compile-time error occurs during compilation of the program. The compiler is unable to translate the program into bytecode and prints an appropriate error message. A syntax error is a compile-time error caused by violating the rules of the programming language. Some examples are omitting semicolons or braces, using undeclared identifiers, using keywords inappropriately, having parameters that don’t match in type and number, and invoking a method for an object whose class definition doesn’t contain that method.\n• A run-time error occurs during execution of the program. The Java run-time environment throws an exception, which means that it stops execution and prints an error message. Typical causes of run-time errors include attempting to divide an integer by zero, using an array index that is out of bounds, attempting to open a file that cannot be found, and so on. An error that causes a program to run forever (“infinite loop”) can also be regarded as a run-time error. (See also Errors and Exceptions, p. 74.)\n• An intent or logic error is one that fails to carry out the specification of the program. The program compiles and runs but does not do the job. These are sometimes the hardest types of errors to fix.\n\nROBUSTNESS\nAlways assume that any user of your program is not as smart as you are. You must therefore aim to write a robust program, namely one that\n• Won’t give inaccurate answers for some input data.\n• Won’t crash if the input data are invalid.\n• Won’t allow execution to proceed if invalid data are entered.\nExamples of bad input data include out-of-range numbers, characters instead of numerical data, and a response of “maybe” when “yes” or “no” was asked for.\nNote that bad input data that invalidates a computation won’t be detected by Java. Your program should include code that catches the error, allows the error to be fixed, and allows program execution to resume.\n\nProgram maintenance involves upgrading the code as circumstances change. New features may be added. New programmers may come on board. To make their task easier, the original program must have clear and precise documentation.\n\n\n###\n\n","completion":" Question: Which of the following is not necessarily a feature of a robust program? \nCorrect: Will run on any computer without modification\nIncorrect: Does not allow execution to proceed with invalid data\nIncorrect: Uses algorithms that give correct answers for extreme data values\nIncorrect: Will not allow division by zero\nIncorrect: Will anticipate the types of errors that users of the program may make\n\nEND"}
{"prompt":"Students of introductory computer science typically see themselves as programmers. They no sooner have a new programming project in their heads than they’re at the computer, typing madly to get some code up and running. (Is this you?) To succeed as a programmer, however, you have to combine the practical skills of a software engineer with the analytical mindset of a computer scientist. A software engineer oversees the life cycle of software development: initiation of the project, analysis of the specification, and design of the program, as well as implementation, testing, and maintenance of the final product. A computer scientist (among other things!) analyzes the implementation, correctness, and efficiency of algorithms. All these topics are tested on the APCS exam.\nThe Waterfall Model\nThe waterfall model of software development came about in the 1960s in order to bring structure and efficiency into the process of creating large programs.\nThe specification is a written description of the project. Typically it is based on a customer's requirements. The first step in writing a program is to analyze the specification, make sure you understand it, and clarify with the customer anything that is unclear.\nEven for a small-scale program a good design can save programming time and enhance the reliability of the final program. The design is a fairly detailed plan for solving the problem outlined in the specification. It should include all objects that will be used in the solution, the data structures that will implement them, plus a detailed list of the tasks to be performed by the program.\nA good design provides a fairly detailed overall plan at a glance, without including the minutiae of Java code.\nProgram implementation is the coding phase. Design and implementation are discussed in more detail on p. 210.\nTEST DATA\nNot every possible input value can be tested, so a programmer should be diligent in selecting a representative set of test data. Typical values in each part of a domain of the program should be selected, as well as endpoint values and out-of-range values. If only positive input is required, your test data should include a negative value just to check that your program handles it appropriately.\n\nExample\nA program must be written to insert a value into its correct position in this sorted list:\n2 5 9\nTest data should include\n• A value less than 2\n• A value between 2 and 5\n• A value between 5 and 9\n• A value greater than 9\n• 2, 5, and 9\n• A negative value\n\nTYPES OF ERRORS (BUGS)\n• A compile-time error occurs during compilation of the program. The compiler is unable to translate the program into bytecode and prints an appropriate error message. A syntax error is a compile-time error caused by violating the rules of the programming language. Some examples are omitting semicolons or braces, using undeclared identifiers, using keywords inappropriately, having parameters that don’t match in type and number, and invoking a method for an object whose class definition doesn’t contain that method.\n• A run-time error occurs during execution of the program. The Java run-time environment throws an exception, which means that it stops execution and prints an error message. Typical causes of run-time errors include attempting to divide an integer by zero, using an array index that is out of bounds, attempting to open a file that cannot be found, and so on. An error that causes a program to run forever (“infinite loop”) can also be regarded as a run-time error. (See also Errors and Exceptions, p. 74.)\n• An intent or logic error is one that fails to carry out the specification of the program. The program compiles and runs but does not do the job. These are sometimes the hardest types of errors to fix.\n\nROBUSTNESS\nAlways assume that any user of your program is not as smart as you are. You must therefore aim to write a robust program, namely one that\n• Won’t give inaccurate answers for some input data.\n• Won’t crash if the input data are invalid.\n• Won’t allow execution to proceed if invalid data are entered.\nExamples of bad input data include out-of-range numbers, characters instead of numerical data, and a response of “maybe” when “yes” or “no” was asked for.\nNote that bad input data that invalidates a computation won’t be detected by Java. Your program should include code that catches the error, allows the error to be fixed, and allows program execution to resume.\n\nProgram maintenance involves upgrading the code as circumstances change. New features may be added. New programmers may come on board. To make their task easier, the original program must have clear and precise documentation.\n\n\n###\n\n","completion":" Question: A certain freight company charges its customers for shipping overseas according to this scale: \n$80 per ton for a weight of 10 tons or less \n$40 per ton for each additional ton over 10 tons but not exceeding 25 tons \n$30 per ton for each additional ton over 25 tons \n\nFor example, to ship a weight of 12 tons will cost 10(80) + 2(40) = $880. To ship 26 tons will cost 10(80) + 15(40) + 1(30) = $1430. \nA method takes as parameter an integer that represents a valid shipping weight and outputs the charge for the shipment. Which of the following is the smallest set of input values for shipping weights that will adequately test this method? \nCorrect: 5, 10, 15, 25, 30\nIncorrect: 10, 25\nIncorrect: 5, 15, 30\nIncorrect: 0, 5, 10, 15, 25, 30\nIncorrect: 5, 10, 15, 20, 25, 30\n\nEND"}
{"prompt":"Students of introductory computer science typically see themselves as programmers. They no sooner have a new programming project in their heads than they’re at the computer, typing madly to get some code up and running. (Is this you?) To succeed as a programmer, however, you have to combine the practical skills of a software engineer with the analytical mindset of a computer scientist. A software engineer oversees the life cycle of software development: initiation of the project, analysis of the specification, and design of the program, as well as implementation, testing, and maintenance of the final product. A computer scientist (among other things!) analyzes the implementation, correctness, and efficiency of algorithms. All these topics are tested on the APCS exam.\nThe Waterfall Model\nThe waterfall model of software development came about in the 1960s in order to bring structure and efficiency into the process of creating large programs.\nThe specification is a written description of the project. Typically it is based on a customer's requirements. The first step in writing a program is to analyze the specification, make sure you understand it, and clarify with the customer anything that is unclear.\nEven for a small-scale program a good design can save programming time and enhance the reliability of the final program. The design is a fairly detailed plan for solving the problem outlined in the specification. It should include all objects that will be used in the solution, the data structures that will implement them, plus a detailed list of the tasks to be performed by the program.\nA good design provides a fairly detailed overall plan at a glance, without including the minutiae of Java code.\nProgram implementation is the coding phase. Design and implementation are discussed in more detail on p. 210.\nTEST DATA\nNot every possible input value can be tested, so a programmer should be diligent in selecting a representative set of test data. Typical values in each part of a domain of the program should be selected, as well as endpoint values and out-of-range values. If only positive input is required, your test data should include a negative value just to check that your program handles it appropriately.\n\nExample\nA program must be written to insert a value into its correct position in this sorted list:\n2 5 9\nTest data should include\n• A value less than 2\n• A value between 2 and 5\n• A value between 5 and 9\n• A value greater than 9\n• 2, 5, and 9\n• A negative value\n\nTYPES OF ERRORS (BUGS)\n• A compile-time error occurs during compilation of the program. The compiler is unable to translate the program into bytecode and prints an appropriate error message. A syntax error is a compile-time error caused by violating the rules of the programming language. Some examples are omitting semicolons or braces, using undeclared identifiers, using keywords inappropriately, having parameters that don’t match in type and number, and invoking a method for an object whose class definition doesn’t contain that method.\n• A run-time error occurs during execution of the program. The Java run-time environment throws an exception, which means that it stops execution and prints an error message. Typical causes of run-time errors include attempting to divide an integer by zero, using an array index that is out of bounds, attempting to open a file that cannot be found, and so on. An error that causes a program to run forever (“infinite loop”) can also be regarded as a run-time error. (See also Errors and Exceptions, p. 74.)\n• An intent or logic error is one that fails to carry out the specification of the program. The program compiles and runs but does not do the job. These are sometimes the hardest types of errors to fix.\n\nROBUSTNESS\nAlways assume that any user of your program is not as smart as you are. You must therefore aim to write a robust program, namely one that\n• Won’t give inaccurate answers for some input data.\n• Won’t crash if the input data are invalid.\n• Won’t allow execution to proceed if invalid data are entered.\nExamples of bad input data include out-of-range numbers, characters instead of numerical data, and a response of “maybe” when “yes” or “no” was asked for.\nNote that bad input data that invalidates a computation won’t be detected by Java. Your program should include code that catches the error, allows the error to be fixed, and allows program execution to resume.\n\nProgram maintenance involves upgrading the code as circumstances change. New features may be added. New programmers may come on board. To make their task easier, the original program must have clear and precise documentation.\n\n\n###\n\n","completion":" Question: A code segment calculates the mean of values stored in integers n1, n2, n3, and n4 and stores the result in average, which is of type double. What kind of error is caused with this statement? \ndouble average = n1 + n2 + n3 + n4 \/ (double) 4; \nCorrect: Logic\nIncorrect: Run-time\nIncorrect: Overflow\nIncorrect: Syntax\nIncorrect: Type mismatch\n\nEND"}
{"prompt":"Students of introductory computer science typically see themselves as programmers. They no sooner have a new programming project in their heads than they’re at the computer, typing madly to get some code up and running. (Is this you?) To succeed as a programmer, however, you have to combine the practical skills of a software engineer with the analytical mindset of a computer scientist. A software engineer oversees the life cycle of software development: initiation of the project, analysis of the specification, and design of the program, as well as implementation, testing, and maintenance of the final product. A computer scientist (among other things!) analyzes the implementation, correctness, and efficiency of algorithms. All these topics are tested on the APCS exam.\nThe Waterfall Model\nThe waterfall model of software development came about in the 1960s in order to bring structure and efficiency into the process of creating large programs.\nThe specification is a written description of the project. Typically it is based on a customer's requirements. The first step in writing a program is to analyze the specification, make sure you understand it, and clarify with the customer anything that is unclear.\nEven for a small-scale program a good design can save programming time and enhance the reliability of the final program. The design is a fairly detailed plan for solving the problem outlined in the specification. It should include all objects that will be used in the solution, the data structures that will implement them, plus a detailed list of the tasks to be performed by the program.\nA good design provides a fairly detailed overall plan at a glance, without including the minutiae of Java code.\nProgram implementation is the coding phase. Design and implementation are discussed in more detail on p. 210.\nTEST DATA\nNot every possible input value can be tested, so a programmer should be diligent in selecting a representative set of test data. Typical values in each part of a domain of the program should be selected, as well as endpoint values and out-of-range values. If only positive input is required, your test data should include a negative value just to check that your program handles it appropriately.\n\nExample\nA program must be written to insert a value into its correct position in this sorted list:\n2 5 9\nTest data should include\n• A value less than 2\n• A value between 2 and 5\n• A value between 5 and 9\n• A value greater than 9\n• 2, 5, and 9\n• A negative value\n\nTYPES OF ERRORS (BUGS)\n• A compile-time error occurs during compilation of the program. The compiler is unable to translate the program into bytecode and prints an appropriate error message. A syntax error is a compile-time error caused by violating the rules of the programming language. Some examples are omitting semicolons or braces, using undeclared identifiers, using keywords inappropriately, having parameters that don’t match in type and number, and invoking a method for an object whose class definition doesn’t contain that method.\n• A run-time error occurs during execution of the program. The Java run-time environment throws an exception, which means that it stops execution and prints an error message. Typical causes of run-time errors include attempting to divide an integer by zero, using an array index that is out of bounds, attempting to open a file that cannot be found, and so on. An error that causes a program to run forever (“infinite loop”) can also be regarded as a run-time error. (See also Errors and Exceptions, p. 74.)\n• An intent or logic error is one that fails to carry out the specification of the program. The program compiles and runs but does not do the job. These are sometimes the hardest types of errors to fix.\n\nROBUSTNESS\nAlways assume that any user of your program is not as smart as you are. You must therefore aim to write a robust program, namely one that\n• Won’t give inaccurate answers for some input data.\n• Won’t crash if the input data are invalid.\n• Won’t allow execution to proceed if invalid data are entered.\nExamples of bad input data include out-of-range numbers, characters instead of numerical data, and a response of “maybe” when “yes” or “no” was asked for.\nNote that bad input data that invalidates a computation won’t be detected by Java. Your program should include code that catches the error, allows the error to be fixed, and allows program execution to resume.\n\nProgram maintenance involves upgrading the code as circumstances change. New features may be added. New programmers may come on board. To make their task easier, the original program must have clear and precise documentation.\n\n\n###\n\n","completion":" Question: A program evaluates binary arithmetic expressions that are read from an input file. All of the operands are integers, and the only operators are +, -, *, and \/. In writing the program, the programmer forgot to include a test that checks whether the right-hand operand in a division expression equals zero. When will this oversight be detected by the computer? \nCorrect: During evaluation of the expressions\nIncorrect: At compile time\nIncorrect: While editing the program\nIncorrect: As soon as the data from the input file is read\nIncorrect: When at least one incorrect value for the expressions is output\n\nEND"}
{"prompt":"Use the verbs to identify key methods in the program: simulate<game>, place <ships>, shoot<at position>, call out<position>, respond<hit or miss>, sink <ship>, inform that<ship was sunk>, keep track of<hits or misses>, sink <opponent’s fleet>, win<game>.\nYou need to decide who will do what. There’s no definitive way of implementingthe program, but it seems clear that the GameManager should run the game and declare the winner. Should the GameManager also be in charge of announcing if a ship is sunk? It makes sense because the game manager can see both players’ grids. Each player should keep track of his calls, so that he can make an intelligent next call and also respond “hit” or “miss.” Will each player have a display? Or will the Display have both players? You have to set it up so that a player can’t see his opponent’s FleetGrid, but he can see his own and also a grid showing the state of the calls he has made. Should each player have a list of his ships, so he can keep track of the state of his fleet? And what about each ship in the fleet? Should a ship have a list of its positions, and should it keep track of if it’s hit or sunk?\nSaving and retrieving updated information is crucial to this program. It seems a bit overwhelming. Where should you start? The Ship classes are low-level classes, independent of the players and grids. Start with these and test that you can get accurate information about each ship. In your driver program create an ArrayList<Ship>. Have a loop that prints information about each ship. Polymorphism will take care of getting the correct information about each ship.\nNow try the Grid classes. This is a complicated program where each small piece should be coded and tested with simple output. For example, a Grid can be displayed with a two-dimensional array of 0’s and 1’s to show the positions of ships. Other symbols can be used to show what’s been hit and what’s been sunk.\nWhen everything is working with the grids, you could add a Display class that has Grid variables and a display method.\nTry a Player. Give him a list of ships, two grids and a Display.\nThen create a GameManager. Give her two Player variables and be sure she has a playGame method.\nThe program development shown above is an example of bottom-up development.\nProgram Correctness\nTesting that a program works does not prove that the program is correct. After all, you can hardly expect to test programs for every conceivable set of input data. Computer scientists have developed mathematical techniques to prove correctness in certain cases, but these are beyond the scope of the APCS course. Nevertheless, you are expected to be able to make assertions about the state of a program at various points during its execution.\n\nAssertions\nAn assertion is a precise statement about a program at any given point. The idea is that if an assertion is proved to be true, then the program is working correctly at that point.\nAn informal step on the way to writing correct algorithms is to be able to make different kinds of assertions about your code.\n\nPRECONDITION\nThe precondition for any piece of code, whether it is a method, loop, or block, is a statement of what is true immediately before execution of that code.\nPOSTCONDITION\nThe postcondition for a piece of code is a statement of what is true immediately after execution of that code.\n\nEfficiency\nAn efficient algorithm is one that is economical in the use of\n• CPU time. This refers to the number of machine operations required to carry out the algorithm (arithmetic operations, comparisons, data movements, etc.).\n• Memory. This refers to the number and complexity of the variables used.\n\nSome factors that affect run-time efficiency include unnecessary tests, excessive movement of data elements, and redundant computations, especially in loops.\nAlways aim for early detection of output conditions: Your sorting algorithm should halt when the list is sorted; your search should stop if the key element has been found. In discussing efficiency of an algorithm, we refer to the best case, worst case, and average case. The best case is a configuration of the data that causes the algorithm to run in the least possible amount of time. The worst case is a configuration that leads to the greatest possible run time. Typical configurations (i.e., not specially chosen data) give the average case. It is possible that best, worst, and average cases don’t differ much in their run times.\nFor example, suppose that a list of distinct random numbers must be searched for a given key value. The algorithm used is a sequential search starting at the beginning of the list. In the best case, the key will be found in the first position examined. In the worst case, it will be in the last position or not in the list at all. On average, the key will be somewhere in the middle of the list.\n\n\n###\n\n","completion":" Question: Which best describes the precondition of a method? It is an assertion that \nCorrect: describes precisely the conditions that must be true at the time the method is called.\nIncorrect: initializes the parameters of the method.\nIncorrect: describes the effect of the method on its postcondition.\nIncorrect: explains what the method does.\nIncorrect: states what the initial values of the local variables in the method must be.\n\nEND"}
{"prompt":"Use the verbs to identify key methods in the program: simulate<game>, place <ships>, shoot<at position>, call out<position>, respond<hit or miss>, sink <ship>, inform that<ship was sunk>, keep track of<hits or misses>, sink <opponent’s fleet>, win<game>.\nYou need to decide who will do what. There’s no definitive way of implementingthe program, but it seems clear that the GameManager should run the game and declare the winner. Should the GameManager also be in charge of announcing if a ship is sunk? It makes sense because the game manager can see both players’ grids. Each player should keep track of his calls, so that he can make an intelligent next call and also respond “hit” or “miss.” Will each player have a display? Or will the Display have both players? You have to set it up so that a player can’t see his opponent’s FleetGrid, but he can see his own and also a grid showing the state of the calls he has made. Should each player have a list of his ships, so he can keep track of the state of his fleet? And what about each ship in the fleet? Should a ship have a list of its positions, and should it keep track of if it’s hit or sunk?\nSaving and retrieving updated information is crucial to this program. It seems a bit overwhelming. Where should you start? The Ship classes are low-level classes, independent of the players and grids. Start with these and test that you can get accurate information about each ship. In your driver program create an ArrayList<Ship>. Have a loop that prints information about each ship. Polymorphism will take care of getting the correct information about each ship.\nNow try the Grid classes. This is a complicated program where each small piece should be coded and tested with simple output. For example, a Grid can be displayed with a two-dimensional array of 0’s and 1’s to show the positions of ships. Other symbols can be used to show what’s been hit and what’s been sunk.\nWhen everything is working with the grids, you could add a Display class that has Grid variables and a display method.\nTry a Player. Give him a list of ships, two grids and a Display.\nThen create a GameManager. Give her two Player variables and be sure she has a playGame method.\nThe program development shown above is an example of bottom-up development.\nProgram Correctness\nTesting that a program works does not prove that the program is correct. After all, you can hardly expect to test programs for every conceivable set of input data. Computer scientists have developed mathematical techniques to prove correctness in certain cases, but these are beyond the scope of the APCS course. Nevertheless, you are expected to be able to make assertions about the state of a program at various points during its execution.\n\nAssertions\nAn assertion is a precise statement about a program at any given point. The idea is that if an assertion is proved to be true, then the program is working correctly at that point.\nAn informal step on the way to writing correct algorithms is to be able to make different kinds of assertions about your code.\n\nPRECONDITION\nThe precondition for any piece of code, whether it is a method, loop, or block, is a statement of what is true immediately before execution of that code.\nPOSTCONDITION\nThe postcondition for a piece of code is a statement of what is true immediately after execution of that code.\n\nEfficiency\nAn efficient algorithm is one that is economical in the use of\n• CPU time. This refers to the number of machine operations required to carry out the algorithm (arithmetic operations, comparisons, data movements, etc.).\n• Memory. This refers to the number and complexity of the variables used.\n\nSome factors that affect run-time efficiency include unnecessary tests, excessive movement of data elements, and redundant computations, especially in loops.\nAlways aim for early detection of output conditions: Your sorting algorithm should halt when the list is sorted; your search should stop if the key element has been found. In discussing efficiency of an algorithm, we refer to the best case, worst case, and average case. The best case is a configuration of the data that causes the algorithm to run in the least possible amount of time. The worst case is a configuration that leads to the greatest possible run time. Typical configurations (i.e., not specially chosen data) give the average case. It is possible that best, worst, and average cases don’t differ much in their run times.\nFor example, suppose that a list of distinct random numbers must be searched for a given key value. The algorithm used is a sequential search starting at the beginning of the list. In the best case, the key will be found in the first position examined. In the worst case, it will be in the last position or not in the list at all. On average, the key will be somewhere in the middle of the list.\n\n\n###\n\n","completion":" Question: Consider the following code fragment:\n\n\/** Precondition: a1, a2, a3 contain 3 distinct integers. \n* Postcondition: max contains the largest of a1, a2, a3. \n*\/ \n\/\/first set max equal to larger of a1 and a2 \nif (a1 > a2) \n    max = a1; \nelse \n    max = a2; \n\/\/set max equal to larger of max and a3 \nif (max < a3) \n    max = a3; \n\nFor this algorithm, which of the following initial setups for a1, a2, and a3 will cause \n(1) the least number of computer operations (best case) and \n(2) the greatest number of computer operations (worst case)? \nCorrect: (1) largest value in a1 or a2 (2) largest value in a3\nIncorrect: (1) largest value in a2 or a3 (2) largest value in a1\nIncorrect: (1) smallest value in a1 (2) largest value in a2\nIncorrect: (1) largest value in a2 (2) smallest value in a3\nIncorrect: (1) smallest value in a1 or a2 (2) largest value in a3\n\nEND"}
{"prompt":"Use the verbs to identify key methods in the program: simulate<game>, place <ships>, shoot<at position>, call out<position>, respond<hit or miss>, sink <ship>, inform that<ship was sunk>, keep track of<hits or misses>, sink <opponent’s fleet>, win<game>.\nYou need to decide who will do what. There’s no definitive way of implementingthe program, but it seems clear that the GameManager should run the game and declare the winner. Should the GameManager also be in charge of announcing if a ship is sunk? It makes sense because the game manager can see both players’ grids. Each player should keep track of his calls, so that he can make an intelligent next call and also respond “hit” or “miss.” Will each player have a display? Or will the Display have both players? You have to set it up so that a player can’t see his opponent’s FleetGrid, but he can see his own and also a grid showing the state of the calls he has made. Should each player have a list of his ships, so he can keep track of the state of his fleet? And what about each ship in the fleet? Should a ship have a list of its positions, and should it keep track of if it’s hit or sunk?\nSaving and retrieving updated information is crucial to this program. It seems a bit overwhelming. Where should you start? The Ship classes are low-level classes, independent of the players and grids. Start with these and test that you can get accurate information about each ship. In your driver program create an ArrayList<Ship>. Have a loop that prints information about each ship. Polymorphism will take care of getting the correct information about each ship.\nNow try the Grid classes. This is a complicated program where each small piece should be coded and tested with simple output. For example, a Grid can be displayed with a two-dimensional array of 0’s and 1’s to show the positions of ships. Other symbols can be used to show what’s been hit and what’s been sunk.\nWhen everything is working with the grids, you could add a Display class that has Grid variables and a display method.\nTry a Player. Give him a list of ships, two grids and a Display.\nThen create a GameManager. Give her two Player variables and be sure she has a playGame method.\nThe program development shown above is an example of bottom-up development.\nProgram Correctness\nTesting that a program works does not prove that the program is correct. After all, you can hardly expect to test programs for every conceivable set of input data. Computer scientists have developed mathematical techniques to prove correctness in certain cases, but these are beyond the scope of the APCS course. Nevertheless, you are expected to be able to make assertions about the state of a program at various points during its execution.\n\nAssertions\nAn assertion is a precise statement about a program at any given point. The idea is that if an assertion is proved to be true, then the program is working correctly at that point.\nAn informal step on the way to writing correct algorithms is to be able to make different kinds of assertions about your code.\n\nPRECONDITION\nThe precondition for any piece of code, whether it is a method, loop, or block, is a statement of what is true immediately before execution of that code.\nPOSTCONDITION\nThe postcondition for a piece of code is a statement of what is true immediately after execution of that code.\n\nEfficiency\nAn efficient algorithm is one that is economical in the use of\n• CPU time. This refers to the number of machine operations required to carry out the algorithm (arithmetic operations, comparisons, data movements, etc.).\n• Memory. This refers to the number and complexity of the variables used.\n\nSome factors that affect run-time efficiency include unnecessary tests, excessive movement of data elements, and redundant computations, especially in loops.\nAlways aim for early detection of output conditions: Your sorting algorithm should halt when the list is sorted; your search should stop if the key element has been found. In discussing efficiency of an algorithm, we refer to the best case, worst case, and average case. The best case is a configuration of the data that causes the algorithm to run in the least possible amount of time. The worst case is a configuration that leads to the greatest possible run time. Typical configurations (i.e., not specially chosen data) give the average case. It is possible that best, worst, and average cases don’t differ much in their run times.\nFor example, suppose that a list of distinct random numbers must be searched for a given key value. The algorithm used is a sequential search starting at the beginning of the list. In the best case, the key will be found in the first position examined. In the worst case, it will be in the last position or not in the list at all. On average, the key will be somewhere in the middle of the list.\n\n\n###\n\n","completion":" Question: Refer to the following code segment.\n\n\/** Compute the mean of integers 1 .. N. \n* N is an integer >= 1 and has been initialized. \n*\/ \nint k = 1; \ndouble mean, sum = 1.0; \nwhile (k < N) \n{ \n    \/* loop body *\/ \n} \nmean = sum \/ N; \n\nWhat is the precondition for the while loop? \nCorrect: N ≥ 1, k = 1, sum = 1.0\nIncorrect: k ≥ N, sum = 1.0\nIncorrect: sum = 1 + 2 + 3 + ... + k\nIncorrect: k < N, sum = 1.0\nIncorrect: mean = sum \/ N\n\nEND"}
{"prompt":"Use the verbs to identify key methods in the program: simulate<game>, place <ships>, shoot<at position>, call out<position>, respond<hit or miss>, sink <ship>, inform that<ship was sunk>, keep track of<hits or misses>, sink <opponent’s fleet>, win<game>.\nYou need to decide who will do what. There’s no definitive way of implementingthe program, but it seems clear that the GameManager should run the game and declare the winner. Should the GameManager also be in charge of announcing if a ship is sunk? It makes sense because the game manager can see both players’ grids. Each player should keep track of his calls, so that he can make an intelligent next call and also respond “hit” or “miss.” Will each player have a display? Or will the Display have both players? You have to set it up so that a player can’t see his opponent’s FleetGrid, but he can see his own and also a grid showing the state of the calls he has made. Should each player have a list of his ships, so he can keep track of the state of his fleet? And what about each ship in the fleet? Should a ship have a list of its positions, and should it keep track of if it’s hit or sunk?\nSaving and retrieving updated information is crucial to this program. It seems a bit overwhelming. Where should you start? The Ship classes are low-level classes, independent of the players and grids. Start with these and test that you can get accurate information about each ship. In your driver program create an ArrayList<Ship>. Have a loop that prints information about each ship. Polymorphism will take care of getting the correct information about each ship.\nNow try the Grid classes. This is a complicated program where each small piece should be coded and tested with simple output. For example, a Grid can be displayed with a two-dimensional array of 0’s and 1’s to show the positions of ships. Other symbols can be used to show what’s been hit and what’s been sunk.\nWhen everything is working with the grids, you could add a Display class that has Grid variables and a display method.\nTry a Player. Give him a list of ships, two grids and a Display.\nThen create a GameManager. Give her two Player variables and be sure she has a playGame method.\nThe program development shown above is an example of bottom-up development.\nProgram Correctness\nTesting that a program works does not prove that the program is correct. After all, you can hardly expect to test programs for every conceivable set of input data. Computer scientists have developed mathematical techniques to prove correctness in certain cases, but these are beyond the scope of the APCS course. Nevertheless, you are expected to be able to make assertions about the state of a program at various points during its execution.\n\nAssertions\nAn assertion is a precise statement about a program at any given point. The idea is that if an assertion is proved to be true, then the program is working correctly at that point.\nAn informal step on the way to writing correct algorithms is to be able to make different kinds of assertions about your code.\n\nPRECONDITION\nThe precondition for any piece of code, whether it is a method, loop, or block, is a statement of what is true immediately before execution of that code.\nPOSTCONDITION\nThe postcondition for a piece of code is a statement of what is true immediately after execution of that code.\n\nEfficiency\nAn efficient algorithm is one that is economical in the use of\n• CPU time. This refers to the number of machine operations required to carry out the algorithm (arithmetic operations, comparisons, data movements, etc.).\n• Memory. This refers to the number and complexity of the variables used.\n\nSome factors that affect run-time efficiency include unnecessary tests, excessive movement of data elements, and redundant computations, especially in loops.\nAlways aim for early detection of output conditions: Your sorting algorithm should halt when the list is sorted; your search should stop if the key element has been found. In discussing efficiency of an algorithm, we refer to the best case, worst case, and average case. The best case is a configuration of the data that causes the algorithm to run in the least possible amount of time. The worst case is a configuration that leads to the greatest possible run time. Typical configurations (i.e., not specially chosen data) give the average case. It is possible that best, worst, and average cases don’t differ much in their run times.\nFor example, suppose that a list of distinct random numbers must be searched for a given key value. The algorithm used is a sequential search starting at the beginning of the list. In the best case, the key will be found in the first position examined. In the worst case, it will be in the last position or not in the list at all. On average, the key will be somewhere in the middle of the list.\n\n\n###\n\n","completion":" Question: The sequence of Fibonacci numbers is 1, 1, 2, 3, 5, 8, 13, 21, . . . . The first two Fibonacci numbers are each 1. Each subsequent number is obtained by adding the previous two. Consider this method: \n\n\/** Precondition: n >= 1. \n* Postcondition: The nth Fibonacci number has been returned. \n*\/ \npublic static int fib(int n) \n{ \n    int prev = 1, next = 1, sum = 1; \n    for (int i = 3; i <= n; i++) \n    { \n        \/* assertion *\/ \n        sum = next + prev; \n        prev = next; \n        next = sum; \n    } \n    return sum; \n} \n\nWhich of the following is a correct \/* assertion *\/ about the loop variable i? \nCorrect: 3 ≤ i ≤ n\nIncorrect: 1 ≤ i ≤ n\nIncorrect: 0 ≤ i ≤ n\nIncorrect: 3 < i ≤ n\nIncorrect: 3 < i < n+1\n\nEND"}
{"prompt":"Use the verbs to identify key methods in the program: simulate<game>, place <ships>, shoot<at position>, call out<position>, respond<hit or miss>, sink <ship>, inform that<ship was sunk>, keep track of<hits or misses>, sink <opponent’s fleet>, win<game>.\nYou need to decide who will do what. There’s no definitive way of implementingthe program, but it seems clear that the GameManager should run the game and declare the winner. Should the GameManager also be in charge of announcing if a ship is sunk? It makes sense because the game manager can see both players’ grids. Each player should keep track of his calls, so that he can make an intelligent next call and also respond “hit” or “miss.” Will each player have a display? Or will the Display have both players? You have to set it up so that a player can’t see his opponent’s FleetGrid, but he can see his own and also a grid showing the state of the calls he has made. Should each player have a list of his ships, so he can keep track of the state of his fleet? And what about each ship in the fleet? Should a ship have a list of its positions, and should it keep track of if it’s hit or sunk?\nSaving and retrieving updated information is crucial to this program. It seems a bit overwhelming. Where should you start? The Ship classes are low-level classes, independent of the players and grids. Start with these and test that you can get accurate information about each ship. In your driver program create an ArrayList<Ship>. Have a loop that prints information about each ship. Polymorphism will take care of getting the correct information about each ship.\nNow try the Grid classes. This is a complicated program where each small piece should be coded and tested with simple output. For example, a Grid can be displayed with a two-dimensional array of 0’s and 1’s to show the positions of ships. Other symbols can be used to show what’s been hit and what’s been sunk.\nWhen everything is working with the grids, you could add a Display class that has Grid variables and a display method.\nTry a Player. Give him a list of ships, two grids and a Display.\nThen create a GameManager. Give her two Player variables and be sure she has a playGame method.\nThe program development shown above is an example of bottom-up development.\nProgram Correctness\nTesting that a program works does not prove that the program is correct. After all, you can hardly expect to test programs for every conceivable set of input data. Computer scientists have developed mathematical techniques to prove correctness in certain cases, but these are beyond the scope of the APCS course. Nevertheless, you are expected to be able to make assertions about the state of a program at various points during its execution.\n\nAssertions\nAn assertion is a precise statement about a program at any given point. The idea is that if an assertion is proved to be true, then the program is working correctly at that point.\nAn informal step on the way to writing correct algorithms is to be able to make different kinds of assertions about your code.\n\nPRECONDITION\nThe precondition for any piece of code, whether it is a method, loop, or block, is a statement of what is true immediately before execution of that code.\nPOSTCONDITION\nThe postcondition for a piece of code is a statement of what is true immediately after execution of that code.\n\nEfficiency\nAn efficient algorithm is one that is economical in the use of\n• CPU time. This refers to the number of machine operations required to carry out the algorithm (arithmetic operations, comparisons, data movements, etc.).\n• Memory. This refers to the number and complexity of the variables used.\n\nSome factors that affect run-time efficiency include unnecessary tests, excessive movement of data elements, and redundant computations, especially in loops.\nAlways aim for early detection of output conditions: Your sorting algorithm should halt when the list is sorted; your search should stop if the key element has been found. In discussing efficiency of an algorithm, we refer to the best case, worst case, and average case. The best case is a configuration of the data that causes the algorithm to run in the least possible amount of time. The worst case is a configuration that leads to the greatest possible run time. Typical configurations (i.e., not specially chosen data) give the average case. It is possible that best, worst, and average cases don’t differ much in their run times.\nFor example, suppose that a list of distinct random numbers must be searched for a given key value. The algorithm used is a sequential search starting at the beginning of the list. In the best case, the key will be found in the first position examined. In the worst case, it will be in the last position or not in the list at all. On average, the key will be somewhere in the middle of the list.\n\n\n###\n\n","completion":" Question: Refer to the following method. \n\n\/** Precondition: a and b are initialized integers. *\/ \npublic static int mystery(int a, int b) \n{ \n    int total = 0, count = 1; \n    while (count <= b) \n    { \n        total += a; \n        count++; \n    } \n    return total; \n} \n\nWhat is the postcondition for method mystery? \nCorrect: total = a * b\nIncorrect: total = a + b\nIncorrect: total = a^b\nIncorrect: total = b^a\nIncorrect: total = a\/b\n\nEND"}
{"prompt":"Object-oriented programming has been the dominant programming methodology since the mid 1990s. It uses an approach that blurs the lines of the waterfall model. Anal ysis of the problem, development of the design, and pieces of the implementation all overlap and influence one another.\nHere are the steps in object-oriented design:\n• Identify classes to be written.\n• Identify behaviors (i.e., methods) for each class.\n• Determine the relationships between classes.\n• Write the interface (public method headers) for each class.\n• Implement the methods.\n\nIdentify the objects in the program by picking out the nouns in the program speci fication. Ignore pronouns and nouns that refer to the user. Select those nouns that seem suitable as classes, the “big-picture” nouns that describe the major objects in the application. Some of the other nouns may end up as attributes of the classes.\nMany applications have similar object types: a low-level basic component; a collec\ntion of low-level components; a controlling object that puts everything together; and a display object that could be a GUI (graphical user interface) but doesn’t have to be.\n\nExample 1\nWrite a program that maintains an inventory of stock items for a small store.\nNouns to consider: inventory, item, store.\nBasic Object: StockItem\nCollection: Inventory (a list of StockItems)\nController: Store (has an Inventory, uses a StoreDisplay)\nDisplay: StoreDisplay (could be a GUI)\n\nExample 2\nWrite a program that simulates a game of bingo. There should be at least two play\ners, each of whom has a bingo card, and a caller who calls the numbers.\nNouns to consider: game, players, bingo card, caller.\nBasic Objects: BingoCard, Caller\nCollection: Players (each has a BingoCard)\nController: GameMaster (sets up the Players and Caller)\nDisplay: BingoDisplay (shows each player’s card and displays winners, etc.)\n\nExample 3\nWrite a program that creates random bridge deals and displays them in a specified format. (The specification defines a “deal” as consisting of four hands. It also describes a deck of cards, and shows how each card should be displayed.)\nNouns to consider: deal, hand, format, deck, card.\nBasic Object: Card\nCollection: Deck (has an array of Cards)\nHand (has an array of Cards)\nDeal (has an array of Hands)\nDealer (has a Deck, or several Decks)\nController: Formatter (has a Deal and a TableDisplay)\nDisplay: TableDisplay (could be a GUI)\n\nIdentifying Behaviors\nFind all verbs in the program description that help lead to the solution of the programming task. These are likely behaviors that will probably become the methods of the classes. Now decide which methods belong in which classes. Recall that the process of bundling a group of methods and data fields into a class is called encapsulation.\nThink carefully about who should do what. Do not ask a basic object to perform operations for the group. For example, a StockItem should keep track of its own details (price, description, how many on the shelf, etc.) but should not be required to search for another item. A Card should know its value and suit but should not be responsible for keeping track of how many cards are left in a deck. A Caller in a bingo game should be responsible for keeping track of the numbers called so far and for producing the next number but not for checking whether a player has bingo: That is the job of an individual player (element of Players) and his BingoCard.\nYou will also need to decide which data fields each class will need and which data structures should store them. For example, if an object represents a list of items, consider an array or ArrayList as the data structure.\n\nINHERITANCE RELATIONSHIPS\nLook for classes with common behaviors. This will help identify inheritance relationships. Recall the is-a relationship—if object1 is-a object2, then object2 is a candidate for a superclass.\nCOMPOSITION RELATIONSHIPS\nComposition relationships are defined by the has-a relationship. For example, a Nurse has-a Uniform. Typically, if two classes have a composition relationship, one of them contains an instance variable whose type is the other class.\nNote that a wrapper class always implements a has-a relationship with any objects that it wraps.\nAn excellent way to keep track of the relationships between classes and show the inheritance hierarchy in your programs is with a UML (Unified Modeling Language) diagram. This is a standard graphical scheme used by object-oriented programmers. Although it is not part of the AP subset, on the AP exam you may be expected to interpret simple UML diagrams and inheritance hierarchies.\nHere is a simplified version of the UML rules:\n• Represent classes with rectangles.\n• Use angle brackets with the word “abstract” or “interface” to indicate either an abstract class or interface.\n• Show the is-a relationship between classes with an open up-arrow.\n• Show the is-a relationship that involves an interface with an open, dotted up arrow.\n• Show the has-a relationship with a down arrow or sideways arrow (indicates composition).\n\n\n###\n\n","completion":" Question: A program is to be written that prints an invoice for a small store. A copy of the invoice will be given to the customer and will display \n• A list of items purchased. \n• The quantity, unit price, and total price for each item. \n• The amount due. \nThree candidate classes for this program are Invoice, Item, and ItemList, where an Item is a single item purchased and ItemList is the list of all items purchased. \nWhich class is a reasonable choice to be responsible for the amountDue method, which returns the amount the customer must pay? \nI Item \nII ItemList \nIII Invoice \nCorrect: II and III only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"Object-oriented programming has been the dominant programming methodology since the mid 1990s. It uses an approach that blurs the lines of the waterfall model. Anal ysis of the problem, development of the design, and pieces of the implementation all overlap and influence one another.\nHere are the steps in object-oriented design:\n• Identify classes to be written.\n• Identify behaviors (i.e., methods) for each class.\n• Determine the relationships between classes.\n• Write the interface (public method headers) for each class.\n• Implement the methods.\n\nIdentify the objects in the program by picking out the nouns in the program speci fication. Ignore pronouns and nouns that refer to the user. Select those nouns that seem suitable as classes, the “big-picture” nouns that describe the major objects in the application. Some of the other nouns may end up as attributes of the classes.\nMany applications have similar object types: a low-level basic component; a collec\ntion of low-level components; a controlling object that puts everything together; and a display object that could be a GUI (graphical user interface) but doesn’t have to be.\n\nExample 1\nWrite a program that maintains an inventory of stock items for a small store.\nNouns to consider: inventory, item, store.\nBasic Object: StockItem\nCollection: Inventory (a list of StockItems)\nController: Store (has an Inventory, uses a StoreDisplay)\nDisplay: StoreDisplay (could be a GUI)\n\nExample 2\nWrite a program that simulates a game of bingo. There should be at least two play\ners, each of whom has a bingo card, and a caller who calls the numbers.\nNouns to consider: game, players, bingo card, caller.\nBasic Objects: BingoCard, Caller\nCollection: Players (each has a BingoCard)\nController: GameMaster (sets up the Players and Caller)\nDisplay: BingoDisplay (shows each player’s card and displays winners, etc.)\n\nExample 3\nWrite a program that creates random bridge deals and displays them in a specified format. (The specification defines a “deal” as consisting of four hands. It also describes a deck of cards, and shows how each card should be displayed.)\nNouns to consider: deal, hand, format, deck, card.\nBasic Object: Card\nCollection: Deck (has an array of Cards)\nHand (has an array of Cards)\nDeal (has an array of Hands)\nDealer (has a Deck, or several Decks)\nController: Formatter (has a Deal and a TableDisplay)\nDisplay: TableDisplay (could be a GUI)\n\nIdentifying Behaviors\nFind all verbs in the program description that help lead to the solution of the programming task. These are likely behaviors that will probably become the methods of the classes. Now decide which methods belong in which classes. Recall that the process of bundling a group of methods and data fields into a class is called encapsulation.\nThink carefully about who should do what. Do not ask a basic object to perform operations for the group. For example, a StockItem should keep track of its own details (price, description, how many on the shelf, etc.) but should not be required to search for another item. A Card should know its value and suit but should not be responsible for keeping track of how many cards are left in a deck. A Caller in a bingo game should be responsible for keeping track of the numbers called so far and for producing the next number but not for checking whether a player has bingo: That is the job of an individual player (element of Players) and his BingoCard.\nYou will also need to decide which data fields each class will need and which data structures should store them. For example, if an object represents a list of items, consider an array or ArrayList as the data structure.\n\nINHERITANCE RELATIONSHIPS\nLook for classes with common behaviors. This will help identify inheritance relationships. Recall the is-a relationship—if object1 is-a object2, then object2 is a candidate for a superclass.\nCOMPOSITION RELATIONSHIPS\nComposition relationships are defined by the has-a relationship. For example, a Nurse has-a Uniform. Typically, if two classes have a composition relationship, one of them contains an instance variable whose type is the other class.\nNote that a wrapper class always implements a has-a relationship with any objects that it wraps.\nAn excellent way to keep track of the relationships between classes and show the inheritance hierarchy in your programs is with a UML (Unified Modeling Language) diagram. This is a standard graphical scheme used by object-oriented programmers. Although it is not part of the AP subset, on the AP exam you may be expected to interpret simple UML diagrams and inheritance hierarchies.\nHere is a simplified version of the UML rules:\n• Represent classes with rectangles.\n• Use angle brackets with the word “abstract” or “interface” to indicate either an abstract class or interface.\n• Show the is-a relationship between classes with an open up-arrow.\n• Show the is-a relationship that involves an interface with an open, dotted up arrow.\n• Show the has-a relationship with a down arrow or sideways arrow (indicates composition).\n\n\n###\n\n","completion":" Question: Which is a false statement about classes in object-oriented program design? \nCorrect: If classes C1 and C2 are related such that C1 is-a C2, then C2 has-a C1.\nIncorrect: If a class C1 has an instance variable whose type is another class, C2, then C1 has-a C2.\nIncorrect: If a class C1 is associated with another class, C2, then C1 depends on C2 for its implementation.\nIncorrect: If class C1 is independent, then none of its methods will have parameters that are objects of other classes.\nIncorrect: Classes that have common methods do not necessarily define an inheritance relationship.\n\nEND"}
{"prompt":"Object-oriented programming has been the dominant programming methodology since the mid 1990s. It uses an approach that blurs the lines of the waterfall model. Anal ysis of the problem, development of the design, and pieces of the implementation all overlap and influence one another.\nHere are the steps in object-oriented design:\n• Identify classes to be written.\n• Identify behaviors (i.e., methods) for each class.\n• Determine the relationships between classes.\n• Write the interface (public method headers) for each class.\n• Implement the methods.\n\nIdentify the objects in the program by picking out the nouns in the program speci fication. Ignore pronouns and nouns that refer to the user. Select those nouns that seem suitable as classes, the “big-picture” nouns that describe the major objects in the application. Some of the other nouns may end up as attributes of the classes.\nMany applications have similar object types: a low-level basic component; a collec\ntion of low-level components; a controlling object that puts everything together; and a display object that could be a GUI (graphical user interface) but doesn’t have to be.\n\nExample 1\nWrite a program that maintains an inventory of stock items for a small store.\nNouns to consider: inventory, item, store.\nBasic Object: StockItem\nCollection: Inventory (a list of StockItems)\nController: Store (has an Inventory, uses a StoreDisplay)\nDisplay: StoreDisplay (could be a GUI)\n\nExample 2\nWrite a program that simulates a game of bingo. There should be at least two play\ners, each of whom has a bingo card, and a caller who calls the numbers.\nNouns to consider: game, players, bingo card, caller.\nBasic Objects: BingoCard, Caller\nCollection: Players (each has a BingoCard)\nController: GameMaster (sets up the Players and Caller)\nDisplay: BingoDisplay (shows each player’s card and displays winners, etc.)\n\nExample 3\nWrite a program that creates random bridge deals and displays them in a specified format. (The specification defines a “deal” as consisting of four hands. It also describes a deck of cards, and shows how each card should be displayed.)\nNouns to consider: deal, hand, format, deck, card.\nBasic Object: Card\nCollection: Deck (has an array of Cards)\nHand (has an array of Cards)\nDeal (has an array of Hands)\nDealer (has a Deck, or several Decks)\nController: Formatter (has a Deal and a TableDisplay)\nDisplay: TableDisplay (could be a GUI)\n\nIdentifying Behaviors\nFind all verbs in the program description that help lead to the solution of the programming task. These are likely behaviors that will probably become the methods of the classes. Now decide which methods belong in which classes. Recall that the process of bundling a group of methods and data fields into a class is called encapsulation.\nThink carefully about who should do what. Do not ask a basic object to perform operations for the group. For example, a StockItem should keep track of its own details (price, description, how many on the shelf, etc.) but should not be required to search for another item. A Card should know its value and suit but should not be responsible for keeping track of how many cards are left in a deck. A Caller in a bingo game should be responsible for keeping track of the numbers called so far and for producing the next number but not for checking whether a player has bingo: That is the job of an individual player (element of Players) and his BingoCard.\nYou will also need to decide which data fields each class will need and which data structures should store them. For example, if an object represents a list of items, consider an array or ArrayList as the data structure.\n\nINHERITANCE RELATIONSHIPS\nLook for classes with common behaviors. This will help identify inheritance relationships. Recall the is-a relationship—if object1 is-a object2, then object2 is a candidate for a superclass.\nCOMPOSITION RELATIONSHIPS\nComposition relationships are defined by the has-a relationship. For example, a Nurse has-a Uniform. Typically, if two classes have a composition relationship, one of them contains an instance variable whose type is the other class.\nNote that a wrapper class always implements a has-a relationship with any objects that it wraps.\nAn excellent way to keep track of the relationships between classes and show the inheritance hierarchy in your programs is with a UML (Unified Modeling Language) diagram. This is a standard graphical scheme used by object-oriented programmers. Although it is not part of the AP subset, on the AP exam you may be expected to interpret simple UML diagrams and inheritance hierarchies.\nHere is a simplified version of the UML rules:\n• Represent classes with rectangles.\n• Use angle brackets with the word “abstract” or “interface” to indicate either an abstract class or interface.\n• Show the is-a relationship between classes with an open up-arrow.\n• Show the is-a relationship that involves an interface with an open, dotted up arrow.\n• Show the has-a relationship with a down arrow or sideways arrow (indicates composition).\n\n\n###\n\n","completion":" Question: A Java program maintains a large database of vehicles and parts for a car dealership. Some of the classes in the program are Vehicle, Car, Truck, Tire, Circle, SteeringWheel, and AirBag. The declarations below show the relationships between classes. Which is a poor choice? \nCorrect: public class Tire extends Circle\n{\n    ... \n    \/\/inherits methods that compute circumference \n    \/\/and center point \n} \nIncorrect: public class Vehicle\n{\n    ... \n    private Tire[] tires; \n    private SteeringWheel sw; \n    ... \n} \nIncorrect: public class Car extends Vehicle\n{\n    ... \n    \/\/inherits private Tire[] tires from Vehicle class \n    \/\/inherits private SteeringWheel sw from Vehicle class \n    ... \n} \nIncorrect: public class Tire\n{\n    ... \n    private String rating; \/\/speed rating of tire \n    private Circle boundary; \n} \nIncorrect: public class SteeringWheel\n{\n    ... \n    private AirBag ab; \/\/AirBag is stored in SteeringWheel \n    private Circle boundary; \n} \n\nEND"}
{"prompt":"Object-oriented programming has been the dominant programming methodology since the mid 1990s. It uses an approach that blurs the lines of the waterfall model. Anal ysis of the problem, development of the design, and pieces of the implementation all overlap and influence one another.\nHere are the steps in object-oriented design:\n• Identify classes to be written.\n• Identify behaviors (i.e., methods) for each class.\n• Determine the relationships between classes.\n• Write the interface (public method headers) for each class.\n• Implement the methods.\n\nIdentify the objects in the program by picking out the nouns in the program speci fication. Ignore pronouns and nouns that refer to the user. Select those nouns that seem suitable as classes, the “big-picture” nouns that describe the major objects in the application. Some of the other nouns may end up as attributes of the classes.\nMany applications have similar object types: a low-level basic component; a collec\ntion of low-level components; a controlling object that puts everything together; and a display object that could be a GUI (graphical user interface) but doesn’t have to be.\n\nExample 1\nWrite a program that maintains an inventory of stock items for a small store.\nNouns to consider: inventory, item, store.\nBasic Object: StockItem\nCollection: Inventory (a list of StockItems)\nController: Store (has an Inventory, uses a StoreDisplay)\nDisplay: StoreDisplay (could be a GUI)\n\nExample 2\nWrite a program that simulates a game of bingo. There should be at least two play\ners, each of whom has a bingo card, and a caller who calls the numbers.\nNouns to consider: game, players, bingo card, caller.\nBasic Objects: BingoCard, Caller\nCollection: Players (each has a BingoCard)\nController: GameMaster (sets up the Players and Caller)\nDisplay: BingoDisplay (shows each player’s card and displays winners, etc.)\n\nExample 3\nWrite a program that creates random bridge deals and displays them in a specified format. (The specification defines a “deal” as consisting of four hands. It also describes a deck of cards, and shows how each card should be displayed.)\nNouns to consider: deal, hand, format, deck, card.\nBasic Object: Card\nCollection: Deck (has an array of Cards)\nHand (has an array of Cards)\nDeal (has an array of Hands)\nDealer (has a Deck, or several Decks)\nController: Formatter (has a Deal and a TableDisplay)\nDisplay: TableDisplay (could be a GUI)\n\nIdentifying Behaviors\nFind all verbs in the program description that help lead to the solution of the programming task. These are likely behaviors that will probably become the methods of the classes. Now decide which methods belong in which classes. Recall that the process of bundling a group of methods and data fields into a class is called encapsulation.\nThink carefully about who should do what. Do not ask a basic object to perform operations for the group. For example, a StockItem should keep track of its own details (price, description, how many on the shelf, etc.) but should not be required to search for another item. A Card should know its value and suit but should not be responsible for keeping track of how many cards are left in a deck. A Caller in a bingo game should be responsible for keeping track of the numbers called so far and for producing the next number but not for checking whether a player has bingo: That is the job of an individual player (element of Players) and his BingoCard.\nYou will also need to decide which data fields each class will need and which data structures should store them. For example, if an object represents a list of items, consider an array or ArrayList as the data structure.\n\nINHERITANCE RELATIONSHIPS\nLook for classes with common behaviors. This will help identify inheritance relationships. Recall the is-a relationship—if object1 is-a object2, then object2 is a candidate for a superclass.\nCOMPOSITION RELATIONSHIPS\nComposition relationships are defined by the has-a relationship. For example, a Nurse has-a Uniform. Typically, if two classes have a composition relationship, one of them contains an instance variable whose type is the other class.\nNote that a wrapper class always implements a has-a relationship with any objects that it wraps.\nAn excellent way to keep track of the relationships between classes and show the inheritance hierarchy in your programs is with a UML (Unified Modeling Language) diagram. This is a standard graphical scheme used by object-oriented programmers. Although it is not part of the AP subset, on the AP exam you may be expected to interpret simple UML diagrams and inheritance hierarchies.\nHere is a simplified version of the UML rules:\n• Represent classes with rectangles.\n• Use angle brackets with the word “abstract” or “interface” to indicate either an abstract class or interface.\n• Show the is-a relationship between classes with an open up-arrow.\n• Show the is-a relationship that involves an interface with an open, dotted up arrow.\n• Show the has-a relationship with a down arrow or sideways arrow (indicates composition).\n\n\n###\n\n","completion":" Question: A Java programmer has completed a preliminary design for a large program. The programmer has developed a list of classes, determined the methods for each class, established the relationships between classes, and written an outline for each class. Which class(es) should be implemented first? \nCorrect: All independent classes (classes that have no references to other classes)\n\n\nIncorrect: Any superclasses\nIncorrect: Any subclasses\nIncorrect: All collaborator classes (classes that will be used to implement other classes)\nIncorrect: The class that represents the dominant object in the programEND"}
{"prompt":"Use the nouns in the specification as a starting point for identifying classes in the program. The nouns are: program, teacher, grade book, class list, class, student, schedule, menu, set of scores, data, record, average, grade, and file. Eliminate each of the following:\nprogram (Always eliminate “program” when used in this context.)\nteacher (Eliminate, because he or she is the user.)\nschedule (This will be reflected in the name of the external file for each class, e.g., apcs_period3.dat.)\ndata, record (These are synonymous with student name, scores, grades, etc., and will be covered by these features.)\nclass (This is synonymous with class list.)\n\nThe following seem to be excellent candidates for classes: GradeBook, ClassList, Student, and FileHandler. Other possibilities are Menu, ScoreList, and a GUI_Display. On further thought: Basic independent objects are Student, Menu, Score, and FileHandler. Group objects are ClassList (collection of students), ScoreList (collection of scores), and AllClasses (collection of ClassLists). The controlling class is the GradeBook. A Display class is essential for many of the grade book operations, like showing a class list or displaying information for a single student.\n\nThere are no inheritance relationships. There are many composition relationships between objects, however. The GradeBook has-a Menu, the ClassList has-a Student (several, in fact!), a Student has-a name, average, grade, list_of_scores, etc. The programmer must decide whether to code these attributes as classes or data fields.\nUse the verbs in the specification to identify required operations in the program. The verbs are: maintain <list>, provide <menu>, allow <user>, create <list>, enter <scores>, correct <data>, display <record>, calculate <average>, calculate <grade>, print <list>, add <student>, delete <student>, transfer <student>, and save <data>.\nYou must make some design decisions about which class is responsible for which behavior. For example, will a ClassList display the record of a single Student, or will a Student display his or her own record? Who will enter scores—the GradeBook, a ClassList, or a Student? Is it desirable for a Student to enter scores of other Students? Probably not!\n\nHere are some preliminary decisions. The GradeBook will provideMenu. The menu selection will send execution to the relevant object.\nThe ClassList will maintain an updated list of each class. It will have these public methods: addStudent, deleteStudent, transferStudent, createNewClass, printClassList, printScores, and updateList. A good candidate for a helper method in this class is search for a given student.\nEach Student will have complete personal and grade information. Public methods will include setName, getName, enterScore, correctData, findAverage, getAverage, getGrade, and displayRecord.\nSaving and retrieving information is crucial to this program. The FileHandler will take care of openFileForReading, openFileForWriting, closeFiles, loadClass, and saveClass. The FileHandler class should be written and tested right at the beginning, using a small dummy class list.\nScore, ScoreList, and Student are easy classes to implement. When these are working, the programmer can go on to ClassList. Finally the Display GUI class, which will have the GradeBook, can be developed. This is an example of bottom-up development.\n\nExample 3\nA program simulates a game of Battleships, which is a game between two players, each of whom has a grid where ships are placed. Each player has five ships:\nbattleship o o o o o\ncruiser o o o o\nsubmarine o o o\ndestroyer o o\nfrigate o\nThe grids of the players’ fleets may look like this. Any two adjacent squares that are taken must belong to the same ship, i.e., different ships shouldn’t “touch.”\nEach player’s grid is hidden from the other player. Players alternate “shooting” at each other’s ships by calling out a position, a row and column number. A player must make an honest response, “hit” or “miss.” If it’s a hit, a player gets another turn. If the whole ship has been hit, the owner must say something like, “You sank my cruiser.” Each player must keep track of hits and misses. The first player to sink his opponent’s fleet is the winner.\nThe nouns in the specification are program, game, players, grid, ship, battleship, cruiser, submarine, destroyer, frigate, square, position, opponent, row, column, turn, hits, misses, fleet, winner.\n\nEliminate each of the following:\nprogram Always eliminate.\nrow, col These are parts of a given position or square, more suitable as instance variables for a position or square object.\nhits, misses These are simply marked positions and probably don’t need their own class.\nturn Taking a turn is an action and will be described by a method rather than a class.\nopponent This is another word for player.\n\nThe following seem to be good candidates for classes: Player, Grid, Position, Ship, Battleship, Cruiser, Submarine, Destroyer, and Frigate. Additionally, it seems there should be a GameManager and Display.\n\nThis program provides two examples of inheritance relationships. Each of the five ships is-a Ship, and shares common features, like isHit, isSunk, and array of positions. However, each has a unique name, length, and position in the grid. This means that Ship is a good candidate for an abstract class with abstract methods like getLength, getName, and getPositions, which depend on the kind of ship.\nThe second inheritance relationship is between the grids. There are two types of\ngrids for each player: his own FleetGrid (the current state of his own ships) and his opponent’s HitGrid, which keeps track of his hits and misses. Each of these grids is-a Grid. A grid is a candidate for an interface, with a list of methods like getAdjacentNeighbors, getRightNeighbor, etc. Each of FleetGrid and HitGrid would implement Grid.\nThere are several composition relationships in this program. A Player has-a HitGrid and a FleetGrid and also has five ships. The GameManager has each of the two Player objects and also has-a Display. The Display has each of the grids.\n\n\n###\n\n","completion":" Question: Consider the following program description:\n\nA program is to be written that simulates bumper cars in a video game. The cars move on a square grid and are located on grid points (x, y), where x and y are integers between −20 and 20. A bumper car moves in a random direction, either left, right, up, or down. If it reaches a boundary (i.e., x or y is ±20), then it reverses direction. If it is about to collide with another bumper car, it reverses direction. Your program should be able to add bumper cars and run the simulation. One step of the simulation allows each car in the grid to move. After a bumper car has reversed direction twice, its turn is over and the next car gets to move. 19. To identify classes in the program, the nouns in the specification are listed: program, bumper car, grid, grid point, integer, direction, boundary, simulation \n\nHow many nouns in the list should immediately be discarded because they are unsuitable as classes for the program? \nCorrect: 2\nIncorrect: 0\nIncorrect: 1\nIncorrect: 3\nIncorrect: 4\n\nEND"}
{"prompt":"Use the nouns in the specification as a starting point for identifying classes in the program. The nouns are: program, teacher, grade book, class list, class, student, schedule, menu, set of scores, data, record, average, grade, and file. Eliminate each of the following:\nprogram (Always eliminate “program” when used in this context.)\nteacher (Eliminate, because he or she is the user.)\nschedule (This will be reflected in the name of the external file for each class, e.g., apcs_period3.dat.)\ndata, record (These are synonymous with student name, scores, grades, etc., and will be covered by these features.)\nclass (This is synonymous with class list.)\n\nThe following seem to be excellent candidates for classes: GradeBook, ClassList, Student, and FileHandler. Other possibilities are Menu, ScoreList, and a GUI_Display. On further thought: Basic independent objects are Student, Menu, Score, and FileHandler. Group objects are ClassList (collection of students), ScoreList (collection of scores), and AllClasses (collection of ClassLists). The controlling class is the GradeBook. A Display class is essential for many of the grade book operations, like showing a class list or displaying information for a single student.\n\nThere are no inheritance relationships. There are many composition relationships between objects, however. The GradeBook has-a Menu, the ClassList has-a Student (several, in fact!), a Student has-a name, average, grade, list_of_scores, etc. The programmer must decide whether to code these attributes as classes or data fields.\nUse the verbs in the specification to identify required operations in the program. The verbs are: maintain <list>, provide <menu>, allow <user>, create <list>, enter <scores>, correct <data>, display <record>, calculate <average>, calculate <grade>, print <list>, add <student>, delete <student>, transfer <student>, and save <data>.\nYou must make some design decisions about which class is responsible for which behavior. For example, will a ClassList display the record of a single Student, or will a Student display his or her own record? Who will enter scores—the GradeBook, a ClassList, or a Student? Is it desirable for a Student to enter scores of other Students? Probably not!\n\nHere are some preliminary decisions. The GradeBook will provideMenu. The menu selection will send execution to the relevant object.\nThe ClassList will maintain an updated list of each class. It will have these public methods: addStudent, deleteStudent, transferStudent, createNewClass, printClassList, printScores, and updateList. A good candidate for a helper method in this class is search for a given student.\nEach Student will have complete personal and grade information. Public methods will include setName, getName, enterScore, correctData, findAverage, getAverage, getGrade, and displayRecord.\nSaving and retrieving information is crucial to this program. The FileHandler will take care of openFileForReading, openFileForWriting, closeFiles, loadClass, and saveClass. The FileHandler class should be written and tested right at the beginning, using a small dummy class list.\nScore, ScoreList, and Student are easy classes to implement. When these are working, the programmer can go on to ClassList. Finally the Display GUI class, which will have the GradeBook, can be developed. This is an example of bottom-up development.\n\nExample 3\nA program simulates a game of Battleships, which is a game between two players, each of whom has a grid where ships are placed. Each player has five ships:\nbattleship o o o o o\ncruiser o o o o\nsubmarine o o o\ndestroyer o o\nfrigate o\nThe grids of the players’ fleets may look like this. Any two adjacent squares that are taken must belong to the same ship, i.e., different ships shouldn’t “touch.”\nEach player’s grid is hidden from the other player. Players alternate “shooting” at each other’s ships by calling out a position, a row and column number. A player must make an honest response, “hit” or “miss.” If it’s a hit, a player gets another turn. If the whole ship has been hit, the owner must say something like, “You sank my cruiser.” Each player must keep track of hits and misses. The first player to sink his opponent’s fleet is the winner.\nThe nouns in the specification are program, game, players, grid, ship, battleship, cruiser, submarine, destroyer, frigate, square, position, opponent, row, column, turn, hits, misses, fleet, winner.\n\nEliminate each of the following:\nprogram Always eliminate.\nrow, col These are parts of a given position or square, more suitable as instance variables for a position or square object.\nhits, misses These are simply marked positions and probably don’t need their own class.\nturn Taking a turn is an action and will be described by a method rather than a class.\nopponent This is another word for player.\n\nThe following seem to be good candidates for classes: Player, Grid, Position, Ship, Battleship, Cruiser, Submarine, Destroyer, and Frigate. Additionally, it seems there should be a GameManager and Display.\n\nThis program provides two examples of inheritance relationships. Each of the five ships is-a Ship, and shares common features, like isHit, isSunk, and array of positions. However, each has a unique name, length, and position in the grid. This means that Ship is a good candidate for an abstract class with abstract methods like getLength, getName, and getPositions, which depend on the kind of ship.\nThe second inheritance relationship is between the grids. There are two types of\ngrids for each player: his own FleetGrid (the current state of his own ships) and his opponent’s HitGrid, which keeps track of his hits and misses. Each of these grids is-a Grid. A grid is a candidate for an interface, with a list of methods like getAdjacentNeighbors, getRightNeighbor, etc. Each of FleetGrid and HitGrid would implement Grid.\nThere are several composition relationships in this program. A Player has-a HitGrid and a FleetGrid and also has five ships. The GameManager has each of the two Player objects and also has-a Display. The Display has each of the grids.\n\n\n###\n\n","completion":" Question: Consider the following program description:\n\nA program is to be written that simulates bumper cars in a video game. The cars move on a square grid and are located on grid points (x, y), where x and y are integers between −20 and 20. A bumper car moves in a random direction, either left, right, up, or down. If it reaches a boundary (i.e., x or y is ±20), then it reverses direction. If it is about to collide with another bumper car, it reverses direction. Your program should be able to add bumper cars and run the simulation. One step of the simulation allows each car in the grid to move. After a bumper car has reversed direction twice, its turn is over and the next car gets to move. 19. To identify classes in the program, the nouns in the specification are listed: program, bumper car, grid, grid point, integer, direction, boundary, simulation \n\nA programmer decides to include the following classes in the program.\n• Simulation will run the simulation. \n• Display will show the state of the game. \n• BumperCar will know its identification number, position in the grid, and current direction when moving. \n• GridPoint will be a position in the grid. It will be represented by two integer fields, x_coord and y_coord. \n• Grid will keep track of all bumper cars in the game, the number of cars, and their positions in the grid. It will update the grid each time a car moves. It will be implemented with a two-dimensional array of BumperCar. \n\nWhich operation should not be the responsibility of the GridPoint class? \nCorrect: isEmpty returns false if grid point contains a BumperCar, true otherwise\nIncorrect: atBoundary returns true if x or y coordinate = ±20, false otherwise\nIncorrect: left if not at left boundary, change grid point to 1 unit left of current point\nIncorrect: up if not at top of grid, change grid point to 1 unit above current point\nIncorrect: get_x return x-coordinate of this point\n\nEND"}
{"prompt":"Use the nouns in the specification as a starting point for identifying classes in the program. The nouns are: program, teacher, grade book, class list, class, student, schedule, menu, set of scores, data, record, average, grade, and file. Eliminate each of the following:\nprogram (Always eliminate “program” when used in this context.)\nteacher (Eliminate, because he or she is the user.)\nschedule (This will be reflected in the name of the external file for each class, e.g., apcs_period3.dat.)\ndata, record (These are synonymous with student name, scores, grades, etc., and will be covered by these features.)\nclass (This is synonymous with class list.)\n\nThe following seem to be excellent candidates for classes: GradeBook, ClassList, Student, and FileHandler. Other possibilities are Menu, ScoreList, and a GUI_Display. On further thought: Basic independent objects are Student, Menu, Score, and FileHandler. Group objects are ClassList (collection of students), ScoreList (collection of scores), and AllClasses (collection of ClassLists). The controlling class is the GradeBook. A Display class is essential for many of the grade book operations, like showing a class list or displaying information for a single student.\n\nThere are no inheritance relationships. There are many composition relationships between objects, however. The GradeBook has-a Menu, the ClassList has-a Student (several, in fact!), a Student has-a name, average, grade, list_of_scores, etc. The programmer must decide whether to code these attributes as classes or data fields.\nUse the verbs in the specification to identify required operations in the program. The verbs are: maintain <list>, provide <menu>, allow <user>, create <list>, enter <scores>, correct <data>, display <record>, calculate <average>, calculate <grade>, print <list>, add <student>, delete <student>, transfer <student>, and save <data>.\nYou must make some design decisions about which class is responsible for which behavior. For example, will a ClassList display the record of a single Student, or will a Student display his or her own record? Who will enter scores—the GradeBook, a ClassList, or a Student? Is it desirable for a Student to enter scores of other Students? Probably not!\n\nHere are some preliminary decisions. The GradeBook will provideMenu. The menu selection will send execution to the relevant object.\nThe ClassList will maintain an updated list of each class. It will have these public methods: addStudent, deleteStudent, transferStudent, createNewClass, printClassList, printScores, and updateList. A good candidate for a helper method in this class is search for a given student.\nEach Student will have complete personal and grade information. Public methods will include setName, getName, enterScore, correctData, findAverage, getAverage, getGrade, and displayRecord.\nSaving and retrieving information is crucial to this program. The FileHandler will take care of openFileForReading, openFileForWriting, closeFiles, loadClass, and saveClass. The FileHandler class should be written and tested right at the beginning, using a small dummy class list.\nScore, ScoreList, and Student are easy classes to implement. When these are working, the programmer can go on to ClassList. Finally the Display GUI class, which will have the GradeBook, can be developed. This is an example of bottom-up development.\n\nExample 3\nA program simulates a game of Battleships, which is a game between two players, each of whom has a grid where ships are placed. Each player has five ships:\nbattleship o o o o o\ncruiser o o o o\nsubmarine o o o\ndestroyer o o\nfrigate o\nThe grids of the players’ fleets may look like this. Any two adjacent squares that are taken must belong to the same ship, i.e., different ships shouldn’t “touch.”\nEach player’s grid is hidden from the other player. Players alternate “shooting” at each other’s ships by calling out a position, a row and column number. A player must make an honest response, “hit” or “miss.” If it’s a hit, a player gets another turn. If the whole ship has been hit, the owner must say something like, “You sank my cruiser.” Each player must keep track of hits and misses. The first player to sink his opponent’s fleet is the winner.\nThe nouns in the specification are program, game, players, grid, ship, battleship, cruiser, submarine, destroyer, frigate, square, position, opponent, row, column, turn, hits, misses, fleet, winner.\n\nEliminate each of the following:\nprogram Always eliminate.\nrow, col These are parts of a given position or square, more suitable as instance variables for a position or square object.\nhits, misses These are simply marked positions and probably don’t need their own class.\nturn Taking a turn is an action and will be described by a method rather than a class.\nopponent This is another word for player.\n\nThe following seem to be good candidates for classes: Player, Grid, Position, Ship, Battleship, Cruiser, Submarine, Destroyer, and Frigate. Additionally, it seems there should be a GameManager and Display.\n\nThis program provides two examples of inheritance relationships. Each of the five ships is-a Ship, and shares common features, like isHit, isSunk, and array of positions. However, each has a unique name, length, and position in the grid. This means that Ship is a good candidate for an abstract class with abstract methods like getLength, getName, and getPositions, which depend on the kind of ship.\nThe second inheritance relationship is between the grids. There are two types of\ngrids for each player: his own FleetGrid (the current state of his own ships) and his opponent’s HitGrid, which keeps track of his hits and misses. Each of these grids is-a Grid. A grid is a candidate for an interface, with a list of methods like getAdjacentNeighbors, getRightNeighbor, etc. Each of FleetGrid and HitGrid would implement Grid.\nThere are several composition relationships in this program. A Player has-a HitGrid and a FleetGrid and also has five ships. The GameManager has each of the two Player objects and also has-a Display. The Display has each of the grids.\n\n\n###\n\n","completion":" Question: Consider the following program description:\n\nA program is to be written that simulates bumper cars in a video game. The cars move on a square grid and are located on grid points (x, y), where x and y are integers between −20 and 20. A bumper car moves in a random direction, either left, right, up, or down. If it reaches a boundary (i.e., x or y is ±20), then it reverses direction. If it is about to collide with another bumper car, it reverses direction. Your program should be able to add bumper cars and run the simulation. One step of the simulation allows each car in the grid to move. After a bumper car has reversed direction twice, its turn is over and the next car gets to move. 19. To identify classes in the program, the nouns in the specification are listed: program, bumper car, grid, grid point, integer, direction, boundary, simulation \n\nA programmer decides to include the following classes in the program.\n• Simulation will run the simulation. \n• Display will show the state of the game. \n• BumperCar will know its identification number, position in the grid, and current direction when moving. \n• GridPoint will be a position in the grid. It will be represented by two integer fields, x_coord and y_coord. \n• Grid will keep track of all bumper cars in the game, the number of cars, and their positions in the grid. It will update the grid each time a car moves. It will be implemented with a two-dimensional array of BumperCar. \n\nWhich method is not suitable for the BumperCar class? \nCorrect: public void update()\n\/\/Modify Grid to reflect new position after each stage \n\/\/ of move.\n\nIncorrect: public boolean atBoundary()\n\/\/Returns true if BumperCar at boundary, false otherwise. \nIncorrect: public void selectRandomDirection()\n\/\/Select random direction (up, down, left, or right) \n\/\/ at start of turn. \nIncorrect: public void reverseDirection()\n\/\/Move to grid position that is in direction opposite to \n\/\/ current direction. \nIncorrect: public void move()\n\/\/Take turn to move. Stop move after two changes \n\/\/ of direction. END"}
{"prompt":"Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization—0 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); \/\/calls default constructor of superclass\n}\n\nRules for Subclasses\n• A subclass can add new private instance variables.\n• A subclass can add new public, private, or static methods.\n• A subclass can override inherited methods.\n• A subclass may not redefine a public method as private.\n• A subclass may not override static methods of the superclass.\n• A subclass should define its own constructors.\n• A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won’t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters—for example, new int[] {90,90,100}— will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\n###\n\n","completion":" Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { \/* implementation not shown *\/ }\n\n    public SavingsAccount(double acctBalance, double rate) { \/* implementation not shown *\/ }\n\n    public void addInterest() \/\/ Add interest to balance\n    { \/* implementation not shown *\/ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { \/* implementation not shown *\/ }\n\n    \/**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     *\/\n    public void withdraw(double amount) { \/* implementation not shown *\/ }\n}\n\nOf the methods shown, how many different nonconstructor methods can be invoked by a SavingsAccount object? \nCorrect: 4\nIncorrect: 1\nIncorrect: 2\nIncorrect: 3\nIncorrect: 5\n\nEND"}
{"prompt":"Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization—0 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); \/\/calls default constructor of superclass\n}\n\nRules for Subclasses\n• A subclass can add new private instance variables.\n• A subclass can add new public, private, or static methods.\n• A subclass can override inherited methods.\n• A subclass may not redefine a public method as private.\n• A subclass may not override static methods of the superclass.\n• A subclass should define its own constructors.\n• A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won’t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters—for example, new int[] {90,90,100}— will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\n###\n\n","completion":" Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { \/* implementation not shown *\/ }\n\n    public SavingsAccount(double acctBalance, double rate) { \/* implementation not shown *\/ }\n\n    public void addInterest() \/\/ Add interest to balance\n    { \/* implementation not shown *\/ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { \/* implementation not shown *\/ }\n\n    \/**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     *\/\n    public void withdraw(double amount) { \/* implementation not shown *\/ }\n}\n\nWhich of the following correctly implements the default constructor of the SavingsAccount class? \nI interestRate = 0; \nsuper(); \nII super(); \ninterestRate = 0; \nIII super(); \nCorrect: II and III only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization—0 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); \/\/calls default constructor of superclass\n}\n\nRules for Subclasses\n• A subclass can add new private instance variables.\n• A subclass can add new public, private, or static methods.\n• A subclass can override inherited methods.\n• A subclass may not redefine a public method as private.\n• A subclass may not override static methods of the superclass.\n• A subclass should define its own constructors.\n• A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won’t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters—for example, new int[] {90,90,100}— will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\n###\n\n","completion":" Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { \/* implementation not shown *\/ }\n\n    public SavingsAccount(double acctBalance, double rate) { \/* implementation not shown *\/ }\n\n    public void addInterest() \/\/ Add interest to balance\n    { \/* implementation not shown *\/ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { \/* implementation not shown *\/ }\n\n    \/**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     *\/\n    public void withdraw(double amount) { \/* implementation not shown *\/ }\n}\n\nWhich is a correct implementation of the constructor with parameters in the SavingsAccount class? \nCorrect: super(acctBalance);\ninterestRate = rate; \nIncorrect: balance = acctBalance;\ninterestRate = rate; \nIncorrect: getBalance() = acctBalance;\ninterestRate = rate; \nIncorrect: super();\ninterestRate = rate; \nIncorrect: super(acctBalance, rate);\n\nEND"}
{"prompt":"Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization—0 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); \/\/calls default constructor of superclass\n}\n\nRules for Subclasses\n• A subclass can add new private instance variables.\n• A subclass can add new public, private, or static methods.\n• A subclass can override inherited methods.\n• A subclass may not redefine a public method as private.\n• A subclass may not override static methods of the superclass.\n• A subclass should define its own constructors.\n• A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won’t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters—for example, new int[] {90,90,100}— will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\n###\n\n","completion":" Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { \/* implementation not shown *\/ }\n\n    public SavingsAccount(double acctBalance, double rate) { \/* implementation not shown *\/ }\n\n    public void addInterest() \/\/ Add interest to balance\n    { \/* implementation not shown *\/ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { \/* implementation not shown *\/ }\n\n    \/**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     *\/\n    public void withdraw(double amount) { \/* implementation not shown *\/ }\n}\n\nWhich is a correct implementation of the CheckingAccount constructor? \nI super(acctBalance); \nII super(); \ndeposit(acctBalance); \nIII deposit(acctBalance); \nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: II and III onlyEND"}
{"prompt":"Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization—0 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); \/\/calls default constructor of superclass\n}\n\nRules for Subclasses\n• A subclass can add new private instance variables.\n• A subclass can add new public, private, or static methods.\n• A subclass can override inherited methods.\n• A subclass may not redefine a public method as private.\n• A subclass may not override static methods of the superclass.\n• A subclass should define its own constructors.\n• A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won’t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters—for example, new int[] {90,90,100}— will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\n###\n\n","completion":" Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { \/* implementation not shown *\/ }\n\n    public SavingsAccount(double acctBalance, double rate) { \/* implementation not shown *\/ }\n\n    public void addInterest() \/\/ Add interest to balance\n    { \/* implementation not shown *\/ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { \/* implementation not shown *\/ }\n\n    \/**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     *\/\n    public void withdraw(double amount) { \/* implementation not shown *\/ }\n}\n\nWhich is correct implementation code for the withdraw method in the CheckingAccount class? \nCorrect: super.withdraw(amount);\nif (getBalance() < MIN_BALANCE) \n    super.withdraw(FEE); \nIncorrect: super.withdraw(amount);\nif (balance < MIN_BALANCE) \n    super.withdraw(FEE); \nIncorrect: withdraw(amount);\nif (balance < MIN_BALANCE) \n    withdraw(FEE); \nIncorrect: withdraw(amount);\nif (getBalance() < MIN_BALANCE) \n    withdraw(FEE); \nIncorrect: balance -= amount;\nif (balance < MIN_BALANCE) \n    balance -= FEE; \n\nEND"}
{"prompt":"Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization—0 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); \/\/calls default constructor of superclass\n}\n\nRules for Subclasses\n• A subclass can add new private instance variables.\n• A subclass can add new public, private, or static methods.\n• A subclass can override inherited methods.\n• A subclass may not redefine a public method as private.\n• A subclass may not override static methods of the superclass.\n• A subclass should define its own constructors.\n• A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won’t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters—for example, new int[] {90,90,100}— will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\n###\n\n","completion":" Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { \/* implementation not shown *\/ }\n\n    public SavingsAccount(double acctBalance, double rate) { \/* implementation not shown *\/ }\n\n    public void addInterest() \/\/ Add interest to balance\n    { \/* implementation not shown *\/ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { \/* implementation not shown *\/ }\n\n    \/**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     *\/\n    public void withdraw(double amount) { \/* implementation not shown *\/ }\n}\n\nRedefining the withdraw method in the CheckingAccount class is an example of \nCorrect: method overriding.\nIncorrect: method overloading.\nIncorrect: downcasting.\nIncorrect: dynamic binding (late binding).\nIncorrect: static binding (early binding).\n\nEND"}
{"prompt":"Consider the statements\nStudent s = new GradStudent();\nGradStudent g = new GradStudent();\nint x = s.getID(); \/\/compile-time error\nint y = g.getID(); \/\/legal\nBoth s and g represent GradStudent objects, so why does s.getID() cause an error? The reason is that s is of type Student, and the Student class doesn’t have a getID method. At compile time, only nonprivate methods of the Student class can appear to the right of the dot operator when applied to s. Don’t confuse this with polymor phism: getID is not a polymorphic method. It occurs in just the GradStudent class and can therefore be called only by a GradStudent object.\nThe error shown above can be fixed by casting s to the correct type:\nint x = ((GradStudent) s).getID();\nSince s (of type Student) is actually representing a GradStudent object, such a cast can be carried out. Casting a superclass to a subclass type is called a downcast.\n\nNOTE\n1. The outer parentheses are necessary:\nint x = (GradStudent) s.getID();\nwill still cause an error, despite the cast. This is because the dot operator has\nhigher precedence than casting, so s.getID() is invoked before s is cast to\nGradStudent.\n2. The statement\nint y = g.getID();\ncompiles without problem because g is declared to be of type GradStudent, and this is the class that contains getID. No cast is required.\n\nType Rules for Polymorphic Method Calls\na.method(b)\n\nMethod selected by type of a at run time\nParameter b must be of correct type at compile time\n\n• For a declaration like Superclass a = new Subclass(); the type of a at compile time is Superclass; at run time it is Subclass.\n• At compile time, method must be found in the class of a, that is, in Superclass. (This is true whether the method is polymorphic or not.) If method cannot be found in the class of a, you need to do an explicit cast on a to its actual type.\n• For a polymorphic method, at run time the actual type of a is determined—Subclass in this example—and method is selected from Subclass. This could be an inherited method if there is no overriding method.\n• The type of parameter b is checked at compile time. You may need to do an explicit cast to the subclass type to make this correct.\n\nThe ClassCastException is a run-time exception thrown to signal an attempt to cast an object to a class of which it is not an instance.\nStudent u = new UnderGrad();\nSystem.out.println((String) u); \/\/ClassCastException\n\/\/u is not an instance of String\nint x = ((GradStudent) u).getID(); \/\/ClassCastException\n\/\/u is not an instance of GradStudent\n\n\n###\n\n","completion":" Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { \/* implementation not shown *\/ }\n\n    public SavingsAccount(double acctBalance, double rate) { \/* implementation not shown *\/ }\n\n    public void addInterest() \/\/ Add interest to balance\n    { \/* implementation not shown *\/ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { \/* implementation not shown *\/ }\n\n    \/**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     *\/\n    public void withdraw(double amount) { \/* implementation not shown *\/ }\n}\n\nA program to test the BankAccount, SavingsAccount, and CheckingAccount classes has these declarations: \nBankAccount b = new BankAccount(1400); \nBankAccount s = new SavingsAccount(1000, 0.04); \nBankAccount c = new CheckingAccount(500); \n\nWhich method call will cause an error? \nCorrect: s.addInterest();\n\n\nIncorrect: b.deposit(200);\nIncorrect: s.withdraw(500);\nIncorrect: c.withdraw(500);\nIncorrect: s.deposit(10000);END"}
{"prompt":"Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization—0 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); \/\/calls default constructor of superclass\n}\n\nRules for Subclasses\n• A subclass can add new private instance variables.\n• A subclass can add new public, private, or static methods.\n• A subclass can override inherited methods.\n• A subclass may not redefine a public method as private.\n• A subclass may not override static methods of the superclass.\n• A subclass should define its own constructors.\n• A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won’t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters—for example, new int[] {90,90,100}— will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\n###\n\n","completion":" Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { \/* implementation not shown *\/ }\n\n    public SavingsAccount(double acctBalance, double rate) { \/* implementation not shown *\/ }\n\n    public void addInterest() \/\/ Add interest to balance\n    { \/* implementation not shown *\/ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { \/* implementation not shown *\/ }\n\n    \/**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     *\/\n    public void withdraw(double amount) { \/* implementation not shown *\/ }\n}\n\nA program to test the BankAccount, SavingsAccount, and CheckingAccount classes has these declarations: \nBankAccount b = new BankAccount(1400); \nBankAccount s = new SavingsAccount(1000, 0.04); \nBankAccount c = new CheckingAccount(500); \n\nIn order to test polymorphism, which method must be used in the program? \nCorrect: withdraw\nIncorrect: Either a SavingsAccount constructor or a CheckingAccount constructor\nIncorrect: addInterest\nIncorrect: deposit\nIncorrect: getBalance\n\nEND"}
{"prompt":"Consider the statements\nStudent s = new GradStudent();\nGradStudent g = new GradStudent();\nint x = s.getID(); \/\/compile-time error\nint y = g.getID(); \/\/legal\nBoth s and g represent GradStudent objects, so why does s.getID() cause an error? The reason is that s is of type Student, and the Student class doesn’t have a getID method. At compile time, only nonprivate methods of the Student class can appear to the right of the dot operator when applied to s. Don’t confuse this with polymor phism: getID is not a polymorphic method. It occurs in just the GradStudent class and can therefore be called only by a GradStudent object.\nThe error shown above can be fixed by casting s to the correct type:\nint x = ((GradStudent) s).getID();\nSince s (of type Student) is actually representing a GradStudent object, such a cast can be carried out. Casting a superclass to a subclass type is called a downcast.\n\nNOTE\n1. The outer parentheses are necessary:\nint x = (GradStudent) s.getID();\nwill still cause an error, despite the cast. This is because the dot operator has\nhigher precedence than casting, so s.getID() is invoked before s is cast to\nGradStudent.\n2. The statement\nint y = g.getID();\ncompiles without problem because g is declared to be of type GradStudent, and this is the class that contains getID. No cast is required.\n\nType Rules for Polymorphic Method Calls\na.method(b)\n\nMethod selected by type of a at run time\nParameter b must be of correct type at compile time\n\n• For a declaration like Superclass a = new Subclass(); the type of a at compile time is Superclass; at run time it is Subclass.\n• At compile time, method must be found in the class of a, that is, in Superclass. (This is true whether the method is polymorphic or not.) If method cannot be found in the class of a, you need to do an explicit cast on a to its actual type.\n• For a polymorphic method, at run time the actual type of a is determined—Subclass in this example—and method is selected from Subclass. This could be an inherited method if there is no overriding method.\n• The type of parameter b is checked at compile time. You may need to do an explicit cast to the subclass type to make this correct.\n\nThe ClassCastException is a run-time exception thrown to signal an attempt to cast an object to a class of which it is not an instance.\nStudent u = new UnderGrad();\nSystem.out.println((String) u); \/\/ClassCastException\n\/\/u is not an instance of String\nint x = ((GradStudent) u).getID(); \/\/ClassCastException\n\/\/u is not an instance of GradStudent\n\n\n###\n\n","completion":" Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { \/* implementation not shown *\/ }\n\n    public SavingsAccount(double acctBalance, double rate) { \/* implementation not shown *\/ }\n\n    public void addInterest() \/\/ Add interest to balance\n    { \/* implementation not shown *\/ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { \/* implementation not shown *\/ }\n\n    \/**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     *\/\n    public void withdraw(double amount) { \/* implementation not shown *\/ }\n}\n\nA program to test the BankAccount, SavingsAccount, and CheckingAccount classes has these declarations: \nBankAccount b = new BankAccount(1400); \nBankAccount s = new SavingsAccount(1000, 0.04); \nBankAccount c = new CheckingAccount(500); \n\nWhich of the following will not cause a ClassCastException to be thrown? \nCorrect: ((CheckingAccount) c).deposit(800);\nIncorrect: ((SavingsAccount) b).addInterest();\nIncorrect: ((CheckingAccount) b).withdraw(200);\nIncorrect: ((CheckingAccount) s).withdraw(150);\nIncorrect: ((SavingsAccount) c).addInterest();\n\nEND"}
{"prompt":"Consider the statements\nStudent s = new GradStudent();\nGradStudent g = new GradStudent();\nint x = s.getID(); \/\/compile-time error\nint y = g.getID(); \/\/legal\nBoth s and g represent GradStudent objects, so why does s.getID() cause an error? The reason is that s is of type Student, and the Student class doesn’t have a getID method. At compile time, only nonprivate methods of the Student class can appear to the right of the dot operator when applied to s. Don’t confuse this with polymor phism: getID is not a polymorphic method. It occurs in just the GradStudent class and can therefore be called only by a GradStudent object.\nThe error shown above can be fixed by casting s to the correct type:\nint x = ((GradStudent) s).getID();\nSince s (of type Student) is actually representing a GradStudent object, such a cast can be carried out. Casting a superclass to a subclass type is called a downcast.\n\nNOTE\n1. The outer parentheses are necessary:\nint x = (GradStudent) s.getID();\nwill still cause an error, despite the cast. This is because the dot operator has\nhigher precedence than casting, so s.getID() is invoked before s is cast to\nGradStudent.\n2. The statement\nint y = g.getID();\ncompiles without problem because g is declared to be of type GradStudent, and this is the class that contains getID. No cast is required.\n\nType Rules for Polymorphic Method Calls\na.method(b)\n\nMethod selected by type of a at run time\nParameter b must be of correct type at compile time\n\n• For a declaration like Superclass a = new Subclass(); the type of a at compile time is Superclass; at run time it is Subclass.\n• At compile time, method must be found in the class of a, that is, in Superclass. (This is true whether the method is polymorphic or not.) If method cannot be found in the class of a, you need to do an explicit cast on a to its actual type.\n• For a polymorphic method, at run time the actual type of a is determined—Subclass in this example—and method is selected from Subclass. This could be an inherited method if there is no overriding method.\n• The type of parameter b is checked at compile time. You may need to do an explicit cast to the subclass type to make this correct.\n\nThe ClassCastException is a run-time exception thrown to signal an attempt to cast an object to a class of which it is not an instance.\nStudent u = new UnderGrad();\nSystem.out.println((String) u); \/\/ClassCastException\n\/\/u is not an instance of String\nint x = ((GradStudent) u).getID(); \/\/ClassCastException\n\/\/u is not an instance of GradStudent\n\n\n###\n\n","completion":" Question: Consider the BankAccount, SavingsAccount, and CheckingAccount classes defined below:\n\npublic class BankAccount {\n    private double balance;\n\n    public BankAccount() { balance = 0; }\n\n    public BankAccount(double acctBalance) { balance = acctBalance; }\n\n    public void deposit(double amount) { balance += amount; }\n\n    public void withdraw(double amount) { balance -= amount; }\n\n    public double getBalance() { return balance; }\n}\n\npublic class SavingsAccount extends BankAccount {\n    private double interestRate;\n\n    public SavingsAccount() { \/* implementation not shown *\/ }\n\n    public SavingsAccount(double acctBalance, double rate) { \/* implementation not shown *\/ }\n\n    public void addInterest() \/\/ Add interest to balance\n    { \/* implementation not shown *\/ }\n}\n\npublic class CheckingAccount extends BankAccount {\n    private static final double FEE = 2.0;\n    private static final double MIN_BALANCE = 50.0;\n\n    public CheckingAccount(double acctBalance) { \/* implementation not shown *\/ }\n\n    \/**\n     * FEE of $2 deducted if withdrawal leaves balance less\n     * than MIN_BALANCE. Allows for negative balance.\n     *\/\n    public void withdraw(double amount) { \/* implementation not shown *\/ }\n}\n\nA new method is added to the BankAccount class. \n\n\/** Transfer amount from this BankAccount to another BankAccount. \n* Precondition: balance > amount \n* @param another a different BankAccount object \n* @param amount the amount to be transferred \n*\/ \npublic void transfer(BankAccount another, double amount) \n{ \n    withdraw(amount); \n    another.deposit(amount); \n} \n\nA program has these declarations: \nBankAccount b = new BankAccount(650); \nSavingsAccount timsSavings = new SavingsAccount(1500, 0.03); \nCheckingAccount daynasChecking = new CheckingAccount(2000); \n\nWhich of the following will transfer money from one account to another without error? \nI b.transfer(timsSavings, 50); \nII timsSavings.transfer(daynasChecking, 30); \nIII daynasChecking.transfer(b, 55); \nCorrect: I, II, and III\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: None\n\nEND"}
{"prompt":"Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization—0 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); \/\/calls default constructor of superclass\n}\n\nRules for Subclasses\n• A subclass can add new private instance variables.\n• A subclass can add new public, private, or static methods.\n• A subclass can override inherited methods.\n• A subclass may not redefine a public method as private.\n• A subclass may not override static methods of the superclass.\n• A subclass should define its own constructors.\n• A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won’t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters—for example, new int[] {90,90,100}— will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\n###\n\n","completion":" Question: Consider these class declarations: \n\npublic class Person \n{ \n    ... \n} \npublic class Teacher extends Person \n{ \n    ... \n} \n\nWhich is a true statement? \nI Teacher inherits the constructors of Person. \nII Teacher can add new methods and private instance variables. \nIII Teacher can override existing private methods of Person. \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: II and III only\n\nEND"}
{"prompt":"Consider writing a program that simulates a game of Battleships. The program may have a Ship class with subclasses Submarine, Cruiser, Destroyer, and so on. The various ships will be placed in a two-dimensional grid that represents a part of the ocean.\nAn abstract class Ship is a good design choice. There will not be any instances of Ship objects because the specific features of the subclasses must be known in order to place these ships in the grid. A Grid interface that manipulates objects in a two dimensional setting suggests itself for the two-dimensional grid.\nNotice that the abstract Ship class is specific to the Battleships application, whereas the Grid interface is not. You could use the Grid interface in any program that has a two-dimensional grid.\n\nInterface vs. Abstract Class\n• Use an abstract class for an object that is application-specific\nbut incomplete without its subclasses.\n• Consider using an interface when its methods are suitable\nfor your program but could be equally applicable in a vari\nety of programs.\n• An interface typically doesn’t provide implementations for\nany of its methods, whereas an abstract class does. (In Java 8,\nimplementation of default methods is allowed in interfaces.)\n• An interface cannot contain instance variables, whereas an\nabstract class can.\n• It is not possible to create an instance of an interface object\nor an abstract class object.\n\n\n###\n\n","completion":" Question: Which statement about abstract classes and interfaces is false? \nCorrect: All of the methods in both an abstract class and an interface are public.\n\n\nIncorrect: An interface cannot implement any non-default instance methods, whereas\nan abstract class can. \nIncorrect: A class can implement many interfaces but can have only one superclass.\nIncorrect: An unlimited number of unrelated classes can implement the same inter\nface. \nIncorrect: It is not possible to construct either an abstract class object or an interface\nobject. END"}
{"prompt":"Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization—0 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); \/\/calls default constructor of superclass\n}\n\nRules for Subclasses\n• A subclass can add new private instance variables.\n• A subclass can add new public, private, or static methods.\n• A subclass can override inherited methods.\n• A subclass may not redefine a public method as private.\n• A subclass may not override static methods of the superclass.\n• A subclass should define its own constructors.\n• A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won’t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters—for example, new int[] {90,90,100}— will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\n###\n\n","completion":" Question: Consider the classes defined below:\n\npublic class ClassA \n{ \n    \/\/default constructor not shown ... \n    public void method1() \n    { \/* implementation of method1 *\/ } \n} \n\npublic class ClassB extends ClassA \n{ \n    \/\/default constructor not shown ... \n    public void method1() \n    { \/* different implementation from method1 in ClassA*\/ } \n\n    public void method2() \n    { \/* implementation of method2 *\/ } \n} \n\nThe method1 method in ClassB is an example of \nCorrect: method overriding.\nIncorrect: method overloading.\nIncorrect: polymorphism.\nIncorrect: information hiding.\nIncorrect: procedural abstraction.\n\nEND"}
{"prompt":"Consider the statements\nStudent s = new GradStudent();\nGradStudent g = new GradStudent();\nint x = s.getID(); \/\/compile-time error\nint y = g.getID(); \/\/legal\nBoth s and g represent GradStudent objects, so why does s.getID() cause an error? The reason is that s is of type Student, and the Student class doesn’t have a getID method. At compile time, only nonprivate methods of the Student class can appear to the right of the dot operator when applied to s. Don’t confuse this with polymor phism: getID is not a polymorphic method. It occurs in just the GradStudent class and can therefore be called only by a GradStudent object.\nThe error shown above can be fixed by casting s to the correct type:\nint x = ((GradStudent) s).getID();\nSince s (of type Student) is actually representing a GradStudent object, such a cast can be carried out. Casting a superclass to a subclass type is called a downcast.\n\nNOTE\n1. The outer parentheses are necessary:\nint x = (GradStudent) s.getID();\nwill still cause an error, despite the cast. This is because the dot operator has\nhigher precedence than casting, so s.getID() is invoked before s is cast to\nGradStudent.\n2. The statement\nint y = g.getID();\ncompiles without problem because g is declared to be of type GradStudent, and this is the class that contains getID. No cast is required.\n\nType Rules for Polymorphic Method Calls\na.method(b)\n\nMethod selected by type of a at run time\nParameter b must be of correct type at compile time\n\n• For a declaration like Superclass a = new Subclass(); the type of a at compile time is Superclass; at run time it is Subclass.\n• At compile time, method must be found in the class of a, that is, in Superclass. (This is true whether the method is polymorphic or not.) If method cannot be found in the class of a, you need to do an explicit cast on a to its actual type.\n• For a polymorphic method, at run time the actual type of a is determined—Subclass in this example—and method is selected from Subclass. This could be an inherited method if there is no overriding method.\n• The type of parameter b is checked at compile time. You may need to do an explicit cast to the subclass type to make this correct.\n\nThe ClassCastException is a run-time exception thrown to signal an attempt to cast an object to a class of which it is not an instance.\nStudent u = new UnderGrad();\nSystem.out.println((String) u); \/\/ClassCastException\n\/\/u is not an instance of String\nint x = ((GradStudent) u).getID(); \/\/ClassCastException\n\/\/u is not an instance of GradStudent\n\n\n###\n\n","completion":" Question: Consider the classes defined below:\n\npublic class ClassA \n{ \n    \/\/default constructor not shown ... \n    public void method1() \n    { \/* implementation of method1 *\/ } \n} \n\npublic class ClassB extends ClassA \n{ \n    \/\/default constructor not shown ... \n    public void method1() \n    { \/* different implementation from method1 in ClassA*\/ } \n\n    public void method2() \n    { \/* implementation of method2 *\/ } \n} \n\nConsider the following declarations in a client class. \n\nClassA ob1 = new ClassA(); \nClassA ob2 = new ClassB(); \n\nWhich of the following method calls will cause an error? \nI ob1.method2(); \nII ob2.method2(); \nIII ((ClassB) ob1).method2(); \nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and III onlyEND"}
{"prompt":"An abstract class is a superclass that represents an abstract concept, and therefore should not be instantiated. For example, a maze program could have several different maze components—paths, walls, entrances, and exits. All of these share certain features (e.g., location, and a way of displaying). They can therefore all be declared as subclasses of the abstract class MazeComponent. The program will create path objects, wall objects, and so on, but no instances of MazeComponent.\nAn abstract class may contain abstract methods. An abstract method has no imple mentation code, just a header. The rationale for an abstract method is that there is no good default code for the method. Every subclass will need to override this method, so why bother with a meaningless implementation in the superclass? The method appears in the abstract class as a placeholder. The implementation for the method oc curs in the subclasses. If a class contains any abstract methods, it must be declared an abstract class.\n\nAn abstract class is declared with the keyword abstract in the header:\npublic abstract class AbstractClass\n{ ...\nThe keyword extends is used as before to declare a subclass:\npublic class SubClass extends AbstractClass\n{ ...\nIf a subclass of an abstract class does not provide implementation code for all the abstract methods of its superclass, it too becomes an abstract class and must be declared as such to avoid a compile-time error:\npublic abstract class SubClass extends AbstractClass\n{ ...\nHere is an example of an abstract class, with two concrete (nonabstract) subclasses.\n\npublic abstract class Shape {\n    private String name;\n\n    \/\/ constructor\n    public Shape(String shapeName) {\n        name = shapeName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double area();\n\n    public abstract double perimeter();\n\n    public double semiPerimeter() {\n        return perimeter() \/ 2;\n    }\n}\n\npublic class Circle extends Shape {\n    private double radius;\n\n    \/\/ constructor\n    public Circle(double circleRadius, String circleName) {\n        super(circleName);\n        radius = circleRadius;\n    }\n\n    public double perimeter() {\n        return 2 * Math.PI * radius;\n    }\n\n    public double area() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class Square extends Shape {\n    private double side;\n\n    \/\/ constructor\n    public Square(double squareSide, String squareName) {\n        super(squareName);\n        side = squareSide;\n    }\n\n    public double perimeter() {\n        return 4 * side;\n    }\n\n    public double area() {\n        return side * side;\n    }\n}\n\nNOTE\n1. It is meaningless to define perimeter and area methods for Shape—thus, these are declared as abstract methods.\n2. An abstract class can have both instance variables and concrete (nonabstract) methods. See, for example, name, getName, and semiPerimeter in the Shape class.\n3. Abstract methods are declared with the keyword abstract. There is no method body. The header is terminated with a semicolon.\n4. A concrete (non-abstract) subclass of an abstract superclass must provide implementation code for all abstract methods of the superclass. Therefore both the Circle and Square classes implement both the perimeter and area methods.\n5. It is possible for an abstract class to have no abstract methods. (An abstract subclass of an abstract superclass inherits the abstract methods without explicitly declaring them.)\n6. An abstract class may or may not have constructors.\n7. No instances can be created for an abstract class:\nShape a = new Shape(\"blob\"); \/\/Illegal.\n\/\/Can’t create instance of abstract class.\nShape c = new Circle(1.5, \"small circle\"); \/\/legal\n8. Polymorphism works with abstract classes as it does with concrete classes:\nShape circ = new Circle(10, \"circle\");\nShape sq = new Square(9.4, \"square\");\nShape s = null;\nSystem.out.println(\"Which shape?\");\nString str = IO.readString(); \/\/read user input\nif (str.equals(\"circle\"))\n    s = circ;\nelse\n    s = sq;\nSystem.out.println(\"Area of \" + s.getName() + \" is \" + s.area());\n\n\n###\n\n","completion":" Question: Consider the classes defined below:\n\npublic abstract class Solid {\n    private String name;\n\n    \/\/ constructor\n    public Solid(String solidName) {\n        name = solidName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double volume();\n}\n\npublic class Sphere extends Solid {\n    private double radius;\n\n    \/\/ constructor\n    public Sphere(String sphereName, double sphereRadius) {\n        super(sphereName);\n        radius = sphereRadius;\n    }\n\n    public double volume() {\n        return (4.0 \/ 3.0) * Math.PI * radius * radius * radius;\n    }\n}\n\npublic class RectangularPrism extends Solid {\n    private double length;\n    private double width;\n    private double height;\n\n    \/\/ constructor\n    public RectangularPrism(String prismName, double l, double w, double h) {\n        super(prismName);\n        length = l;\n        width = w;\n        height = h;\n    }\n\n    public double volume() {\n        return length * width * height;\n    }\n}\n\nA program that tests these classes has the following declarations and assignments: \nSolid s1, s2, s3, s4; \ns1 = new Solid(\"blob\"); \ns2 = new Sphere(\"sphere\", 3.8); \ns3 = new RectangularPrism(\"box\", 2, 4, 6.5); \ns4 = null; \n\nHow many of the above lines of code are incorrect? \nCorrect: 1\nIncorrect: 0\nIncorrect: 2\nIncorrect: 3\nIncorrect: 4\n\nEND"}
{"prompt":"An abstract class is a superclass that represents an abstract concept, and therefore should not be instantiated. For example, a maze program could have several different maze components—paths, walls, entrances, and exits. All of these share certain features (e.g., location, and a way of displaying). They can therefore all be declared as subclasses of the abstract class MazeComponent. The program will create path objects, wall objects, and so on, but no instances of MazeComponent.\nAn abstract class may contain abstract methods. An abstract method has no imple mentation code, just a header. The rationale for an abstract method is that there is no good default code for the method. Every subclass will need to override this method, so why bother with a meaningless implementation in the superclass? The method appears in the abstract class as a placeholder. The implementation for the method oc curs in the subclasses. If a class contains any abstract methods, it must be declared an abstract class.\n\nAn abstract class is declared with the keyword abstract in the header:\npublic abstract class AbstractClass\n{ ...\nThe keyword extends is used as before to declare a subclass:\npublic class SubClass extends AbstractClass\n{ ...\nIf a subclass of an abstract class does not provide implementation code for all the abstract methods of its superclass, it too becomes an abstract class and must be declared as such to avoid a compile-time error:\npublic abstract class SubClass extends AbstractClass\n{ ...\nHere is an example of an abstract class, with two concrete (nonabstract) subclasses.\n\npublic abstract class Shape {\n    private String name;\n\n    \/\/ constructor\n    public Shape(String shapeName) {\n        name = shapeName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double area();\n\n    public abstract double perimeter();\n\n    public double semiPerimeter() {\n        return perimeter() \/ 2;\n    }\n}\n\npublic class Circle extends Shape {\n    private double radius;\n\n    \/\/ constructor\n    public Circle(double circleRadius, String circleName) {\n        super(circleName);\n        radius = circleRadius;\n    }\n\n    public double perimeter() {\n        return 2 * Math.PI * radius;\n    }\n\n    public double area() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class Square extends Shape {\n    private double side;\n\n    \/\/ constructor\n    public Square(double squareSide, String squareName) {\n        super(squareName);\n        side = squareSide;\n    }\n\n    public double perimeter() {\n        return 4 * side;\n    }\n\n    public double area() {\n        return side * side;\n    }\n}\n\nNOTE\n1. It is meaningless to define perimeter and area methods for Shape—thus, these are declared as abstract methods.\n2. An abstract class can have both instance variables and concrete (nonabstract) methods. See, for example, name, getName, and semiPerimeter in the Shape class.\n3. Abstract methods are declared with the keyword abstract. There is no method body. The header is terminated with a semicolon.\n4. A concrete (non-abstract) subclass of an abstract superclass must provide implementation code for all abstract methods of the superclass. Therefore both the Circle and Square classes implement both the perimeter and area methods.\n5. It is possible for an abstract class to have no abstract methods. (An abstract subclass of an abstract superclass inherits the abstract methods without explicitly declaring them.)\n6. An abstract class may or may not have constructors.\n7. No instances can be created for an abstract class:\nShape a = new Shape(\"blob\"); \/\/Illegal.\n\/\/Can’t create instance of abstract class.\nShape c = new Circle(1.5, \"small circle\"); \/\/legal\n8. Polymorphism works with abstract classes as it does with concrete classes:\nShape circ = new Circle(10, \"circle\");\nShape sq = new Square(9.4, \"square\");\nShape s = null;\nSystem.out.println(\"Which shape?\");\nString str = IO.readString(); \/\/read user input\nif (str.equals(\"circle\"))\n    s = circ;\nelse\n    s = sq;\nSystem.out.println(\"Area of \" + s.getName() + \" is \" + s.area());\n\n\n###\n\n","completion":" Question: Consider the classes defined below:\n\npublic abstract class Solid {\n    private String name;\n\n    \/\/ constructor\n    public Solid(String solidName) {\n        name = solidName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double volume();\n}\n\npublic class Sphere extends Solid {\n    private double radius;\n\n    \/\/ constructor\n    public Sphere(String sphereName, double sphereRadius) {\n        super(sphereName);\n        radius = sphereRadius;\n    }\n\n    public double volume() {\n        return (4.0 \/ 3.0) * Math.PI * radius * radius * radius;\n    }\n}\n\npublic class RectangularPrism extends Solid {\n    private double length;\n    private double width;\n    private double height;\n\n    \/\/ constructor\n    public RectangularPrism(String prismName, double l, double w, double h) {\n        super(prismName);\n        length = l;\n        width = w;\n        height = h;\n    }\n\n    public double volume() {\n        return length * width * height;\n    }\n}\n\nWhich is false? \nCorrect: Since Solid is abstract and its subclasses are nonabstract, polymorphism no longer applies when these classes are used in a program.\n\n\nIncorrect: If a program has several objects declared as type Solid, the decision about which volume method to call will be resolved at run time.\nIncorrect: If the Solid class were modified to provide a default implementation for the volume method, it would no longer need to be an abstract class.\nIncorrect: If the Sphere and RectangularPrism classes failed to provide an implementation for the volume method, they would need to be declared as abstract classes.\nIncorrect: The fact that there is no reasonable default implementation for the volume method in the Solid class suggests that it should be an abstract method.END"}
{"prompt":"Any public method in a superclass can be overridden in a subclass by defining a method with the same return type and signature (name and parameter types). For example, the computeGrade method in the UnderGrad subclass overrides the computeGrade method in the Student superclass.\nSometimes the code for overriding a method includes a call to the superclass method. This is called partial overriding. Typically this occurs when the subclass method wants to do what the superclass does, plus something extra. This is achieved by using the keyword super in the implementation. The computeGrademethod in the GradStudent subclass partially overrides the matching method in the Student class. The statement\nsuper.computeGrade();\nsignals that the computeGrade method in the superclass should be invoked here. The additional test\nif (getTestAverage() >= 90)\n    ...\nallows a GradStudent to have a grade Pass with distinction. Note that this option is open to GradStudents only.\n\nNOTE\nPrivate methods cannot be overridden.\nConstructors are never inherited! If no constructor is written for a subclass, the superclass default constructor with no parameters is generated. If the superclass does not have a default (zero-parameter) constructor, but only a constructor with parameters, a compiler error will occur. If there is a default constructor in the superclass, inherited data members will be initialized as for the superclass. Additional instance variables in the subclass will get a default initialization—0 for primitive types and null for reference types.\n\nA subclass constructor can be implemented with a call to the super method, which invokes the superclass constructor. For example, the default constructor in the UnderGrad class is identical to that of the Student class. This is implemented with the statement\nsuper();\n\nThe second constructor in the UnderGrad class is called with parameters that match those in the constructor of the Student superclass.\npublic UnderGrad(String studName, int[] studTests, String studGrade) { super(studName, studTests, studGrade); }\nFor each constructor, the call to super has the effect of initializing the instance vari ables name, tests, and grade exactly as they are initialized in the Student class. Contrast this with the constructors in GradStudent. In each case, the instance vari ables name, tests, and grade are initialized as for the Student class. Then the new instance variable, gradID, must be explicitly initialized.\npublic GradStudent()\n{\n    super();\n    gradID = 0;\n}\npublic GradStudent(String studName, int[] studTests,\nString studGrade, int gradStudID)\n{\n    super(studName, studTests, studGrade);\n    gradID = gradStudID;\n}\n\nNOTE\n1. If super is used in the implementation of a subclass constructor, it must be used in the first line of the constructor body.\n2. If no constructor is provided in a subclass, the compiler provides the following default constructor:\npublic SubClass()\n{\nsuper(); \/\/calls default constructor of superclass\n}\n\nRules for Subclasses\n• A subclass can add new private instance variables.\n• A subclass can add new public, private, or static methods.\n• A subclass can override inherited methods.\n• A subclass may not redefine a public method as private.\n• A subclass may not override static methods of the superclass.\n• A subclass should define its own constructors.\n• A subclass cannot directly access the private members of its superclass. It must use accessor or mutator methods.\nWhen a superclass object is declared in a client program, that reference can refer not only to an object of the superclass, but also to objects of any of its subclasses. Thus, each of the following is legal:\nStudent s = new Student();\nStudent g = new GradStudent();\nStudent u = new UnderGrad();\nThis works because a GradStudent is-a Student, and an UnderGrad is-a Student.\nNote that since a Student is not necessarily a GradStudent nor an UnderGrad, the following declarations are not valid:\nGradStudent g = new Student();\nUnderGrad u = new Student();\nConsider these valid declarations:\nStudent s = new Student(\"Brian Lorenzen\", new int[] {90,94,99},\n\"none\");\nStudent u = new UnderGrad(\"Tim Broder\", new int[] {90,90,100},\n\"none\");\nStudent g = new GradStudent(\"Kevin Cristella\",\nnew int[] {85,70,90}, \"none\", 1234);\nSuppose you make the method call\ns.setGrade(\"Pass\");\nThe appropriate method in Student is found and the new grade assigned. The method calls\ng.setGrade(\"Pass\");\nand\nu.setGrade(\"Pass\");\nachieve the same effect on g and u since GradStudent and UnderGrad both inherit the setGrade method from Student. The following method calls, however, won’t work:\nint studentNum = s.getID();\nint underGradNum = u.getID();\nNeither Student s nor UnderGrad u inherit the getID method from the GradStudent class: A superclass does not inherit from a subclass.\nNow consider the following valid method calls:\ns.computeGrade();\ng.computeGrade();\nu.computeGrade();\nSince s, g, and u have all been declared to be of type Student, will the appropriate method be executed in each case? That is the topic of the next section, polymorphism.\n\nNOTE\nThe initializer list syntax used in constructing the array parameters—for example, new int[] {90,90,100}— will not be tested on the AP exam.\nA method that has been overridden in at least one subclass is said to be polymorphic. An example is computeGrade, which is redefined for both GradStudent and UnderGrad. Polymorphism is the mechanism of selecting the appropriate method for a particu lar object in a class hierarchy. The correct method is chosen because, in Java, method calls are always determined by the type of the actual object, not the type of the ob ject reference. For example, even though s, g, and u are all declared as type Student, s.computeGrade(), g.computeGrade(), and u.computeGrade() will all perform the correct operations for their particular instances. In Java, the selection of the correct method occurs during the run of the program.\n\n\n###\n\n","completion":" Question: Consider the classes defined below:\n\npublic abstract class Solid {\n    private String name;\n\n    \/\/ constructor\n    public Solid(String solidName) {\n        name = solidName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double volume();\n}\n\npublic class Sphere extends Solid {\n    private double radius;\n\n    \/\/ constructor\n    public Sphere(String sphereName, double sphereRadius) {\n        super(sphereName);\n        radius = sphereRadius;\n    }\n\n    public double volume() {\n        return (4.0 \/ 3.0) * Math.PI * radius * radius * radius;\n    }\n}\n\npublic class RectangularPrism extends Solid {\n    private double length;\n    private double width;\n    private double height;\n\n    \/\/ constructor\n    public RectangularPrism(String prismName, double l, double w, double h) {\n        super(prismName);\n        length = l;\n        width = w;\n        height = h;\n    }\n\n    public double volume() {\n        return length * width * height;\n    }\n}\n\nHere is a program that prints the volume of a solid: \npublic class SolidMain {\n    \/** Output volume of Solid s. *\/\n    public static void printVolume(Solid s) {\n        System.out.println(\"Volume = \" + s.volume() + \" cubic units\");\n    }\n\n    public static void main(String[] args) {\n        Solid sol;\n        Solid sph = new Sphere(\"sphere\", 4);\n        Solid rec = new RectangularPrism(\"box\", 3, 6, 9);\n        int flipCoin = (int) (Math.random() * 2); \/\/ 0 or 1\n        if (flipCoin == 0)\n            sol = sph;\n        else\n            sol = rec;\n        printVolume(sol);\n    }\n}\n\nWhich is a true statement about this program? \nCorrect: It will output the volume of the sphere or box, as intended.\nIncorrect: It will output the volume of the default Solid s, which is neither a sphere nor a box.\nIncorrect: A ClassCastException will be thrown.\nIncorrect: A compile-time error will occur because there is no implementation code for volume in the Solid class.\nIncorrect: A run-time error will occur because of parameter type mismatch in the method call printVolume(sol).\n\nEND"}
{"prompt":"An interface is a collection of related methods, either abstract (headers only) or default (implementation provided in the interface). Default methods are new in Java 8, and will not be tested on the AP exam. Non-default (i.e., abstract) methods will be tested on the exam and are discussed below.\nStudents may be required to design, create, or modify classes that implement inter faces with abstract methods.\nThe non-default methods are both public and abstract—no need to explicitly include these keywords. As such, they provide a framework of behavior for any class.\nThe classes that implement a given interface may represent objects that are vastly different. They all, however, have in common a capability or feature expressed in the methods of the interface. An interface called FlyingObject, for example, may have the methods fly and isFlying. Some classes that implement FlyingObject could be Bird, Airplane, Missile, Butterfly, and Witch. A class called Turtle would be unlikely to implement FlyingObject because turtles don’t fly.\nAn interface called Computable may have just three methods: add, subtract, and multiply. Classes that implement Computable could be Fraction, Matrix, LongInteger, and ComplexNumber. It would not be meaningful, however, for a TelevisionSet to implement Computable—what does it mean, for example, to mul tiply two TelevisionSet objects?\nA class that implements an interface can define any number of methods. In par\n\nticular, it contracts to provide implementations for all the non-default (i.e., abstract) methods declared in the interface. If it fails to implement any of the methods, the class must be declared abstract.\nA nonabstract class that implements an interface must\nimplement every abstract method of the interface.\n\nAn interface is declared with the interface keyword. For example,\npublic interface FlyingObject\n{\n    void fly(); \/\/method that simulates flight of object\n    boolean isFlying(); \/\/true if object is in flight,\n    \/\/false otherwise\n}\n\nInterfaces are implemented using the implements keyword. For example,\npublic class Bird implements FlyingObject\n{\n...\nThis declaration means that two of the methods in the Bird class must be fly and isFlying. Note that any subclass of Bird will automatically implement the interface FlyingObject, since fly and isFlying will be inherited by the subclass.\nA class that extends a superclass can also directly implement an interface. For exam ple,\npublic class Mosquito extends Insect implements FlyingObject\n{\n...\n\nNOTE\n1. The extends clause must precede the implements clause.\n2. A class can have just one superclass, but it can implement any number of interfaces:\npublic class SubClass extends SuperClass\nimplements Interface1, Interface2, ...\n\n\n###\n\n","completion":" Question: Consider the Computable interface below for performing simple calculator operations: \npublic interface Computable \n{ \n    \/** Return this Object + y. *\/ \n    Object add(Object y); \n\n    \/** Return this Object - y. *\/ \n    Object subtract(Object y); \n\n    \/** Return this Object * y. *\/ \n    Object multiply(Object y); \n} \n\nWhich of the following is the least suitable class for implementing Computable? \nCorrect: BankAccount \/\/implemented with balance\n\n\nIncorrect: LargeInteger \/\/integers with 100 digits or more\nIncorrect: Fraction \/\/implemented with numerator and\n\/\/denominator of type int \nIncorrect: IrrationalNumber \/\/nonrepeating, nonterminating decimal\nIncorrect: Length \/\/implemented with different units, such\n\/\/as inches, centimeters, etc. END"}
{"prompt":"An interface is a collection of related methods, either abstract (headers only) or default (implementation provided in the interface). Default methods are new in Java 8, and will not be tested on the AP exam. Non-default (i.e., abstract) methods will be tested on the exam and are discussed below.\nStudents may be required to design, create, or modify classes that implement inter faces with abstract methods.\nThe non-default methods are both public and abstract—no need to explicitly include these keywords. As such, they provide a framework of behavior for any class.\nThe classes that implement a given interface may represent objects that are vastly different. They all, however, have in common a capability or feature expressed in the methods of the interface. An interface called FlyingObject, for example, may have the methods fly and isFlying. Some classes that implement FlyingObject could be Bird, Airplane, Missile, Butterfly, and Witch. A class called Turtle would be unlikely to implement FlyingObject because turtles don’t fly.\nAn interface called Computable may have just three methods: add, subtract, and multiply. Classes that implement Computable could be Fraction, Matrix, LongInteger, and ComplexNumber. It would not be meaningful, however, for a TelevisionSet to implement Computable—what does it mean, for example, to mul tiply two TelevisionSet objects?\nA class that implements an interface can define any number of methods. In par\n\nticular, it contracts to provide implementations for all the non-default (i.e., abstract) methods declared in the interface. If it fails to implement any of the methods, the class must be declared abstract.\nA nonabstract class that implements an interface must\nimplement every abstract method of the interface.\n\nAn interface is declared with the interface keyword. For example,\npublic interface FlyingObject\n{\n    void fly(); \/\/method that simulates flight of object\n    boolean isFlying(); \/\/true if object is in flight,\n    \/\/false otherwise\n}\n\nInterfaces are implemented using the implements keyword. For example,\npublic class Bird implements FlyingObject\n{\n...\nThis declaration means that two of the methods in the Bird class must be fly and isFlying. Note that any subclass of Bird will automatically implement the interface FlyingObject, since fly and isFlying will be inherited by the subclass.\nA class that extends a superclass can also directly implement an interface. For exam ple,\npublic class Mosquito extends Insect implements FlyingObject\n{\n...\n\nNOTE\n1. The extends clause must precede the implements clause.\n2. A class can have just one superclass, but it can implement any number of interfaces:\npublic class SubClass extends SuperClass\nimplements Interface1, Interface2, ...\n\n\n###\n\n","completion":" Question: Consider the Player interface defined below:\n\npublic interface Player \n{ \n    \/** Return an integer that represents a move in a game. *\/ \n    int getMove();\n\n    \/** Display the status of the game for this Player after \n    * implementing the next move. *\/ \n    void updateDisplay(); \n} \n\nHumanPlayer is a class that implements the Player interface. Another class, SmartPlayer, is a subclass of HumanPlayer. Which statement is false? \nCorrect: It is not possible to declare a reference of type Player.\nIncorrect: SmartPlayer automatically implements the Player interface.\nIncorrect: HumanPlayermust contain implementations of both the updateDisplay and getMove methods, or be declared as abstract.\nIncorrect: The SmartPlayer class can override the methods updateDisplay and getMove of the HumanPlayer class.\nIncorrect: A method in a client program can have Player as a parameter type.\n\nEND"}
{"prompt":"An interface is a collection of related methods, either abstract (headers only) or default (implementation provided in the interface). Default methods are new in Java 8, and will not be tested on the AP exam. Non-default (i.e., abstract) methods will be tested on the exam and are discussed below.\nStudents may be required to design, create, or modify classes that implement inter faces with abstract methods.\nThe non-default methods are both public and abstract—no need to explicitly include these keywords. As such, they provide a framework of behavior for any class.\nThe classes that implement a given interface may represent objects that are vastly different. They all, however, have in common a capability or feature expressed in the methods of the interface. An interface called FlyingObject, for example, may have the methods fly and isFlying. Some classes that implement FlyingObject could be Bird, Airplane, Missile, Butterfly, and Witch. A class called Turtle would be unlikely to implement FlyingObject because turtles don’t fly.\nAn interface called Computable may have just three methods: add, subtract, and multiply. Classes that implement Computable could be Fraction, Matrix, LongInteger, and ComplexNumber. It would not be meaningful, however, for a TelevisionSet to implement Computable—what does it mean, for example, to mul tiply two TelevisionSet objects?\nA class that implements an interface can define any number of methods. In par\n\nticular, it contracts to provide implementations for all the non-default (i.e., abstract) methods declared in the interface. If it fails to implement any of the methods, the class must be declared abstract.\nA nonabstract class that implements an interface must\nimplement every abstract method of the interface.\n\nAn interface is declared with the interface keyword. For example,\npublic interface FlyingObject\n{\n    void fly(); \/\/method that simulates flight of object\n    boolean isFlying(); \/\/true if object is in flight,\n    \/\/false otherwise\n}\n\nInterfaces are implemented using the implements keyword. For example,\npublic class Bird implements FlyingObject\n{\n...\nThis declaration means that two of the methods in the Bird class must be fly and isFlying. Note that any subclass of Bird will automatically implement the interface FlyingObject, since fly and isFlying will be inherited by the subclass.\nA class that extends a superclass can also directly implement an interface. For exam ple,\npublic class Mosquito extends Insect implements FlyingObject\n{\n...\n\nNOTE\n1. The extends clause must precede the implements clause.\n2. A class can have just one superclass, but it can implement any number of interfaces:\npublic class SubClass extends SuperClass\nimplements Interface1, Interface2, ...\n\n\n###\n\n","completion":" Question: Consider the Player interface defined below:\n\npublic interface Player \n{ \n    \/** Return an integer that represents a move in a game. *\/ \n    int getMove();\n\n    \/** Display the status of the game for this Player after \n    * implementing the next move. *\/ \n    void updateDisplay(); \n} \n\nA programmer plans to write programs that simulate various games. In each case he will have several classes, each representing a different kind of competitor in the game, such as ExpertPlayer, ComputerPlayer, RecklessPlayer, CheatingPlayer, Beginner, IntermediatePlayer, and so on. It may or may not be suitable for these classes to implement the Player interface, depending on the particular game being simulated. In the games described below, which is the least suitable for having the competitor classes implement the given Player interface? \nCorrect: Chess: Played on a square board of 64 squares of alternating colors. There are just two players, called White and Black, the colors of their respective pieces. The players each have a set of pieces on the board that can move according to a set of rules. The players alternate moves, where a move consists of moving any one piece to another square. If that square is occupied by an opponent’s piece, the piece is captured and removed from the board.\nIncorrect: High-Low Guessing Game: The computer thinks of a number and the competitor who guesses it with the least number of guesses wins. After each guess, the computer tells whether its number is higher or lower than the guess.\nIncorrect: Chips: Start with a pile of chips. Each player in turn removes some number of chips. The winner is the one who removes the final chip. The first player may remove any number of chips, but not all of them. Each subsequent player must remove at least one chip and at most twice the number removed by the preceding player.\nIncorrect: Tic-Tac-Toe: Two players alternate placing “X” or “O” on a 3 × 3 grid. The first player to get three in a row, where a row can be vertical, horizontal, or diagonal, wins.\nIncorrect: Battleships: There are two players, each with a 10 × 10 grid hidden from his opponent. Various “ships” are placed on the grid. A move consists of calling out a grid location, trying to “hit” an opponent’s ship. Players alternate moves. The first player to sink his opponent’s fleet wins.\n\nEND"}
{"prompt":"Starting in 2015, this will not be tested on the AP exam. Students will, however, be required to use compareTo for comparison of strings (p. 178).\nThe standard java.lang package contains the Comparable interface, which provides a useful method for comparing objects.\nClasses written for objects that need to be compared\nshould implement Comparable.\npublic interface Comparable\n{\n    int compareTo(Object obj);\n}\nAny class that implements Comparable must provide a compareTomethod. This method compares the implicit object (this) with the parameter object (obj) and returns a nega tive integer, zero, or a positive integer depending on whether the implicit object is less than, equal to, or greater than the parameter. If the two objects being compared are not type compatible, a ClassCastException is thrown by the method.\nExample\nThe abstract Shape class defined previously (p. 143) is modified to implement the Comparable interface:\npublic abstract class Shape implements Comparable {\n    private String name;\n\n    \/\/ constructor\n    public Shape(String shapeName) {\n        name = shapeName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double area();\n\n    public abstract double perimeter();\n\n    public double semiPerimeter() {\n        return perimeter() \/ 2;\n    }\n\n    public int compareTo(Object obj) {\n        final double EPSILON = 1.0e-15; \/\/ slightly bigger than \/\/machine precision\n        Shape rhs = (Shape) obj;\n        double diff = area() - rhs.area();\n        if (Math.abs(diff) <= EPSILON * Math.abs(area()))\n            return 0; \/\/ area of this shape equals area of obj\n        else if (diff < 0)\n            return -1; \/\/ area of this shape less than area of obj\n        else\n            return 1; \/\/ area of this shape greater than area of obj }\n    }\n}\n\nNOTE\n1. The Circle, Square, and other subclasses of Shape will all automatically imple ment Comparable and inherit the compareTo method.\n2. It is tempting to use a simpler test for equality of areas, namely\nif (diff == 0)\nreturn 0;\nBut recall that real numbers can have round-off errors in their storage (Box p. 65). This means that the simple test may return false even though the two areas are essentially equal. A more robust test is implemented in the code given, namely to test if the relative error in diff is small enough to be considered zero.\n3. The Object class is a universal superclass (see p. 174). This means that the compareTo method can take as a parameter any object reference that imple ments Comparable.\n4. One of the first steps of a compareTo method must cast the Object argument to the class type, in this case Shape. If this is not done, the compiler won’t find the area method—remember, an Object is not necessarily a Shape.\n5. The algorithm one chooses in compareTo should in general be consistent with the equals method (see p. 176): Whenever object1.equals(object2) returns true, object1.compareTo(object2) returns 0.\nHere is a program that finds the larger of two Comparable objects.\n\npublic class FindMaxTest {\n    \/** Return the larger of two objects a and b. *\/\n    public static Comparable max(Comparable a, Comparable b) {\n        if (a.compareTo(b) > 0) \/\/ if a > b ...\n            return a;\n        else\n            return b;\n    }\n\n    public static void main(String[] args) {\n        Shape s1 = new Circle(3.0, \"circle\");\n        Shape s2 = new Square(4.5, \"square\");\n        System.out.println(\"Area of \" + s1.getName() + \" is \" +\n                s1.area());\n        System.out.println(\"Area of \" + s2.getName() + \" is \" +\n                s2.area());\n        Shape s3 = (Shape) max(s1, s2);\n        System.out.println(\"The larger shape is the \" +\n                s3.getName());\n    }\n}\n\nHere is the output:\nArea of circle is 28.27\nArea of square is 20.25\nThe larger shape is the circle\n\nNOTE\n1. The max method takes parameters of type Comparable. Since s1 is-a Comparable object and s2 is-a Comparable object, no casting is necessary in the method call.\n2. The max method can be called with any two Comparable objects, for example, two String objects or two Integer objects (see Chapter 4).\n3. The objects must be type compatible (i.e., it must make sense to compare them). For example, in the program shown, if s1 is-a Shape and s2 is-a String, the compareTo method will throw a ClassCastException at the line\nShape rhs = (Shape) obj;\n4. The cast is needed in the line\nShape s3 = (Shape) max(s1, s2);\nsince max(s1, s2) returns a Comparable.\n5. A primitive type is not an object and therefore cannot be passed as Comparable. You can, however, use a wrapper class and in this way convert a primitive type to a Comparable (see p. 180).\n\n\n###\n\n","completion":" Question: Consider the interface and classes defined below:\n\npublic interface Player \n{ \n    \/** Return an integer that represents a move in a game. *\/ \n    int getMove();\n\n    \/** Display the status of the game for this Player after \n    * implementing the next move. *\/ \n    void updateDisplay(); \n} \n\npublic class HumanPlayer implements Player {\n    private String name;\n\n    \/\/ Constructors not shown ...\n    \/\/ Code to implement getMove and updateDisplay not shown ...\n    public String getName() { \/* implementation not shown *\/ }\n}\n\npublic class ExpertPlayer extends HumanPlayer {\n    private int rating;\n\n    \/\/ Constructors not shown ...\n    public int compareTo(ExpertPlayer expert) { \/* implementation not shown *\/ }\n}\n\nWhich code segment in a client program will cause an error? \nI Player p1 = new HumanPlayer(); \nPlayer p2 = new ExpertPlayer(); \nint x1 = p1.getMove(); \nint x2 = p2.getMove(); \nII int x; \nPlayer c1 = new ExpertPlayer(\/* correct parameter list *\/); \nPlayer c2 = new ExpertPlayer(\/* correct parameter list *\/); \nif (c1.compareTo(c2) < 0) \n    x = c1.getMove(); \nelse \n    x = c2.getMove(); \nIII int x; \nHumanPlayer h1 = new HumanPlayer(\/* correct parameter list *\/); \nHumanPlayer h2 = new HumanPlayer(\/* correct parameter list *\/); \nif (h1.compareTo(h2) < 0) \n    x = h1.getMove(); \nelse \n    x = h2.getMove(); \nCorrect: II and III only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and III\nIncorrect: None\n\nEND"}
{"prompt":"Starting in 2015, this will not be tested on the AP exam. Students will, however, be required to use compareTo for comparison of strings (p. 178).\nThe standard java.lang package contains the Comparable interface, which provides a useful method for comparing objects.\nClasses written for objects that need to be compared\nshould implement Comparable.\npublic interface Comparable\n{\n    int compareTo(Object obj);\n}\nAny class that implements Comparable must provide a compareTomethod. This method compares the implicit object (this) with the parameter object (obj) and returns a nega tive integer, zero, or a positive integer depending on whether the implicit object is less than, equal to, or greater than the parameter. If the two objects being compared are not type compatible, a ClassCastException is thrown by the method.\nExample\nThe abstract Shape class defined previously (p. 143) is modified to implement the Comparable interface:\npublic abstract class Shape implements Comparable {\n    private String name;\n\n    \/\/ constructor\n    public Shape(String shapeName) {\n        name = shapeName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double area();\n\n    public abstract double perimeter();\n\n    public double semiPerimeter() {\n        return perimeter() \/ 2;\n    }\n\n    public int compareTo(Object obj) {\n        final double EPSILON = 1.0e-15; \/\/ slightly bigger than \/\/machine precision\n        Shape rhs = (Shape) obj;\n        double diff = area() - rhs.area();\n        if (Math.abs(diff) <= EPSILON * Math.abs(area()))\n            return 0; \/\/ area of this shape equals area of obj\n        else if (diff < 0)\n            return -1; \/\/ area of this shape less than area of obj\n        else\n            return 1; \/\/ area of this shape greater than area of obj }\n    }\n}\n\nNOTE\n1. The Circle, Square, and other subclasses of Shape will all automatically imple ment Comparable and inherit the compareTo method.\n2. It is tempting to use a simpler test for equality of areas, namely\nif (diff == 0)\nreturn 0;\nBut recall that real numbers can have round-off errors in their storage (Box p. 65). This means that the simple test may return false even though the two areas are essentially equal. A more robust test is implemented in the code given, namely to test if the relative error in diff is small enough to be considered zero.\n3. The Object class is a universal superclass (see p. 174). This means that the compareTo method can take as a parameter any object reference that imple ments Comparable.\n4. One of the first steps of a compareTo method must cast the Object argument to the class type, in this case Shape. If this is not done, the compiler won’t find the area method—remember, an Object is not necessarily a Shape.\n5. The algorithm one chooses in compareTo should in general be consistent with the equals method (see p. 176): Whenever object1.equals(object2) returns true, object1.compareTo(object2) returns 0.\nHere is a program that finds the larger of two Comparable objects.\n\npublic class FindMaxTest {\n    \/** Return the larger of two objects a and b. *\/\n    public static Comparable max(Comparable a, Comparable b) {\n        if (a.compareTo(b) > 0) \/\/ if a > b ...\n            return a;\n        else\n            return b;\n    }\n\n    public static void main(String[] args) {\n        Shape s1 = new Circle(3.0, \"circle\");\n        Shape s2 = new Square(4.5, \"square\");\n        System.out.println(\"Area of \" + s1.getName() + \" is \" +\n                s1.area());\n        System.out.println(\"Area of \" + s2.getName() + \" is \" +\n                s2.area());\n        Shape s3 = (Shape) max(s1, s2);\n        System.out.println(\"The larger shape is the \" +\n                s3.getName());\n    }\n}\n\nHere is the output:\nArea of circle is 28.27\nArea of square is 20.25\nThe larger shape is the circle\n\nNOTE\n1. The max method takes parameters of type Comparable. Since s1 is-a Comparable object and s2 is-a Comparable object, no casting is necessary in the method call.\n2. The max method can be called with any two Comparable objects, for example, two String objects or two Integer objects (see Chapter 4).\n3. The objects must be type compatible (i.e., it must make sense to compare them). For example, in the program shown, if s1 is-a Shape and s2 is-a String, the compareTo method will throw a ClassCastException at the line\nShape rhs = (Shape) obj;\n4. The cast is needed in the line\nShape s3 = (Shape) max(s1, s2);\nsince max(s1, s2) returns a Comparable.\n5. A primitive type is not an object and therefore cannot be passed as Comparable. You can, however, use a wrapper class and in this way convert a primitive type to a Comparable (see p. 180).\n\n\n###\n\n","completion":" Question: Consider the interface and classes defined below:\n\npublic interface Player \n{ \n    \/** Return an integer that represents a move in a game. *\/ \n    int getMove();\n\n    \/** Display the status of the game for this Player after \n    * implementing the next move. *\/ \n    void updateDisplay(); \n} \n\npublic class HumanPlayer implements Player {\n    private String name;\n\n    \/\/ Constructors not shown ...\n    \/\/ Code to implement getMove and updateDisplay not shown ...\n    public String getName() { \/* implementation not shown *\/ }\n}\n\npublic class ExpertPlayer extends HumanPlayer {\n    private int rating;\n\n    \/\/ Constructors not shown ...\n    public int compareTo(ExpertPlayer expert) { \/* implementation not shown *\/ }\n}\n\nWhich of the following is correct implementation code for the compareTo method in the ExpertPlayer class? \nI if (rating == expert.rating) \n    return 0; \nelse if (rating < expert.rating) \n    return -1; \nelse \n    return 1; \nII return rating - expert.rating; \nIII if (getName().equals(expert.getName())) \n    return 0; \nelse if (getName().compareTo(expert.getName()) < 0) \n    return -1; \nelse \n    return 1; \nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II onlyEND"}
{"prompt":"Starting in 2015, this will not be tested on the AP exam. Students will, however, be required to use compareTo for comparison of strings (p. 178).\nThe standard java.lang package contains the Comparable interface, which provides a useful method for comparing objects.\nClasses written for objects that need to be compared\nshould implement Comparable.\npublic interface Comparable\n{\n    int compareTo(Object obj);\n}\nAny class that implements Comparable must provide a compareTomethod. This method compares the implicit object (this) with the parameter object (obj) and returns a nega tive integer, zero, or a positive integer depending on whether the implicit object is less than, equal to, or greater than the parameter. If the two objects being compared are not type compatible, a ClassCastException is thrown by the method.\nExample\nThe abstract Shape class defined previously (p. 143) is modified to implement the Comparable interface:\npublic abstract class Shape implements Comparable {\n    private String name;\n\n    \/\/ constructor\n    public Shape(String shapeName) {\n        name = shapeName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double area();\n\n    public abstract double perimeter();\n\n    public double semiPerimeter() {\n        return perimeter() \/ 2;\n    }\n\n    public int compareTo(Object obj) {\n        final double EPSILON = 1.0e-15; \/\/ slightly bigger than \/\/machine precision\n        Shape rhs = (Shape) obj;\n        double diff = area() - rhs.area();\n        if (Math.abs(diff) <= EPSILON * Math.abs(area()))\n            return 0; \/\/ area of this shape equals area of obj\n        else if (diff < 0)\n            return -1; \/\/ area of this shape less than area of obj\n        else\n            return 1; \/\/ area of this shape greater than area of obj }\n    }\n}\n\nNOTE\n1. The Circle, Square, and other subclasses of Shape will all automatically imple ment Comparable and inherit the compareTo method.\n2. It is tempting to use a simpler test for equality of areas, namely\nif (diff == 0)\nreturn 0;\nBut recall that real numbers can have round-off errors in their storage (Box p. 65). This means that the simple test may return false even though the two areas are essentially equal. A more robust test is implemented in the code given, namely to test if the relative error in diff is small enough to be considered zero.\n3. The Object class is a universal superclass (see p. 174). This means that the compareTo method can take as a parameter any object reference that imple ments Comparable.\n4. One of the first steps of a compareTo method must cast the Object argument to the class type, in this case Shape. If this is not done, the compiler won’t find the area method—remember, an Object is not necessarily a Shape.\n5. The algorithm one chooses in compareTo should in general be consistent with the equals method (see p. 176): Whenever object1.equals(object2) returns true, object1.compareTo(object2) returns 0.\nHere is a program that finds the larger of two Comparable objects.\n\npublic class FindMaxTest {\n    \/** Return the larger of two objects a and b. *\/\n    public static Comparable max(Comparable a, Comparable b) {\n        if (a.compareTo(b) > 0) \/\/ if a > b ...\n            return a;\n        else\n            return b;\n    }\n\n    public static void main(String[] args) {\n        Shape s1 = new Circle(3.0, \"circle\");\n        Shape s2 = new Square(4.5, \"square\");\n        System.out.println(\"Area of \" + s1.getName() + \" is \" +\n                s1.area());\n        System.out.println(\"Area of \" + s2.getName() + \" is \" +\n                s2.area());\n        Shape s3 = (Shape) max(s1, s2);\n        System.out.println(\"The larger shape is the \" +\n                s3.getName());\n    }\n}\n\nHere is the output:\nArea of circle is 28.27\nArea of square is 20.25\nThe larger shape is the circle\n\nNOTE\n1. The max method takes parameters of type Comparable. Since s1 is-a Comparable object and s2 is-a Comparable object, no casting is necessary in the method call.\n2. The max method can be called with any two Comparable objects, for example, two String objects or two Integer objects (see Chapter 4).\n3. The objects must be type compatible (i.e., it must make sense to compare them). For example, in the program shown, if s1 is-a Shape and s2 is-a String, the compareTo method will throw a ClassCastException at the line\nShape rhs = (Shape) obj;\n4. The cast is needed in the line\nShape s3 = (Shape) max(s1, s2);\nsince max(s1, s2) returns a Comparable.\n5. A primitive type is not an object and therefore cannot be passed as Comparable. You can, however, use a wrapper class and in this way convert a primitive type to a Comparable (see p. 180).\n\n\n###\n\n","completion":" Question: Which of the following classes is the least suitable candidate for containing a compareTo method? \nCorrect: public class Point\n{ \n    private double x; \n    private double y; \n    \/\/various methods follow \n    ... \n} \nIncorrect: public class Name\n{ \n    private String firstName; \n    private String lastName; \n    \/\/various methods follow \n    ... \n} \nIncorrect: public class Car\n{ \n    private int modelNumber; \n    private int year; \n    private double price; \n    \/\/various methods follow \n    ... \n} \nIncorrect: public class Student\n{ \n    private String name; \n    private double gpa; \n    \/\/various methods follow \n    ... \n} \nIncorrect: public class Employee\n{ \n    private String name; \n    private int hireDate; \n    private double salary; \n    \/\/various methods follow \n    ... \n}\n\nEND"}
{"prompt":"Consider writing a program that simulates a game of Battleships. The program may have a Ship class with subclasses Submarine, Cruiser, Destroyer, and so on. The various ships will be placed in a two-dimensional grid that represents a part of the ocean.\nAn abstract class Ship is a good design choice. There will not be any instances of Ship objects because the specific features of the subclasses must be known in order to place these ships in the grid. A Grid interface that manipulates objects in a two dimensional setting suggests itself for the two-dimensional grid.\nNotice that the abstract Ship class is specific to the Battleships application, whereas the Grid interface is not. You could use the Grid interface in any program that has a two-dimensional grid.\n\nInterface vs. Abstract Class\n• Use an abstract class for an object that is application-specific\nbut incomplete without its subclasses.\n• Consider using an interface when its methods are suitable\nfor your program but could be equally applicable in a vari\nety of programs.\n• An interface typically doesn’t provide implementations for\nany of its methods, whereas an abstract class does. (In Java 8,\nimplementation of default methods is allowed in interfaces.)\n• An interface cannot contain instance variables, whereas an\nabstract class can.\n• It is not possible to create an instance of an interface object\nor an abstract class object.\n\n\n###\n\n","completion":" Question: A programmer has the task of maintaining a database of students of a large university. There are two types of students, undergraduates and graduate students. About a third of the graduate students are doctoral candidates. All of the students have the same personal information stored, like name, address, and phone number, and also student information like courses taken and grades. Each student’s GPA is computed, but differently for undergraduates and graduates. The doctoral candidates have information about their dissertations and faculty advisors. \nThe programmer will write a Java program to handle all the student informa tion. Which of the following is the best design, in terms of programmer efficiency and code reusability? Note: { ... } denotes class code. \nCorrect: public abstract class Student { ...}\npublic class Undergraduate extends Student { ... } \npublic class Graduate extends Student { ... } \npublic class DocStudent extends Graduate { ... } \nIncorrect: public interface Student { ...}\npublic class Undergraduate implements Student { ... } \npublic class Graduate implements Student { ... } \npublic class DocStudent extends Graduate { ... } \nIncorrect: public class Student { ...}\npublic class Undergraduate extends Student { ... } \npublic class Graduate extends Student { ... } \npublic class DocStudent extends Graduate { ... } \nIncorrect: public abstract class Student { ...}\npublic class Undergraduate extends Student { ... } \npublic class Graduate extends Student { ... } \npublic class DocStudent extends Student { ... } \nIncorrect: public interface PersonalInformation { ... }\npublic class Student implements PersonalInformation { ...} \npublic class Undergraduate extends Student { ... } \npublic abstract class Graduate extends Student { ... } \npublic class DocStudent extends Graduate { ... }\n\nEND"}
{"prompt":"Starting in 2015, this will not be tested on the AP exam. Students will, however, be required to use compareTo for comparison of strings (p. 178).\nThe standard java.lang package contains the Comparable interface, which provides a useful method for comparing objects.\nClasses written for objects that need to be compared\nshould implement Comparable.\npublic interface Comparable\n{\n    int compareTo(Object obj);\n}\nAny class that implements Comparable must provide a compareTomethod. This method compares the implicit object (this) with the parameter object (obj) and returns a nega tive integer, zero, or a positive integer depending on whether the implicit object is less than, equal to, or greater than the parameter. If the two objects being compared are not type compatible, a ClassCastException is thrown by the method.\nExample\nThe abstract Shape class defined previously (p. 143) is modified to implement the Comparable interface:\npublic abstract class Shape implements Comparable {\n    private String name;\n\n    \/\/ constructor\n    public Shape(String shapeName) {\n        name = shapeName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public abstract double area();\n\n    public abstract double perimeter();\n\n    public double semiPerimeter() {\n        return perimeter() \/ 2;\n    }\n\n    public int compareTo(Object obj) {\n        final double EPSILON = 1.0e-15; \/\/ slightly bigger than \/\/machine precision\n        Shape rhs = (Shape) obj;\n        double diff = area() - rhs.area();\n        if (Math.abs(diff) <= EPSILON * Math.abs(area()))\n            return 0; \/\/ area of this shape equals area of obj\n        else if (diff < 0)\n            return -1; \/\/ area of this shape less than area of obj\n        else\n            return 1; \/\/ area of this shape greater than area of obj }\n    }\n}\n\nNOTE\n1. The Circle, Square, and other subclasses of Shape will all automatically imple ment Comparable and inherit the compareTo method.\n2. It is tempting to use a simpler test for equality of areas, namely\nif (diff == 0)\nreturn 0;\nBut recall that real numbers can have round-off errors in their storage (Box p. 65). This means that the simple test may return false even though the two areas are essentially equal. A more robust test is implemented in the code given, namely to test if the relative error in diff is small enough to be considered zero.\n3. The Object class is a universal superclass (see p. 174). This means that the compareTo method can take as a parameter any object reference that imple ments Comparable.\n4. One of the first steps of a compareTo method must cast the Object argument to the class type, in this case Shape. If this is not done, the compiler won’t find the area method—remember, an Object is not necessarily a Shape.\n5. The algorithm one chooses in compareTo should in general be consistent with the equals method (see p. 176): Whenever object1.equals(object2) returns true, object1.compareTo(object2) returns 0.\nHere is a program that finds the larger of two Comparable objects.\n\npublic class FindMaxTest {\n    \/** Return the larger of two objects a and b. *\/\n    public static Comparable max(Comparable a, Comparable b) {\n        if (a.compareTo(b) > 0) \/\/ if a > b ...\n            return a;\n        else\n            return b;\n    }\n\n    public static void main(String[] args) {\n        Shape s1 = new Circle(3.0, \"circle\");\n        Shape s2 = new Square(4.5, \"square\");\n        System.out.println(\"Area of \" + s1.getName() + \" is \" +\n                s1.area());\n        System.out.println(\"Area of \" + s2.getName() + \" is \" +\n                s2.area());\n        Shape s3 = (Shape) max(s1, s2);\n        System.out.println(\"The larger shape is the \" +\n                s3.getName());\n    }\n}\n\nHere is the output:\nArea of circle is 28.27\nArea of square is 20.25\nThe larger shape is the circle\n\nNOTE\n1. The max method takes parameters of type Comparable. Since s1 is-a Comparable object and s2 is-a Comparable object, no casting is necessary in the method call.\n2. The max method can be called with any two Comparable objects, for example, two String objects or two Integer objects (see Chapter 4).\n3. The objects must be type compatible (i.e., it must make sense to compare them). For example, in the program shown, if s1 is-a Shape and s2 is-a String, the compareTo method will throw a ClassCastException at the line\nShape rhs = (Shape) obj;\n4. The cast is needed in the line\nShape s3 = (Shape) max(s1, s2);\nsince max(s1, s2) returns a Comparable.\n5. A primitive type is not an object and therefore cannot be passed as Comparable. You can, however, use a wrapper class and in this way convert a primitive type to a Comparable (see p. 180).\n\n\n###\n\n","completion":" Question: Consider the Orderable interface and the partial implementation of the Temperature class defined below:\n\npublic interface Orderable {\n    \/**\n     * Returns -1, 0, or 1 depending on whether the implicit\n     * object is less than, equal to, or greater than other.\n     *\/\n    int compareTo(Object other);\n}\n\npublic class Temperature implements Orderable {\n    private String scale;\n    private double degrees;\n\n    \/\/ default constructor\n    public Temperature() { \/* implementation not shown *\/ }\n\n    \/\/ constructor\n    public Temperature(String tempScale, double tempDegrees) { \/* implementation not shown *\/ }\n\n    public int compareTo(Object obj) { \/* implementation not shown *\/ }\n\n    public String toString() { \/* implementation not shown *\/ }\n    \/\/ Other methods are not shown.\n}\n\nHere is a program that finds the lowest of three temperatures:\n\npublic class TemperatureMain {\n    \/** Find smaller of objects a and b. *\/\n    public static Orderable min(Orderable a, Orderable b) {\n        if (a.compareTo(b) < 0)\n            return a;\n        else\n            return b;\n    }\n\n    \/** Find smallest of objects a, b, and c. *\/\n    public static Orderable minThree(Orderable a, Orderable b, Orderable c) {\n        return min(min(a, b), c);\n    }\n\n    public static void main(String[] args) { \/* code to test minThree method *\/ }\n}\n\nWhich are correct replacements for \/* code to test minThree method *\/? \nI Temperature t1 = new Temperature(\"C\", 85); \nTemperature t2 = new Temperature(\"F\", 45); \nTemperature t3 = new Temperature(\"F\", 120); \nSystem.out.println(\"The lowest temperature is \" + \nminThree(t1, t2, t3)); \nII Orderable c1 = new Temperature(\"C\", 85); \nOrderable c2 = new Temperature(\"F\", 45); \nOrderable c3 = new Temperature(\"F\", 120); \nSystem.out.println(\"The lowest temperature is \" + \nminThree(c1, c2, c3)); \nIII Orderable c1 = new Orderable(\"C\", 85); \nOrderable c2 = new Orderable(\"F\", 45); \nOrderable c3 = new Orderable(\"F\", 120); \nSystem.out.println(\"The lowest temperature is \" + \nminThree(c1, c2, c3)); \nCorrect: I and II only\nIncorrect: II only\nIncorrect: II and III only\nIncorrect: I and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"An interface is a collection of related methods, either abstract (headers only) or default (implementation provided in the interface). Default methods are new in Java 8, and will not be tested on the AP exam. Non-default (i.e., abstract) methods will be tested on the exam and are discussed below.\nStudents may be required to design, create, or modify classes that implement inter faces with abstract methods.\nThe non-default methods are both public and abstract—no need to explicitly include these keywords. As such, they provide a framework of behavior for any class.\nThe classes that implement a given interface may represent objects that are vastly different. They all, however, have in common a capability or feature expressed in the methods of the interface. An interface called FlyingObject, for example, may have the methods fly and isFlying. Some classes that implement FlyingObject could be Bird, Airplane, Missile, Butterfly, and Witch. A class called Turtle would be unlikely to implement FlyingObject because turtles don’t fly.\nAn interface called Computable may have just three methods: add, subtract, and multiply. Classes that implement Computable could be Fraction, Matrix, LongInteger, and ComplexNumber. It would not be meaningful, however, for a TelevisionSet to implement Computable—what does it mean, for example, to mul tiply two TelevisionSet objects?\nA class that implements an interface can define any number of methods. In par\n\nticular, it contracts to provide implementations for all the non-default (i.e., abstract) methods declared in the interface. If it fails to implement any of the methods, the class must be declared abstract.\nA nonabstract class that implements an interface must\nimplement every abstract method of the interface.\n\nAn interface is declared with the interface keyword. For example,\npublic interface FlyingObject\n{\n    void fly(); \/\/method that simulates flight of object\n    boolean isFlying(); \/\/true if object is in flight,\n    \/\/false otherwise\n}\n\nInterfaces are implemented using the implements keyword. For example,\npublic class Bird implements FlyingObject\n{\n...\nThis declaration means that two of the methods in the Bird class must be fly and isFlying. Note that any subclass of Bird will automatically implement the interface FlyingObject, since fly and isFlying will be inherited by the subclass.\nA class that extends a superclass can also directly implement an interface. For exam ple,\npublic class Mosquito extends Insect implements FlyingObject\n{\n...\n\nNOTE\n1. The extends clause must precede the implements clause.\n2. A class can have just one superclass, but it can implement any number of interfaces:\npublic class SubClass extends SuperClass\nimplements Interface1, Interface2, ...\n\n\n###\n\n","completion":" Question: A certain interface provided by a Java package contains just a single method: \n\npublic interface SomeName \n{ \n    int method1(Object o); \n} \n\nA programmer adds some functionality to this interface by adding another abstract method to it, method2: \n\npublic interface SomeName \n{ \n    int method1(Object ob1); \n    void method2(Object ob2); \n} \n\nAs a result of this addition, which of the following is true? \nCorrect: All classes that implement the original SomeName interface will need to be rewritten because they no longer implement SomeName.\nIncorrect: A ClassCastException will occur if ob1 and ob2 are not compatible.\nIncorrect: A class that implements the original SomeName interface will need to modify its declaration as follows:\npublic class ClassName implements SomeName extends method2 \n{ ... \nIncorrect: SomeName will need to be changed to an abstract class and provide implementation code for method2, so that the original and upgraded versions of SomeName are compatible.\nIncorrect: Any new class that implements the upgraded version of SomeName will not compile.\nEND"}
{"prompt":"Selection and insertion sorts are inefficient for large n, requiring approximately n passes through a list of n elements. More efficient algorithms can be devised using a “divide-and-conquer” approach, which is used in both the sorting algorithms that follow.\n\nMergesort\nHere is a recursive description of how mergesort works:\n\nIf there is more than one element in the array\n    Break the array into two halves.\n    Mergesort the left half.\n    Mergesort the right half.\n    Merge the two subarrays into a sorted array.\n\nMergesort uses a merge method to merge two sorted pieces of an array into a single sorted array. For example, suppose array a[0] . . . a[n-1] is such that a[0] . . . a[k] is sorted and a[k+1] . . . a[n-1] is sorted, both parts in increasing order. Example:\na[0] a[1] a[2] a[3] a[4] a[5]\n2 5 8 9 1 6\n\nIn this case, a[0] . . . a[3] and a[4] . . . a[5] are the two sorted pieces. The method call merge(a,0,3,5) should produce the “merged” array:\na[0] a[1] a[2] a[3] a[4] a[5]\n1 2 5 6 8 9\n\nThe middle numerical parameter in merge (the 3 in this case) represents the index of the last element in the first “piece” of the array. The first and third numerical parameters are the lowest and highest index, respectively, of array a.\nHere’s what happens in mergesort:\n1. Start with an unsorted list of n elements.\n2. The recursive calls break the list into n sublists, each of length 1. Note that these n arrays, each containing just one element, are sorted!\n3. Recursively merge adjacent pairs of lists. There are then approximately n\/2 lists of length 2; then, approximately n\/4 lists of approximate length 4, and so on, until there is just one list of length n.\n\nAnalysis of Mergesort:\n1. The major disadvantage of mergesort is that it needs a temporary array that is as large as the original array to be sorted. This could be a problem if space is a factor.\n2. Mergesort is not affected by the initial ordering of the elements. Thus, best, worst, and average cases have similar run times.\n\nFor large n, quicksort is, on average, the fastest known sorting algorithm. Here is a recursive description of how quicksort works:\n\nIf there are at least two elements in the array\n    Partition the array.\n    Quicksort the left subarray.\n    Quicksort the right subarray.\n\nThe partition method splits the array into two subarrays as follows: a pivot element is chosen at random from the array (often just the first element) and placed so that all items to the left of the pivot are less than or equal to the pivot, whereas those to the right are greater than or equal to it.\nFor example, if the array is 4, 1, 2, 7, 5, −1, 8, 0, 6, and a[0] = 4 is the pivot, the partition method produces\n−1 1 2 0 4 5 8 7 6\n\nHere’s how the partitioning works: Let a[0], 4 in this case, be the pivot. Markers up and down are initialized to index values 0 and n − 1, as shown. Move the up marker until a value less than the pivot is found, or down equals up. Move the down marker until a value greater than the pivot is found, or down equals up. Swap a[up] and a[down]. Continue the process until down equals up. This is the pivot position. Swap a[0] and a[pivotPosition].\nNotice that the pivot element, 4, is in its final sorted position.\n\nAnalysis of Quicksort:\n1. For the fastest run time, the array should be partitioned into two parts of roughly the same size.\n2. If the pivot happens to be the smallest or largest element in the array, the split is not much of a split—one of the subarrays is empty! If this happens repeatedly, quicksort degenerates into a slow, recursive version of selection sort and is very inefficient.\n3. The worst case for quicksort occurs when the partitioning algorithm repeatedly divides the array into pieces of size 1 and n − 1. An example is when the array is initially sorted in either order and the first or last element is chosen as the pivot. Some algorithms avoid this situation by initially shuffling up the given array (!) or selecting the pivot by examining several elements of the array (such as first, middle, and last) and then taking the median.\n\nNOTE\nFor both quicksort and mergesort, when a subarray gets down to some small size m, it becomes faster to sort by straight insertion. The optimal value of m is machine dependent, but it’s approximately equal to 7.\n\n\n###\n\n","completion":" Question: The decision to choose a particular sorting algorithm should be made based on \nI Run-time efficiency of the sort \nII Size of the array \nIII Space efficiency of the algorithm \nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II onlyEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: The following code fragment does a sequential search to determine whether a given integer, value, is stored in an array a[0]...a[n-1]. \n\nint i = 0; \nwhile (\/* boolean expression *\/) \n{ \n    i++; \n} \nif (i == n) \n    return -1; \/\/value not found \nelse \n    return i; \/\/ value found at location i \n\nWhich of the following should replace \/* boolean expression *\/ so that the algorithm works as intended? \nCorrect: i < n && value != a[i]\nIncorrect: value != a[i]\nIncorrect: i < n && value == a[i]\nIncorrect: value != a[i] && i < n\nIncorrect: i < n || value != a[i]\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: A feature of data that is used for a binary search but not necessarily used for a sequential search is \nCorrect: order of data.\nIncorrect: length of list.\nIncorrect: type of data.\nIncorrect: smallest value in the list.\nIncorrect: median value of the data.\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: Array unsortedArr contains an unsorted list of integers. Array sortedArr contains a sorted list of integers. Which of the following operations is more efficient for sortedArr than unsortedArr? Assume the most efficient algorithms are used. \nI Inserting a new element \nII Searching for a given element \nIII Computing the mean of the elements \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: An algorithm for searching a large sorted array for a specific value x compares every third item in the array to x until it finds one that is greater than or equal to x. When a larger value is found, the algorithm compares x to the previous two items. If the array is sorted in increasing order, which of the following describes all cases when this algorithm uses fewer comparisons to find x than would a binary search? \nCorrect: When x is very close to the beginning of the array\nIncorrect: It will never use fewer comparisons.\nIncorrect: When x is in the middle position of the array\nIncorrect: When x is very close to the end of the array\nIncorrect: When x is not in the array\n\nEND"}
{"prompt":"In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a “search-and-swap” algorithm. Here’s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is “it,” the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that “it” is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\n###\n\n","completion":" Question: Assume that a[0]...a[N-1] is an array of N positive integers and that the following assertion is true: \na[0] > a[k] for all k such that 0 < k < N \nWhich of the following must be true? \nCorrect: a[0] holds the largest value in the array.\n\n\nIncorrect: The array is sorted in ascending order.\nIncorrect: The array is sorted in descending order.\nIncorrect: All values in the array are different.\nIncorrect: a[0] holds the smallest value in the array.END"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: The following code is designed to set index to the location of the first occurrence of key in array a and to set index to −1 if key is not in a. \n\nindex = 0; \nwhile (a[index] != key) \n    index++; \nif (a[index] != key) \n    index = -1; \n\nIn which case will this program definitely fail to perform the task described? \nCorrect: When key is not in the array\nIncorrect: When key is the first element of the array\nIncorrect: When key is the last element of the array\nIncorrect: When key equals 0\nIncorrect: When key equals a[key]\n\nEND"}
{"prompt":"In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a “search-and-swap” algorithm. Here’s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is “it,” the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that “it” is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\n###\n\n","completion":" Question: Consider the following class. \n\n\/**\n * A class that sorts an array of Integer objects from\n * largest to smallest using a selection sort.\n *\/\npublic class Sorter {\n    private Integer[] a;\n\n    public Sorter(Integer[] arr) {\n        a = arr;\n    }\n\n    \/** Swap a[i] and a[j] in array a. *\/\n    private void swap(int i, int j) { \/* implementation not shown *\/ }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of Integer objects.\n     *\/\n    public void selectionSort() {\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[n-1]\n            Integer max = a[i];\n            int maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max.compareTo(a[j]) < 0) \/\/ max less than a[j]\n                {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nIf an array of Integer contains the following elements, what would the array look like after the third pass of selectionSort, sorting from high to low? \n89 42 − 3 13 109 70 2 \nCorrect: 109 89 70 13 42 −3 2\nIncorrect: 109 89 70 42 13 2 −3\nIncorrect: 109 89 70 −3 2 13 42\nIncorrect: 89 42 13 −3 109 70 2\nIncorrect: 109 89 42 −3 13 70 2\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: Refer to method search. \n\n\/** @param v an initialized array of integers \n* @param key the value to be found \n* Postcondition: \n* - Returned value k is such that -1 <= k <= v.length-1. \n* - If k >= 0 then v[k] == key. \n* - If k == -1, then key != any of the elements in v. \n*\/ \npublic static int search(int[] v, int key) \n{ \n    int index = 0; \n    while (index < v.length && v[index] < key) \n        index++; \n    if (v[index] == key) \n        return index; \n    else \n        return -1; \n} \n\nAssuming that the method works as intended, which of the following should be added to the precondition of search? \nCorrect: v is sorted smallest to largest.\nIncorrect: v is sorted largest to smallest.\nIncorrect: v is unsorted.\nIncorrect: There is at least one occurrence of key in v.\nIncorrect: key occurs no more than once in v.\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: Consider the binSearch method and the private instance variable a for some class: \n\nprivate int[] a; \n\n\/** Does binary search for key in array a[0]...a[a.length-1], \n* sorted in ascending order. \n* @param key the integer value to be found \n* Postcondition: \n* - index has been returned such that a[index]==key. \n* - If key not in a, return -1. \n*\/ \npublic int binSearch(int key) \n{ \n    int low = 0; \n    int high = a.length - 1; \n    while (low <= high) \n    { \n        int mid = (low + high) \/ 2; \n        if (a[mid] == key) \n            return mid; \n        else if (a[mid] < key) \n            low = mid + 1; \n        else \n            high = mid - 1; \n    } \n    return -1; \n}\n\nA binary search will be performed on the following list. \na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] \n4 7 9 11 20 24 30 41 \n\nTo find the key value 27, the search interval after the first pass through the while loop will be \nCorrect: a[4] . . . a[7]\nIncorrect: a[0] . . . a[7]\nIncorrect: a[5] . . . a[6]\nIncorrect: a[2] . . . a[6]\nIncorrect: a[6] . . . a[7]\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: Consider the binSearch method and the private instance variable a for some class: \n\nprivate int[] a; \n\n\/** Does binary search for key in array a[0]...a[a.length-1], \n* sorted in ascending order. \n* @param key the integer value to be found \n* Postcondition: \n* - index has been returned such that a[index]==key. \n* - If key not in a, return -1. \n*\/ \npublic int binSearch(int key) \n{ \n    int low = 0; \n    int high = a.length - 1; \n    while (low <= high) \n    { \n        int mid = (low + high) \/ 2; \n        if (a[mid] == key) \n            return mid; \n        else if (a[mid] < key) \n            low = mid + 1; \n        else \n            high = mid - 1; \n    } \n    return -1; \n}\n\nA binary search will be performed on the following list. \na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] \n4 7 9 11 20 24 30 41 \n\nHow many iterations will be required to determine that 27 is not in the list? \nCorrect: 3\nIncorrect: 1\nIncorrect: 8\nIncorrect: 27\nIncorrect: An infinite loop since 27 is not found\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: Consider the binSearch method and the private instance variable a for some class: \n\nprivate int[] a; \n\n\/** Does binary search for key in array a[0]...a[a.length-1], \n* sorted in ascending order. \n* @param key the integer value to be found \n* Postcondition: \n* - index has been returned such that a[index]==key. \n* - If key not in a, return -1. \n*\/ \npublic int binSearch(int key) \n{ \n    int low = 0; \n    int high = a.length - 1; \n    while (low <= high) \n    { \n        int mid = (low + high) \/ 2; \n        if (a[mid] == key) \n            return mid; \n        else if (a[mid] < key) \n            low = mid + 1; \n        else \n            high = mid - 1; \n    } \n    return -1; \n}\n\nA binary search will be performed on the following list. \na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] \n4 7 9 11 20 24 30 41 \n\nWhat will be stored in y after executing the following? \nint y = binSearch(4); \nCorrect: 0\nIncorrect: 20\nIncorrect: 7\nIncorrect: 4\nIncorrect: -1\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: Consider the binSearch method and the private instance variable a for some class: \n\nprivate int[] a; \n\n\/** Does binary search for key in array a[0]...a[a.length-1], \n* sorted in ascending order. \n* @param key the integer value to be found \n* Postcondition: \n* - index has been returned such that a[index]==key. \n* - If key not in a, return -1. \n*\/ \npublic int binSearch(int key) \n{ \n    int low = 0; \n    int high = a.length - 1; \n    while (low <= high) \n    { \n        int mid = (low + high) \/ 2; \n        if (a[mid] == key) \n            return mid; \n        else if (a[mid] < key) \n            low = mid + 1; \n        else \n            high = mid - 1; \n    } \n    return -1; \n}\n\nA binary search will be performed on the following list. \na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] \n4 7 9 11 20 24 30 41 \n\nIf the test for the while loop is changed to \nwhile (low < high) \nthe binSearch method does not work as intended. Which value in the given list will not be found? \nCorrect: 4\nIncorrect: 7\nIncorrect: 11\nIncorrect: 24\nIncorrect: 30\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: Consider the binSearch method and the private instance variable a for some class: \n\nprivate int[] a; \n\n\/** Does binary search for key in array a[0]...a[a.length-1], \n* sorted in ascending order. \n* @param key the integer value to be found \n* Postcondition: \n* - index has been returned such that a[index]==key. \n* - If key not in a, return -1. \n*\/ \npublic int binSearch(int key) \n{ \n    int low = 0; \n    int high = a.length - 1; \n    while (low <= high) \n    { \n        int mid = (low + high) \/ 2; \n        if (a[mid] == key) \n            return mid; \n        else if (a[mid] < key) \n            low = mid + 1; \n        else \n            high = mid - 1; \n    } \n    return -1; \n}\n\nA binary search will be performed on the following list. \na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] \n4 7 9 11 20 24 30 41 \n\nFor binSearch, which of the following assertions will be true following every iteration of the while loop? \nCorrect: key = a[mid], or a[low] ≤ key ≤ a[high], or key is not in array a.\n\n\nIncorrect: key = a[mid] or key is not in a.\nIncorrect: a[low] ≤ key ≤ a[high]\nIncorrect: low ≤ mid ≤ high\nIncorrect: key = a[mid], or a[low] ≤ key ≤ a[high]END"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: A large sorted array containing about 30,000 elements is to be searched for a value key using an iterative binary search algorithm. Assuming that key is in the array, which of the following is closest to the smallest number of iterations that will guarantee that key is found? Note: 10^3 ≈ 2^10. \nCorrect: 15\nIncorrect: 30\nIncorrect: 100\nIncorrect: 300\nIncorrect: 3000\n\nEND"}
{"prompt":"In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a “search-and-swap” algorithm. Here’s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is “it,” the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that “it” is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\n###\n\n","completion":" Question: Consider the insertionSort method and the private instance variable a, both in a Sorter class. \n\nprivate Integer[] a; \n\n\/** Precondition: a[0],a[1]...a[a.length-1] is an unsorted array \n* of Integer objects. \n* Postcondition: Array a is sorted in descending order. \n*\/ \npublic void insertionSort() \n{ \n    for (int i = 1; i < a.length; i++) \n    { \n        Integer temp = a[i]; \n        int j = i - 1; \n        while (j >= 0 && temp.compareTo(a[j]) > 0) \n        { \n            a[j+1] = a[j]; \n            j--; \n        } \n        a[j+1] = temp; \n    } \n} \n\nAn array of Integer is to be sorted biggest to smallest using the insertionSort method. If the array originally contains \n1 7 9 5 4 12 \nwhat will it look like after the third pass of the for loop? \nCorrect: 9 7 5 1 4 12\nIncorrect: 9 7 1 5 4 12\nIncorrect: 12 9 7 1 5 4\nIncorrect: 12 9 7 5 4 1\nIncorrect: 9 7 12 5 4 1\n\nEND"}
{"prompt":"In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a “search-and-swap” algorithm. Here’s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is “it,” the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that “it” is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\n###\n\n","completion":" Question: Consider the insertionSort method and the private instance variable a, both in a Sorter class. \n\nprivate Integer[] a; \n\n\/** Precondition: a[0],a[1]...a[a.length-1] is an unsorted array \n* of Integer objects. \n* Postcondition: Array a is sorted in descending order. \n*\/ \npublic void insertionSort() \n{ \n    for (int i = 1; i < a.length; i++) \n    { \n        Integer temp = a[i]; \n        int j = i - 1; \n        while (j >= 0 && temp.compareTo(a[j]) > 0) \n        { \n            a[j+1] = a[j]; \n            j--; \n        } \n        a[j+1] = temp; \n    } \n} \n\nWhen sorted biggest to smallest with insertionSort, which list will need the fewest changes of position for individual elements? \nCorrect: 9, 5, 1, 4, 3, 2\nIncorrect: 5, 1, 2, 3, 4, 9\nIncorrect: 9, 4, 2, 5, 1, 3\nIncorrect: 9, 3, 5, 1, 4, 2\nIncorrect: 3, 2, 1, 9, 5, 4\n\nEND"}
{"prompt":"In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a “search-and-swap” algorithm. Here’s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is “it,” the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that “it” is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\n###\n\n","completion":" Question: Consider the insertionSort method and the private instance variable a, both in a Sorter class. \n\nprivate Integer[] a; \n\n\/** Precondition: a[0],a[1]...a[a.length-1] is an unsorted array \n* of Integer objects. \n* Postcondition: Array a is sorted in descending order. \n*\/ \npublic void insertionSort() \n{ \n    for (int i = 1; i < a.length; i++) \n    { \n        Integer temp = a[i]; \n        int j = i - 1; \n        while (j >= 0 && temp.compareTo(a[j]) > 0) \n        { \n            a[j+1] = a[j]; \n            j--; \n        } \n        a[j+1] = temp; \n    } \n} \n\nWhen sorted biggest to smallest with insertionSort, which list will need the greatest number of changes in position? \nCorrect: 5, 1, 2, 3, 4, 7, 6, 9\nIncorrect: 9, 5, 1, 4, 3, 2, 1, 0\nIncorrect: 9, 4, 6, 2, 1, 5, 1, 3\nIncorrect: 9, 6, 9, 5, 6, 7, 2, 0\nIncorrect: 3, 2, 1, 0, 9, 6, 5, 4\n\nEND"}
{"prompt":"In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a “search-and-swap” algorithm. Here’s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is “it,” the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that “it” is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\n###\n\n","completion":" Question: Consider the insertionSort method and the private instance variable a, both in a Sorter class. \n\nprivate Integer[] a; \n\n\/** Precondition: a[0],a[1]...a[a.length-1] is an unsorted array \n* of Integer objects. \n* Postcondition: Array a is sorted in descending order. \n*\/ \npublic void insertionSort() \n{ \n    for (int i = 1; i < a.length; i++) \n    { \n        Integer temp = a[i]; \n        int j = i - 1; \n        while (j >= 0 && temp.compareTo(a[j]) > 0) \n        { \n            a[j+1] = a[j]; \n            j--; \n        } \n        a[j+1] = temp; \n    } \n} \n\nWhile typing the insertionSort method, a programmer by mistake enters \nwhile (temp.compareTo( a[j]) > 0) \ninstead of \nwhile (j >= 0 && temp.compareTo( a[j]) > 0) \n\nDespite this mistake, the method works as intended the first time the programmer enters an array to be sorted in descending order. Which of the following could explain this? \nI The first element in the array was the largest element in the array. \nII The array was already sorted in descending order. \nIII The first element was less than or equal to all the other elements in the array. \nCorrect: I and II only\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: II and III only\n\nEND"}
{"prompt":"In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a “search-and-swap” algorithm. Here’s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is “it,” the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that “it” is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\n###\n\n","completion":" Question: The elements in a long list of integers are roughly sorted in decreasing order. No more than 5 percent of the elements are out of order. Which of the following is a valid reason for using an insertion sort rather than a selection sort to sort this list into decreasing order? \nI There will be fewer comparisons of elements for insertion sort. \nII There will be fewer changes of position of elements for insertion sort. \nIII There will be less space required for insertion sort. \nCorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"Selection and insertion sorts are inefficient for large n, requiring approximately n passes through a list of n elements. More efficient algorithms can be devised using a “divide-and-conquer” approach, which is used in both the sorting algorithms that follow.\n\nMergesort\nHere is a recursive description of how mergesort works:\n\nIf there is more than one element in the array\n    Break the array into two halves.\n    Mergesort the left half.\n    Mergesort the right half.\n    Merge the two subarrays into a sorted array.\n\nMergesort uses a merge method to merge two sorted pieces of an array into a single sorted array. For example, suppose array a[0] . . . a[n-1] is such that a[0] . . . a[k] is sorted and a[k+1] . . . a[n-1] is sorted, both parts in increasing order. Example:\na[0] a[1] a[2] a[3] a[4] a[5]\n2 5 8 9 1 6\n\nIn this case, a[0] . . . a[3] and a[4] . . . a[5] are the two sorted pieces. The method call merge(a,0,3,5) should produce the “merged” array:\na[0] a[1] a[2] a[3] a[4] a[5]\n1 2 5 6 8 9\n\nThe middle numerical parameter in merge (the 3 in this case) represents the index of the last element in the first “piece” of the array. The first and third numerical parameters are the lowest and highest index, respectively, of array a.\nHere’s what happens in mergesort:\n1. Start with an unsorted list of n elements.\n2. The recursive calls break the list into n sublists, each of length 1. Note that these n arrays, each containing just one element, are sorted!\n3. Recursively merge adjacent pairs of lists. There are then approximately n\/2 lists of length 2; then, approximately n\/4 lists of approximate length 4, and so on, until there is just one list of length n.\n\nAnalysis of Mergesort:\n1. The major disadvantage of mergesort is that it needs a temporary array that is as large as the original array to be sorted. This could be a problem if space is a factor.\n2. Mergesort is not affected by the initial ordering of the elements. Thus, best, worst, and average cases have similar run times.\n\nFor large n, quicksort is, on average, the fastest known sorting algorithm. Here is a recursive description of how quicksort works:\n\nIf there are at least two elements in the array\n    Partition the array.\n    Quicksort the left subarray.\n    Quicksort the right subarray.\n\nThe partition method splits the array into two subarrays as follows: a pivot element is chosen at random from the array (often just the first element) and placed so that all items to the left of the pivot are less than or equal to the pivot, whereas those to the right are greater than or equal to it.\nFor example, if the array is 4, 1, 2, 7, 5, −1, 8, 0, 6, and a[0] = 4 is the pivot, the partition method produces\n−1 1 2 0 4 5 8 7 6\n\nHere’s how the partitioning works: Let a[0], 4 in this case, be the pivot. Markers up and down are initialized to index values 0 and n − 1, as shown. Move the up marker until a value less than the pivot is found, or down equals up. Move the down marker until a value greater than the pivot is found, or down equals up. Swap a[up] and a[down]. Continue the process until down equals up. This is the pivot position. Swap a[0] and a[pivotPosition].\nNotice that the pivot element, 4, is in its final sorted position.\n\nAnalysis of Quicksort:\n1. For the fastest run time, the array should be partitioned into two parts of roughly the same size.\n2. If the pivot happens to be the smallest or largest element in the array, the split is not much of a split—one of the subarrays is empty! If this happens repeatedly, quicksort degenerates into a slow, recursive version of selection sort and is very inefficient.\n3. The worst case for quicksort occurs when the partitioning algorithm repeatedly divides the array into pieces of size 1 and n − 1. An example is when the array is initially sorted in either order and the first or last element is chosen as the pivot. Some algorithms avoid this situation by initially shuffling up the given array (!) or selecting the pivot by examining several elements of the array (such as first, middle, and last) and then taking the median.\n\nNOTE\nFor both quicksort and mergesort, when a subarray gets down to some small size m, it becomes faster to sort by straight insertion. The optimal value of m is machine dependent, but it’s approximately equal to 7.\n\n\n###\n\n","completion":" Question: The code shown sorts array a[0] . . . a[a.length-1] in descending order. \n\npublic static void sort(String[] a) \n{ \n    for (int i = 0; i < a.length - 1; i++) \n        for (int j = 0; j < a.length - i - 1; j++) \n            if (a[j].compareTo(a[j+1]) < 0) \n                swap(a, j, j + 1); \/\/swap a[j] and a[j+1] \n} \n\nThis is an example of \nCorrect: none of the above.\n\n\nIncorrect: selection sort.\nIncorrect: insertion sort.\nIncorrect: mergesort.\nIncorrect: quicksort.END"}
{"prompt":"Selection and insertion sorts are inefficient for large n, requiring approximately n passes through a list of n elements. More efficient algorithms can be devised using a “divide-and-conquer” approach, which is used in both the sorting algorithms that follow.\n\nMergesort\nHere is a recursive description of how mergesort works:\n\nIf there is more than one element in the array\n    Break the array into two halves.\n    Mergesort the left half.\n    Mergesort the right half.\n    Merge the two subarrays into a sorted array.\n\nMergesort uses a merge method to merge two sorted pieces of an array into a single sorted array. For example, suppose array a[0] . . . a[n-1] is such that a[0] . . . a[k] is sorted and a[k+1] . . . a[n-1] is sorted, both parts in increasing order. Example:\na[0] a[1] a[2] a[3] a[4] a[5]\n2 5 8 9 1 6\n\nIn this case, a[0] . . . a[3] and a[4] . . . a[5] are the two sorted pieces. The method call merge(a,0,3,5) should produce the “merged” array:\na[0] a[1] a[2] a[3] a[4] a[5]\n1 2 5 6 8 9\n\nThe middle numerical parameter in merge (the 3 in this case) represents the index of the last element in the first “piece” of the array. The first and third numerical parameters are the lowest and highest index, respectively, of array a.\nHere’s what happens in mergesort:\n1. Start with an unsorted list of n elements.\n2. The recursive calls break the list into n sublists, each of length 1. Note that these n arrays, each containing just one element, are sorted!\n3. Recursively merge adjacent pairs of lists. There are then approximately n\/2 lists of length 2; then, approximately n\/4 lists of approximate length 4, and so on, until there is just one list of length n.\n\nAnalysis of Mergesort:\n1. The major disadvantage of mergesort is that it needs a temporary array that is as large as the original array to be sorted. This could be a problem if space is a factor.\n2. Mergesort is not affected by the initial ordering of the elements. Thus, best, worst, and average cases have similar run times.\n\nFor large n, quicksort is, on average, the fastest known sorting algorithm. Here is a recursive description of how quicksort works:\n\nIf there are at least two elements in the array\n    Partition the array.\n    Quicksort the left subarray.\n    Quicksort the right subarray.\n\nThe partition method splits the array into two subarrays as follows: a pivot element is chosen at random from the array (often just the first element) and placed so that all items to the left of the pivot are less than or equal to the pivot, whereas those to the right are greater than or equal to it.\nFor example, if the array is 4, 1, 2, 7, 5, −1, 8, 0, 6, and a[0] = 4 is the pivot, the partition method produces\n−1 1 2 0 4 5 8 7 6\n\nHere’s how the partitioning works: Let a[0], 4 in this case, be the pivot. Markers up and down are initialized to index values 0 and n − 1, as shown. Move the up marker until a value less than the pivot is found, or down equals up. Move the down marker until a value greater than the pivot is found, or down equals up. Swap a[up] and a[down]. Continue the process until down equals up. This is the pivot position. Swap a[0] and a[pivotPosition].\nNotice that the pivot element, 4, is in its final sorted position.\n\nAnalysis of Quicksort:\n1. For the fastest run time, the array should be partitioned into two parts of roughly the same size.\n2. If the pivot happens to be the smallest or largest element in the array, the split is not much of a split—one of the subarrays is empty! If this happens repeatedly, quicksort degenerates into a slow, recursive version of selection sort and is very inefficient.\n3. The worst case for quicksort occurs when the partitioning algorithm repeatedly divides the array into pieces of size 1 and n − 1. An example is when the array is initially sorted in either order and the first or last element is chosen as the pivot. Some algorithms avoid this situation by initially shuffling up the given array (!) or selecting the pivot by examining several elements of the array (such as first, middle, and last) and then taking the median.\n\nNOTE\nFor both quicksort and mergesort, when a subarray gets down to some small size m, it becomes faster to sort by straight insertion. The optimal value of m is machine dependent, but it’s approximately equal to 7.\n\n\n###\n\n","completion":" Question: Which of the following is a valid reason why mergesort is a better sorting algorithm than insertion sort for sorting long, randomly ordered lists? \nI Mergesort requires less code than insertion sort. \nII Mergesort requires less storage space than insertion sort. \nIII Mergesort runs faster than insertion sort. \nCorrect: III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: II and III only\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: A large array of lowercase characters is to be searched for the pattern “pqrs.” The first step in a very efficient searching algorithm is to look at characters with index \nCorrect: 3, 7, 11, . . . until any letter in “p” . . . “s” is encountered.\nIncorrect: 0, 1, 2, . . . until a “p” is encountered.\nIncorrect: 0, 1, 2, . . . until any letter in “p” . . . “s” is encountered.\nIncorrect: 3, 7, 11, . . . until an “s” is encountered.\nIncorrect: 3, 7, 11, . . . until any letter other than “p” . . . “s” is encountered.\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: The array names[0], names[1], . . . , names[9999] is a list of 10,000 name strings. The list is to be searched to determine the location of some name X in the list. \nWhich of the following preconditions is necessary for a binary search? \nCorrect: The list is in alphabetical order.\nIncorrect: There are no duplicate names in the list.\nIncorrect: The number of names N in the list is large.\nIncorrect: Name X is definitely in the list.\nIncorrect: Name X occurs near the middle of the list.\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: Consider the following method: \n\n\/** Precondition: a[0],a[1]...a[n-1] contain integers. *\/ \npublic static int someMethod(int[] a, int n, int value) \n{ \n    if (n == 0) \n        return -1; \n    else \n    { \n        if (a[n-1] == value) \n            return n - 1; \n        else \n            return someMethod(a, n - 1, value); \n    } \n} \n\nThe method shown is an example of \nCorrect: sequential search.\n\n\nIncorrect: insertion sort.\nIncorrect: mergesort.\nIncorrect: selection sort.\nIncorrect: binary search.END"}
{"prompt":"Selection and insertion sorts are inefficient for large n, requiring approximately n passes through a list of n elements. More efficient algorithms can be devised using a “divide-and-conquer” approach, which is used in both the sorting algorithms that follow.\n\nMergesort\nHere is a recursive description of how mergesort works:\n\nIf there is more than one element in the array\n    Break the array into two halves.\n    Mergesort the left half.\n    Mergesort the right half.\n    Merge the two subarrays into a sorted array.\n\nMergesort uses a merge method to merge two sorted pieces of an array into a single sorted array. For example, suppose array a[0] . . . a[n-1] is such that a[0] . . . a[k] is sorted and a[k+1] . . . a[n-1] is sorted, both parts in increasing order. Example:\na[0] a[1] a[2] a[3] a[4] a[5]\n2 5 8 9 1 6\n\nIn this case, a[0] . . . a[3] and a[4] . . . a[5] are the two sorted pieces. The method call merge(a,0,3,5) should produce the “merged” array:\na[0] a[1] a[2] a[3] a[4] a[5]\n1 2 5 6 8 9\n\nThe middle numerical parameter in merge (the 3 in this case) represents the index of the last element in the first “piece” of the array. The first and third numerical parameters are the lowest and highest index, respectively, of array a.\nHere’s what happens in mergesort:\n1. Start with an unsorted list of n elements.\n2. The recursive calls break the list into n sublists, each of length 1. Note that these n arrays, each containing just one element, are sorted!\n3. Recursively merge adjacent pairs of lists. There are then approximately n\/2 lists of length 2; then, approximately n\/4 lists of approximate length 4, and so on, until there is just one list of length n.\n\nAnalysis of Mergesort:\n1. The major disadvantage of mergesort is that it needs a temporary array that is as large as the original array to be sorted. This could be a problem if space is a factor.\n2. Mergesort is not affected by the initial ordering of the elements. Thus, best, worst, and average cases have similar run times.\n\nFor large n, quicksort is, on average, the fastest known sorting algorithm. Here is a recursive description of how quicksort works:\n\nIf there are at least two elements in the array\n    Partition the array.\n    Quicksort the left subarray.\n    Quicksort the right subarray.\n\nThe partition method splits the array into two subarrays as follows: a pivot element is chosen at random from the array (often just the first element) and placed so that all items to the left of the pivot are less than or equal to the pivot, whereas those to the right are greater than or equal to it.\nFor example, if the array is 4, 1, 2, 7, 5, −1, 8, 0, 6, and a[0] = 4 is the pivot, the partition method produces\n−1 1 2 0 4 5 8 7 6\n\nHere’s how the partitioning works: Let a[0], 4 in this case, be the pivot. Markers up and down are initialized to index values 0 and n − 1, as shown. Move the up marker until a value less than the pivot is found, or down equals up. Move the down marker until a value greater than the pivot is found, or down equals up. Swap a[up] and a[down]. Continue the process until down equals up. This is the pivot position. Swap a[0] and a[pivotPosition].\nNotice that the pivot element, 4, is in its final sorted position.\n\nAnalysis of Quicksort:\n1. For the fastest run time, the array should be partitioned into two parts of roughly the same size.\n2. If the pivot happens to be the smallest or largest element in the array, the split is not much of a split—one of the subarrays is empty! If this happens repeatedly, quicksort degenerates into a slow, recursive version of selection sort and is very inefficient.\n3. The worst case for quicksort occurs when the partitioning algorithm repeatedly divides the array into pieces of size 1 and n − 1. An example is when the array is initially sorted in either order and the first or last element is chosen as the pivot. Some algorithms avoid this situation by initially shuffling up the given array (!) or selecting the pivot by examining several elements of the array (such as first, middle, and last) and then taking the median.\n\nNOTE\nFor both quicksort and mergesort, when a subarray gets down to some small size m, it becomes faster to sort by straight insertion. The optimal value of m is machine dependent, but it’s approximately equal to 7.\n\n\n###\n\n","completion":" Question: The partition method for quicksort partitions a list as follows: \n(i) A pivot element is selected from the array. \n(ii) The elements of the list are rearranged such that all elements to the left of the pivot are less than or equal to it; all elements to the right of the pivot are greater than or equal to it. \nPartitioning the array requires which of the following? \nCorrect: A swap algorithm for interchanging array elements\nIncorrect: A recursive algorithm\nIncorrect: A temporary array\nIncorrect: An external file for the array\nIncorrect: A merge method for merging two sorted lists\n\nEND"}
{"prompt":"Selection and insertion sorts are inefficient for large n, requiring approximately n passes through a list of n elements. More efficient algorithms can be devised using a “divide-and-conquer” approach, which is used in both the sorting algorithms that follow.\n\nMergesort\nHere is a recursive description of how mergesort works:\n\nIf there is more than one element in the array\n    Break the array into two halves.\n    Mergesort the left half.\n    Mergesort the right half.\n    Merge the two subarrays into a sorted array.\n\nMergesort uses a merge method to merge two sorted pieces of an array into a single sorted array. For example, suppose array a[0] . . . a[n-1] is such that a[0] . . . a[k] is sorted and a[k+1] . . . a[n-1] is sorted, both parts in increasing order. Example:\na[0] a[1] a[2] a[3] a[4] a[5]\n2 5 8 9 1 6\n\nIn this case, a[0] . . . a[3] and a[4] . . . a[5] are the two sorted pieces. The method call merge(a,0,3,5) should produce the “merged” array:\na[0] a[1] a[2] a[3] a[4] a[5]\n1 2 5 6 8 9\n\nThe middle numerical parameter in merge (the 3 in this case) represents the index of the last element in the first “piece” of the array. The first and third numerical parameters are the lowest and highest index, respectively, of array a.\nHere’s what happens in mergesort:\n1. Start with an unsorted list of n elements.\n2. The recursive calls break the list into n sublists, each of length 1. Note that these n arrays, each containing just one element, are sorted!\n3. Recursively merge adjacent pairs of lists. There are then approximately n\/2 lists of length 2; then, approximately n\/4 lists of approximate length 4, and so on, until there is just one list of length n.\n\nAnalysis of Mergesort:\n1. The major disadvantage of mergesort is that it needs a temporary array that is as large as the original array to be sorted. This could be a problem if space is a factor.\n2. Mergesort is not affected by the initial ordering of the elements. Thus, best, worst, and average cases have similar run times.\n\nFor large n, quicksort is, on average, the fastest known sorting algorithm. Here is a recursive description of how quicksort works:\n\nIf there are at least two elements in the array\n    Partition the array.\n    Quicksort the left subarray.\n    Quicksort the right subarray.\n\nThe partition method splits the array into two subarrays as follows: a pivot element is chosen at random from the array (often just the first element) and placed so that all items to the left of the pivot are less than or equal to the pivot, whereas those to the right are greater than or equal to it.\nFor example, if the array is 4, 1, 2, 7, 5, −1, 8, 0, 6, and a[0] = 4 is the pivot, the partition method produces\n−1 1 2 0 4 5 8 7 6\n\nHere’s how the partitioning works: Let a[0], 4 in this case, be the pivot. Markers up and down are initialized to index values 0 and n − 1, as shown. Move the up marker until a value less than the pivot is found, or down equals up. Move the down marker until a value greater than the pivot is found, or down equals up. Swap a[up] and a[down]. Continue the process until down equals up. This is the pivot position. Swap a[0] and a[pivotPosition].\nNotice that the pivot element, 4, is in its final sorted position.\n\nAnalysis of Quicksort:\n1. For the fastest run time, the array should be partitioned into two parts of roughly the same size.\n2. If the pivot happens to be the smallest or largest element in the array, the split is not much of a split—one of the subarrays is empty! If this happens repeatedly, quicksort degenerates into a slow, recursive version of selection sort and is very inefficient.\n3. The worst case for quicksort occurs when the partitioning algorithm repeatedly divides the array into pieces of size 1 and n − 1. An example is when the array is initially sorted in either order and the first or last element is chosen as the pivot. Some algorithms avoid this situation by initially shuffling up the given array (!) or selecting the pivot by examining several elements of the array (such as first, middle, and last) and then taking the median.\n\nNOTE\nFor both quicksort and mergesort, when a subarray gets down to some small size m, it becomes faster to sort by straight insertion. The optimal value of m is machine dependent, but it’s approximately equal to 7.\n\n\n###\n\n","completion":" Question: Assume that mergesort will be used to sort an array arr of n integers into increasing order. What is the purpose of the merge method in the mergesort algorithm?\nCorrect: Merge two sorted parts of arr into a single sorted array.\nIncorrect: Partition arr into two parts of roughly equal length, then merge these parts.\nIncorrect: Use a recursive algorithm to sort arr into increasing order.\nIncorrect: Divide arr into n subarrays, each with one element.\nIncorrect: Merge two sorted arrays into a temporary array that is sorted.\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: A binary search is to be performed on an array with 600 elements. In the worst case, which of the following best approximates the number of iterations of the algorithm? \nCorrect: 10\nIncorrect: 6\nIncorrect: 100\nIncorrect: 300\nIncorrect: 600\n\nEND"}
{"prompt":"In each of the following sorting algorithms, assume that an array of n elements, a[0], a[1], . . . , a[n-1], is to be sorted in ascending order.\n\nSelection Sort\nThis is a “search-and-swap” algorithm. Here’s how it works.\nFind the smallest element in the array and exchange it with a[0], the first element. Now find the smallest element in the subarray a[1] . . . a[n-1] and swap it with a[1], the second element in the array. Continue this process until just the last two elements remain to be sorted, a[n-2] and a[n-1]. The smaller of these two elements is placed in a[n-2]; the larger, in a[n-1]; and the sort is complete.\nTrace these steps with a small array of four elements. The unshaded part is the subarray still to be searched.\n\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, the first k elements are in their final sorted position.\n\nInsertion Sort\nThink of the first element in the array, a[0], as being sorted with respect to itself. The array can now be thought of as consisting of two parts, a sorted list followed by an unsorted list. The idea of insertion sort is to move elements from the unsorted list to the sorted list one at a time; as each item is moved, it is inserted into its correct position in the sorted list. In order to place the new item, some elements may need to be moved down to create a slot.\nHere is the array of four elements. In each case, the boxed element is “it,” the next element to be inserted into the sorted part of the list. The shaded area is the part of the list sorted so far.\n8 1 4 6\n1 8 4 6 after first pass\n1 4 8 6 after second pass\n1 4 6 8 after third pass\n\nNOTE\n1. For an array of n elements, the array is sorted after n − 1 passes.\n2. After the kth pass, a[0], a[1], . . . , a[k] are sorted with respect to each other but not necessarily in their final sorted positions.\n3. The worst case for insertion sort occurs if the array is initially sorted in reverse order, since this will lead to the maximum possible number of comparisons and moves.\n4. The best case for insertion sort occurs if the array is already sorted in increasing order. In this case, each pass through the array will involve just one comparison, which will indicate that “it” is in its correct position with respect to the sorted list. Therefore, no elements will need to be moved.\n\n\n###\n\n","completion":" Question: A worst case situation for insertion sort would be \nI A list in correct sorted order. \nII A list sorted in reverse order. \nIII A list in random order. \nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: II and III only\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: Consider a binary search algorithm to search an ordered list of numbers. Which of the following choices is closest to the maximum number of times that such an algorithm will execute its main comparison loop when searching a list of 1 million numbers? \nCorrect: 20\nIncorrect: 6\nIncorrect: 100\nIncorrect: 120\nIncorrect: 1000\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: Consider these three tasks: \nI A sequential search of an array of n names \nII A binary search of an array of n names in alphabetical order \nIII An insertion sort into alphabetical order of an array of n names that are initially in random order \nFor large n, which of the following lists these tasks in order (from least to greatest) of their average case run times? \nCorrect: II I III\nIncorrect: I II III\nIncorrect: II III I\nIncorrect: III I II\nIncorrect: III II I\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: Consider the problem of writing a Hi-Lo game in which a user thinks of an integer from 1 to 100 inclusive and the computer tries to guess that number. Each time the computer makes a guess, the user makes one of three responses: \n• “lower” (i.e., the number is lower than the computer’s guess) \n• “higher” (i.e., the number is higher than the computer’s guess) \n• “you got it in < however many > tries!” \n\nSuppose the game is programmed so that the computer uses a binary search strategy for making its guesses. What is the maximum number of guesses the computer could make before guessing the user’s number? \nCorrect: 7\nIncorrect: 50\nIncorrect: 25\nIncorrect: 10\nIncorrect: 6\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: Consider the problem of writing a Hi-Lo game in which a user thinks of an integer from 1 to 100 inclusive and the computer tries to guess that number. Each time the computer makes a guess, the user makes one of three responses: \n• “lower” (i.e., the number is lower than the computer’s guess) \n• “higher” (i.e., the number is higher than the computer’s guess) \n• “you got it in < however many > tries!”\n\nSuppose the computer used a sequential search strategy for guessing the user’s number. What is the maximum number of guesses the computer could make before guessing the user’s number? \nCorrect: 100\nIncorrect: 99\nIncorrect: 50\nIncorrect: 25\nIncorrect: 10\n\nEND"}
{"prompt":"Unlike the container classes like ArrayList, whose elements must be objects, arrays can hold either objects or primitive types like int or double.\nA common way of organizing code for sorting arrays is to create a sorter class with an array private instance variable. The class holds all the methods for a given type of sorting algorithm, and the constructor assigns the user’s array to the private array variable.\n\nExample\nSelection sort for an array of int.\n\n\/* A class that sorts an array of ints from\n* largest to smallest using selection sort. *\/\npublic class SelectionSort {\n    private int[] a;\n\n    public SelectionSort(int[] arr) {\n        a = arr;\n    }\n\n    \/**\n     * Swap a[i] and a[j] in array a.\n     *\n     * @param i an index for array a\n     * @param j an index for array a\n     *\/\n    private void swap(int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    \/**\n     * Sort array a from largest to smallest using selection sort.\n     * Precondition: a is an array of ints.\n     *\/\n    public void selectionSort() {\n        int maxPos, max;\n        for (int i = 0; i < a.length - 1; i++) {\n            \/\/ find max element in a[i+1] to a[a.length-1]\n            max = a[i];\n            maxPos = i;\n            for (int j = i + 1; j < a.length; j++)\n                if (max < a[j]) {\n                    max = a[j];\n                    maxPos = j;\n                }\n            swap(i, maxPos); \/\/ swap a[i] and a[maxPos]\n        }\n    }\n}\n\nNote that in order to sort objects, there must be a compareTo method in the class, since you need to be able to compare elements.\nAssume that you are searching for a key in a list of n elements. A sequential search starts at the first element and compares the key to each element in turn until the key is found or there are no more elements to examine in the list. If the list is sorted, in ascending order, say, stop searching as soon as the key is less than the current list element.\n\nAnalysis:\n1. The best case has key in the first slot.\n2. The worst case occurs if the key is in the last slot or not in the list. In the worst case, all n elements must be examined.\n3. On average, there will be n\/2 comparisons.\nIf the elements are in a sorted array, a divide-and-conquer approach provides a much more efficient searching algorithm. The following recursive pseudo-code algorithm shows how the binary search works. Assume that a[low] . . . a[high] is sorted in ascending order and that a method binSearch returns the index of key. If key is not in the array, it returns −1.\n\nif (low > high) \/\/Base case. No elements left in array.\n    return -1;\nelse\n{\n    mid = (low + high)\/2;\n    if (key is equal to a[mid]) \/\/found the key\n        return mid;\n    else if (key is less than a[mid]) \/\/key in left half of array\n        < binSearch for key in a[low] to a[mid-1] >\n    else \/\/key in right half of array\n        < binSearch for key in a[mid+1] to a[high] >\n}\n\nNOTE\nWhen low and high cross, there are no more elements to examine, and key is not in the array.\nExample: suppose 5 is the key to be found in the following array:\n\na[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]\n1 4 5 7 9 12 15 20 21\n\nFirst pass: mid = (8+0)\/2 = 4. Check a[4].\nSecond pass: mid = (0+3)\/2 = 1. Check a[1].\nThird pass: mid = (2+3)\/2 = 2. Check a[2]. Yes! Key is found.\n\nAnalysis of Binary Search:\n1. In the best case, the key is found on the first try (i.e., (low + high)\/2 is the index of key).\n2. In the worst case, the key is not in the list or is at either end of a sublist. Here the n elements must be divided by 2 until there is just one element, and then that last element must be tested. An easy way to find the number of comparisons in the worst case is to round n up to the next power of 2 and take the exponent. For example, in the array above, n = 9. Suppose 21 were the key. Round 9 up to 16, which equals 24. Thus you would need four comparisons to find it. Try it!\n\n\n###\n\n","completion":" Question: Consider the problem of writing a Hi-Lo game in which a user thinks of an integer from 1 to 100 inclusive and the computer tries to guess that number. Each time the computer makes a guess, the user makes one of three responses: \n• “lower” (i.e., the number is lower than the computer’s guess) \n• “higher” (i.e., the number is higher than the computer’s guess) \n• “you got it in < however many > tries!”\n\nUsing a sequential search strategy, how many guesses on average would the computer need to guess the number? \nCorrect: 50\nIncorrect: 100\nIncorrect: 51\nIncorrect: 25\nIncorrect: Fewer than 25\nEND"}
{"prompt":"The final flow control structure that appears on the AP Exam is called recursion. It is not represented in the free-response questions and appears at least once in the multiple-choice questions (but typically only a few times). This structure has a result similar to a loop, but approaches the task in a different manner. \nRemember those little wind-up toys you played with when you were little? You know, the plastic teeth or bunny (or whatever) with the little white knob on the side? You would wind the knob over and over, and when you let go, the little teeth would move across the table. The more you wound the knob, the longer the teeth would walk. Since the winding is the same action repeated, it can be considered a loop. The unwinding action, however, differentiates this situation from a while or for loop. When an unwinding or “winding down” occurs as a result of a “winding up,” recursion is lurking in the shadows. \nThe distinguishing characteristic of a recursive method is a call to the very method itself; this statement is called a recursive call. In order to prevent an infinite loop, the recursive method includes a base case, which signals execution to stop recursing and return to each prior recursive call, finishing the job for each. Let’s use an easy example to illustrate this somewhat confusing topic, and then we’ll spice up the example a bit afterward.\nSuppose you have a giant bag of small, multicolored, candy-coated chocolates. As a programmer, you naturally do not want to eat these candies in a haphazard manner; instead, you want to use some sort of algorithm. You decide that you will eat random candies, one at a time, until you reach your favorite color; when your favorite color is reached, you will systematically eat the same colors you ate previously, in backward order. \nFor example, if you eat red -> blue -> orange -> blue -> green, and green is your base case, you will then eat blue -> orange -> blue -> red and the recursion is complete. Pretty tough to remember, right? Well, a recursive method renders this task a cinch. In pseudocode, \neatCandy (color of current candy) \n{ \n    if (current candy color is green) \n        done eating; \n    else \n        eat more candy; \n} \n\nAlthough there is no for or while loop in the code, the recursive call to the method will exhibit a looping quality; unlike our previous loops, however, there is a forward\/backward progression, as described above. \nLet’s add to this task: tell the user that you’re done eating once you finish. Would adding the following line after the if-else statement accomplish this task? \ndisplay I’m done; \n\nThe way recursion works, the task will be accomplished, although perhaps not according to plan. When the base case is reached, execution of the current method is completed, and then the process continues all the way back to the initial recursive call. Since the “I’m done” message is displayed after, and regardless of, the if-else, it will be displayed each time a recursive iteration completes. The result is the displaying of “I’m done” once for every candy that you ate. Nine candies, nine “I’m done” outputs. It works, but probably not as planned. \nAlthough it is more common to use a for loop to step through an array, it is also possible to use a recursion. For example, say you have a lineup of football players, each of whom has a numbered helmet. You want to step through the lineup and find the position of the person who has “9” written on his helmet.\nA recursive solution for this problem is very easy to implement. You need to look through an array of int values and find the position of a specific value, if it’s there. \nFirst, we’ll need to describe the problem in recursive terms. \nIf we’ve looked through every item, then return –1. \nIf the current item in the array is a match, return its position. Or else, restart the process with the next item in the array. \n\npublic int findPosition(int nums[], int key, int currentIndex) { \n    \/\/if we’ve already looked through \n    \/\/the entire array \n    if (nums.length <= currentIndex) \n        return -1; \n    \/\/if the next item in the array is a match, \n    \/\/then return it \n    if (nums[currentIndex] == key)\n        return currentIndex; \n    \/\/else, step past the current item in the array, \n    \/\/and repeat the search on the next item \n    return findPosition(nums, key, currentIndex + 1);\n} \n\nThis example is slightly more subtle than the others because we’re carrying information from one recursive call to the next. Specifically, we’re using the currentIndex field to pass information from one recursive call to another. Thus, the first recursive call starts looking at position 0, the next one at position 1, and so on. \nLet’s go back to our football-player example. You want to step through a lineup of football players and return the position of the player who has the helmet with “9” written on it. Your code would be of the following form: \nint [] players = \/\/represents the football players \nint pos = findPosition(players, 9, 0);\n\n###\n\n","completion":" Question: Consider the following method:\n\/\/ precondition: x >= 0\npublic int mystery (int x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    else\n    {\n        return ((x % 10) + mystery(x \/ 10));\n    }\n}\n\nWhich of the following is returned as a result of the call mystery(3543)?\nCorrect: 15\nIncorrect: 10\nIncorrect: 22\nIncorrect: 180\nIncorrect: Nothing is returned due to infinite recursion.\n\nEND"}
{"prompt":"The final flow control structure that appears on the AP Exam is called recursion. It is not represented in the free-response questions and appears at least once in the multiple-choice questions (but typically only a few times). This structure has a result similar to a loop, but approaches the task in a different manner. \nRemember those little wind-up toys you played with when you were little? You know, the plastic teeth or bunny (or whatever) with the little white knob on the side? You would wind the knob over and over, and when you let go, the little teeth would move across the table. The more you wound the knob, the longer the teeth would walk. Since the winding is the same action repeated, it can be considered a loop. The unwinding action, however, differentiates this situation from a while or for loop. When an unwinding or “winding down” occurs as a result of a “winding up,” recursion is lurking in the shadows. \nThe distinguishing characteristic of a recursive method is a call to the very method itself; this statement is called a recursive call. In order to prevent an infinite loop, the recursive method includes a base case, which signals execution to stop recursing and return to each prior recursive call, finishing the job for each. Let’s use an easy example to illustrate this somewhat confusing topic, and then we’ll spice up the example a bit afterward.\nSuppose you have a giant bag of small, multicolored, candy-coated chocolates. As a programmer, you naturally do not want to eat these candies in a haphazard manner; instead, you want to use some sort of algorithm. You decide that you will eat random candies, one at a time, until you reach your favorite color; when your favorite color is reached, you will systematically eat the same colors you ate previously, in backward order. \nFor example, if you eat red -> blue -> orange -> blue -> green, and green is your base case, you will then eat blue -> orange -> blue -> red and the recursion is complete. Pretty tough to remember, right? Well, a recursive method renders this task a cinch. In pseudocode, \neatCandy (color of current candy) \n{ \n    if (current candy color is green) \n        done eating; \n    else \n        eat more candy; \n} \n\nAlthough there is no for or while loop in the code, the recursive call to the method will exhibit a looping quality; unlike our previous loops, however, there is a forward\/backward progression, as described above. \nLet’s add to this task: tell the user that you’re done eating once you finish. Would adding the following line after the if-else statement accomplish this task? \ndisplay I’m done; \n\nThe way recursion works, the task will be accomplished, although perhaps not according to plan. When the base case is reached, execution of the current method is completed, and then the process continues all the way back to the initial recursive call. Since the “I’m done” message is displayed after, and regardless of, the if-else, it will be displayed each time a recursive iteration completes. The result is the displaying of “I’m done” once for every candy that you ate. Nine candies, nine “I’m done” outputs. It works, but probably not as planned. \nAlthough it is more common to use a for loop to step through an array, it is also possible to use a recursion. For example, say you have a lineup of football players, each of whom has a numbered helmet. You want to step through the lineup and find the position of the person who has “9” written on his helmet.\nA recursive solution for this problem is very easy to implement. You need to look through an array of int values and find the position of a specific value, if it’s there. \nFirst, we’ll need to describe the problem in recursive terms. \nIf we’ve looked through every item, then return –1. \nIf the current item in the array is a match, return its position. Or else, restart the process with the next item in the array. \n\npublic int findPosition(int nums[], int key, int currentIndex) { \n    \/\/if we’ve already looked through \n    \/\/the entire array \n    if (nums.length <= currentIndex) \n        return -1; \n    \/\/if the next item in the array is a match, \n    \/\/then return it \n    if (nums[currentIndex] == key)\n        return currentIndex; \n    \/\/else, step past the current item in the array, \n    \/\/and repeat the search on the next item \n    return findPosition(nums, key, currentIndex + 1);\n} \n\nThis example is slightly more subtle than the others because we’re carrying information from one recursive call to the next. Specifically, we’re using the currentIndex field to pass information from one recursive call to another. Thus, the first recursive call starts looking at position 0, the next one at position 1, and so on. \nLet’s go back to our football-player example. You want to step through a lineup of football players and return the position of the player who has the helmet with “9” written on it. Your code would be of the following form: \nint [] players = \/\/represents the football players \nint pos = findPosition(players, 9, 0);\n\n###\n\n","completion":" Question: Consider the following recursive method:\npublic int mystery(int x)\n{\n    if (x == 1)\n        return 2;\n    else\n        return 2 * mystery(x – 1);\n}\n\nWhat value is returned as a result of the call mystery(6)?\nCorrect: 64\nIncorrect: 2\nIncorrect: 12\nIncorrect: 32\nIncorrect: 128\n\nEND"}
{"prompt":"The final flow control structure that appears on the AP Exam is called recursion. It is not represented in the free-response questions and appears at least once in the multiple-choice questions (but typically only a few times). This structure has a result similar to a loop, but approaches the task in a different manner. \nRemember those little wind-up toys you played with when you were little? You know, the plastic teeth or bunny (or whatever) with the little white knob on the side? You would wind the knob over and over, and when you let go, the little teeth would move across the table. The more you wound the knob, the longer the teeth would walk. Since the winding is the same action repeated, it can be considered a loop. The unwinding action, however, differentiates this situation from a while or for loop. When an unwinding or “winding down” occurs as a result of a “winding up,” recursion is lurking in the shadows. \nThe distinguishing characteristic of a recursive method is a call to the very method itself; this statement is called a recursive call. In order to prevent an infinite loop, the recursive method includes a base case, which signals execution to stop recursing and return to each prior recursive call, finishing the job for each. Let’s use an easy example to illustrate this somewhat confusing topic, and then we’ll spice up the example a bit afterward.\nSuppose you have a giant bag of small, multicolored, candy-coated chocolates. As a programmer, you naturally do not want to eat these candies in a haphazard manner; instead, you want to use some sort of algorithm. You decide that you will eat random candies, one at a time, until you reach your favorite color; when your favorite color is reached, you will systematically eat the same colors you ate previously, in backward order. \nFor example, if you eat red -> blue -> orange -> blue -> green, and green is your base case, you will then eat blue -> orange -> blue -> red and the recursion is complete. Pretty tough to remember, right? Well, a recursive method renders this task a cinch. In pseudocode, \neatCandy (color of current candy) \n{ \n    if (current candy color is green) \n        done eating; \n    else \n        eat more candy; \n} \n\nAlthough there is no for or while loop in the code, the recursive call to the method will exhibit a looping quality; unlike our previous loops, however, there is a forward\/backward progression, as described above. \nLet’s add to this task: tell the user that you’re done eating once you finish. Would adding the following line after the if-else statement accomplish this task? \ndisplay I’m done; \n\nThe way recursion works, the task will be accomplished, although perhaps not according to plan. When the base case is reached, execution of the current method is completed, and then the process continues all the way back to the initial recursive call. Since the “I’m done” message is displayed after, and regardless of, the if-else, it will be displayed each time a recursive iteration completes. The result is the displaying of “I’m done” once for every candy that you ate. Nine candies, nine “I’m done” outputs. It works, but probably not as planned. \nAlthough it is more common to use a for loop to step through an array, it is also possible to use a recursion. For example, say you have a lineup of football players, each of whom has a numbered helmet. You want to step through the lineup and find the position of the person who has “9” written on his helmet.\nA recursive solution for this problem is very easy to implement. You need to look through an array of int values and find the position of a specific value, if it’s there. \nFirst, we’ll need to describe the problem in recursive terms. \nIf we’ve looked through every item, then return –1. \nIf the current item in the array is a match, return its position. Or else, restart the process with the next item in the array. \n\npublic int findPosition(int nums[], int key, int currentIndex) { \n    \/\/if we’ve already looked through \n    \/\/the entire array \n    if (nums.length <= currentIndex) \n        return -1; \n    \/\/if the next item in the array is a match, \n    \/\/then return it \n    if (nums[currentIndex] == key)\n        return currentIndex; \n    \/\/else, step past the current item in the array, \n    \/\/and repeat the search on the next item \n    return findPosition(nums, key, currentIndex + 1);\n} \n\nThis example is slightly more subtle than the others because we’re carrying information from one recursive call to the next. Specifically, we’re using the currentIndex field to pass information from one recursive call to another. Thus, the first recursive call starts looking at position 0, the next one at position 1, and so on. \nLet’s go back to our football-player example. You want to step through a lineup of football players and return the position of the player who has the helmet with “9” written on it. Your code would be of the following form: \nint [] players = \/\/represents the football players \nint pos = findPosition(players, 9, 0);\n\n###\n\n","completion":" Question: Consider the following recursive method:\npublic static int mystery(int x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    else\n    {\n        return (x + mystery(x \/ 2) + mystery(x \/ 4));\n    }\n}\n\nWhat value is returned as a result of a call to mystery(10)?\nCorrect: 22\nIncorrect: 10\nIncorrect: 12\nIncorrect: 20\nIncorrect: 35\n\nEND"}
{"prompt":"The final flow control structure that appears on the AP Exam is called recursion. It is not represented in the free-response questions and appears at least once in the multiple-choice questions (but typically only a few times). This structure has a result similar to a loop, but approaches the task in a different manner. \nRemember those little wind-up toys you played with when you were little? You know, the plastic teeth or bunny (or whatever) with the little white knob on the side? You would wind the knob over and over, and when you let go, the little teeth would move across the table. The more you wound the knob, the longer the teeth would walk. Since the winding is the same action repeated, it can be considered a loop. The unwinding action, however, differentiates this situation from a while or for loop. When an unwinding or “winding down” occurs as a result of a “winding up,” recursion is lurking in the shadows. \nThe distinguishing characteristic of a recursive method is a call to the very method itself; this statement is called a recursive call. In order to prevent an infinite loop, the recursive method includes a base case, which signals execution to stop recursing and return to each prior recursive call, finishing the job for each. Let’s use an easy example to illustrate this somewhat confusing topic, and then we’ll spice up the example a bit afterward.\nSuppose you have a giant bag of small, multicolored, candy-coated chocolates. As a programmer, you naturally do not want to eat these candies in a haphazard manner; instead, you want to use some sort of algorithm. You decide that you will eat random candies, one at a time, until you reach your favorite color; when your favorite color is reached, you will systematically eat the same colors you ate previously, in backward order. \nFor example, if you eat red -> blue -> orange -> blue -> green, and green is your base case, you will then eat blue -> orange -> blue -> red and the recursion is complete. Pretty tough to remember, right? Well, a recursive method renders this task a cinch. In pseudocode, \neatCandy (color of current candy) \n{ \n    if (current candy color is green) \n        done eating; \n    else \n        eat more candy; \n} \n\nAlthough there is no for or while loop in the code, the recursive call to the method will exhibit a looping quality; unlike our previous loops, however, there is a forward\/backward progression, as described above. \nLet’s add to this task: tell the user that you’re done eating once you finish. Would adding the following line after the if-else statement accomplish this task? \ndisplay I’m done; \n\nThe way recursion works, the task will be accomplished, although perhaps not according to plan. When the base case is reached, execution of the current method is completed, and then the process continues all the way back to the initial recursive call. Since the “I’m done” message is displayed after, and regardless of, the if-else, it will be displayed each time a recursive iteration completes. The result is the displaying of “I’m done” once for every candy that you ate. Nine candies, nine “I’m done” outputs. It works, but probably not as planned. \nAlthough it is more common to use a for loop to step through an array, it is also possible to use a recursion. For example, say you have a lineup of football players, each of whom has a numbered helmet. You want to step through the lineup and find the position of the person who has “9” written on his helmet.\nA recursive solution for this problem is very easy to implement. You need to look through an array of int values and find the position of a specific value, if it’s there. \nFirst, we’ll need to describe the problem in recursive terms. \nIf we’ve looked through every item, then return –1. \nIf the current item in the array is a match, return its position. Or else, restart the process with the next item in the array. \n\npublic int findPosition(int nums[], int key, int currentIndex) { \n    \/\/if we’ve already looked through \n    \/\/the entire array \n    if (nums.length <= currentIndex) \n        return -1; \n    \/\/if the next item in the array is a match, \n    \/\/then return it \n    if (nums[currentIndex] == key)\n        return currentIndex; \n    \/\/else, step past the current item in the array, \n    \/\/and repeat the search on the next item \n    return findPosition(nums, key, currentIndex + 1);\n} \n\nThis example is slightly more subtle than the others because we’re carrying information from one recursive call to the next. Specifically, we’re using the currentIndex field to pass information from one recursive call to another. Thus, the first recursive call starts looking at position 0, the next one at position 1, and so on. \nLet’s go back to our football-player example. You want to step through a lineup of football players and return the position of the player who has the helmet with “9” written on it. Your code would be of the following form: \nint [] players = \/\/represents the football players \nint pos = findPosition(players, 9, 0);\n\n###\n\n","completion":" Question: Consider the following nonrecursive method:\n\/\/precondition: x >= 0\npublic static int mystery(int x)\n{\n    int sum = 0;\n    while(x >= 0)\n    {\n        sum += x;\n        x--;\n    }\n    return sum;\n}\n\nWhich of the following recursive methods are equivalent to the method above?\nI. public static int mystery2(int x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    return (x + mystery2(x – 1));\n}\nII. public static int mystery3 (int x)\n{\n    if (x == 0)\n        return 0;\n    else\n        return mystery3(x – 1);\n}\nIII. public static int mystery4 (int x) {\n    if (x == 1)\n    {\n        return 1:\n    }\n    return (x + mystery 4(x – 1));\n}\nCorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II only\nIncorrect: II and III only\n\nEND"}
{"prompt":"The final flow control structure that appears on the AP Exam is called recursion. It is not represented in the free-response questions and appears at least once in the multiple-choice questions (but typically only a few times). This structure has a result similar to a loop, but approaches the task in a different manner. \nRemember those little wind-up toys you played with when you were little? You know, the plastic teeth or bunny (or whatever) with the little white knob on the side? You would wind the knob over and over, and when you let go, the little teeth would move across the table. The more you wound the knob, the longer the teeth would walk. Since the winding is the same action repeated, it can be considered a loop. The unwinding action, however, differentiates this situation from a while or for loop. When an unwinding or “winding down” occurs as a result of a “winding up,” recursion is lurking in the shadows. \nThe distinguishing characteristic of a recursive method is a call to the very method itself; this statement is called a recursive call. In order to prevent an infinite loop, the recursive method includes a base case, which signals execution to stop recursing and return to each prior recursive call, finishing the job for each. Let’s use an easy example to illustrate this somewhat confusing topic, and then we’ll spice up the example a bit afterward.\nSuppose you have a giant bag of small, multicolored, candy-coated chocolates. As a programmer, you naturally do not want to eat these candies in a haphazard manner; instead, you want to use some sort of algorithm. You decide that you will eat random candies, one at a time, until you reach your favorite color; when your favorite color is reached, you will systematically eat the same colors you ate previously, in backward order. \nFor example, if you eat red -> blue -> orange -> blue -> green, and green is your base case, you will then eat blue -> orange -> blue -> red and the recursion is complete. Pretty tough to remember, right? Well, a recursive method renders this task a cinch. In pseudocode, \neatCandy (color of current candy) \n{ \n    if (current candy color is green) \n        done eating; \n    else \n        eat more candy; \n} \n\nAlthough there is no for or while loop in the code, the recursive call to the method will exhibit a looping quality; unlike our previous loops, however, there is a forward\/backward progression, as described above. \nLet’s add to this task: tell the user that you’re done eating once you finish. Would adding the following line after the if-else statement accomplish this task? \ndisplay I’m done; \n\nThe way recursion works, the task will be accomplished, although perhaps not according to plan. When the base case is reached, execution of the current method is completed, and then the process continues all the way back to the initial recursive call. Since the “I’m done” message is displayed after, and regardless of, the if-else, it will be displayed each time a recursive iteration completes. The result is the displaying of “I’m done” once for every candy that you ate. Nine candies, nine “I’m done” outputs. It works, but probably not as planned. \nAlthough it is more common to use a for loop to step through an array, it is also possible to use a recursion. For example, say you have a lineup of football players, each of whom has a numbered helmet. You want to step through the lineup and find the position of the person who has “9” written on his helmet.\nA recursive solution for this problem is very easy to implement. You need to look through an array of int values and find the position of a specific value, if it’s there. \nFirst, we’ll need to describe the problem in recursive terms. \nIf we’ve looked through every item, then return –1. \nIf the current item in the array is a match, return its position. Or else, restart the process with the next item in the array. \n\npublic int findPosition(int nums[], int key, int currentIndex) { \n    \/\/if we’ve already looked through \n    \/\/the entire array \n    if (nums.length <= currentIndex) \n        return -1; \n    \/\/if the next item in the array is a match, \n    \/\/then return it \n    if (nums[currentIndex] == key)\n        return currentIndex; \n    \/\/else, step past the current item in the array, \n    \/\/and repeat the search on the next item \n    return findPosition(nums, key, currentIndex + 1);\n} \n\nThis example is slightly more subtle than the others because we’re carrying information from one recursive call to the next. Specifically, we’re using the currentIndex field to pass information from one recursive call to another. Thus, the first recursive call starts looking at position 0, the next one at position 1, and so on. \nLet’s go back to our football-player example. You want to step through a lineup of football players and return the position of the player who has the helmet with “9” written on it. Your code would be of the following form: \nint [] players = \/\/represents the football players \nint pos = findPosition(players, 9, 0);\n\n###\n\n","completion":" Question: Consider the following method:\npublic int mystery(int x, int y)\n{\n    if (x >= 100 || y <= 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return mystery(x + 10, y – 3);\n    }\n}\nWhat value is returned by the call mystery (30, 18)?\nCorrect: 1\nIncorrect: 0\nIncorrect: 6\nIncorrect: 7\nIncorrect: Nothing will be returned due to infinite recursion.\n\nEND"}
{"prompt":"The final flow control structure that appears on the AP Exam is called recursion. It is not represented in the free-response questions and appears at least once in the multiple-choice questions (but typically only a few times). This structure has a result similar to a loop, but approaches the task in a different manner. \nRemember those little wind-up toys you played with when you were little? You know, the plastic teeth or bunny (or whatever) with the little white knob on the side? You would wind the knob over and over, and when you let go, the little teeth would move across the table. The more you wound the knob, the longer the teeth would walk. Since the winding is the same action repeated, it can be considered a loop. The unwinding action, however, differentiates this situation from a while or for loop. When an unwinding or “winding down” occurs as a result of a “winding up,” recursion is lurking in the shadows. \nThe distinguishing characteristic of a recursive method is a call to the very method itself; this statement is called a recursive call. In order to prevent an infinite loop, the recursive method includes a base case, which signals execution to stop recursing and return to each prior recursive call, finishing the job for each. Let’s use an easy example to illustrate this somewhat confusing topic, and then we’ll spice up the example a bit afterward.\nSuppose you have a giant bag of small, multicolored, candy-coated chocolates. As a programmer, you naturally do not want to eat these candies in a haphazard manner; instead, you want to use some sort of algorithm. You decide that you will eat random candies, one at a time, until you reach your favorite color; when your favorite color is reached, you will systematically eat the same colors you ate previously, in backward order. \nFor example, if you eat red -> blue -> orange -> blue -> green, and green is your base case, you will then eat blue -> orange -> blue -> red and the recursion is complete. Pretty tough to remember, right? Well, a recursive method renders this task a cinch. In pseudocode, \neatCandy (color of current candy) \n{ \n    if (current candy color is green) \n        done eating; \n    else \n        eat more candy; \n} \n\nAlthough there is no for or while loop in the code, the recursive call to the method will exhibit a looping quality; unlike our previous loops, however, there is a forward\/backward progression, as described above. \nLet’s add to this task: tell the user that you’re done eating once you finish. Would adding the following line after the if-else statement accomplish this task? \ndisplay I’m done; \n\nThe way recursion works, the task will be accomplished, although perhaps not according to plan. When the base case is reached, execution of the current method is completed, and then the process continues all the way back to the initial recursive call. Since the “I’m done” message is displayed after, and regardless of, the if-else, it will be displayed each time a recursive iteration completes. The result is the displaying of “I’m done” once for every candy that you ate. Nine candies, nine “I’m done” outputs. It works, but probably not as planned. \nAlthough it is more common to use a for loop to step through an array, it is also possible to use a recursion. For example, say you have a lineup of football players, each of whom has a numbered helmet. You want to step through the lineup and find the position of the person who has “9” written on his helmet.\nA recursive solution for this problem is very easy to implement. You need to look through an array of int values and find the position of a specific value, if it’s there. \nFirst, we’ll need to describe the problem in recursive terms. \nIf we’ve looked through every item, then return –1. \nIf the current item in the array is a match, return its position. Or else, restart the process with the next item in the array. \n\npublic int findPosition(int nums[], int key, int currentIndex) { \n    \/\/if we’ve already looked through \n    \/\/the entire array \n    if (nums.length <= currentIndex) \n        return -1; \n    \/\/if the next item in the array is a match, \n    \/\/then return it \n    if (nums[currentIndex] == key)\n        return currentIndex; \n    \/\/else, step past the current item in the array, \n    \/\/and repeat the search on the next item \n    return findPosition(nums, key, currentIndex + 1);\n} \n\nThis example is slightly more subtle than the others because we’re carrying information from one recursive call to the next. Specifically, we’re using the currentIndex field to pass information from one recursive call to another. Thus, the first recursive call starts looking at position 0, the next one at position 1, and so on. \nLet’s go back to our football-player example. You want to step through a lineup of football players and return the position of the player who has the helmet with “9” written on it. Your code would be of the following form: \nint [] players = \/\/represents the football players \nint pos = findPosition(players, 9, 0);\n\n###\n\n","completion":" Question: Consider the following incomplete method:\npublic int mystery(int x)\n{\n    if (x <= 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return (\/ * missing code * \/);\n    }\n}\n\nWhich of the following could be used to replace \/ * missing code * \/ so that the value of mystery(10) is 32?\nCorrect: 2 * mystery(x – 2)\nIncorrect: mystery(x – 1) + mystery(x – 2)\nIncorrect: 2 * mystery(x – 1)\nIncorrect: 4 * mystery(x – 4)\nIncorrect: 4 + mystery(x – 1)END"}
{"prompt":"When a group of statements, including control structures, is assembled into a single unit, the unit is called a class. Similar to a word processing document or a picture file stored on your computer, a class is stored on your computer in a file. Unlike a word processing document, however, a class must follow specific rules in order to conform to Java and, as a result, to be understood by the compiler. Remember that your brilliantly constructed program is useless unless the compiler can successfully translate it into machine code.\nThe structure of a class, at this level anyway, is straightforward. Take all of the statements you’ve written before this chapter, put curly brackets around them, kind of like a huge block, name it, and save it. The naming conventions for a class are similar to those of a variable, except that they should begin with a capital letter. The name of the class should reference the purpose or function of the class. For example, a class that calculates a GPA might be called GPA or GradePointAvg. The way we declare a class in Java is using the header:\npublic class GradePointAvg\n{\n\t\/\/ statements not shown\n}\n\nWell, Actually… This is a convention but not a rule. You can have all of the code on a single line if your heart so desires, but that would be very bad form.\nNote that the statements in the class reside at least one tab stop across the page. If the programmer would like to use more white space within the structures of the class, they will be tabbed further into the page:\npublic class GradePointAvg\n{\n\t\/\/ other code and variable declarations not shown\n\twhile (\/* condition not shown *\/)\n\t{\n\t\t\/\/ looped statements not shown\n\t}\n}\n\nTypically, variable declarations are placed into the code first, right after the class header, as a sort of “setup” for the rest of the class. Of course, this is not a rule, but it is a good guideline in order to keep your code readable.\nThis class would be saved to the computer as GradePointAvg.java; the .java extension helps the compiler to recognize the file as containing Java code. If the code compiles (there are no syntax errors), the compiler will create another file in the same folder called GradePointAvg.class; this file is unreadable to the programmer because it is encoded in machine language. The computer, however, uses this file to execute the program. The .java file is called the source code of the program, since it defines the program’s actions and functions.\nRemember that classes are executed top-down—i.e., line 1 followed by line 2, etc. If programmers want to alter top-down execution, they must use a flow control structure, as we studied before.\n\n\n###\n\n","completion":" Question: Which of the following class declarations would cause a compile-time error? Assume the rest of the code compiles as intended.\nCorrect: public class 4APCalculus\nIncorrect: public class Calculus\nIncorrect: public class apCalculus\nIncorrect: public class APCalculus\nIncorrect: public class APCalculus extends Calculus\n\nEND"}
{"prompt":"Picture a Java class as a closet, with essentially limitless possibilities. If you were to declare a single shelf to hold, say, board game boxes…that would be a great way to organize your collection of games, toys, and other sophisticated possessions.\nA class is organized in this way using methods.\nA method is a group of code that performs a specific task.\n\nAlthough a class can simply contain a list of commands, any program that accomplishes a task could easily balloon to 100 lines of code, or more. Instead of writing a class that contains a giant list of disorganized code, writing separate methods for each small task (within the overarching task) is an excellent way to make your code more readable. In addition, method based classes enable easier flow control.\nTo understand this concept, let’s break down a bright, sunny Saturday in the middle of the summer (don’t worry—you will make it). Perhaps some of the activities you would do might include getting out of bed (obviously), eating breakfast, taking a shower, getting ready for the beach, driving to the beach, enjoying the beach, and eating lunch. Each of these activities has its own specific components; for example, part of eating breakfast includes drinking orange juice and taking a daily vitamin supplement. The pseudocode of a program that simulates this Saturday’s activities might look like this:\npublic class Saturday1\n{\n\thear alarm;\n\tturn off alarm;\n\tget out of bed;\n\tmake breakfast;\n\teat breakfast;…\n\nYou get the idea…. A long list of commands that occur top-down. Now, consider each of these general activities as a separate grouping of smaller activities, called a method. Each small activity will be defined later, but your Saturday class would look much cleaner:\npublic class Saturday2\n{\n\twake up method; \/\/ includes alarm\n\teat breakfast method; \/\/ includes preparation, OJ, vitamin, etc.\n\ttake a shower method; \/\/ includes preparing for the shower, etc.\n\tbeach method; \/\/ includes prep for the beach, driving to the beach, etc.\n\teat lunch method;\n}\n\nThe result is a cleaner, more structured class that is easier to read. A class that is created to control a larger program, such as Saturday2, is called a driver class because it drives the program through its general structure which will, in turn, execute the smaller commands. Note also that if, for some reason, the programmer wanted the simulation to take a shower before eating breakfast, the two lines would be switched in Saturday2 and the job would be done. Performing the same change in Saturday1 would involve switching multiple lines of code. Even more poignant would be a simulation that repeats method calls, such as one that represents your extra hungry older brother, who eats breakfast twice. The driver would simply call the breakfast method twice (or use a loop to call it more than twice) and the job would be completed.\nAn object class is a different kind of class which houses the “guts” of the methods that the driver class calls. As you understand this setup, you will see that your driver classes begin to shorten, while your object classes expand. For example, the driver of a car truly performs a relatively small set of actions in order to drive the car: start the engine, buckle the seatbelt, check the mirrors, accelerate, brake, steer. The driver does not actually understand (nor does he need to) exactly how these operations work: he just does them. How does the accelerator pedal actually make the car move more quickly? Doesn’t matter. The “driver” just operates the pedal and the rest happens under the hood. The object class is the “under the hood” class. It defines all of the aspects of an object; more specifically, it defines what the object has and what the object does.\nThe object class referred to in this section should not be confused with the Object class in the Java language which is the Parent class of all classes. The Object class is part of the Java.lang package. Every class in Java is a descendent of this class. Every class in Java inherits the methods of the Object class.\nFor the AP Exam, you must be able to write, troubleshoot, and understand object AND driver classes, as well as understand how they interact. These skills are HUGE in the free-response questions!\nBack to the breakfast example… pseudocode for the object class might look something like this:\npublic class Saturday3\n{\n\twake up(…)\n\t{\n\t\thear alarm;\n\t\tturn off alarm;\n\t\tget out of bed;\n\t}\n\tbreakfast(…)\n\t{\n\t\tmake breakfast;\n\t\teat breakfast;\n\t}\n\nSince our object class could be used for any day of the week, not just Saturday, BeachDay might be a more appropriate name for this class. The driver class from before, which executes a series of actions for this particular day, might be called Saturday.\n\n\n###\n\n","completion":" Question: Which of the following statements would best describe an efficient design to represent a pair of sunglasses?\nCorrect: A PairOfSunglasses class with methods that unfold, clean, and wear the objects in the class\nIncorrect: Three classes: UnfoldGlasses, CleanGlasses, and WearGlasses\nIncorrect: An UnfoldGlasses class with methods CleanGlasses and WearGlasses\nIncorrect: A PairOfSunglasses class with boolean variables unfolded, cleaned, and worn\nIncorrect: A UseSunglasses class with statements that unfold, clean, and wear the sunglasses\n\nEND"}
{"prompt":"Now that we have written classes to run a program, we must get these classes to interact correctly in order to create a functioning program. We have the driver, we have the car, now we need to put the driver into the car to eagerly drive to the AP Computer Science A Exam on exam day.\nThe driver and object classes must reside in the same folder on the computer. If you are using an interactive development environment (as opposed to command line programming), you often have to create a “Project” or some similar structure in the software that will hold all of the program’s files in one place. Remember that the driver depends on the object class in order to compile, and the object class depends on the driver to make it actually do anything.\n\nConsider a program that will take “flower” objects and “plant” them into a garden. The flower objects might be outlined in an object class called Flower. One class will perform the planting, so we can call it MakeGarden.\nSuppose the Flower constructor method has the following header: public Flower(int xPosition, int yPosition) where xPosition and yPosition are the horizontal and vertical coordinates in the garden, respectively, where the flower object will be planted. Our driver would have to first “create” the flowers, and then plant them accordingly.\nIn order to create an object, we must instantiate the object using its corresponding class. Each time we instantiate a flower object, we must assign it an object reference variable; as the fancy name implies, this is just a variable name. Some lines in MakeGarden might look like this:\nFlower f1 = new Flower(2, 1);\nFlower f2 = new Flower(2, 2);\nFlower f3 = new Flower(2, 3);\n\nThese lines will instantiate three different flower objects, each containing its own instance data. f1, f2, and f3 are used to distinguish between the objects. We can then use these objects to perform methods. Consider a plant method in the Flower class; this method would “plant” the flower and might have the following header:\npublic void plant()\n\nIn MakeGarden, we must invoke this method through the objects. Let’s say we want to plant only f1 and f3, but not f2. We would add the following lines:\nf1.plant();\nf3.plant();\n\nNow let’s say the plant method, instead, returns whether or not the plant was successfully planted. This altered plant method might have the header:\npublic boolean plant()\n\nNow we can use the returned data to output an appropriate message in the driver:\nif (f1.plant())\n\tSystem.out.print(\"Planted successfully.\");\nelse\n\tSystem.out.print(\"There was a problem.\");\n\nBecause we are invoking f1.plant, f1 should be planted as requested. Since the plant method returns a boolean value, we can place f1.plant in the context of an if statement (it produces a truth value so it is considered a condition) and now it also functions as part of a control structure. Awesome!\nLet’s add to our garden situation. As you know, other items can appear in a garden besides flowers. Plants, bushes, and weeds can appear in gardens. Each of these items would probably have its own object class, since their instance data and methods would be different from those of flowers. For example, a flower has flower petals, while a plant does not; weeds often grow on their own without water, whereas most flowers and plants do not. Regardless, separate object classes can be created for each of these object types, and the driver can hold them all together, as long as they are all stored in the same folder on the computer.\nAssuming each of these object classes has been created and each corresponding object class has a plant method as outlined above, MakeGarden might include these lines:\nFlower f1 = new Flower();\nFlower f2 = new Flower();\nPlant p1 = new Plant();\nPlant p2 = new Plant();\nWeed w1 = new Weed();\nif (f1.plant())\n\tSystem.out.println(\"Planted successfully\");\nif (f2.plant())\n\tSystem.out.println(\"Planted successfully\");\nif (p1.plant())\n\tSystem.out.println(\"Planted successfully\");\nif (w1.plant())\n\tSystem.out.println(\"You have a weed.\");\n\nNote that MakeGarden does not instantiate any Bush objects, and does not attempt to plant the p2 object. Note also that we cannot see the entire class!\nThe programmer has the task of deciding which objects to instantiate of which type, when and whether to use them, and how to use them appropriately, based on their class specifications. Still think you can go directly to the final draft?\nLet’s add another layer. Programmers often recognize that an object is actually composed of many smaller, or more basic, objects. If you think about a flower, it actually has several parts, each of which has data and does particular actions. As a result, we could write object classes for, say, the stalk and the root system. The Stalk class and the RootSystem class, then, would reside as attributes of each flower. Their classes, again, must be placed in the same folder as the rest of the program’s classes. The programmer can then set up the Flower class as follows:\npublic class Flower\n{\n\t\/\/ other data not shown\n\tprivate Stalk st;\n\tprivate RootSystem rootSys;\n\tpublic Flower()\n\t{\n\t\tst = new Stalk();\n\t\trootSys = new RootSystem();\n\t\t\/\/ other commands not shown\n\t}\n\t\/\/ other methods not shown\n}\nThis means that every Flower object has a stalk and a root system. The Flower class, then, is called an aggregate class because it is made up of, among other data, instances of other classes. This setup is more realistic; think of any object in your room, and you can probably see pretty quickly that it is made of smaller objects, each with its own data and methods. A laptop computer has keys, ports, and a screen, which can all be considered objects because they have stuff and do stuff. A dresser has drawers, but we can go even deeper…a drawer has walls and a floor and can be opened or closed…the floor of a drawer has a shape and is made of a certain material and can be broken if the drawer is overstuffed…you get the idea. Luckily, as programmers, we get to decide the detail of the object classes, and the answer typically lies in the desired function of the program, as we stated before. Do you really need to know what material the floor of the drawer is made of? Most people do not, although a furniture retailer might. Again, it all depends on the application.\nThe free-response questions on the AP Exam will present some sort of context and will often tell you exactly what class(es) and\/or method(s) to write, so they don’t get a wild variety of solutions from test takers around the world.\nOtherwise, they could literally be forced to read thousands of completely different approaches to a given task. This fact is not good for our creativity, but it’s great for scoring a 5; save your creative juices for those extra college classes you can take when you AP out of CS!\n\n\n###\n\n","completion":" Question: Use class Chair and method sitOnChair to answer the following question.\npublic class Chair\n{\n    private int numberOfLegs = 4;\n    private boolean padded;\n    public Chair(boolean soft)\n    {\n        if (soft) padded = true;\n        else padded = false;\n    }\n}\npublic void sitOnChair( )\n{\n    <implementation not shown>\n}\n\nThe method sitOnChair belongs to another class and is supposed to allow the user to “sit” on a Chair if the chair is padded. Which of the following code segments could be used to replace <implementation not shown> so that sitOnChair will work as intended?\nI. Chair c = new Chair(true);\nc.sit();\nII. Chair c = new Chair(true);\nIII. Chair c = new Chair(true);\nif (c.padded) System.out.print(\"You are sitting.\");\nCorrect: None\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and IIIEND"}
{"prompt":"Picture a Java class as a closet, with essentially limitless possibilities. If you were to declare a single shelf to hold, say, board game boxes…that would be a great way to organize your collection of games, toys, and other sophisticated possessions.\nA class is organized in this way using methods.\nA method is a group of code that performs a specific task.\n\nAlthough a class can simply contain a list of commands, any program that accomplishes a task could easily balloon to 100 lines of code, or more. Instead of writing a class that contains a giant list of disorganized code, writing separate methods for each small task (within the overarching task) is an excellent way to make your code more readable. In addition, method based classes enable easier flow control.\nTo understand this concept, let’s break down a bright, sunny Saturday in the middle of the summer (don’t worry—you will make it). Perhaps some of the activities you would do might include getting out of bed (obviously), eating breakfast, taking a shower, getting ready for the beach, driving to the beach, enjoying the beach, and eating lunch. Each of these activities has its own specific components; for example, part of eating breakfast includes drinking orange juice and taking a daily vitamin supplement. The pseudocode of a program that simulates this Saturday’s activities might look like this:\npublic class Saturday1\n{\n\thear alarm;\n\tturn off alarm;\n\tget out of bed;\n\tmake breakfast;\n\teat breakfast;…\n\nYou get the idea…. A long list of commands that occur top-down. Now, consider each of these general activities as a separate grouping of smaller activities, called a method. Each small activity will be defined later, but your Saturday class would look much cleaner:\npublic class Saturday2\n{\n\twake up method; \/\/ includes alarm\n\teat breakfast method; \/\/ includes preparation, OJ, vitamin, etc.\n\ttake a shower method; \/\/ includes preparing for the shower, etc.\n\tbeach method; \/\/ includes prep for the beach, driving to the beach, etc.\n\teat lunch method;\n}\n\nThe result is a cleaner, more structured class that is easier to read. A class that is created to control a larger program, such as Saturday2, is called a driver class because it drives the program through its general structure which will, in turn, execute the smaller commands. Note also that if, for some reason, the programmer wanted the simulation to take a shower before eating breakfast, the two lines would be switched in Saturday2 and the job would be done. Performing the same change in Saturday1 would involve switching multiple lines of code. Even more poignant would be a simulation that repeats method calls, such as one that represents your extra hungry older brother, who eats breakfast twice. The driver would simply call the breakfast method twice (or use a loop to call it more than twice) and the job would be completed.\nAn object class is a different kind of class which houses the “guts” of the methods that the driver class calls. As you understand this setup, you will see that your driver classes begin to shorten, while your object classes expand. For example, the driver of a car truly performs a relatively small set of actions in order to drive the car: start the engine, buckle the seatbelt, check the mirrors, accelerate, brake, steer. The driver does not actually understand (nor does he need to) exactly how these operations work: he just does them. How does the accelerator pedal actually make the car move more quickly? Doesn’t matter. The “driver” just operates the pedal and the rest happens under the hood. The object class is the “under the hood” class. It defines all of the aspects of an object; more specifically, it defines what the object has and what the object does.\nThe object class referred to in this section should not be confused with the Object class in the Java language which is the Parent class of all classes. The Object class is part of the Java.lang package. Every class in Java is a descendent of this class. Every class in Java inherits the methods of the Object class.\nFor the AP Exam, you must be able to write, troubleshoot, and understand object AND driver classes, as well as understand how they interact. These skills are HUGE in the free-response questions!\nBack to the breakfast example… pseudocode for the object class might look something like this:\npublic class Saturday3\n{\n\twake up(…)\n\t{\n\t\thear alarm;\n\t\tturn off alarm;\n\t\tget out of bed;\n\t}\n\tbreakfast(…)\n\t{\n\t\tmake breakfast;\n\t\teat breakfast;\n\t}\n\nSince our object class could be used for any day of the week, not just Saturday, BeachDay might be a more appropriate name for this class. The driver class from before, which executes a series of actions for this particular day, might be called Saturday.\n\n\n###\n\n","completion":" Question: Use class Chair and method sitOnChair to answer the following question.\npublic class Chair\n{\n    private int numberOfLegs = 4;\n    private boolean padded;\n    public Chair(boolean soft)\n    {\n        if (soft) padded = true;\n        else padded = false;\n    }\n}\npublic void sitOnChair( )\n{\n    <implementation not shown>\n}\n\nWhich of the following modifications, if any, would help to make the Chair class MOST useful to the sitOnChair method, based on the task attempted in Question 3?\nCorrect: Adding an accessor method that returns the value of padded\nIncorrect: Adding an accessor method that returns the value of numberOfLegs\nIncorrect: Adding a mutator method that changes the value of numberOfLegs\nIncorrect: Adding a mutator method that changes the value of padded\nIncorrect: Adding an accessor method that returns the values of both numberOfLegs and padded\n\nEND"}
{"prompt":"One more item that needs to be mentioned… do you see how each method in the object class has a “title,” or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let’s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() \/\/ just do it, we’ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() \/\/ closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() \/\/ opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running…\"); 23 }\n24  }\n\nOUTPUT:\nApp is running…\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4–7 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which “builds” the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,…)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer’s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method’s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field—in this case, updates hasApp to true once the “app” is “downloaded.” As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it’s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action—the car starting—a method would be a great way to keep the “car starting” commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways—for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four…), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and\/or numbers of parameters.\n\n\n###\n\n","completion":" Question: Consider the following method:\npublic int halfRoot(int n)\n{\n    return Math.sqrt(n) \/ 2;\n}\n\nWhich of the following method calls would cause a run-time error?\nCorrect: None will cause a run-time error.\n\n\nIncorrect: halfRoot(–2)\nIncorrect: halfRoot(3)\nIncorrect: halfRoot((int)2.0)\nIncorrect: halfRoot(3.0)END"}
{"prompt":"All of this data that is passed from driver classes to object classes and vice versa creates a complicated operation that’s occurring behind the scenes. Consider this example: the programmer decides to write a class that represents a vinyl record player (for music), or “turntable.” The driver class will then operate the turntable, turning it on and off, controlling it, and putting on\/taking off the desired record. For this program, we will have three classes: Turntable and Record, which represent each of these objects, and PlayRecord, which will be the driver that relates them.\nIn theory, we would have to perform the following steps in the driver:\ncreate (instantiate) a turntable object\ncreate one or more record objects\nplace the record onto the turntable\nswitch on the turntable\n\nSome code from these classes might look like this:\npublic class Record\n{\n\t\/\/ data not shown\n\tpublic Record()\n\t\/\/ constructor code and other methods not shown\n}\n\npublic class Turntable\n{\n private Record r;\n \/\/ other data not shown\n public Turntable(Record r1)\n {\n\tr = r1;\n\t\/\/ other statements not shown\n }\n \/\/ other methods not shown\n}\n\npublic class PlayRecord\n{\n\tpublic static void play()\n\t{\n\t\tRecord rec = new Record();\n\t\tTurntable tt = new Turntable(rec);\n\t\t\/\/ other statements not shown\n\t}\n\t\/\/ other methods not shown\n}\n\nIn this example, note that Turntable is an aggregate class, since part of its instance data involves another object. More importantly for this section, note the instantiation of the Record object in the driver, the “passing” of that object to the Turntable class, and the assignment r = r1. When an object is passed to another class and, as a result, received through a parameter, a reference is created to the object. Think of it this way: if you just picked up your favorite Taylor Swift record (you know you love her) and wanted to play it, you wouldn’t need two copies of the album. In the same way, we don’t have to create a copy of the Record object; we just need to create another reference to it in order for it to be used in the Turntable class. This is the only way the Turntable class can use this record, since it was instantiated in the driver. The record can then be used in context (in this case, assigned to the data field r) and then the reference will disappear once the constructor is over. Since the reference is not an actual copy of the object, its life is not affected.\nAnother way to think of references is to think of superheroes and their secret identities. Clark Kent was just another name for the person; he was still Superman the whole time. They were the same guy with the same superpowers, the same attributes, and the same ability to perform cool superhero actions. Therefore, “Clark Kent” was simply a reference created to refer to the same guy.\nIt is extremely important to know that primitive data is not copied by reference; it is copied by value itself.\nWhen received as a parameter, primitive data is actually copied, while object data will simply receive a new reference to the object itself. Primitives are copied by value; objects are copied by reference.\nHere’s the really confusing part—or maybe not really. If a copy of a primitive data value is made, then the two copies (the original and the new one) exist exclusively. Therefore, if you change the value of one copy, the other is not affected. On the other hand, if a new reference to an object is made, then a modification of the object through the reference will be reflected by all references. Again, the superhero example: if Superman dyed his hair blond because it was all the rage, then both Clark Kent and Superman will have blond hair. They are two names that reference the same guy, so any changes will be reflected in all the references. If we suddenly decided that Superman\/Clark Kent should be called “Blue Guy” instead of either of these two names, we are still referring to the same guy; he now has three aliases instead of two.\nThis is important for understanding object equality. Two objects are considered equivalent only if they are, in fact, the same object. In the superhero example above, Clark Kent is equal to Superman, since they are the exact same person.\nNow imagine that Superman has an identical twin brother named Duperman with alter ego Klarc Tenk. Since Duperman and Klarc Tenk are the same person, Duperman is equal to Klarc Tenk. Therefore, in Java Duperman == Klarc Tenk is true. However, even though they are identical twins, Superman and Duperman are different people. Therefore, Superman is not equal to Duperman. In Java, Superman and Duperman could be identified as identical twins using the equals method of the Object class. The equals method takes an Object parameter and returns true if and only if the two object have identical data, regardless of whether they are the same object. While the boolean statement Superman == Duperman is false, the statement Superman.equals(Duperman) is true.\nSometimes to call a method it may be necessary for the calling object to be able to refer to itself. When an object calls a method, an implicit reference is assigned to the calling object. The name of this implicit reference is this. The keyword this is a reference to the current calling object and may be used as an object variable. For example:\nthis.mySize\n\n\n###\n\n","completion":" Question: Use the incomplete class declarations to answer the following question.\npublic class Number\n{\n    private int value;\n    public Number(int someNum)\n    {\n        if (someNum >= 0)\n            value = someNum;\n    }\n    public int changeVal(int newVal)\n    {\n        \/ * missing code * \/\n    }\n    public int getValue()\n    {\n        return value;\n    }\n}\n\npublic class NumChanger\n{\n    public void change()\n    {\n        Number n1 = new Number(5);\n        Number n2 = new Number(5);\n        int sum1 = n1.getValue() + n2.getValue();\n        int oldn1Val = n1.changeValue(10);\n        n2 = n1;\n        int sum2 = n1.getValue() + n2.getValue();\n        System.out.print(sum1 + \" \" + sum2);\n    }\n    \/\/other methods not shown\n}\n\nThe changeVal method in Number should reassign value to be the value taken as the parameter and return the original value. Which of the following code segments should be used to replace \/ * missing code * \/ so that changeVal will work as intended?\nCorrect: int oldVal = value;\nvalue = newVal;\nreturn oldVal;\n\n\nIncorrect: value = newVal;\nreturn value;\nIncorrect: value = newVal;\nreturn 5;\nIncorrect: int oldVal = value\nvalue = newVal;\nIncorrect: int oldVal = value;\nvalue = newVal;\nreturn value;END"}
{"prompt":"All of this data that is passed from driver classes to object classes and vice versa creates a complicated operation that’s occurring behind the scenes. Consider this example: the programmer decides to write a class that represents a vinyl record player (for music), or “turntable.” The driver class will then operate the turntable, turning it on and off, controlling it, and putting on\/taking off the desired record. For this program, we will have three classes: Turntable and Record, which represent each of these objects, and PlayRecord, which will be the driver that relates them.\nIn theory, we would have to perform the following steps in the driver:\ncreate (instantiate) a turntable object\ncreate one or more record objects\nplace the record onto the turntable\nswitch on the turntable\n\nSome code from these classes might look like this:\npublic class Record\n{\n\t\/\/ data not shown\n\tpublic Record()\n\t\/\/ constructor code and other methods not shown\n}\n\npublic class Turntable\n{\n private Record r;\n \/\/ other data not shown\n public Turntable(Record r1)\n {\n\tr = r1;\n\t\/\/ other statements not shown\n }\n \/\/ other methods not shown\n}\n\npublic class PlayRecord\n{\n\tpublic static void play()\n\t{\n\t\tRecord rec = new Record();\n\t\tTurntable tt = new Turntable(rec);\n\t\t\/\/ other statements not shown\n\t}\n\t\/\/ other methods not shown\n}\n\nIn this example, note that Turntable is an aggregate class, since part of its instance data involves another object. More importantly for this section, note the instantiation of the Record object in the driver, the “passing” of that object to the Turntable class, and the assignment r = r1. When an object is passed to another class and, as a result, received through a parameter, a reference is created to the object. Think of it this way: if you just picked up your favorite Taylor Swift record (you know you love her) and wanted to play it, you wouldn’t need two copies of the album. In the same way, we don’t have to create a copy of the Record object; we just need to create another reference to it in order for it to be used in the Turntable class. This is the only way the Turntable class can use this record, since it was instantiated in the driver. The record can then be used in context (in this case, assigned to the data field r) and then the reference will disappear once the constructor is over. Since the reference is not an actual copy of the object, its life is not affected.\nAnother way to think of references is to think of superheroes and their secret identities. Clark Kent was just another name for the person; he was still Superman the whole time. They were the same guy with the same superpowers, the same attributes, and the same ability to perform cool superhero actions. Therefore, “Clark Kent” was simply a reference created to refer to the same guy.\nIt is extremely important to know that primitive data is not copied by reference; it is copied by value itself.\nWhen received as a parameter, primitive data is actually copied, while object data will simply receive a new reference to the object itself. Primitives are copied by value; objects are copied by reference.\nHere’s the really confusing part—or maybe not really. If a copy of a primitive data value is made, then the two copies (the original and the new one) exist exclusively. Therefore, if you change the value of one copy, the other is not affected. On the other hand, if a new reference to an object is made, then a modification of the object through the reference will be reflected by all references. Again, the superhero example: if Superman dyed his hair blond because it was all the rage, then both Clark Kent and Superman will have blond hair. They are two names that reference the same guy, so any changes will be reflected in all the references. If we suddenly decided that Superman\/Clark Kent should be called “Blue Guy” instead of either of these two names, we are still referring to the same guy; he now has three aliases instead of two.\nThis is important for understanding object equality. Two objects are considered equivalent only if they are, in fact, the same object. In the superhero example above, Clark Kent is equal to Superman, since they are the exact same person.\nNow imagine that Superman has an identical twin brother named Duperman with alter ego Klarc Tenk. Since Duperman and Klarc Tenk are the same person, Duperman is equal to Klarc Tenk. Therefore, in Java Duperman == Klarc Tenk is true. However, even though they are identical twins, Superman and Duperman are different people. Therefore, Superman is not equal to Duperman. In Java, Superman and Duperman could be identified as identical twins using the equals method of the Object class. The equals method takes an Object parameter and returns true if and only if the two object have identical data, regardless of whether they are the same object. While the boolean statement Superman == Duperman is false, the statement Superman.equals(Duperman) is true.\nSometimes to call a method it may be necessary for the calling object to be able to refer to itself. When an object calls a method, an implicit reference is assigned to the calling object. The name of this implicit reference is this. The keyword this is a reference to the current calling object and may be used as an object variable. For example:\nthis.mySize\n\n\n###\n\n","completion":" Question: Use the incomplete class declarations to answer the following question.\npublic class Number\n{\n    private int value;\n    public Number(int someNum)\n    {\n        if (someNum >= 0)\n            value = someNum;\n    }\n    public int changeVal(int newVal)\n    {\n        \/ * missing code * \/\n    }\n    public int getValue()\n    {\n        return value;\n    }\n}\n\npublic class NumChanger\n{\n    public void change()\n    {\n        Number n1 = new Number(5);\n        Number n2 = new Number(5);\n        int sum1 = n1.getValue() + n2.getValue();\n        int oldn1Val = n1.changeValue(10);\n        n2 = n1;\n        int sum2 = n1.getValue() + n2.getValue();\n        System.out.print(sum1 + \" \" + sum2);\n    }\n    \/\/other methods not shown\n}\n\nWhat will be printed as a result of executing the change method? Assume changeVal in the Number class works as intended.\nCorrect: None of these\n\n\nIncorrect: 5 5\nIncorrect: 5 10\nIncorrect: 10 5\nIncorrect: 10 10END"}
{"prompt":"All of this data that is passed from driver classes to object classes and vice versa creates a complicated operation that’s occurring behind the scenes. Consider this example: the programmer decides to write a class that represents a vinyl record player (for music), or “turntable.” The driver class will then operate the turntable, turning it on and off, controlling it, and putting on\/taking off the desired record. For this program, we will have three classes: Turntable and Record, which represent each of these objects, and PlayRecord, which will be the driver that relates them.\nIn theory, we would have to perform the following steps in the driver:\ncreate (instantiate) a turntable object\ncreate one or more record objects\nplace the record onto the turntable\nswitch on the turntable\n\nSome code from these classes might look like this:\npublic class Record\n{\n\t\/\/ data not shown\n\tpublic Record()\n\t\/\/ constructor code and other methods not shown\n}\n\npublic class Turntable\n{\n private Record r;\n \/\/ other data not shown\n public Turntable(Record r1)\n {\n\tr = r1;\n\t\/\/ other statements not shown\n }\n \/\/ other methods not shown\n}\n\npublic class PlayRecord\n{\n\tpublic static void play()\n\t{\n\t\tRecord rec = new Record();\n\t\tTurntable tt = new Turntable(rec);\n\t\t\/\/ other statements not shown\n\t}\n\t\/\/ other methods not shown\n}\n\nIn this example, note that Turntable is an aggregate class, since part of its instance data involves another object. More importantly for this section, note the instantiation of the Record object in the driver, the “passing” of that object to the Turntable class, and the assignment r = r1. When an object is passed to another class and, as a result, received through a parameter, a reference is created to the object. Think of it this way: if you just picked up your favorite Taylor Swift record (you know you love her) and wanted to play it, you wouldn’t need two copies of the album. In the same way, we don’t have to create a copy of the Record object; we just need to create another reference to it in order for it to be used in the Turntable class. This is the only way the Turntable class can use this record, since it was instantiated in the driver. The record can then be used in context (in this case, assigned to the data field r) and then the reference will disappear once the constructor is over. Since the reference is not an actual copy of the object, its life is not affected.\nAnother way to think of references is to think of superheroes and their secret identities. Clark Kent was just another name for the person; he was still Superman the whole time. They were the same guy with the same superpowers, the same attributes, and the same ability to perform cool superhero actions. Therefore, “Clark Kent” was simply a reference created to refer to the same guy.\nIt is extremely important to know that primitive data is not copied by reference; it is copied by value itself.\nWhen received as a parameter, primitive data is actually copied, while object data will simply receive a new reference to the object itself. Primitives are copied by value; objects are copied by reference.\nHere’s the really confusing part—or maybe not really. If a copy of a primitive data value is made, then the two copies (the original and the new one) exist exclusively. Therefore, if you change the value of one copy, the other is not affected. On the other hand, if a new reference to an object is made, then a modification of the object through the reference will be reflected by all references. Again, the superhero example: if Superman dyed his hair blond because it was all the rage, then both Clark Kent and Superman will have blond hair. They are two names that reference the same guy, so any changes will be reflected in all the references. If we suddenly decided that Superman\/Clark Kent should be called “Blue Guy” instead of either of these two names, we are still referring to the same guy; he now has three aliases instead of two.\nThis is important for understanding object equality. Two objects are considered equivalent only if they are, in fact, the same object. In the superhero example above, Clark Kent is equal to Superman, since they are the exact same person.\nNow imagine that Superman has an identical twin brother named Duperman with alter ego Klarc Tenk. Since Duperman and Klarc Tenk are the same person, Duperman is equal to Klarc Tenk. Therefore, in Java Duperman == Klarc Tenk is true. However, even though they are identical twins, Superman and Duperman are different people. Therefore, Superman is not equal to Duperman. In Java, Superman and Duperman could be identified as identical twins using the equals method of the Object class. The equals method takes an Object parameter and returns true if and only if the two object have identical data, regardless of whether they are the same object. While the boolean statement Superman == Duperman is false, the statement Superman.equals(Duperman) is true.\nSometimes to call a method it may be necessary for the calling object to be able to refer to itself. When an object calls a method, an implicit reference is assigned to the calling object. The name of this implicit reference is this. The keyword this is a reference to the current calling object and may be used as an object variable. For example:\nthis.mySize\n\n\n###\n\n","completion":" Question: The following method is intended to output \"Strings match.\" if the two strings contain identical data and otherwise print \"Strings do not match.\"\npublic void match(String s, String t)\n{\nif (\/ * missing code * \/)\n    System.out.println(\"Strings match.\");\nelse\n    System.out.println(\"Strings do not match.\");\n}\n\nWhich of the following statements could replace \/ * missing code * \/ to allow the method to work as intended?\nI. s.compareTo(t) == 0\nII. compareTo(s, t) == 0\nIII. s == t\nCorrect: I only\nIncorrect: III only\nIncorrect: I and III only\nIncorrect: II and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"The static keyword can appear in two contexts at this level. A static variable is an attribute that is shared among all instances of a class. When the value of this variable is changed, the alteration is reflected by all of the objects instantiated through that class. A classic example of a static variable is the high score list on a video game. Consider the video game Tetris. After you launch the game, you start a new game and play until you lose… then, since you are obsessed with Tetris, you start over. If each game of that you play is considered an object of the same class, a static variable might be the high score. Every time you start (or instantiate) a new game, the high score remains the same as it was when it was initially set. Once a new high score is set, every new game will reflect the new high score, rendering the old high score non-existent (or second best, etc.).\nIn an object class, a static variable is declared with the rest of the instance data at the top of the class, preceded by the keyword static. Static variables are often used for identification numbers or for counters. Consider this short program:\npublic class Box\n{\n\tprivate static int boxNumber = 0;\n\t\/\/ other data fields not shown\n\tpublic Box()\n\t{\n\t\tboxNumber++;\n\t\t\/\/ other statements not shown\n\t}\n}\n\npublic class BoxCreator\n{\n\tpublic BoxCreator()\n\t{\n\t\tBox box1 = new Box();\n\t\tBox box2 = new Box();\n\t}\n}\n\nAs each Box object is instantiated in BoxCreator, the static variable in the Box class will be updated. That way, the next time a box is created, the box number value is incremented for all box objects. The static variable is not an attribute of each individual box; rather, it is a shared value among all boxes. Contrast this setup with a non-static declaration of boxNumber; every time a box is instantiated, its boxNumber would start as 0 and then be incremented, making every box have the same boxNumber value of 1.\nIn order to show that this structure is actually working, let’s create an accessor method to let the driver “see,” or access, the value of boxNumber. This method is necessary for this result since boxNumber has been declared private. A non-constructor method that is designed to access and\/or modify a static variable is a static method and must be declared as such. To add this functionality and test it, here are our new object and driver classes:\npublic class Box\n{\n\tprivate static int boxNumber = 0;\n\t\/\/ other data fields not shown\n\tpublic Box()\n\t{\n\t\tboxNumber++;\n\t\t\/\/ other statements not shown\n\t}\n\tstatic public int getBoxNum()\n\t{\n\t\treturn boxNumber;\n\t}\n}\n\npublic class BoxCreator\n{\n\tpublic BoxCreator()\n\t{\n\t\tBox box1 = new Box();\n\t\tBox box2 = new Box();\n\t\tSystem.out.print (Box.getBoxNum() + \" boxes created so far.\");\n\t}\n}\n\nNotice the method call from BoxCreator does not use an object reference variable; rather, the class is used directly. Since static variables are shared among all instances, the programmer needs to access static methods (and therefore, static variables) through the class itself.\n\n\n###\n\n","completion":" Question: A class called ComputerMouse has a static variable connector and a static method getConnector. Which of the following statements is true based on this information?\nCorrect: In order to invoke getConnector, a new ComputerMouse object does not need to be instantiated; getConnector must be called directly through the object class.\nIncorrect: In order to invoke getConnector, a new ComputerMouse object must be instantiated and then getConnector must be called through that object.\nIncorrect: Since connector is declared static, getConnector is shared among all objects in the program.\nIncorrect: Since connector is declared static, ComputerMouse objects cannot be mutated during execution.\nIncorrect: Since connector is declared static, all of the methods in ComputerMouse must also be declared static.\n\nEND"}
{"prompt":"When a group of statements, including control structures, is assembled into a single unit, the unit is called a class. Similar to a word processing document or a picture file stored on your computer, a class is stored on your computer in a file. Unlike a word processing document, however, a class must follow specific rules in order to conform to Java and, as a result, to be understood by the compiler. Remember that your brilliantly constructed program is useless unless the compiler can successfully translate it into machine code.\nThe structure of a class, at this level anyway, is straightforward. Take all of the statements you’ve written before this chapter, put curly brackets around them, kind of like a huge block, name it, and save it. The naming conventions for a class are similar to those of a variable, except that they should begin with a capital letter. The name of the class should reference the purpose or function of the class. For example, a class that calculates a GPA might be called GPA or GradePointAvg. The way we declare a class in Java is using the header:\npublic class GradePointAvg\n{\n\t\/\/ statements not shown\n}\n\nWell, Actually… This is a convention but not a rule. You can have all of the code on a single line if your heart so desires, but that would be very bad form.\nNote that the statements in the class reside at least one tab stop across the page. If the programmer would like to use more white space within the structures of the class, they will be tabbed further into the page:\npublic class GradePointAvg\n{\n\t\/\/ other code and variable declarations not shown\n\twhile (\/* condition not shown *\/)\n\t{\n\t\t\/\/ looped statements not shown\n\t}\n}\n\nTypically, variable declarations are placed into the code first, right after the class header, as a sort of “setup” for the rest of the class. Of course, this is not a rule, but it is a good guideline in order to keep your code readable.\nThis class would be saved to the computer as GradePointAvg.java; the .java extension helps the compiler to recognize the file as containing Java code. If the code compiles (there are no syntax errors), the compiler will create another file in the same folder called GradePointAvg.class; this file is unreadable to the programmer because it is encoded in machine language. The computer, however, uses this file to execute the program. The .java file is called the source code of the program, since it defines the program’s actions and functions.\nRemember that classes are executed top-down—i.e., line 1 followed by line 2, etc. If programmers want to alter top-down execution, they must use a flow control structure, as we studied before.\n\n\n###\n\n","completion":" Question: A development team is building an online bookstore that customers can use to order books. Information about inventory and customer orders is kept in a database. Code must be developed that will store and retrieve data from the database. The development team decides to put the database code in separate classes from the rest of the program. Which of the following would be an advantage of this plan?\nI. The database access code could be reused in other applications that also need to access the database.\nII. The database access code can be tested independently. It will be possible to test the database access code before the interface is developed.\nIII. A team of programmers can be assigned to work just on the code that is used to access the database. The programmers can work independently from other programmers, such as those who develop the user interface.\nCorrect: I, II, and III\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II onlyEND"}
{"prompt":"One more item that needs to be mentioned… do you see how each method in the object class has a “title,” or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let’s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() \/\/ just do it, we’ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() \/\/ closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() \/\/ opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running…\"); 23 }\n24  }\n\nOUTPUT:\nApp is running…\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4–7 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which “builds” the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,…)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer’s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method’s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field—in this case, updates hasApp to true once the “app” is “downloaded.” As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it’s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action—the car starting—a method would be a great way to keep the “car starting” commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways—for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four…), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and\/or numbers of parameters.\n\n\n###\n\n","completion":" Question: In Java, instance fields (also known as instance variables) and methods can be designated public or private. Which of the following best characterizes the designation that should be used?\nCorrect: Instance fields should always be private so that clients can’t directly access them. Methods can be either public or private.\nIncorrect: Instance fields and methods should always be public. This makes it easier for client programs to access data fields and use the methods of the class.\nIncorrect: Instance fields should be either public or private, depending on whether or not it is beneficial for client programs to access them directly. All methods should be public. A private method is useless because a client program can’t access it.\nIncorrect: Keep all methods and instance fields private. This enforces encapsulation.\nIncorrect: All instance fields should be public so client programs can access them, and all methods should be private.\n\nEND"}
{"prompt":"When a group of statements, including control structures, is assembled into a single unit, the unit is called a class. Similar to a word processing document or a picture file stored on your computer, a class is stored on your computer in a file. Unlike a word processing document, however, a class must follow specific rules in order to conform to Java and, as a result, to be understood by the compiler. Remember that your brilliantly constructed program is useless unless the compiler can successfully translate it into machine code.\nThe structure of a class, at this level anyway, is straightforward. Take all of the statements you’ve written before this chapter, put curly brackets around them, kind of like a huge block, name it, and save it. The naming conventions for a class are similar to those of a variable, except that they should begin with a capital letter. The name of the class should reference the purpose or function of the class. For example, a class that calculates a GPA might be called GPA or GradePointAvg. The way we declare a class in Java is using the header:\npublic class GradePointAvg\n{\n\t\/\/ statements not shown\n}\n\nWell, Actually… This is a convention but not a rule. You can have all of the code on a single line if your heart so desires, but that would be very bad form.\nNote that the statements in the class reside at least one tab stop across the page. If the programmer would like to use more white space within the structures of the class, they will be tabbed further into the page:\npublic class GradePointAvg\n{\n\t\/\/ other code and variable declarations not shown\n\twhile (\/* condition not shown *\/)\n\t{\n\t\t\/\/ looped statements not shown\n\t}\n}\n\nTypically, variable declarations are placed into the code first, right after the class header, as a sort of “setup” for the rest of the class. Of course, this is not a rule, but it is a good guideline in order to keep your code readable.\nThis class would be saved to the computer as GradePointAvg.java; the .java extension helps the compiler to recognize the file as containing Java code. If the code compiles (there are no syntax errors), the compiler will create another file in the same folder called GradePointAvg.class; this file is unreadable to the programmer because it is encoded in machine language. The computer, however, uses this file to execute the program. The .java file is called the source code of the program, since it defines the program’s actions and functions.\nRemember that classes are executed top-down—i.e., line 1 followed by line 2, etc. If programmers want to alter top-down execution, they must use a flow control structure, as we studied before.\n\n\n###\n\n","completion":" Question: Which of the following are signs of a well-designed program?\nI. Clients know how data is stored in the class.\nII. Classes and methods can be tested independently.\nIII. The implementation of a method can be changed without changing the programs that use the method.\nCorrect: II and III\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and II\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"One more item that needs to be mentioned… do you see how each method in the object class has a “title,” or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let’s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() \/\/ just do it, we’ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() \/\/ closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() \/\/ opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running…\"); 23 }\n24  }\n\nOUTPUT:\nApp is running…\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4–7 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which “builds” the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,…)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer’s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method’s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field—in this case, updates hasApp to true once the “app” is “downloaded.” As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it’s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action—the car starting—a method would be a great way to keep the “car starting” commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways—for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four…), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and\/or numbers of parameters.\n\n\n###\n\n","completion":" Question: Consider the following class:\npublic class Sample\n{\n    public void writeMe(Object obj)\n    {\n        System.out.println(\"object\");\n    }\n    public void writeMe(String s)\n    {\n        System.out.println(\"string\");\n    }\n}\n\nWhat will be the result of executing the following?\nSample s = new Sample( );\nString tmp = new String(\"hi\");\ns.writeMe(tmp);\nCorrect: \"string\"\nIncorrect: Compile-time error\nIncorrect: \"hi\"\nIncorrect: \"object\"\nIncorrect: Run-time error\n\nEND"}
{"prompt":"One more item that needs to be mentioned… do you see how each method in the object class has a “title,” or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let’s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() \/\/ just do it, we’ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() \/\/ closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() \/\/ opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running…\"); 23 }\n24  }\n\nOUTPUT:\nApp is running…\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4–7 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which “builds” the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,…)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer’s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method’s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field—in this case, updates hasApp to true once the “app” is “downloaded.” As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it’s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action—the car starting—a method would be a great way to keep the “car starting” commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways—for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four…), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and\/or numbers of parameters.\n\n\n###\n\n","completion":" Question: Consider the following class:\npublic class Sample\n{\n    public void writeMe(Object obj)\n    {\n        System.out.println(\"object\");\n    }\n    public void writeMe(String s)\n    {\n        System.out.println(\"string\");\n    }\n}\n\nWhat will be the result of executing the following?\nSample s = new Sample( );\nObject tmp = new Object( );\ns.writeMe(tmp);\nCorrect: \"object\"\nIncorrect: Compile-time error\nIncorrect: \"string\"\nIncorrect: \"tmp\"\nIncorrect: Run-time error\n\nEND"}
{"prompt":"One more item that needs to be mentioned… do you see how each method in the object class has a “title,” or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let’s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() \/\/ just do it, we’ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() \/\/ closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() \/\/ opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running…\"); 23 }\n24  }\n\nOUTPUT:\nApp is running…\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4–7 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which “builds” the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,…)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer’s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method’s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field—in this case, updates hasApp to true once the “app” is “downloaded.” As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it’s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action—the car starting—a method would be a great way to keep the “car starting” commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways—for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four…), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and\/or numbers of parameters.\n\n\n###\n\n","completion":" Question: Consider the following class:\npublic class Sample\n{\n    public void writeMe(Object obj)\n    {\n        System.out.println(\"object\");\n    }\n    public void writeMe(String s)\n    {\n        System.out.println(\"string\");\n    }\n}\n\nWhat will be the result of executing the following?\nSample s = new Sample( );\nObject tmp = new String(\"hi\");\ns.writeMe(tmp);\nCorrect: \"object\"\nIncorrect: Compile-time error\nIncorrect: \"hi\"\nIncorrect: \"string\"\nIncorrect: Run-time error\n\nEND"}
{"prompt":"One more item that needs to be mentioned… do you see how each method in the object class has a “title,” or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let’s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() \/\/ just do it, we’ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() \/\/ closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() \/\/ opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running…\"); 23 }\n24  }\n\nOUTPUT:\nApp is running…\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4–7 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which “builds” the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,…)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer’s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method’s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field—in this case, updates hasApp to true once the “app” is “downloaded.” As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it’s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action—the car starting—a method would be a great way to keep the “car starting” commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways—for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four…), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and\/or numbers of parameters.\n\n\n###\n\n","completion":" Question: Consider the following class:\npublic class Sample\n{\n    public void writeMe(Object obj)\n    {\n        System.out.println(\"object\");\n    }\n    public void writeMe(String s)\n    {\n        System.out.println(\"string\");\n    }\n}\n\nWhat will be the result of executing the following?\nSample s = new Sample( );\nString tmp = new Object( );\ns.writeMe(tmp);\nCorrect: Compile-time error\nIncorrect: \"hi\"\nIncorrect: \"object\"\nIncorrect: \"string\"\nIncorrect: Run-time error\n\nEND"}
{"prompt":"Now that we have written classes to run a program, we must get these classes to interact correctly in order to create a functioning program. We have the driver, we have the car, now we need to put the driver into the car to eagerly drive to the AP Computer Science A Exam on exam day.\nThe driver and object classes must reside in the same folder on the computer. If you are using an interactive development environment (as opposed to command line programming), you often have to create a “Project” or some similar structure in the software that will hold all of the program’s files in one place. Remember that the driver depends on the object class in order to compile, and the object class depends on the driver to make it actually do anything.\n\nConsider a program that will take “flower” objects and “plant” them into a garden. The flower objects might be outlined in an object class called Flower. One class will perform the planting, so we can call it MakeGarden.\nSuppose the Flower constructor method has the following header: public Flower(int xPosition, int yPosition) where xPosition and yPosition are the horizontal and vertical coordinates in the garden, respectively, where the flower object will be planted. Our driver would have to first “create” the flowers, and then plant them accordingly.\nIn order to create an object, we must instantiate the object using its corresponding class. Each time we instantiate a flower object, we must assign it an object reference variable; as the fancy name implies, this is just a variable name. Some lines in MakeGarden might look like this:\nFlower f1 = new Flower(2, 1);\nFlower f2 = new Flower(2, 2);\nFlower f3 = new Flower(2, 3);\n\nThese lines will instantiate three different flower objects, each containing its own instance data. f1, f2, and f3 are used to distinguish between the objects. We can then use these objects to perform methods. Consider a plant method in the Flower class; this method would “plant” the flower and might have the following header:\npublic void plant()\n\nIn MakeGarden, we must invoke this method through the objects. Let’s say we want to plant only f1 and f3, but not f2. We would add the following lines:\nf1.plant();\nf3.plant();\n\nNow let’s say the plant method, instead, returns whether or not the plant was successfully planted. This altered plant method might have the header:\npublic boolean plant()\n\nNow we can use the returned data to output an appropriate message in the driver:\nif (f1.plant())\n\tSystem.out.print(\"Planted successfully.\");\nelse\n\tSystem.out.print(\"There was a problem.\");\n\nBecause we are invoking f1.plant, f1 should be planted as requested. Since the plant method returns a boolean value, we can place f1.plant in the context of an if statement (it produces a truth value so it is considered a condition) and now it also functions as part of a control structure. Awesome!\nLet’s add to our garden situation. As you know, other items can appear in a garden besides flowers. Plants, bushes, and weeds can appear in gardens. Each of these items would probably have its own object class, since their instance data and methods would be different from those of flowers. For example, a flower has flower petals, while a plant does not; weeds often grow on their own without water, whereas most flowers and plants do not. Regardless, separate object classes can be created for each of these object types, and the driver can hold them all together, as long as they are all stored in the same folder on the computer.\nAssuming each of these object classes has been created and each corresponding object class has a plant method as outlined above, MakeGarden might include these lines:\nFlower f1 = new Flower();\nFlower f2 = new Flower();\nPlant p1 = new Plant();\nPlant p2 = new Plant();\nWeed w1 = new Weed();\nif (f1.plant())\n\tSystem.out.println(\"Planted successfully\");\nif (f2.plant())\n\tSystem.out.println(\"Planted successfully\");\nif (p1.plant())\n\tSystem.out.println(\"Planted successfully\");\nif (w1.plant())\n\tSystem.out.println(\"You have a weed.\");\n\nNote that MakeGarden does not instantiate any Bush objects, and does not attempt to plant the p2 object. Note also that we cannot see the entire class!\nThe programmer has the task of deciding which objects to instantiate of which type, when and whether to use them, and how to use them appropriately, based on their class specifications. Still think you can go directly to the final draft?\nLet’s add another layer. Programmers often recognize that an object is actually composed of many smaller, or more basic, objects. If you think about a flower, it actually has several parts, each of which has data and does particular actions. As a result, we could write object classes for, say, the stalk and the root system. The Stalk class and the RootSystem class, then, would reside as attributes of each flower. Their classes, again, must be placed in the same folder as the rest of the program’s classes. The programmer can then set up the Flower class as follows:\npublic class Flower\n{\n\t\/\/ other data not shown\n\tprivate Stalk st;\n\tprivate RootSystem rootSys;\n\tpublic Flower()\n\t{\n\t\tst = new Stalk();\n\t\trootSys = new RootSystem();\n\t\t\/\/ other commands not shown\n\t}\n\t\/\/ other methods not shown\n}\nThis means that every Flower object has a stalk and a root system. The Flower class, then, is called an aggregate class because it is made up of, among other data, instances of other classes. This setup is more realistic; think of any object in your room, and you can probably see pretty quickly that it is made of smaller objects, each with its own data and methods. A laptop computer has keys, ports, and a screen, which can all be considered objects because they have stuff and do stuff. A dresser has drawers, but we can go even deeper…a drawer has walls and a floor and can be opened or closed…the floor of a drawer has a shape and is made of a certain material and can be broken if the drawer is overstuffed…you get the idea. Luckily, as programmers, we get to decide the detail of the object classes, and the answer typically lies in the desired function of the program, as we stated before. Do you really need to know what material the floor of the drawer is made of? Most people do not, although a furniture retailer might. Again, it all depends on the application.\nThe free-response questions on the AP Exam will present some sort of context and will often tell you exactly what class(es) and\/or method(s) to write, so they don’t get a wild variety of solutions from test takers around the world.\nOtherwise, they could literally be forced to read thousands of completely different approaches to a given task. This fact is not good for our creativity, but it’s great for scoring a 5; save your creative juices for those extra college classes you can take when you AP out of CS!\n\n\n###\n\n","completion":" Question: Consider the following class:\npublic class Sample\n{\n    int val = 0;\n}\nIs val an attribute or a method?\nCorrect: val is an attribute.\nIncorrect: Neither: a compile-time error occurs when we try to execute this code.\nIncorrect: val is a method.\nIncorrect: val is both an attribute and a method.\nIncorrect: Neither: val is a primitive.\n\nEND"}
{"prompt":"One more item that needs to be mentioned… do you see how each method in the object class has a “title,” or header? The header is used to indicate the overall function of a method.\nThis is a Java book, right? So let’s look at some Java. These two classes are designed to simulate a phone downloading and opening a new app.\n1 import Phone;\n2 public class UsePhoneApp\n3 {\n4   public UsePhoneApp() \/\/ just do it, we’ll explain later\n5   {\n6       Phone myPhone = new Phone();\n7       myPhone.downloadApp();\n8       myPhone.openApp();\n9       myPhone.closeApp();\n10  }\n11 }\n\n1 public class Phone\n2 {\n3   private boolean hasApp;\n4   public Phone()\n5   {\n6       hasApp = false;\n7   }\n8   public void downloadApp()\n9   {\n10      hasApp = true;\n11  }\n12\n13  public void closeApp() \/\/ closes the app\n14  {\n15      if (hasApp)\n16          System.out.println (\"App is closed.\");\n17  }\n18\n19  public void openApp() \/\/ opens the app\n20  {\n21      if (hasApp)\n22          System.out.println (\"App is running…\"); 23 }\n24  }\n\nOUTPUT:\nApp is running…\nApp is closed.\n\nThere are many components in this program; first, note that we now have two classes that make up a single program. In isolation, neither of these classes would produce a useful result. The UsePhoneApp class would not compile because the compiler does not understand the methods if they are not present (compiler: what does openApp mean?); the Phone class would compile but would not actually perform any actions without UsePhoneApp (compiler: when do I openApp, and on which phone?). In order to allow the UsePhoneApp class to access the Phone class, the line\nimport Phone;\n\nmust be used at the top of the file above the class declaration.\nLines 4–7 in Phone make up a special kind of method called a constructor. An object must be constructed before it can perform any actions, just as a car must be built before it can be driven. Line 6 in UsePhoneApp calls this constructor method, which “builds” the Phone object; this command must occur before the non-constructor methods are called; otherwise, the compiler will return an error. Imagine someone pressing an imaginary accelerator pedal and trying to drive somewhere, without a car. Interesting, but not possible.\nLine 3 of Phone defines whether the Phone has an app (true) or does not (false). This is the sole attribute of a Phone object in our program; more complex programs may have dozens or even hundreds of attributes (a phone, in reality, has many more attributes, such as a screen, volume buttons, etc.). The programmer should write these attributes, called instance variables or fields. Following the data fields is the constructor, as we stated before, and then a series of methods that control what the Phone can do.\nAn object class defines what an object HAS and DOES. A method has several components. The method header is built in a very specific way; its syntax is as follows:\nvisibility returnType methodName (param1, param2,…)\n\nThe visibility of a method can be public or private, depending on the situation (more on this later). The return type identifies what type of data, if any, will be returned from the method after its commands are executed. The name of a method, similar to the name of a variable, should be an intuitive name that summarizes the function of the method; it should conform to the same specifications as a variable name (begin with a lowercase letter, etc.). The parameters, which are optional, are the data that the method needs in order to perform its job.\nIn our previous example, the method header for closeApp was: public void closeApp()\n\nThis is functional, but it is also relatively simple for the example. Its visibility is public, its return type is void (there is no information returned), and it does not have parameters. A more realistic method to close an app on a phone might require information regarding when it should be closed, and might return data, such as whether or not it was closed successfully. Thus, the revised method header might look like\npublic boolean closeApp (int minutes)\n\nNote that the single parameter, minutes, is defined with its type. Since minutes will be a temporary variable that exists only during the execution of this method, it must be defined as new, right in the header. A method can have any number of parameters, depending on the programmer’s design decisions for the program.\nA method must begin with a header containing a visibility modifier (private or public), a return type or void if no information will be returned, and a method name. Parameter(s) are optional, depending on the method’s requirements to perform its task.\nThe ultimate purpose of a method is to perform some sort of task with respect to the object. Note that openApp() and closeApp() simply access the data field hasApp and react accordingly; i.e., the message is displayed only if the value hasApp is true. downloadApp() is more profound, in a way; rather than simply accessing data, it actually changes the value of a data field—in this case, updates hasApp to true once the “app” is “downloaded.” As a result, it is common in Java to label methods like openApp() and closeApp() as accessor methods and to label methods like downloadApp() as mutator methods.\nWe have used an analogy to a car several times already in this chapter, but it’s a great way to understand these concepts. When you want to start a car, you have to go through a series of steps. Since all of those steps perform, ultimately, a single action—the car starting—a method would be a great way to keep the “car starting” commands in a single, convenient unit. As a programmer, you would have to decide what data the method would need in order to work (parameter(s)) and what data, if any, the method would return. Does the car need a key to start? A password code? Does the brake pedal have to be depressed? This information would all be accepted through parameters. Should the method return whether the car has started? How long it took to start? A code that represents whether it needs an oil change? These are all examples of possible return data.\nIn some cases, there may be a situation in which the car can be started multiple ways—for example, the owner has a push-button starter and a remote starter. The designer could write two startCar methods (or three, or four…), each one performing the same task but requiring different information (parameters) to do the task. This process is called overloading and can be accomplished by writing two or more methods with identical names but different types and\/or numbers of parameters.\n\n\n###\n\n","completion":" Question: Consider the following class:\npublic class Sample\n{\n    public String writeMe(String s)\n    {\n        System.out.println(\"object\");\n    }\n    public void writeMe(String s)\n    {\n        System.out.println(\"string\");\n    }\n}\n\nWhat will be the result of executing the following?\nSample s = new Sample( );\nObject tmp = new Object( );\ns.writeMe(tmp);\nCorrect: Compile-time error\nIncorrect: \"hi\"\nIncorrect: \"object\"\nIncorrect: \"string\"\nIncorrect: Run-time errorEND"}
{"prompt":"There are two big limitations of the powerful array structure in Java: an array has a fixed length and it can store only one type of data. If you wanted to represent, say, a friend’s collection of action figures, an array would require all of the action figures to be the same type. Generally speaking, they must all be flying superheroes, or they must all have protective body armor, etc. \nLikewise, a collection of action figures represented as an array could store only a fixed number of action figures, no more and no less. If there are extra, unused slots, they stay there, which could be problematic if you have an array of helmeted heroes and you try to remove the helmet from every element in every index of the array. Once you reach the first empty spot, there is no hero and therefore no helmet, so the directions do not make sense; in Java, the compiler will return a NullPointerException for this situation. \nAn ArrayList addresses both of these issues. An ArrayList object is dynamically sized, expanding and compressing as elements are added and removed. An ArrayList can also store multiple types of data, without limit. \nLet’s use an example to understand the advantages and disadvantages of arrays versus ArrayLists. Consider your lunch bag that you take to school. If you wanted to represent your lunch bag using an array or ArrayList structure, which would be more accurate?\nNaturally, the answer to this question depends on (1) the details of the objects in the bag—in this case, the types of lunch items—and (2) the programmer’s choice of which is more appropriate. If your lunch contains a sandwich object, a fruit object, and a drink object, the ArrayList structure might be a better choice. Furthermore, as the components of the lunch are removed, the lunch bag theoretically shrinks (or can shrink). An ArrayList seems appropriate. \nLet’s consider the same lunch example, but this time, suppose the items are stored in a plastic container with compartments. Regardless of whether you have not yet eaten your lunch, you are done with your lunch, or it’s currently anytime in between, the number and setup of the compartments do not change. We will discuss a workaround for “tricking” the array into thinking the lunch objects are all the same type. These facts and abilities render an array structure more appropriate than an ArrayList. \nTo further demonstrate the usefulness of an ArrayList structure, note that it is also possible to create a typed ArrayList, which allows only objects of the same type to be stored in the list. This structure combines useful aspects of both arrays and ArrayLists. \nIn order to instantiate an ArrayList called lunchBag that will store the various components of our lunch, we use the following line of code: \nArrayList lunchBag = new ArrayList(); \n\nNote that, unlike the syntax we use for instantiating an array, neither the type of object nor the length of the list is defined initially. \nIn order to access data from within the list, particular methods must be invoked; unlike for array structures in Java, there is not a convenient bracket notation available with lists. To return the second object, an Apple object, in the ArrayList and store it using the variable food, the line of code would be\nApple red = lunchBag.get(1); \n\nThere are several other useful methods available in the List class, and they are all mentioned in the AP Exam Quick Reference, although their functionality is (obviously) not given. These methods include add, set, remove, and size. \nIf the programmer decides it is more appropriate to keep the dynamic sizing ability of the ArrayList while fixing the type of data it can hold (as in an array), it would be instantiated as follows: \nArrayList<Apple> lunchBag = new ArrayList<Apple>(); \n\nOne of the drawbacks of using ArrayList is that only objects can be stored in an ArrayList. The primitive data types int and double cannot be stored in ArrayLists. If programmers want to store integer and double data types, they must use the Integer or Double wrapper classes. Integer and Double objects can be created using integers and doubles, respectively, as parameters. For example, \nInteger n = new Integer(5); \nDouble x = new Double(6.1); \n\nTo call the values, use the intValue() and doubleValue() methods. The following commands \nint a = n.intValue(); \nint y = x.doubleValue(); \n\nassign a = 5 and y = 6.1.\n\nAdditionally, the AP Computer Science Java Subset includes the static variables MIN_VALUE and MAX_VALUE of the Integer class. These store the minimum and maximum possible values of the integer data type.\n\nArray vs Arraylist\nAfter an array is created, it cannot be resized. --> ArrayLists will automatically resize as new elements are added.\nNo import statement is needed to use an array, unless the array holds elements that require an import statement. --> You must import java.util.ArrayList, or use the full package name whenever you use an ArrayList.\nElements are accessed using index notation (e.g., myArray[2]). --> Elements are accessed using methods of the ArrayList class (e.g., myList.get(2), myList.add(\"George\")).\nArrays can be constructed to hold either primitives or object references. --> ArrayList instances can hold only object references, not primitives. The Integer and Double wrapper classes must be used to store integer and double primitives in an ArrayList.\nEach array can be declared for only one type of element. For example, if an array is declared to hold strings, you cannot store an integer in it. --> An ArrayList can hold a heterogeneous collection of objects. For example, the following is perfectly legal (though not recommended): ArrayList list = new ArrayList(); list.add(new String(\"A String\">)); list.add(new Integer(4));\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nArrayList list = new ArrayList( );\nlist.add(\"A\");\nlist.add(\"B\");\nlist.add(0, \"C\");\nlist.add(\"D\");\nlist.set(2, \"E\");\nlist.remove(1);\nSystem.out.println(list);\n\nWhat is printed as a result of executing the code segment?\nCorrect: [C, E, D]\nIncorrect: [A, B, C, D, E]\nIncorrect: [A, B, D, E]\nIncorrect: [A, D, E]\nIncorrect: [A, C, D, E]\n\nEND"}
{"prompt":"There are two big limitations of the powerful array structure in Java: an array has a fixed length and it can store only one type of data. If you wanted to represent, say, a friend’s collection of action figures, an array would require all of the action figures to be the same type. Generally speaking, they must all be flying superheroes, or they must all have protective body armor, etc. \nLikewise, a collection of action figures represented as an array could store only a fixed number of action figures, no more and no less. If there are extra, unused slots, they stay there, which could be problematic if you have an array of helmeted heroes and you try to remove the helmet from every element in every index of the array. Once you reach the first empty spot, there is no hero and therefore no helmet, so the directions do not make sense; in Java, the compiler will return a NullPointerException for this situation. \nAn ArrayList addresses both of these issues. An ArrayList object is dynamically sized, expanding and compressing as elements are added and removed. An ArrayList can also store multiple types of data, without limit. \nLet’s use an example to understand the advantages and disadvantages of arrays versus ArrayLists. Consider your lunch bag that you take to school. If you wanted to represent your lunch bag using an array or ArrayList structure, which would be more accurate?\nNaturally, the answer to this question depends on (1) the details of the objects in the bag—in this case, the types of lunch items—and (2) the programmer’s choice of which is more appropriate. If your lunch contains a sandwich object, a fruit object, and a drink object, the ArrayList structure might be a better choice. Furthermore, as the components of the lunch are removed, the lunch bag theoretically shrinks (or can shrink). An ArrayList seems appropriate. \nLet’s consider the same lunch example, but this time, suppose the items are stored in a plastic container with compartments. Regardless of whether you have not yet eaten your lunch, you are done with your lunch, or it’s currently anytime in between, the number and setup of the compartments do not change. We will discuss a workaround for “tricking” the array into thinking the lunch objects are all the same type. These facts and abilities render an array structure more appropriate than an ArrayList. \nTo further demonstrate the usefulness of an ArrayList structure, note that it is also possible to create a typed ArrayList, which allows only objects of the same type to be stored in the list. This structure combines useful aspects of both arrays and ArrayLists. \nIn order to instantiate an ArrayList called lunchBag that will store the various components of our lunch, we use the following line of code: \nArrayList lunchBag = new ArrayList(); \n\nNote that, unlike the syntax we use for instantiating an array, neither the type of object nor the length of the list is defined initially. \nIn order to access data from within the list, particular methods must be invoked; unlike for array structures in Java, there is not a convenient bracket notation available with lists. To return the second object, an Apple object, in the ArrayList and store it using the variable food, the line of code would be\nApple red = lunchBag.get(1); \n\nThere are several other useful methods available in the List class, and they are all mentioned in the AP Exam Quick Reference, although their functionality is (obviously) not given. These methods include add, set, remove, and size. \nIf the programmer decides it is more appropriate to keep the dynamic sizing ability of the ArrayList while fixing the type of data it can hold (as in an array), it would be instantiated as follows: \nArrayList<Apple> lunchBag = new ArrayList<Apple>(); \n\nOne of the drawbacks of using ArrayList is that only objects can be stored in an ArrayList. The primitive data types int and double cannot be stored in ArrayLists. If programmers want to store integer and double data types, they must use the Integer or Double wrapper classes. Integer and Double objects can be created using integers and doubles, respectively, as parameters. For example, \nInteger n = new Integer(5); \nDouble x = new Double(6.1); \n\nTo call the values, use the intValue() and doubleValue() methods. The following commands \nint a = n.intValue(); \nint y = x.doubleValue(); \n\nassign a = 5 and y = 6.1.\n\nAdditionally, the AP Computer Science Java Subset includes the static variables MIN_VALUE and MAX_VALUE of the Integer class. These store the minimum and maximum possible values of the integer data type.\n\nArray vs Arraylist\nAfter an array is created, it cannot be resized. --> ArrayLists will automatically resize as new elements are added.\nNo import statement is needed to use an array, unless the array holds elements that require an import statement. --> You must import java.util.ArrayList, or use the full package name whenever you use an ArrayList.\nElements are accessed using index notation (e.g., myArray[2]). --> Elements are accessed using methods of the ArrayList class (e.g., myList.get(2), myList.add(\"George\")).\nArrays can be constructed to hold either primitives or object references. --> ArrayList instances can hold only object references, not primitives. The Integer and Double wrapper classes must be used to store integer and double primitives in an ArrayList.\nEach array can be declared for only one type of element. For example, if an array is declared to hold strings, you cannot store an integer in it. --> An ArrayList can hold a heterogeneous collection of objects. For example, the following is perfectly legal (though not recommended): ArrayList list = new ArrayList(); list.add(new String(\"A String\">)); list.add(new Integer(4));\n\n\n###\n\n","completion":" Question: Consider the following data fields and method:\nprivate ArrayList letters;\n\/\/ precondition: letters.size( ) > 0\n\/\/ letters contains String objects\npublic void letterRemover( )\n{\n    int i = 0;\n    while (i < letters.size( ))\n    {\n        if (letters.get(i).equals(\"A\"))\n            letters.remove(i);\n        i++;\n    }\n}\n\nAssume that ArrayList letters originally contains the following String values:\n[A, B, A, A, C, D, B]\n\nWhat will letters contain as a result of executing letterRemover( )?\nCorrect: [B, A, C, D, B]\nIncorrect: [A, B, A, A, C, D, B]\nIncorrect: [B, C, D, B]\nIncorrect: [A, B, A, C, D, B]\nIncorrect: [A, A, B, C, D, B, D]\n\nEND"}
{"prompt":"There are two big limitations of the powerful array structure in Java: an array has a fixed length and it can store only one type of data. If you wanted to represent, say, a friend’s collection of action figures, an array would require all of the action figures to be the same type. Generally speaking, they must all be flying superheroes, or they must all have protective body armor, etc. \nLikewise, a collection of action figures represented as an array could store only a fixed number of action figures, no more and no less. If there are extra, unused slots, they stay there, which could be problematic if you have an array of helmeted heroes and you try to remove the helmet from every element in every index of the array. Once you reach the first empty spot, there is no hero and therefore no helmet, so the directions do not make sense; in Java, the compiler will return a NullPointerException for this situation. \nAn ArrayList addresses both of these issues. An ArrayList object is dynamically sized, expanding and compressing as elements are added and removed. An ArrayList can also store multiple types of data, without limit. \nLet’s use an example to understand the advantages and disadvantages of arrays versus ArrayLists. Consider your lunch bag that you take to school. If you wanted to represent your lunch bag using an array or ArrayList structure, which would be more accurate?\nNaturally, the answer to this question depends on (1) the details of the objects in the bag—in this case, the types of lunch items—and (2) the programmer’s choice of which is more appropriate. If your lunch contains a sandwich object, a fruit object, and a drink object, the ArrayList structure might be a better choice. Furthermore, as the components of the lunch are removed, the lunch bag theoretically shrinks (or can shrink). An ArrayList seems appropriate. \nLet’s consider the same lunch example, but this time, suppose the items are stored in a plastic container with compartments. Regardless of whether you have not yet eaten your lunch, you are done with your lunch, or it’s currently anytime in between, the number and setup of the compartments do not change. We will discuss a workaround for “tricking” the array into thinking the lunch objects are all the same type. These facts and abilities render an array structure more appropriate than an ArrayList. \nTo further demonstrate the usefulness of an ArrayList structure, note that it is also possible to create a typed ArrayList, which allows only objects of the same type to be stored in the list. This structure combines useful aspects of both arrays and ArrayLists. \nIn order to instantiate an ArrayList called lunchBag that will store the various components of our lunch, we use the following line of code: \nArrayList lunchBag = new ArrayList(); \n\nNote that, unlike the syntax we use for instantiating an array, neither the type of object nor the length of the list is defined initially. \nIn order to access data from within the list, particular methods must be invoked; unlike for array structures in Java, there is not a convenient bracket notation available with lists. To return the second object, an Apple object, in the ArrayList and store it using the variable food, the line of code would be\nApple red = lunchBag.get(1); \n\nThere are several other useful methods available in the List class, and they are all mentioned in the AP Exam Quick Reference, although their functionality is (obviously) not given. These methods include add, set, remove, and size. \nIf the programmer decides it is more appropriate to keep the dynamic sizing ability of the ArrayList while fixing the type of data it can hold (as in an array), it would be instantiated as follows: \nArrayList<Apple> lunchBag = new ArrayList<Apple>(); \n\nOne of the drawbacks of using ArrayList is that only objects can be stored in an ArrayList. The primitive data types int and double cannot be stored in ArrayLists. If programmers want to store integer and double data types, they must use the Integer or Double wrapper classes. Integer and Double objects can be created using integers and doubles, respectively, as parameters. For example, \nInteger n = new Integer(5); \nDouble x = new Double(6.1); \n\nTo call the values, use the intValue() and doubleValue() methods. The following commands \nint a = n.intValue(); \nint y = x.doubleValue(); \n\nassign a = 5 and y = 6.1.\n\nAdditionally, the AP Computer Science Java Subset includes the static variables MIN_VALUE and MAX_VALUE of the Integer class. These store the minimum and maximum possible values of the integer data type.\n\nArray vs Arraylist\nAfter an array is created, it cannot be resized. --> ArrayLists will automatically resize as new elements are added.\nNo import statement is needed to use an array, unless the array holds elements that require an import statement. --> You must import java.util.ArrayList, or use the full package name whenever you use an ArrayList.\nElements are accessed using index notation (e.g., myArray[2]). --> Elements are accessed using methods of the ArrayList class (e.g., myList.get(2), myList.add(\"George\")).\nArrays can be constructed to hold either primitives or object references. --> ArrayList instances can hold only object references, not primitives. The Integer and Double wrapper classes must be used to store integer and double primitives in an ArrayList.\nEach array can be declared for only one type of element. For example, if an array is declared to hold strings, you cannot store an integer in it. --> An ArrayList can hold a heterogeneous collection of objects. For example, the following is perfectly legal (though not recommended): ArrayList list = new ArrayList(); list.add(new String(\"A String\">)); list.add(new Integer(4));\n\n\n###\n\n","completion":" Question: Consider the following method:\nprivate ArrayList myList;\n\/\/ precondition: myList.size( ) > 0\n\/\/ myList contains String objects\npublic void myMethod( )\n{\n    for (int i = 0; i < myList.size( ) – 1; i++)  {\n        myList.remove(i);\n        System.out.print(myList.get(i) + \" \");\n    }\n}\n\nAssume that myList originally contains the following String values: [A, B, C, D, E]\nWhat will be printed when the method above executes?\nCorrect: B D\nIncorrect: A B C D E\nIncorrect: A C E\nIncorrect: B D E\nIncorrect: Nothing will be printed due to an IndexOutOfBoundsException.\n\nEND"}
{"prompt":"There are two big limitations of the powerful array structure in Java: an array has a fixed length and it can store only one type of data. If you wanted to represent, say, a friend’s collection of action figures, an array would require all of the action figures to be the same type. Generally speaking, they must all be flying superheroes, or they must all have protective body armor, etc. \nLikewise, a collection of action figures represented as an array could store only a fixed number of action figures, no more and no less. If there are extra, unused slots, they stay there, which could be problematic if you have an array of helmeted heroes and you try to remove the helmet from every element in every index of the array. Once you reach the first empty spot, there is no hero and therefore no helmet, so the directions do not make sense; in Java, the compiler will return a NullPointerException for this situation. \nAn ArrayList addresses both of these issues. An ArrayList object is dynamically sized, expanding and compressing as elements are added and removed. An ArrayList can also store multiple types of data, without limit. \nLet’s use an example to understand the advantages and disadvantages of arrays versus ArrayLists. Consider your lunch bag that you take to school. If you wanted to represent your lunch bag using an array or ArrayList structure, which would be more accurate?\nNaturally, the answer to this question depends on (1) the details of the objects in the bag—in this case, the types of lunch items—and (2) the programmer’s choice of which is more appropriate. If your lunch contains a sandwich object, a fruit object, and a drink object, the ArrayList structure might be a better choice. Furthermore, as the components of the lunch are removed, the lunch bag theoretically shrinks (or can shrink). An ArrayList seems appropriate. \nLet’s consider the same lunch example, but this time, suppose the items are stored in a plastic container with compartments. Regardless of whether you have not yet eaten your lunch, you are done with your lunch, or it’s currently anytime in between, the number and setup of the compartments do not change. We will discuss a workaround for “tricking” the array into thinking the lunch objects are all the same type. These facts and abilities render an array structure more appropriate than an ArrayList. \nTo further demonstrate the usefulness of an ArrayList structure, note that it is also possible to create a typed ArrayList, which allows only objects of the same type to be stored in the list. This structure combines useful aspects of both arrays and ArrayLists. \nIn order to instantiate an ArrayList called lunchBag that will store the various components of our lunch, we use the following line of code: \nArrayList lunchBag = new ArrayList(); \n\nNote that, unlike the syntax we use for instantiating an array, neither the type of object nor the length of the list is defined initially. \nIn order to access data from within the list, particular methods must be invoked; unlike for array structures in Java, there is not a convenient bracket notation available with lists. To return the second object, an Apple object, in the ArrayList and store it using the variable food, the line of code would be\nApple red = lunchBag.get(1); \n\nThere are several other useful methods available in the List class, and they are all mentioned in the AP Exam Quick Reference, although their functionality is (obviously) not given. These methods include add, set, remove, and size. \nIf the programmer decides it is more appropriate to keep the dynamic sizing ability of the ArrayList while fixing the type of data it can hold (as in an array), it would be instantiated as follows: \nArrayList<Apple> lunchBag = new ArrayList<Apple>(); \n\nOne of the drawbacks of using ArrayList is that only objects can be stored in an ArrayList. The primitive data types int and double cannot be stored in ArrayLists. If programmers want to store integer and double data types, they must use the Integer or Double wrapper classes. Integer and Double objects can be created using integers and doubles, respectively, as parameters. For example, \nInteger n = new Integer(5); \nDouble x = new Double(6.1); \n\nTo call the values, use the intValue() and doubleValue() methods. The following commands \nint a = n.intValue(); \nint y = x.doubleValue(); \n\nassign a = 5 and y = 6.1.\n\nAdditionally, the AP Computer Science Java Subset includes the static variables MIN_VALUE and MAX_VALUE of the Integer class. These store the minimum and maximum possible values of the integer data type.\n\nArray vs Arraylist\nAfter an array is created, it cannot be resized. --> ArrayLists will automatically resize as new elements are added.\nNo import statement is needed to use an array, unless the array holds elements that require an import statement. --> You must import java.util.ArrayList, or use the full package name whenever you use an ArrayList.\nElements are accessed using index notation (e.g., myArray[2]). --> Elements are accessed using methods of the ArrayList class (e.g., myList.get(2), myList.add(\"George\")).\nArrays can be constructed to hold either primitives or object references. --> ArrayList instances can hold only object references, not primitives. The Integer and Double wrapper classes must be used to store integer and double primitives in an ArrayList.\nEach array can be declared for only one type of element. For example, if an array is declared to hold strings, you cannot store an integer in it. --> An ArrayList can hold a heterogeneous collection of objects. For example, the following is perfectly legal (though not recommended): ArrayList list = new ArrayList(); list.add(new String(\"A String\">)); list.add(new Integer(4));\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nArrayList list = new ArrayList( );\nfor (int i = 1; i <= 8; i++)\n{\n    list.add(new Integer(i));\n}\nfor (int j = 1; j < list.size( ); j++)\n{\n    list.set(j \/ 2, list.get(j));\n}\nSystem.out.println(list);\n\nWhat is printed as a result of executing the code segment?\nCorrect: [2, 4, 6, 8, 5, 6, 7, 8]\nIncorrect: [1, 2, 3, 4, 5, 6, 7, 8]\nIncorrect: [1, 2, 3, 4]\nIncorrect: [1, 2, 3, 4, 1, 2, 3, 4]\nIncorrect: [2, 2, 4, 4, 6, 6, 8, 8]END"}
{"prompt":"Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let’s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an “array of arrays,” which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn’t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array— just a fancy one. It’s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint[][] num = new int [4][4];\nfor (int i = 0; i < num.length; i++)\n{\n    for (int k = 0; k < num.length; k++\n    {\n        num[i][k] = i * k;\n    }\n}\n\nWhat are the contents of num after the code segment has executed?\nCorrect: 0 0 0 0\n0 1 2 3\n0 2 4 6\n0 3 6 9\nIncorrect: 0 1 2 3\n1 2 3 4\n2 3 4 5\n3 4 5 6\nIncorrect: 0 3 6 9\n0 2 4 6\n0 1 2 3\n0 0 0 0\nIncorrect: 1 1 1 1\n2 2 2 2\n3 3 3 3\n4 4 4 4\nIncorrect: 0 0 0 0\n1 2 3 4\n2 4 6 8\n3 6 9 12\n\nEND"}
{"prompt":"Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let’s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an “array of arrays,” which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn’t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array— just a fancy one. It’s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\n###\n\n","completion":" Question: The following class, Arr2d, is meant to represent a 2-dimensional array object. The constructor will initialize Arr2d using the number of rows and columns that have been passed. Choose the statement that will initialize the array in the constructor.\npublic class Arr2D {\n    private int [][] arr;\n    Arr2D (int rows, int columns)\n    {\n        \/*missing code *\/\n    }\n}\nCorrect: arr = new String [rows][columns];\nIncorrect: int [] arr = new String [rows][columns];\nIncorrect: int [][] arr = new String [rows - 1][columns - 1];\nIncorrect: arr = new String [rows - 1][columns - 1];\nIncorrect: int arr [][] = new String [rows][columns];\n\nEND"}
{"prompt":"Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let’s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an “array of arrays,” which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn’t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array— just a fancy one. It’s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint [][] numbers = {{1, 2, 3, 4}, {5, 6, 7, 8}};\nfor (int [] nums : numbers)\n    for (int n : nums)\n        System.out.print(n + \" \");\nSystem.out.print(\"\\n\");\n\nWhat is printed as a result of executing the code segment?\nCorrect: 1 2 3 4 5 6 7 8\nIncorrect: 1 2 3 4\n5 6 7 8\nIncorrect: 1 2\n3 4\n5 6\n7 8\nIncorrect: 5 6 7 8\n1 2 3 4\nIncorrect: A compiler error would occur.\n\nEND"}
{"prompt":"Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let’s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an “array of arrays,” which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn’t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array— just a fancy one. It’s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint[][] numbers = new int [4][4];\ninitializeIt(numbers);\nint total = 0;\nfor (int z = 0; z < numbers.length; z++)\n{\n    total += numbers[z][numbers [0].length – 1 – z];\n}\n\nThe call to initializeIt() on the second line initializes the array numbers so that it looks like the following:\n1 2 5 3\n7 9 4 0\n3 3 2 5\n4 5 8 1\n\nWhat will be the value of total after the code has executed?\nCorrect: 14\nIncorrect: 11\nIncorrect: 12\nIncorrect: 13\nIncorrect: 15\n\nEND"}
{"prompt":"Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let’s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an “array of arrays,” which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn’t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array— just a fancy one. It’s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint[][] numbers = new int[3][6];\ninitializeIt(numbers);\nint total = 0;\nfor (int j = 0; j < numbers.length; j++)\n{\n    for (int k = 0; k < numbers[0].length; k += 2)  {\n        total+= numbers[j][k];\n    }\n}\n\nThe call to initializeIt() on the second line initializes the array numbers so that it looks like the following:\n2 4 6 3 2 1\n5 6 7 4 2 9\n4 0 5 6 4 2\n\nWhat will be the value of total after the code has executed?\nCorrect: 37\nIncorrect: 18\nIncorrect: 35\nIncorrect: 72\nIncorrect: 101\n\nEND"}
{"prompt":"Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let’s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an “array of arrays,” which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn’t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array— just a fancy one. It’s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint[][] num = new int[4][4];\nfor (int i = 0; i < num.length; i++)\n{\n    for (int k = 0; k < num[0].length; k++)\n    {\n        num[i][k] = i * k;\n    }\n}\n\nWhat are the contents of num after the code segment has executed?\nCorrect: 0 0 0 0\n0 1 2 3\n0 2 4 6\n0 3 6 9\nIncorrect: 0 1 2 3\n1 2 3 4\n2 3 4 5\n3 4 5 6\nIncorrect: 0 3 6 9\n0 2 4 6\n0 1 2 3\n0 0 0 0\nIncorrect: 1 1 1 1\n2 2 2 2\n3 3 3 3\n4 4 4 4\nIncorrect: 0 0 0 0\n1 2 3 4\n2 4 6 8\n3 6 9 12\n\nEND"}
{"prompt":"Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let’s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an “array of arrays,” which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn’t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array— just a fancy one. It’s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint [][] numbers = {{1, 2, 3, 4},{5, 6, 7, 8}}; initializeIt(numbers);\nString line =””;\nfor (int a = 0; a < numbers[0].length; a++)\n{\n    for (int b = 0; b < numbers.length; b++)\n    {\n        line += numbers[b][a] + “ “;\n    }\n    line += “\\n”;\n}\nSystem.out.println(line);\n\nThe call to initializeIt() on the second line initializes the array so that it looks like the following:\n1 2 3 4\n5 6 7 8\n\nWhat will be printed after the code has executed?\nCorrect: 1 5\n2 6\n3 4\n4 8\n\n\nIncorrect: 1 2 3 4\n5 6 7 8\nIncorrect: 5 6 7 8\n1 2 3 4\nIncorrect: 8 7 6 5\n4 3 2 1\nIncorrect: 1 2\n3 4\n5 6\n7 8END"}
{"prompt":"Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let’s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an “array of arrays,” which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn’t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array— just a fancy one. It’s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\n###\n\n","completion":" Question: Consider the following client code and method:\nint [][] numbers = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\nint [] myArr = mystery(numbers, 2);\nfor (int j: myArr)\n    System.out.print(j + \" \");\n\npublic static int [] mystery(int [][] arr, int n) {\n    int [] m = new int[arr.length];\n    for (int i = 0; i < arr.length; i++)\n        m[i] = arr[i][n];\n    return m;\n}\n\nWhat will be printed after the code executes?\nCorrect: 3 7 11\n\n\nIncorrect: 5 6 7 8\nIncorrect: 2 6 10\nIncorrect: 9 10 11 12\nIncorrect: 4 8 12END"}
{"prompt":"Two-dimensional, or 2D, arrays are structures that have entered, exited, and re-entered the required topics for the AP Exam. They are quite powerful and, at the same time, not too difficult to understand once you have mastered 1D array structures, which we studied in Chapter 8. \nA great example of a 2D array is a stand-up soda machine, like you see in the mall or in front of the supermarket. You know the type, the one in which you drop money and hope desperately that the soda actually drops out. \nThink of the soda machine as a set of rows across the machine, each having a different type of soda (let’s say that the first row has cola, second has orange, etc.). Each of those rows can be considered an array. Now consider the vertical columns down the machine; each column will have one of each type of soda, since it travels down the rows (first item is cola, second item is orange, etc.). That vertical column can also be considered an array. The result is an “array of arrays,” which Java quantifies as a 2D array, with index numbers assigned independently to each row and column location. \nIn the soda machine example, the very first cola in the upper left location of the 2D array would be located at index 0 of the first horizontal array, as well as index 0 of the first vertical array. The code to access this element (soda) in a 2D array (soda machine) already instantiated as sodaMachine would be soda-Machine[0][0], with the first 0 being the row and the second 0 being the column. The second cola would be located at [0][1], and the first orange would be located at [1][0], and so on. For an m by n 2D array, with m being the number of rows and n being the number of columns, the last element in the lower right corner would be located at [m - 1][n - 1]. But you didn’t forget that index numbers begin at 0 and end at (array.length - 1), did you?\nThe methods and constants available for use with array structures are available for 2D array structures as well, because a 2D array is an array— just a fancy one. It’s a little tricky, however; in order to, say, return the number of cola slots across the soda machine, you would use sodaMachine.length, as expected. In order to access the number of slots down the left side of the machine, however, you would use sodaMachine[0].length, meaning you want the length of the first column of the 2D array. \n\n\n###\n\n","completion":" Question: Consider the following code:\nint [][] numbers = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\nfor (int r = numbers.length - 1; r > 0 ; r--)  {\n    for (int c = 0; c < numbers[r].length; c++)\n    {\n        numbers[r - 1][c] = numbers[r][c];\n    }\n}\n\nWhich of the following represents the current values in the array?\nCorrect: 9 10 11 12\n9 10 11 12\n9 10 11 12\nIncorrect: 1 2 3 4\n5 6 7 8\n9 10 11 12\nIncorrect: 9 10 11 12\n5 6 7 8\n1 2 3 4\nIncorrect: 1 2 3 4\n1 2 3 4\n1 2 3 4\nIncorrect: 12 11 10 9\n8 7 6 5\n4 3 2 1END"}
{"prompt":"Consider a situation in which you need a study break and decide to visit your local bakery for a snack. Your favorite dessert is typically Italian cannoli but you will also accept an apple turnover. But apple turnovers are somewhat dry, so you will buy one only if they are selling coffee that day.\nSince this example is relatively complicated, let’s break it into chunks. We will use pseudocode for this example.\nLet’s outline the conditions presented in this example, in order:\n    The bakery has cannoli.\n    The bakery has apple turnovers.\n    The bakery has coffee.\n\nThe complication here is that some of these decisions depend on others. For example, if the bakery DOES have cannoli, then it doesn’t matter whether it has apple turnovers. Again, step by step: start with condition (1)\nif (bakery has cannoli) buy dessert;\n\nNow, another decision must be made, based on this decision; if the bakery DOES have cannoli, we get our desired dessert. If it does NOT have cannoli, we must try the apple turnover.\nif (bakery has cannoli)\n    buy dessert; \/\/ occurs only if bakery has cannoli\nelse if (bakery has apple turnovers) \/\/ occurs only if bakery has no cannoli\n    buy dessert; \/\/ occurs only if bakery has apple turnovers\n\nNote the else keyword used here. else is used if the programmer wants a statement to execute if the condition is false.\nIt’s not that easy, though…we must consider the coffee. Since you will buy an apple turnover only if there is ALSO coffee for sale, the && operator is appropriate here:\n1 if (bakery has cannoli)\n2 buy dessert; \/\/ bakery has cannoli\n3 else if (bakery has apple turnovers && bakery has coffee) \/\/ no cannoli\n4 buy dessert; \/\/ bakery has apple turnovers AND coffee\n\nThis pseudocode seems to work, but we must check for logical errors.\nUsing the numbered lines of pseudocode, let’s trace the possibilities using a trace table.\nhas cannoli: line 1, condition is true -> line 2, buy dessert\nno cannoli, no turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, no turnovers, yes coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, yes coffee: line 1, false -> line 3, true -> line 4, buy dessert\n\nMoral of the story: This bakery had better get itself together.\n\nThere is a lot of pseudocode here! Controlling the flow of a program can be difficult and confusing, which is why it is a popular topic on the AP Exam. But it is also important because most programs, like most things we do in life, rely on conditions and react accordingly.\nIf we look at the bakery example one more time, the line\nbuy dessert;\n\noccurs twice. Good programming style attempts to repeat the same lines of code as little as possible, if ever. Therefore, we can rearrange the boolean operators in the following way, creating the same result:\nif (bakery has cannoli OR (bakery has apple turnovers AND bakery has coffee))\n    buy dessert;\n\nThat is a hefty boolean condition; however, it (1) eliminates the repetition of code and (2) provides a more “elegant” programming solution. “Elegant” is a relative term, of course, but the AP Exam often uses this subjective term to write code and to confuse you. Either way, you should be familiar with both ways.\nThe AP Exam free-response questions do not require you to write code with “elegance”; in the free-response questions they will accept any code solution as long as it fulfills the specifications of the question.\nTo make things more complicated (or more life-like), consider a further idea. What if we want to execute several commands when a condition is true (or false) instead of just one? For example, using the bakery case, let’s say that buying cannoli is so exciting that we must devour it right away. In other words, if the conditions are met for the bakery having cannoli, we want to buy it AND eat it. The pseudocode would look something like:\n1 if (bakery has cannoli)\n2 {\n3   buy dessert; \/\/ bakery has cannoli\n4   eat dessert;\n5 }\n6 else if (bakery has apple turnovers && bakery has coffee) \/\/ no cannoli\n7   buy dessert; \/\/ bakery has apple turnovers AND coffee\n\nThe { and } symbols in lines 2 and 5 indicate blocking, a technique used in flow control statements that allows the programmer to execute a series of commands (instead of just one) when a given condition is satisfied.\n\nHere is a summary for evaluating boolean expressions:\nAn && (and) expression is true if BOTH A and B are true. An || (or) expression is true if EITHER A or B is true, or if they are both true.\nThe ! (not) operator simply reverses the truth value of the variable.\nThe truth value of an expression is often abbreviated to a single letter. Thus, A may represent an expression such as x >= 0. The expression will either be true or false depending on the value of x, but for simplicity’s sake we just refer to the whole expression as A.\nConsider the following three expressions:\nTo evaluate A && B\nFirst evaluate A. If A is false then stop: the whole expression is false. Since false && anything is false, there is no need to continue after the first false has been evaluated. This idea is called short-circuit evaluation. This idea is used (and tested) frequently. However, if A is true, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate A || B\nFirst evaluate A. If A is true then stop: the whole expression is true. Since true || anything is true, there is no need to continue after the first true has been evaluated. This is short-circuit evaluation again. However, if A is false, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate !A\nFirst evaluate A. If A is true, the whole expression is false. If A is false, the whole expression is true.\n\n\n###\n\n","completion":" Question: Consider the following code.\nint x = 0;\nif (x == 0)\n    System.out.print(“1”);\nelse\n    System.out.print(“2”);\n    System.out.print(“3”);\n\nWhich of the following best describes the result of executing the code segment?\nCorrect: Since the value of x is 0, the first print statement will be performed, producing 13 as the output.\nIncorrect: Since the value of x is 0, the first print statement will be performed, producing 1 as the output.\nIncorrect: Since the value of x is 0, the first print statement will be performed, producing 123 as the output.\nIncorrect: == is not the correct boolean operator, so a syntax error will be produced by the compiler prior to execution.\nIncorrect: == is not the correct boolean operator, so a logical error will be produced by the compiler prior to execution.\n\nEND"}
{"prompt":"Consider a situation in which you need a study break and decide to visit your local bakery for a snack. Your favorite dessert is typically Italian cannoli but you will also accept an apple turnover. But apple turnovers are somewhat dry, so you will buy one only if they are selling coffee that day.\nSince this example is relatively complicated, let’s break it into chunks. We will use pseudocode for this example.\nLet’s outline the conditions presented in this example, in order:\n    The bakery has cannoli.\n    The bakery has apple turnovers.\n    The bakery has coffee.\n\nThe complication here is that some of these decisions depend on others. For example, if the bakery DOES have cannoli, then it doesn’t matter whether it has apple turnovers. Again, step by step: start with condition (1)\nif (bakery has cannoli) buy dessert;\n\nNow, another decision must be made, based on this decision; if the bakery DOES have cannoli, we get our desired dessert. If it does NOT have cannoli, we must try the apple turnover.\nif (bakery has cannoli)\n    buy dessert; \/\/ occurs only if bakery has cannoli\nelse if (bakery has apple turnovers) \/\/ occurs only if bakery has no cannoli\n    buy dessert; \/\/ occurs only if bakery has apple turnovers\n\nNote the else keyword used here. else is used if the programmer wants a statement to execute if the condition is false.\nIt’s not that easy, though…we must consider the coffee. Since you will buy an apple turnover only if there is ALSO coffee for sale, the && operator is appropriate here:\n1 if (bakery has cannoli)\n2 buy dessert; \/\/ bakery has cannoli\n3 else if (bakery has apple turnovers && bakery has coffee) \/\/ no cannoli\n4 buy dessert; \/\/ bakery has apple turnovers AND coffee\n\nThis pseudocode seems to work, but we must check for logical errors.\nUsing the numbered lines of pseudocode, let’s trace the possibilities using a trace table.\nhas cannoli: line 1, condition is true -> line 2, buy dessert\nno cannoli, no turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, no turnovers, yes coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, yes coffee: line 1, false -> line 3, true -> line 4, buy dessert\n\nMoral of the story: This bakery had better get itself together.\n\nThere is a lot of pseudocode here! Controlling the flow of a program can be difficult and confusing, which is why it is a popular topic on the AP Exam. But it is also important because most programs, like most things we do in life, rely on conditions and react accordingly.\nIf we look at the bakery example one more time, the line\nbuy dessert;\n\noccurs twice. Good programming style attempts to repeat the same lines of code as little as possible, if ever. Therefore, we can rearrange the boolean operators in the following way, creating the same result:\nif (bakery has cannoli OR (bakery has apple turnovers AND bakery has coffee))\n    buy dessert;\n\nThat is a hefty boolean condition; however, it (1) eliminates the repetition of code and (2) provides a more “elegant” programming solution. “Elegant” is a relative term, of course, but the AP Exam often uses this subjective term to write code and to confuse you. Either way, you should be familiar with both ways.\nThe AP Exam free-response questions do not require you to write code with “elegance”; in the free-response questions they will accept any code solution as long as it fulfills the specifications of the question.\nTo make things more complicated (or more life-like), consider a further idea. What if we want to execute several commands when a condition is true (or false) instead of just one? For example, using the bakery case, let’s say that buying cannoli is so exciting that we must devour it right away. In other words, if the conditions are met for the bakery having cannoli, we want to buy it AND eat it. The pseudocode would look something like:\n1 if (bakery has cannoli)\n2 {\n3   buy dessert; \/\/ bakery has cannoli\n4   eat dessert;\n5 }\n6 else if (bakery has apple turnovers && bakery has coffee) \/\/ no cannoli\n7   buy dessert; \/\/ bakery has apple turnovers AND coffee\n\nThe { and } symbols in lines 2 and 5 indicate blocking, a technique used in flow control statements that allows the programmer to execute a series of commands (instead of just one) when a given condition is satisfied.\n\nHere is a summary for evaluating boolean expressions:\nAn && (and) expression is true if BOTH A and B are true. An || (or) expression is true if EITHER A or B is true, or if they are both true.\nThe ! (not) operator simply reverses the truth value of the variable.\nThe truth value of an expression is often abbreviated to a single letter. Thus, A may represent an expression such as x >= 0. The expression will either be true or false depending on the value of x, but for simplicity’s sake we just refer to the whole expression as A.\nConsider the following three expressions:\nTo evaluate A && B\nFirst evaluate A. If A is false then stop: the whole expression is false. Since false && anything is false, there is no need to continue after the first false has been evaluated. This idea is called short-circuit evaluation. This idea is used (and tested) frequently. However, if A is true, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate A || B\nFirst evaluate A. If A is true then stop: the whole expression is true. Since true || anything is true, there is no need to continue after the first true has been evaluated. This is short-circuit evaluation again. However, if A is false, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate !A\nFirst evaluate A. If A is true, the whole expression is false. If A is false, the whole expression is true.\n\n\n###\n\n","completion":" Question: Consider the following boolean expression.\n(X && !Y) || (!X && Y)\n\nWhich of the following condition(s) will always cause the expression to evaluate to true?\nCorrect: X and Y have opposite truth values\n\n\nIncorrect: X is true\nIncorrect: Y is false\nIncorrect: X and Y are both true\nIncorrect: X and Y have the same truth valuesEND"}
{"prompt":"Consider a situation in which you need a study break and decide to visit your local bakery for a snack. Your favorite dessert is typically Italian cannoli but you will also accept an apple turnover. But apple turnovers are somewhat dry, so you will buy one only if they are selling coffee that day.\nSince this example is relatively complicated, let’s break it into chunks. We will use pseudocode for this example.\nLet’s outline the conditions presented in this example, in order:\n    The bakery has cannoli.\n    The bakery has apple turnovers.\n    The bakery has coffee.\n\nThe complication here is that some of these decisions depend on others. For example, if the bakery DOES have cannoli, then it doesn’t matter whether it has apple turnovers. Again, step by step: start with condition (1)\nif (bakery has cannoli) buy dessert;\n\nNow, another decision must be made, based on this decision; if the bakery DOES have cannoli, we get our desired dessert. If it does NOT have cannoli, we must try the apple turnover.\nif (bakery has cannoli)\n    buy dessert; \/\/ occurs only if bakery has cannoli\nelse if (bakery has apple turnovers) \/\/ occurs only if bakery has no cannoli\n    buy dessert; \/\/ occurs only if bakery has apple turnovers\n\nNote the else keyword used here. else is used if the programmer wants a statement to execute if the condition is false.\nIt’s not that easy, though…we must consider the coffee. Since you will buy an apple turnover only if there is ALSO coffee for sale, the && operator is appropriate here:\n1 if (bakery has cannoli)\n2 buy dessert; \/\/ bakery has cannoli\n3 else if (bakery has apple turnovers && bakery has coffee) \/\/ no cannoli\n4 buy dessert; \/\/ bakery has apple turnovers AND coffee\n\nThis pseudocode seems to work, but we must check for logical errors.\nUsing the numbered lines of pseudocode, let’s trace the possibilities using a trace table.\nhas cannoli: line 1, condition is true -> line 2, buy dessert\nno cannoli, no turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, no turnovers, yes coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, yes coffee: line 1, false -> line 3, true -> line 4, buy dessert\n\nMoral of the story: This bakery had better get itself together.\n\nThere is a lot of pseudocode here! Controlling the flow of a program can be difficult and confusing, which is why it is a popular topic on the AP Exam. But it is also important because most programs, like most things we do in life, rely on conditions and react accordingly.\nIf we look at the bakery example one more time, the line\nbuy dessert;\n\noccurs twice. Good programming style attempts to repeat the same lines of code as little as possible, if ever. Therefore, we can rearrange the boolean operators in the following way, creating the same result:\nif (bakery has cannoli OR (bakery has apple turnovers AND bakery has coffee))\n    buy dessert;\n\nThat is a hefty boolean condition; however, it (1) eliminates the repetition of code and (2) provides a more “elegant” programming solution. “Elegant” is a relative term, of course, but the AP Exam often uses this subjective term to write code and to confuse you. Either way, you should be familiar with both ways.\nThe AP Exam free-response questions do not require you to write code with “elegance”; in the free-response questions they will accept any code solution as long as it fulfills the specifications of the question.\nTo make things more complicated (or more life-like), consider a further idea. What if we want to execute several commands when a condition is true (or false) instead of just one? For example, using the bakery case, let’s say that buying cannoli is so exciting that we must devour it right away. In other words, if the conditions are met for the bakery having cannoli, we want to buy it AND eat it. The pseudocode would look something like:\n1 if (bakery has cannoli)\n2 {\n3   buy dessert; \/\/ bakery has cannoli\n4   eat dessert;\n5 }\n6 else if (bakery has apple turnovers && bakery has coffee) \/\/ no cannoli\n7   buy dessert; \/\/ bakery has apple turnovers AND coffee\n\nThe { and } symbols in lines 2 and 5 indicate blocking, a technique used in flow control statements that allows the programmer to execute a series of commands (instead of just one) when a given condition is satisfied.\n\nHere is a summary for evaluating boolean expressions:\nAn && (and) expression is true if BOTH A and B are true. An || (or) expression is true if EITHER A or B is true, or if they are both true.\nThe ! (not) operator simply reverses the truth value of the variable.\nThe truth value of an expression is often abbreviated to a single letter. Thus, A may represent an expression such as x >= 0. The expression will either be true or false depending on the value of x, but for simplicity’s sake we just refer to the whole expression as A.\nConsider the following three expressions:\nTo evaluate A && B\nFirst evaluate A. If A is false then stop: the whole expression is false. Since false && anything is false, there is no need to continue after the first false has been evaluated. This idea is called short-circuit evaluation. This idea is used (and tested) frequently. However, if A is true, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate A || B\nFirst evaluate A. If A is true then stop: the whole expression is true. Since true || anything is true, there is no need to continue after the first true has been evaluated. This is short-circuit evaluation again. However, if A is false, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate !A\nFirst evaluate A. If A is true, the whole expression is false. If A is false, the whole expression is true.\n\n\n###\n\n","completion":" Question: Consider the following code segment.\nboolean a = true, b = false;\nif (\/ * missing code * \/)\n    System.out.print(\"Nice job.\");\nelse\n    System.out.print(\"Nicer job.\");\n\nWhich of the following could be used to replace \/ * missing code * \/ so that the output of this block of code is “Nicer job.”?\nI. a && !b\nII. !a || b\nIII. !a && b\nCorrect: II and III only\nIncorrect: I only\nIncorrect: I and II only\nIncorrect: I and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"Consider a situation in which you need a study break and decide to visit your local bakery for a snack. Your favorite dessert is typically Italian cannoli but you will also accept an apple turnover. But apple turnovers are somewhat dry, so you will buy one only if they are selling coffee that day.\nSince this example is relatively complicated, let’s break it into chunks. We will use pseudocode for this example.\nLet’s outline the conditions presented in this example, in order:\n    The bakery has cannoli.\n    The bakery has apple turnovers.\n    The bakery has coffee.\n\nThe complication here is that some of these decisions depend on others. For example, if the bakery DOES have cannoli, then it doesn’t matter whether it has apple turnovers. Again, step by step: start with condition (1)\nif (bakery has cannoli) buy dessert;\n\nNow, another decision must be made, based on this decision; if the bakery DOES have cannoli, we get our desired dessert. If it does NOT have cannoli, we must try the apple turnover.\nif (bakery has cannoli)\n    buy dessert; \/\/ occurs only if bakery has cannoli\nelse if (bakery has apple turnovers) \/\/ occurs only if bakery has no cannoli\n    buy dessert; \/\/ occurs only if bakery has apple turnovers\n\nNote the else keyword used here. else is used if the programmer wants a statement to execute if the condition is false.\nIt’s not that easy, though…we must consider the coffee. Since you will buy an apple turnover only if there is ALSO coffee for sale, the && operator is appropriate here:\n1 if (bakery has cannoli)\n2 buy dessert; \/\/ bakery has cannoli\n3 else if (bakery has apple turnovers && bakery has coffee) \/\/ no cannoli\n4 buy dessert; \/\/ bakery has apple turnovers AND coffee\n\nThis pseudocode seems to work, but we must check for logical errors.\nUsing the numbered lines of pseudocode, let’s trace the possibilities using a trace table.\nhas cannoli: line 1, condition is true -> line 2, buy dessert\nno cannoli, no turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, no turnovers, yes coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, yes coffee: line 1, false -> line 3, true -> line 4, buy dessert\n\nMoral of the story: This bakery had better get itself together.\n\nThere is a lot of pseudocode here! Controlling the flow of a program can be difficult and confusing, which is why it is a popular topic on the AP Exam. But it is also important because most programs, like most things we do in life, rely on conditions and react accordingly.\nIf we look at the bakery example one more time, the line\nbuy dessert;\n\noccurs twice. Good programming style attempts to repeat the same lines of code as little as possible, if ever. Therefore, we can rearrange the boolean operators in the following way, creating the same result:\nif (bakery has cannoli OR (bakery has apple turnovers AND bakery has coffee))\n    buy dessert;\n\nThat is a hefty boolean condition; however, it (1) eliminates the repetition of code and (2) provides a more “elegant” programming solution. “Elegant” is a relative term, of course, but the AP Exam often uses this subjective term to write code and to confuse you. Either way, you should be familiar with both ways.\nThe AP Exam free-response questions do not require you to write code with “elegance”; in the free-response questions they will accept any code solution as long as it fulfills the specifications of the question.\nTo make things more complicated (or more life-like), consider a further idea. What if we want to execute several commands when a condition is true (or false) instead of just one? For example, using the bakery case, let’s say that buying cannoli is so exciting that we must devour it right away. In other words, if the conditions are met for the bakery having cannoli, we want to buy it AND eat it. The pseudocode would look something like:\n1 if (bakery has cannoli)\n2 {\n3   buy dessert; \/\/ bakery has cannoli\n4   eat dessert;\n5 }\n6 else if (bakery has apple turnovers && bakery has coffee) \/\/ no cannoli\n7   buy dessert; \/\/ bakery has apple turnovers AND coffee\n\nThe { and } symbols in lines 2 and 5 indicate blocking, a technique used in flow control statements that allows the programmer to execute a series of commands (instead of just one) when a given condition is satisfied.\n\nHere is a summary for evaluating boolean expressions:\nAn && (and) expression is true if BOTH A and B are true. An || (or) expression is true if EITHER A or B is true, or if they are both true.\nThe ! (not) operator simply reverses the truth value of the variable.\nThe truth value of an expression is often abbreviated to a single letter. Thus, A may represent an expression such as x >= 0. The expression will either be true or false depending on the value of x, but for simplicity’s sake we just refer to the whole expression as A.\nConsider the following three expressions:\nTo evaluate A && B\nFirst evaluate A. If A is false then stop: the whole expression is false. Since false && anything is false, there is no need to continue after the first false has been evaluated. This idea is called short-circuit evaluation. This idea is used (and tested) frequently. However, if A is true, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate A || B\nFirst evaluate A. If A is true then stop: the whole expression is true. Since true || anything is true, there is no need to continue after the first true has been evaluated. This is short-circuit evaluation again. However, if A is false, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate !A\nFirst evaluate A. If A is true, the whole expression is false. If A is false, the whole expression is true.\n\n\n###\n\n","completion":" Question: Suppose p and q are declared as boolean variables and have been initialized to unknown truth values.\nWhat does the following boolean expression evaluate to?\n(!p && !q) || !(p || q)\nCorrect: The expression evaluates to false whenever p and q have opposite truth values.\n\n\nIncorrect: The expression always evaluates to true.\nIncorrect: The expression always evaluates to false.\nIncorrect: The expression evaluates to true whenever p is false.\nIncorrect: The expression evaluates to true whenever q is false.END"}
{"prompt":"Now that we have some tools to make the computer accomplish a simple task, let’s discuss how to make our programs a little more…interesting.\nWhen you wake up in the morning, some tasks occur automatically, while others may depend on a decision. For example, if your alarm clock sounds at 6:00 a.m.…wait, what if it doesn’t? If it sounds at 6:00 a.m., you proceed with your morning rituals; if it does not sound, you wake up late and have to speed up, or change, your routine. When you sit down to eat your favorite breakfast cereal…none is left! Now what?\nMost, if not all, of the actions we perform depend on decisions. These decisions affect whether or not we perform the actions, or even how we perform the actions. Programs possess this exact ability to make decisions and react accordingly. In this way, the programmer can control the flow of the program.\nIf you read the above examples closely, you will literally find the word if as a pivotal word in your decisions of what actions to perform next. The reserved word if is a conditional statement used in Java when programmers want to control the flow of the programs—e.g., if they want Line 2 to occur ONLY if a condition in Line 1 is true. This is referred to as flow control.\nThe syntax of a simple if statement is\nif (condition) statement;\n\nSyntax statements in this book will be presented in pseudocode in order to illustrate the general form, and then further examples will be given. Pseudocode is not Java code that will compile, but it shows the format of the Java statements that we will write later.\nConsider an instance when you are asking a parent whether you can go out to the mall with a friend on Friday night. The (classic) parent response usually looks something like this: If you clean your room, you can go to the mall on Friday.\nIn pseudocode, the parent’s response could be written as\nif (you clean your room) go to the mall;\n\nIn this example, “you clean your room” is the condition of the if statement and “go to the mall” is the statement. The condition in an if statement must have a boolean result. Note that if you do clean your room (true), you will go to the mall; however, if you do not clean your room (false), you will not go to the mall. The if statement is written in this way; the programmer is now controlling the flow of the program. Thus, “go to the mall” will occur if the condition is true, but will be skipped if the condition is false. Another popular (pseudocode) way to write this statement is\nif (you clean your room)\n    go to the mall;\n\nThis construction simply uses white space to make the code more readable. The AP Exam may present an if statement in either of these formats.\nLet’s try a code example. Consider the following lines from a Java program:\nint num1 = 4, num2 = 5;\nif (num1 == num2)\n    System.out.print(\"The numbers are the same.\");\n\nSince we have an if statement, one of two possibilities can occur, based on whether num1 has the same value as num2: (1) the program will display the string literal \"The numbers are the same.\" if the condition is true, or (2) the program will not display any output if the condition is false.\nNote the use, here, of the boolean operator == (also known as the equality operator); do not confuse this boolean operator with the assignment operator =. A boolean operator asks a question, while an assignment operator executes a command. num1 = 4 assigns the value 4 to the variable num1, while num1 == num2 determines whether the two values are equal. The assignment statement produces no other result, while the boolean statement returns a truth value based on the comparison.\nWouldn’t it be nice if conditions in life depended on just one comparison, as our previous code example did? If we dig a bit deeper into our alarm clock example from before, there are probably a few more decisions that need to be made in order to begin your morning rituals; a few of these decisions might be, “is it a school day?”…“do I feel healthy?”…“is my blanket glued to my mattress, trapping me between them?” Note that each of these questions, regardless of its plausibility, has a true or false (boolean) answer.\nIf (see how many times we use this word?) we want to incorporate a more complicated condition into our code, we must create a compound condition. Compound conditions include at least one boolean operator; all of these and their meanings are as follows:\n&& logical and\n|| logical or\n! logical not\n== is equal to\n!= is not equal to\n\nLet’s explore how each of these can be incorporated into a program.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nfor (int i = 200; i > 0; i \/= 3)\n{\n    if (i % 2 == 0)\n        System.out.print(i + \" \");\n}\n\nWhat is the output as a result of executing the code segment?\nCorrect: 200 66 22 2\nIncorrect: 200 66 22 7 2\nIncorrect: 66 22 7 2\nIncorrect: 200 66 22\nIncorrect: 7\n\nEND"}
{"prompt":"Consider a situation in which you need a study break and decide to visit your local bakery for a snack. Your favorite dessert is typically Italian cannoli but you will also accept an apple turnover. But apple turnovers are somewhat dry, so you will buy one only if they are selling coffee that day.\nSince this example is relatively complicated, let’s break it into chunks. We will use pseudocode for this example.\nLet’s outline the conditions presented in this example, in order:\n    The bakery has cannoli.\n    The bakery has apple turnovers.\n    The bakery has coffee.\n\nThe complication here is that some of these decisions depend on others. For example, if the bakery DOES have cannoli, then it doesn’t matter whether it has apple turnovers. Again, step by step: start with condition (1)\nif (bakery has cannoli) buy dessert;\n\nNow, another decision must be made, based on this decision; if the bakery DOES have cannoli, we get our desired dessert. If it does NOT have cannoli, we must try the apple turnover.\nif (bakery has cannoli)\n    buy dessert; \/\/ occurs only if bakery has cannoli\nelse if (bakery has apple turnovers) \/\/ occurs only if bakery has no cannoli\n    buy dessert; \/\/ occurs only if bakery has apple turnovers\n\nNote the else keyword used here. else is used if the programmer wants a statement to execute if the condition is false.\nIt’s not that easy, though…we must consider the coffee. Since you will buy an apple turnover only if there is ALSO coffee for sale, the && operator is appropriate here:\n1 if (bakery has cannoli)\n2 buy dessert; \/\/ bakery has cannoli\n3 else if (bakery has apple turnovers && bakery has coffee) \/\/ no cannoli\n4 buy dessert; \/\/ bakery has apple turnovers AND coffee\n\nThis pseudocode seems to work, but we must check for logical errors.\nUsing the numbered lines of pseudocode, let’s trace the possibilities using a trace table.\nhas cannoli: line 1, condition is true -> line 2, buy dessert\nno cannoli, no turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, no coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, no turnovers, yes coffee: line 1, false -> line 3, false -> no dessert\nno cannoli, yes turnovers, yes coffee: line 1, false -> line 3, true -> line 4, buy dessert\n\nMoral of the story: This bakery had better get itself together.\n\nThere is a lot of pseudocode here! Controlling the flow of a program can be difficult and confusing, which is why it is a popular topic on the AP Exam. But it is also important because most programs, like most things we do in life, rely on conditions and react accordingly.\nIf we look at the bakery example one more time, the line\nbuy dessert;\n\noccurs twice. Good programming style attempts to repeat the same lines of code as little as possible, if ever. Therefore, we can rearrange the boolean operators in the following way, creating the same result:\nif (bakery has cannoli OR (bakery has apple turnovers AND bakery has coffee))\n    buy dessert;\n\nThat is a hefty boolean condition; however, it (1) eliminates the repetition of code and (2) provides a more “elegant” programming solution. “Elegant” is a relative term, of course, but the AP Exam often uses this subjective term to write code and to confuse you. Either way, you should be familiar with both ways.\nThe AP Exam free-response questions do not require you to write code with “elegance”; in the free-response questions they will accept any code solution as long as it fulfills the specifications of the question.\nTo make things more complicated (or more life-like), consider a further idea. What if we want to execute several commands when a condition is true (or false) instead of just one? For example, using the bakery case, let’s say that buying cannoli is so exciting that we must devour it right away. In other words, if the conditions are met for the bakery having cannoli, we want to buy it AND eat it. The pseudocode would look something like:\n1 if (bakery has cannoli)\n2 {\n3   buy dessert; \/\/ bakery has cannoli\n4   eat dessert;\n5 }\n6 else if (bakery has apple turnovers && bakery has coffee) \/\/ no cannoli\n7   buy dessert; \/\/ bakery has apple turnovers AND coffee\n\nThe { and } symbols in lines 2 and 5 indicate blocking, a technique used in flow control statements that allows the programmer to execute a series of commands (instead of just one) when a given condition is satisfied.\n\nHere is a summary for evaluating boolean expressions:\nAn && (and) expression is true if BOTH A and B are true. An || (or) expression is true if EITHER A or B is true, or if they are both true.\nThe ! (not) operator simply reverses the truth value of the variable.\nThe truth value of an expression is often abbreviated to a single letter. Thus, A may represent an expression such as x >= 0. The expression will either be true or false depending on the value of x, but for simplicity’s sake we just refer to the whole expression as A.\nConsider the following three expressions:\nTo evaluate A && B\nFirst evaluate A. If A is false then stop: the whole expression is false. Since false && anything is false, there is no need to continue after the first false has been evaluated. This idea is called short-circuit evaluation. This idea is used (and tested) frequently. However, if A is true, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate A || B\nFirst evaluate A. If A is true then stop: the whole expression is true. Since true || anything is true, there is no need to continue after the first true has been evaluated. This is short-circuit evaluation again. However, if A is false, then you must evaluate B to determine the truth value of the whole expression.\n\nTo evaluate !A\nFirst evaluate A. If A is true, the whole expression is false. If A is false, the whole expression is true.\n\n\n###\n\n","completion":" Question: Suppose p and q are declared as boolean variables and have been initialized to unknown truth values.\nWhat does the following boolean expression evaluate to? (p && !q) || (p && q)\nCorrect: The expression always evaluates to the same value as p.\nIncorrect: The expression always evaluates to the same value as q.\nIncorrect: The expression always evaluates to true.\nIncorrect: The expression always evaluates to false.\nIncorrect: The expression evaluates to true only if p and q have opposite truth values.END"}
{"prompt":"When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and “elegant”).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty —is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly “freeze” in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) \/\/ ! means NOT wet\n2 {\n3   clean paintbrush; \/\/ is it COMPLETELY clean?\n4   dry paintbrush; \/\/ is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let’s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\n###\n\n","completion":" Question: Consider the following code segment.\nint val1 = 2, val2 = 22, val3 = 78;\nwhile (val2 % val1 == 0 || val2 % 3 == 0)\n{\n    val3++;\n    val2--;\n}\n\nWhat will val3 contain after the code segment is executed?\nCorrect: None of the above\n\n\nIncorrect: 77\nIncorrect: 78\nIncorrect: 79\nIncorrect: 80END"}
{"prompt":"When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and “elegant”).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty —is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly “freeze” in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) \/\/ ! means NOT wet\n2 {\n3   clean paintbrush; \/\/ is it COMPLETELY clean?\n4   dry paintbrush; \/\/ is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let’s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\n###\n\n","completion":" Question: What will be the output when the following code is evaluated?\nfor (int k = 0; k < 3; k++)\n{\n    for (int j = 1; j < 4; j++)\n    {\n        System.out.print(j + \" \");\n    }\n    System.out.println();\n}\n\nCorrect: 1 2 3\n1 2 3\n1 2 3\nIncorrect: 1 2 3 4\n1 2 3 4\n1 2 3 4\nIncorrect: 0 1 2\n0 1 2\n0 1 2\n0 1 2\nIncorrect: 1 2 3\n1 2 3\n1 2 3\n1 2 3\nIncorrect: 1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n\nEND"}
{"prompt":"When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and “elegant”).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty —is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly “freeze” in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) \/\/ ! means NOT wet\n2 {\n3   clean paintbrush; \/\/ is it COMPLETELY clean?\n4   dry paintbrush; \/\/ is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let’s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\n###\n\n","completion":" Question: Consider the following code fragments. Assume someNum has been correctly defined and initialized as a positive integer.\nI. for (int i; i = 0; i < someNum; i++)\n{\n    someNum--;\n}\nII. for (int i; i = 1; i < someNum - 1; i++)\n{\n    someNum -=1;\n}\nIII. int i = 0;\nwhile (i < someNum)\n{\n    i++;\n    someNum--;\n}\n\nAll of the following statements are true about these code fragments EXCEPT\nCorrect: The value of someNum after the execution of I and II is the same.\nIncorrect: The for loops in I and II have the same number of iterations.\nIncorrect: The value of i after execution of II and III is the same.\nIncorrect: The loops in I and III have the same number of iterations.\nIncorrect: I, II, and III do not produce identical results.\n\nEND"}
{"prompt":"When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and “elegant”).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty —is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly “freeze” in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) \/\/ ! means NOT wet\n2 {\n3   clean paintbrush; \/\/ is it COMPLETELY clean?\n4   dry paintbrush; \/\/ is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let’s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nfor (int i = 1; i < 100; i = i * 2)\n{\n    if (i \/ 50 == 0)\n        System.out.print(i + \" \");\n}\n\nWhat is printed as a result of executing the code segment?\nCorrect: 1 2 4 8 16 32\nIncorrect: 1 2 4 8 16 32 64\nIncorrect: 2 4 8 16 32 64\nIncorrect: 2 4 8 16 32\nIncorrect: 4 8 16 32 64\n\nEND"}
{"prompt":"When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and “elegant”).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty —is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly “freeze” in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) \/\/ ! means NOT wet\n2 {\n3   clean paintbrush; \/\/ is it COMPLETELY clean?\n4   dry paintbrush; \/\/ is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let’s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\n###\n\n","completion":" Question: Consider the following output:\n0 1\n0 2 4\n0 3 6 9\n0 4 8 12 16\nWhich of the following code segments will produce this output?\nCorrect: for (int x = 1; x < 5; x++)\n{\n    for (int z = 0; z <= x; z++)\n    {\n        System.out.print(x * z + \" \");\n    }\n    System.out.println(\" \");\n}\nIncorrect: for (int x = 1; x <= 5; x++)\n{\n    for (int z = 0; z < x; z++)\n    {\n        System.out.print(x * z + \" \");\n    }\n    System.out.println(\" \");\n}\nIncorrect: for (int x = 1; x < 5; x++)\n{\n    for (int z = 0; z <= 4; z++)\n    {\n        System.out.print(x * z + \" \");\n    }\n    System.out.println(\" \");\n}\nIncorrect: for (int x = 1; x < 5; x++)\n{\n    for (int z = 0; z <= 4; z += 2)\n    {\n        System.out.print(x * z + \" \");\n    }\n    System.out.println(\" \");\n}\nIncorrect: for (int x = 1; x <= 5; x++)\n{\n    for (int z = 0; z <= x; z++)\n    {\n        System.out.print(x * z + \" \");\n    }\n    System.out.println(\" \");\n}\n\nEND"}
{"prompt":"When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and “elegant”).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty —is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly “freeze” in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) \/\/ ! means NOT wet\n2 {\n3   clean paintbrush; \/\/ is it COMPLETELY clean?\n4   dry paintbrush; \/\/ is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let’s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\n###\n\n","completion":" Question: The speed limit of a stretch of highway is 55 miles per hour (mph). The highway patrol issues speeding tickets to anyone caught going faster than 55 miles per hour. The fine for speeding is based on the following scale:\nSpeed Fine:\ngreater than 55 mph but less than 65 mph $100\ngreater than or equal to 65 mph but less than 75 mph $150\ngreater than or equal to 75 mph $300\n\nIf the value of the int variable speed is the speed of a driver who was pulled over for going faster than 55 mph, which of the following code segments will assign the correct value to the int variable fine?\nI. if (speed >= 75)\n    fine = 300;\nif (speed >= 65 && speed < 75)\n    fine = 150;\nif (speed > 55 && speed < 65)\n    fine = 100;\nII. if (speed >= 75)\n    fine = 300;\nif (65 <= speed < 75)\n    fine = 150;\nif (55 < speed < 65)\n    fine = 100;\nIII. if (speed >= 75)\n    fine = 300;\nif (speed >= 65)\n    fine = 150;\nif (speed > 55)\n    fine = 100;\nCorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and II\nIncorrect: I and III\n\nEND"}
{"prompt":"When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and “elegant”).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty —is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly “freeze” in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) \/\/ ! means NOT wet\n2 {\n3   clean paintbrush; \/\/ is it COMPLETELY clean?\n4   dry paintbrush; \/\/ is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let’s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint x = 10;\nint y = 3;\nboolean b = true;\nfor (int i = 0, i < 15; i += 5)\n{\n    x = x + y;\n    b = (x % y == 2);\n    if (!b)\n    {\n        y++;\n        i += 5;\n    }\n}\n\nWhat is the value of x after the code segment executes?\nCorrect: 17\nIncorrect: 10\nIncorrect: 15\nIncorrect: 22\nIncorrect: 25\n\nEND"}
{"prompt":"When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and “elegant”).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty —is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly “freeze” in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) \/\/ ! means NOT wet\n2 {\n3   clean paintbrush; \/\/ is it COMPLETELY clean?\n4   dry paintbrush; \/\/ is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let’s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\n###\n\n","completion":" Question: In the following statement, a and b are boolean variables: boolean c = (a && b) || !(a || b);\nUnder what conditions will the value of c be true?\nCorrect: Only when the value of a is the same as the value of b\nIncorrect: Only when the value of a is different than the value of b\nIncorrect: Only when a and b are both true\nIncorrect: Only when a and b are both false\nIncorrect: The value of c will be true for all values of a and b.\n\nEND"}
{"prompt":"When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and “elegant”).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty —is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly “freeze” in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) \/\/ ! means NOT wet\n2 {\n3   clean paintbrush; \/\/ is it COMPLETELY clean?\n4   dry paintbrush; \/\/ is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let’s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nwhile ((x > y) || y >= z)\n{\n    System.out.print(“*”);\n}\n\nIn the code segment above, x, y, and z are the variables of type int. Which of the following must be true after the code segment has executed?\nCorrect: x <= y && y < z\n\n\nIncorrect: x > y || y >= z\nIncorrect: x <= y || y > z\nIncorrect: x > y && y >= z\nIncorrect: x < y && y <= zEND"}
{"prompt":"When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and “elegant”).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty —is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly “freeze” in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) \/\/ ! means NOT wet\n2 {\n3   clean paintbrush; \/\/ is it COMPLETELY clean?\n4   dry paintbrush; \/\/ is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let’s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint a = 0;\nfor (int i = 0; i < 10; i++)\n{\n    for (int k = 0; k <= 5; k++)\n    {\n        for (int z = 1; z <= 16; z = z * 2)\n        {\n            a++;\n        }\n    }\n}\n\nWhat is the value of a after the code segment executes?\nCorrect: 300\nIncorrect: 31\nIncorrect: 180\nIncorrect: 200\nIncorrect: 400\n\nEND"}
{"prompt":"When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and “elegant”).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty —is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly “freeze” in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) \/\/ ! means NOT wet\n2 {\n3   clean paintbrush; \/\/ is it COMPLETELY clean?\n4   dry paintbrush; \/\/ is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let’s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint x = 10;\nint y = x \/ 3;\nint z = x % 2;\nx++;\nSystem.out.println(x)\n\nWhat is printed as a result of executing the code segment above?\nCorrect: 11\nIncorrect: 2\nIncorrect: 4\nIncorrect: 10\nIncorrect: 15\n\nEND"}
{"prompt":"When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and “elegant”).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty —is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly “freeze” in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) \/\/ ! means NOT wet\n2 {\n3   clean paintbrush; \/\/ is it COMPLETELY clean?\n4   dry paintbrush; \/\/ is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let’s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint a = 10;\ndouble b = 3.7;\nint c = 4;\nint x = (int) (a + b);\ndouble y = (double) a \/ c;\ndouble z = (double) (a \/ c);\ndouble w = x + y + z;\nSystem.out.println(w);\n\nWhat is printed as a result of evaluating the code above?\nCorrect: 17.5\n\n\nIncorrect: 10\nIncorrect: 15\nIncorrect: 15.5\nIncorrect: 17END"}
{"prompt":"When programmers want a statement (or multiple statements) to occur repeatedly, they have two options: (1) copy and paste the statement as many times as necessary (inefficient and ugly), or (2) write a conditional statement called a loop (efficient and “elegant”).\nOn the AP Exam, you will be expected to know two types of loops: while and for.\nThe syntax of a while loop is as follows:\nwhile (condition) statement;\n\nNote its similarity to the if statement. The while statement is a loop that does exactly what its name implies: the loop cycles again and again, while the condition is true. Consider a paint-soaked paintbrush that you just used to paint your bedroom. Hopefully, you will not store the paintbrush away until it is no longer dirty. A while loop that could represent this situation in pseudocode would look like:\n1 while (paintbrush is dirty)\n2 do not put away paintbrush;\n3 put away paintbrush;\n\nNote that if the condition is true (paintbrush is dirty), line 2 will continue to execute, over and over again, until the condition is false (paintbrush is not dirty). Once the condition is false, line 2 is skipped and line 3 is finally executed.\nUnfortunately, this loop is fundamentally flawed. Although its logic seems to be correct, it is not. Within the statement(s) of a loop, the variable(s) in the condition must be modified so that there is a chance that the truth value of the condition will be changed. How will the paintbrush become less dirty —is this a self-cleaning paintbrush? Probably not. Therefore, the paintbrush will actually remain dirty, and Java will keep executing line 2, forever. When this happens, the programmer has written an infinite loop, which is a logical error and is therefore undesirable. Ever have your computer randomly “freeze” in the middle of your work, leaving it unresponsive and causing you to lose that perfectly sculpted digital picture that you just spent an hour perfecting? That is an infinite loop and definitely not desirable.\nOn the AP Exam, you must trace code in multiple-choice questions and detect infinite loops. In free-response questions, you must write code that is free of infinite loops.\nWhile loops, like if statements, are therefore dependent on their conditions. If a condition is more intricate, as it usually is (Do we put the paintbrush away if it is not dirty but it is wet? Not dirty but it is still not clean?), we can use the techniques outlined in the previous section. Boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary. A more realistic pseudocode representation of our paintbrush example could be\n1 while (paintbrush is dirty && paintbrush is wet) \/\/ ! means NOT wet\n2 {\n3   clean paintbrush; \/\/ is it COMPLETELY clean?\n4   dry paintbrush; \/\/ is it COMPLETELY dry?\n5   do not put paintbrush away;\n6 }\n7 put paintbrush away;\n\nIn this example, the paintbrush will continue to be cleaned and dried (and not put away) until it is either NOT dirty or NOT wet, or both, at which point the condition will be false and the paintbrush will be put away. Remember that an && condition is true only if both conditions are true; therefore, if the paintbrush is not dirty but is still wet (or vice versa), it will be put away. Is this the desired result? Who cares?! Reading code is not about logical understanding of a situation; rather, it is about understanding the code and its result.\nIt is also worth noting here that an && statement may be short-circuited. Since both boolean statements on either side of the && must be true, a false result from the first statement will automatically render the condition false. As a result, Java will completely skip the second condition, bypassing the rest of the condition.\nA for statement is another type of loop. For loops and while loops are equally effective in controlling the flow of a program when a statement (or set of statements) is to be executed repeatedly. The syntax is quite different, however:\n    for (initializer; condition; incrementer) statement;\n\nSince the for loop requires more components, it can potentially avoid an infinite loop situation, although there is no guarantee. Let’s try a pseudocode example. Consider a younger sibling who is learning to count to 22. The child will start with 1 and continue counting until reaching 22, and then stop. The counting process repeats until the condition is met. Pseudocode may look like:\nfor (start with 1; not yet reached 22; go to the next number) count the number;\n\nThe execution of a for loop is more difficult to understand. Here are the steps:\n1. The initializer will occur first, beginning the process.\n2. The condition will be checked to make sure it is true.\n3. The statement(s) will execute.\n4. The incrementer will occur, changing the number.\n5. See step (1) and keep repeating (1) to (4), until (2) is false. 6. The loop ends.\n\nA code example of this situation, outputting the current number to the screen, could be:\nfor (int num = 1; num <= 22; num++)\n    System.out.println(num);\n\nThis code will produce each counting number and output it to the screen, each on a separate line. Once again, remember that boolean operators are mandatory and compound conditions and\/or blocking are appropriate when necessary.\nTake Note: for loops and while loops are interchangeable, although one method may look more elegant than the other.\nOn the AP Exam, multiple-choice questions may show you several loop structures in both formats and ask you questions that compare the results, so you should practice working between them. On a free-response question that asks you to write a loop, you will be equally correct whether you decide to write a for loop or a while loop.\nFor and while statements are loops; if statements are not.\n\nThe following two code examples involving loops have identical results:\nint num = 1;\nwhile (num <= 3)\n{\n    System.out.println(num);\n    num++;\n}\nSystem.out.println(\"Done\");\n---\nfor (int num = 1; num <= 3; num++)\n    System.out.println(num);\n    System.out.println(\"Done\");\n\nEach set of code is equally effective and equally respected in both the programming world and on the AP Exam. But multiple-choice questions can use either format, or both, so you should familiarize yourself with both.\nWhile loops perform the blocked statement(s) once, and then evaluate the condition to determine whether the loop continues; for loops evaluate the condition first and then perform the blocked statement(s) if the condition is initially true.\n\n\n###\n\n","completion":" Question: Consider the following code segments:\nI. int x = 10;\nint y = 20;\nint z = 0;\nif (x < y && 10 < y\/z)\n{\n    System.out.println(\"Homer\");\n}\nelse\n{\n    System.out.println(\"Bart\");\n}\nII. int x = 10;\nint y = 20;\nint z = 0;\nif (x > y && 10 < y\/z)\n    System.out.println(\"Homer\");\nelse\n    System.out.println(\"Bart\");\nIII. int x = 10;\nint y = 20;\nint z = 0;\nif (x < y || 10 < y\/z)\n    System.out.println(\"Homer\");\nelse\n    System.out.println(\"Bart\");\n\nWhich of the code segments above will run without error?\nCorrect: II and III\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I, II, and IIIEND"}
{"prompt":"Inheritance is the quintessential way—and the only way, for our purposes —to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the “parent” class and all of its “child” classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer\/designer—yes, there are programmers who focus solely on design—is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet’s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities—would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable—yet all viable—results. \nIn this case, let’s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let’s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and\/or conform to the given specifications. \nLet’s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let’s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization—think: if I look around the room right now, what isn’t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, “eaters” have to wipe their hands before continuing to eat. The desired eat() method—possessing the identical name, parameters, and return type—would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass’s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it’s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method’s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\n###\n\n","completion":" Question: In order to write LawAcademy, a subclass of College, which of the following constructors is valid?\nI. public LawAcademy (String twn, double tuit)\n{\n    super.College(twn, tuit);\n}\nII. public LawAcademy (String twn, double tuit)\n{\n    super(twn, tuit);\n}\nIII. public LawAcademy (String twn, double tuit, String st) {\n    super(st, tuit);\n}\nCorrect: II and III only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: I and III only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"Inheritance is the quintessential way—and the only way, for our purposes —to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the “parent” class and all of its “child” classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer\/designer—yes, there are programmers who focus solely on design—is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet’s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities—would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable—yet all viable—results. \nIn this case, let’s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let’s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and\/or conform to the given specifications. \nLet’s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let’s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization—think: if I look around the room right now, what isn’t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, “eaters” have to wipe their hands before continuing to eat. The desired eat() method—possessing the identical name, parameters, and return type—would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass’s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it’s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method’s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\n###\n\n","completion":" Question: Consider a class Recliner that extends a Chair class. Assuming both classes each have a no-parameter constructor, which of the following statements is NOT valid?\nCorrect: Recliner b = new Chair();\nIncorrect: Object a = new Recliner();\nIncorrect: Chair c = new Chair();\nIncorrect: Chair d = new Recliner();\nIncorrect: All of the above choices are valid.\n\nEND"}
{"prompt":"Inheritance is the quintessential way—and the only way, for our purposes —to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the “parent” class and all of its “child” classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer\/designer—yes, there are programmers who focus solely on design—is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet’s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities—would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable—yet all viable—results. \nIn this case, let’s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let’s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and\/or conform to the given specifications. \nLet’s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let’s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization—think: if I look around the room right now, what isn’t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, “eaters” have to wipe their hands before continuing to eat. The desired eat() method—possessing the identical name, parameters, and return type—would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass’s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it’s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method’s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\n###\n\n","completion":" Question: Consider the following two classes:\npublic class A\n{\n    public int method1(int x)\n    {\n        return 2;\n    }\n}\npublic class B extends A\n{ \/* code not shown *\/ }\n\nWhich of the following could be the signature of a method in class B that correctly overloads method1 in class A?\nCorrect: public int method1(String x)\nIncorrect: public int method1(int y)\nIncorrect: private int method1(int x)\nIncorrect: public int method2(String x)\nIncorrect: public int method2(int y)\n\nEND"}
{"prompt":"Inheritance is the quintessential way—and the only way, for our purposes —to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the “parent” class and all of its “child” classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer\/designer—yes, there are programmers who focus solely on design—is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet’s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities—would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable—yet all viable—results. \nIn this case, let’s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let’s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and\/or conform to the given specifications. \nLet’s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let’s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization—think: if I look around the room right now, what isn’t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, “eaters” have to wipe their hands before continuing to eat. The desired eat() method—possessing the identical name, parameters, and return type—would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass’s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it’s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method’s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\n###\n\n","completion":" Question: Consider the following two classes:\npublic class Parent\n{\n    public void writeMe(String s)\n    {\n        System.out.println(\"Object\");\n    }\n}\npublic class Child extends Parent\n{\n    public void writeMe(String s)\n    {\n        System.out.println(\"Object\");\n    }\n}\n\nWhich of the following best describes the writeMe method of the Child class?\nCorrect: An overridden method\nIncorrect: An inherited method\nIncorrect: An overloaded method\nIncorrect: An interface method\nIncorrect: An abstract method\n\nEND"}
{"prompt":"Polymorphism is a technique that, in a way, breaks all of the rules we think would happen in inheritance—and yet, it conforms to them at the same time. \nUsing our Snack example from above, including the overridden method in OnionChip, suppose several objects from various levels in the hierarchy reside in an untyped ArrayList. The programmer would like to, using a simple loop, simulate the user “eating” the chips in the list, regardless of their type. The loop will iterate through the list and automatically invoke the appropriate eat() method, including the overridden method for OnionChip objects, as desired. This is an example of polymorphism.\nThe word polymorphism, which means “many forms,” can also apply to programs in a more profound manner. This process, directly or indirectly, involves virtually every technique we have learned in this book. \nSuppose an interface called Eatable is implemented by all of the classes in the Snack hierarchy. Every class has either overridden the abstract methods from the interface, as normally required, or passed the abstraction to a subclass. \nHave you ever seen those snack bags that have multiple forms of snacks (for example, potato chips AND pretzels AND nacho chips…) in them? This example is similar; if you instantiated the “bag” as either a typed ArrayList or an array, you could fill the structure with instances of all of these classes by declaring the type as Eatable. Once the eat() method is invoked on all of the components of the list structure using a loop, each object will automatically invoke its corresponding eat method! Pretty awesome. \n\n###\n\n","completion":" Question: Consider the following class:\npublic class Cat\n{\n    private String name;\n    private int age;\n    public Cat(String name, int age)\n    {\n        this.name = name;\n        this.age = age;\n    }\n    public String toString()\n    {\n        return (name + \": \" + age);\n    }\n}\n\nSuppose another class were to include the following code segment:\nCat c = new Cat(\"Billi\", 5);\nSystem.out.println(c);\n\nWhich of the following will be the output of the code segment?\nCorrect: Billi: 5\nIncorrect: c\nIncorrect: 5\nIncorrect: Billi\nIncorrect: There would be no output.\n\nEND"}
{"prompt":"Inheritance is the quintessential way—and the only way, for our purposes —to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the “parent” class and all of its “child” classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer\/designer—yes, there are programmers who focus solely on design—is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet’s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities—would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable—yet all viable—results. \nIn this case, let’s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let’s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and\/or conform to the given specifications. \nLet’s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let’s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization—think: if I look around the room right now, what isn’t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, “eaters” have to wipe their hands before continuing to eat. The desired eat() method—possessing the identical name, parameters, and return type—would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass’s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it’s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method’s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\n###\n\n","completion":" Question: Consider the following two classes:\npublic class Parent\n{\n    public void writeMe(String s)\n    {\n        System.out.println(\"object\");\n    }\n}\npublic class Child extends Parent\n{\n    public void writeMe(String s)\n    {\n        System.out.println(\"object\");\n    }\n}\n\nWhich of the following best describes the writeMe method of the Child class?\nCorrect: An overridden method\nIncorrect: An inherited method\nIncorrect: An overloaded method\nIncorrect: An interface method\nIncorrect: An abstract method\n\nEND"}
{"prompt":"Inheritance is the quintessential way—and the only way, for our purposes —to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the “parent” class and all of its “child” classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer\/designer—yes, there are programmers who focus solely on design—is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet’s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities—would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable—yet all viable—results. \nIn this case, let’s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let’s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and\/or conform to the given specifications. \nLet’s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let’s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization—think: if I look around the room right now, what isn’t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, “eaters” have to wipe their hands before continuing to eat. The desired eat() method—possessing the identical name, parameters, and return type—would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass’s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it’s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method’s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\n###\n\n","completion":" Question: How many classes can a given class extend?\nCorrect: 1\nIncorrect: None\nIncorrect: 2\nIncorrect: 3\nIncorrect: As many as it needs to\n\nEND"}
{"prompt":"Inheritance is the quintessential way—and the only way, for our purposes —to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the “parent” class and all of its “child” classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer\/designer—yes, there are programmers who focus solely on design—is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet’s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities—would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable—yet all viable—results. \nIn this case, let’s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let’s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and\/or conform to the given specifications. \nLet’s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let’s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization—think: if I look around the room right now, what isn’t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, “eaters” have to wipe their hands before continuing to eat. The desired eat() method—possessing the identical name, parameters, and return type—would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass’s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it’s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method’s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\n###\n\n","completion":" Question: Consider the following classes.\npublic class Employee\n{\n    private String name;\n    private String department;\n    Employee ()\n    {\n        name = \"\";\n        department = \"\";\n    }\n    Employee (String iName)\n    {\n        name = iName;\n        department = \"\";\n    }\n    Employee (String iName, String iDepartment)  {\n        name = iName;\n        department = iDepartment;\n    }\n    public String toString()\n    {\n        return name + \" \" + department;\n    }\n}\n\npublic class Manager extends Employee {\n    private double salary;\n    Manager()\n    {\n        salary = 0;\n    }\n    Manager(double iSalary)\n    {\n        salary = iSalary;\n    }\n    Manager(String iName, String iDepartment, double iSalary)\n    {\n        super(iName, iDepartment);\n        salary = iSalary;\n    }\n    public void setSalary(double iSalary)\n    {\n        salary = iSalary;\n    }\n    public String toString()\n    {\n        String str = super.toString();\n        return str += \" \" + salary;\n    }\n}\n\nWhich of the following code combinations will NOT cause a compilation error?\nCorrect: Manager emp5 = new Employee(\"Jones\", \"Sales\");\n\n\nIncorrect: Employee emp1 = new Employee();\nIncorrect: Employee emp2 = new Employee(\"Jones\", \"Sales\");\nIncorrect: Employee emp3 = new Manager(\"Jones\", \"Sales\", 50000.0);\nIncorrect: Employee emp4 = new Manager(50000.0);END"}
{"prompt":"Inheritance is the quintessential way—and the only way, for our purposes —to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the “parent” class and all of its “child” classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. \nThe designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. \nThe first decision for the programmer\/designer—yes, there are programmers who focus solely on design—is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. \nLet’s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities—would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable—yet all viable—results. \nIn this case, let’s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let’s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. \nAs you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and\/or conform to the given specifications. \nLet’s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. \nNow consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let’s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.\nIf we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. \nIt is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. \nIt is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization—think: if I look around the room right now, what isn’t an object? \n\nNow, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()\nmethod in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, “eaters” have to wipe their hands before continuing to eat. The desired eat() method—possessing the identical name, parameters, and return type—would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass’s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). \nThough no longer part of the official Course Description, it’s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method’s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. \n(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. \n\n\n###\n\n","completion":" Question: An apartment rental company has asked you to write a program to store information about the apartments that it has available for rent. For each apartment, the company wants to keep track of the following information: number of rooms, whether or not the apartment has a dishwasher, and whether or not pets are allowed. Which of the following is the best design?\nCorrect: Use one class, Apartment, which has three data fields: int rooms, boolean hasDishwasher, boolean allowsPets.\nIncorrect: Use four unrelated classes: Apartment, Rooms, Dishwasher, and Pets.\nIncorrect: Use one class, Apartment, which has three subclasses: Room, Dishwasher, and Pet.\nIncorrect: Use three classes—Pets, Rooms, and Dishwasher—each with a subclass Apartment.\nIncorrect: Use four classes: Apartment, Pets, Dishwasher, and Rooms. The class Apartment contains instances of the other classes as attributes.\n\nEND"}
{"prompt":"Polymorphism is a technique that, in a way, breaks all of the rules we think would happen in inheritance—and yet, it conforms to them at the same time. \nUsing our Snack example from above, including the overridden method in OnionChip, suppose several objects from various levels in the hierarchy reside in an untyped ArrayList. The programmer would like to, using a simple loop, simulate the user “eating” the chips in the list, regardless of their type. The loop will iterate through the list and automatically invoke the appropriate eat() method, including the overridden method for OnionChip objects, as desired. This is an example of polymorphism.\nThe word polymorphism, which means “many forms,” can also apply to programs in a more profound manner. This process, directly or indirectly, involves virtually every technique we have learned in this book. \nSuppose an interface called Eatable is implemented by all of the classes in the Snack hierarchy. Every class has either overridden the abstract methods from the interface, as normally required, or passed the abstraction to a subclass. \nHave you ever seen those snack bags that have multiple forms of snacks (for example, potato chips AND pretzels AND nacho chips…) in them? This example is similar; if you instantiated the “bag” as either a typed ArrayList or an array, you could fill the structure with instances of all of these classes by declaring the type as Eatable. Once the eat() method is invoked on all of the components of the list structure using a loop, each object will automatically invoke its corresponding eat method! Pretty awesome. \n\n###\n\n","completion":" Question: Consider the following class declarations:\npublic class Vehicle\n{\n    private int maxPassengers;\n    public Vehicle( )\n    {\n        maxPassengers = 1;\n    }\n    public Vehicle(int x)\n    {\n        maxPassengers = x;\n    }\n    public int maxPassengers( )\n    {\n        return maxPassengers;\n    }\n}\n\npublic class Motorcycle extends Vehicle\n{\n    public Motorcycle( )\n    {\n        super(2);\n    }\n}\n\nWhich of the following code segments will NOT cause a compilation error?\nCorrect: Vehicle v2 = new Motorcycle( );\nIncorrect: Motorcycle m1 = new Motorcycle(3);\nIncorrect: Vehicle v1 = new Motorcycle(4);\nIncorrect: Motorcycle m2 = new Vehicle( );\nIncorrect: Vehicle v3 = new Vehicle( );\nint max = v3.maxPassengers;END"}
{"prompt":"An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let’s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) \/\/x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) \/\/x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those “solve this problem” memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n\/\/ returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); \/\/ returns -1 \nstr1.compareTo(\"cat\"); \/\/ returns 0 \nstr2.compareTo(str1); \/\/ returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() – 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to – 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 – 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return –1, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet’s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\n###\n\n","completion":" Question: A math teacher is writing a program that will correctly calculate the area of a circle. Recall that the area of a circle is pi times the radius squared (πr2). Assuming Math.PI returns an accurate decimal approximation of pi, which of the following statements WILL NOT calculate an accurate area of a circle with radius 22?\nCorrect: All of the above choices will calculate an accurate area.\n\n\nIncorrect: r*r*Math.PI; \/\/ r is the int 22\nIncorrect: r*r*Math.PI; \/\/ r is the double 22.0\nIncorrect: (double)r*r*Math.PI; \/\/ r is the int 22\nIncorrect: (double)(r*r)*Math.PI; \/\/ r is the int 22END"}
{"prompt":"An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let’s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) \/\/x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) \/\/x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those “solve this problem” memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n\/\/ returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); \/\/ returns -1 \nstr1.compareTo(\"cat\"); \/\/ returns 0 \nstr2.compareTo(str1); \/\/ returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() – 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to – 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 – 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return –1, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet’s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\n###\n\n","completion":" Question: Consider the following code segment:\nString s = \"This is the beginning\";\nString t = s.substring(5);\nint n = t.indexOf(\"the\");\nWhich of the following will be the value of n?\nCorrect: 3\nIncorrect: –1\nIncorrect: 7\nIncorrect: 9\nIncorrect: n will have no value because of a run-time error.\n\nEND"}
{"prompt":"An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let’s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) \/\/x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) \/\/x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those “solve this problem” memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n\/\/ returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); \/\/ returns -1 \nstr1.compareTo(\"cat\"); \/\/ returns 0 \nstr2.compareTo(str1); \/\/ returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() – 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to – 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 – 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return –1, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet’s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\n###\n\n","completion":" Question: Given the following code, what line will cause a compiler error?\nString word = \"Sunday Funday Celebration 1.0\"; 2 word.substring(7);\nword.substring(3, 6);\nword.indexOf(\"day\");\nword.indexOf(1.0);\nword.compareTo(\"day\");\nCorrect: line 5\nIncorrect: line 2\nIncorrect: line 3\nIncorrect: line 4\nIncorrect: line 6\n\nEND"}
{"prompt":"An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let’s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) \/\/x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) \/\/x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those “solve this problem” memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n\/\/ returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); \/\/ returns -1 \nstr1.compareTo(\"cat\"); \/\/ returns 0 \nstr2.compareTo(str1); \/\/ returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() – 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to – 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 – 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return –1, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet’s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\n###\n\n","completion":" Question: Given the following code, which of the following would cause a run time error?\nString s1 = \"pizza\";\nCorrect: String s2 = s1.substring(4, 6);\n\n\nIncorrect: String s2 = s1.substring(0, 2);\nIncorrect: String s2 = s1.substring(1, 3);\nIncorrect: String s2 = s1.substring(3, 3);\nIncorrect: String s2 = s1.substring(2, 3);END"}
{"prompt":"An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let’s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) \/\/x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) \/\/x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those “solve this problem” memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n\/\/ returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); \/\/ returns -1 \nstr1.compareTo(\"cat\"); \/\/ returns 0 \nstr2.compareTo(str1); \/\/ returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() – 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to – 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 – 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return –1, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet’s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\n###\n\n","completion":" Question: Given the following code, what is the final value stored in s3?\nString s1 = \"kangaroo\";\nString s3 = s1.substring(1, 2);\nCorrect: \"a\"\nIncorrect: \"k\"\nIncorrect: \"ka\"\nIncorrect: \"an\"\nIncorrect: \"kn\"\n\nEND"}
{"prompt":"An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let’s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) \/\/x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) \/\/x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those “solve this problem” memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n\/\/ returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); \/\/ returns -1 \nstr1.compareTo(\"cat\"); \/\/ returns 0 \nstr2.compareTo(str1); \/\/ returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() – 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to – 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 – 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return –1, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet’s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\n###\n\n","completion":" Question: Given the following code, what is the final value stored in s4?\nString s1 = \"tango\";\nString s4 = s1.substring(s1.length() - 2);\nCorrect: \"go\"\nIncorrect: \"g\"\nIncorrect: \"o\"\nIncorrect: \"og\"\nIncorrect: A compiler error will occur.\n\nEND"}
{"prompt":"An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let’s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) \/\/x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) \/\/x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those “solve this problem” memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n\/\/ returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); \/\/ returns -1 \nstr1.compareTo(\"cat\"); \/\/ returns 0 \nstr2.compareTo(str1); \/\/ returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() – 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to – 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 – 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return –1, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet’s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\n###\n\n","completion":" Question: Given that “A” comes before “a” in the dictionary and the following variables have been defined and initialized, which is true?\nString str1 = \"january\";\nString str2 = \"June\";\nString str3 = \"July\";\nCorrect: str1.compareTo(str2) > 0\nIncorrect: str1.compareTo(str3) < 0\nIncorrect: str3.compareTo(str2) > 0\nIncorrect: str1.compareTo(str2) < 0\nIncorrect: str2.compareTo(str3) < 0\n\nEND"}
{"prompt":"An object is an entity or data type we create in Java. To do so, we use a class built specifically for this purpose. Classes contain instance fields (data) belonging to the object and methods to manipulate that data. We will review this in more detail in a later chapter. For now, let’s dive into the Math class.\nPart of the AP Computer Science Java subset is the Math class. The Math class stores common numbers used in mathematical calculations (Math.PI and Math.E) and methods to perform mathematical functions. The methods of the Math class are static. There will be more on static methods later, but, for now, understand that to call the methods of the Math class, the programmer must type Math. before the name of the method. The Math class contains many methods, but only a few are part of the AP Computer Science Java Subset. Unlike most classes that we use to create an object, we normally do not create Math objects. \nCommon Math Methods\nMath.abs(x) \/\/x is an int \nAn int equal to the absolute value of x\n\nMath.abs(x) \/\/x is a double \nA double equal to the absolute value of x\n\nMath.pow(base, exponent) \nA double equal to the base raised to the exponent\n\nMath.sqrt(x) \nA double equal to the square root of x\n\nMath.random() \nA random double in the range (0, 1)\n\nUnderstanding operator precedence is essential for multiple-choice questions on the AP Exam and, perhaps more importantly, for showing off on social media when those “solve this problem” memes pop up and everyone argues over the right answer.\n\nIt is important to note that Math.PI is a static variable of the Math class. Therefore, it can be called only if the class has been imported by putting the following statement at the top of the class coding: \nimport java.lang.Math;\nString is an object data type, meaning it has a class with many methods describing the behavior of the object. Below is a table of common methods utilized in the String class.\n\nCommon String Methods\nlength() \nAn int equal to the length of the string\n\nsubstring(int beginIndex) \nA String that is a substring of this string starting at the character at the beginIndex, through to the end of the string\n\nsubstring(int beginIndex, int endIndex)\nA String that is a substring of this string starting at the character at the beginIndex, up to but not including the character at the endIndex\n\nequals(ObjectanObject) \nA boolean reflecting the status after comparing this string to the specified object. \nString str1 = \"frog\"; \nString str2 = \"frog\"; \nboolean isEqual = str1.equals(str2); \n\/\/ returns true\n\ncompareTo(String anotherString) \nAn int reflecting the status after comparing two strings lexicographically. \n- Returns an integer < 0 if string1 comes before string2 \n- Returns an integer 0 if string1 is the same as string2 \n- Returns an integer > 0 if string1 comes after string2 \nString str1 = \"cat\"; \nString str2 = \"dog\"; \nstr1.compareTo(str2); \/\/ returns -1 \nstr1.compareTo(\"cat\"); \/\/ returns 0 \nstr2.compareTo(str1); \/\/ returns 1\n\nThere are many more methods in the String class that can make your programming technique easier. They can be found in the Java API documentation. \nWhile the char data type is not directly tested, it can be useful to understand that the data in the String class is an array of characters. Therefore, strings have many analogous tools to arrays. Consider the coding below. \nString sample = \"Sample\"\nSystem.out.print(sample.length()); \n\nThe coding will output the number 6. The length() method of the String class will output the number of characters in the string, much as length is the number of elements in an array. Furthermore, the strings use indices in much the same way. The index of the first character in a string is 0, and the index of the last character is length() – 1. \nIndices are useful when dealing with substrings, which are portions of strings. The String class has two substring methods. One has two integer parameters \nString substring (int from, int to) \n\nThis method returns, as a String object, the substring starting at index from and ending at index to – 1. Note that the character at index to will NOT be included in the substring. Therefore, using the String sample from above, the command \nSystem.out.print(sample.substring(1, 4)) \nwill display \namp \n\nNote that \nSystem.out.println(sample.substring(1, 7)); \n\nwill result in an IndexOutOfBoundsException since the index 7 – 1 = 6 is outside the bounds of the string. \n\nThe other substring method works similarly but uses only one parameter, to indicate the starting index. The resulting substring will continue to the end of the string. Therefore, the command\nSystem.out.print(sample.substring(1)) \nwill display \nample \n\nThis process can be reversed using the indexOf method of the String class. This method takes a substring as a parameter and returns the first occurrence of that substring. For example, \nsample.indexOf(\"amp\") \n\nwill return 1, as the substring first occurs at index 1. However, sample.indexOf(\"amb\") \nwill return –1, as this substring does not occur. \n\nThe String class is an immutable class. In other words, it has no mutator methods. Thus, if you wish to change the contents of a String object, the new contents must be reassigned to the variable. \nLet’s look at the following code: \nString sample = \"Sample\"; \nsample.substring(1, 4); \n\nWhile this code will not cause an error, \"amp\" is not stored, making it rather useless. Instead, we assign the String obtained from the substring command back into the original variable so that sample will now contain the literal \"amp\". \nsample = sample.substring(1, 4);\n\nWhen using methods of any class, you should remember that the parameters used to call the method must match the data types of the arguments of the defined method. \nFor example, substring is defined as: \nsubstring(int beginIndex, int endIndex) \n\nTherefore, the following code would cause a compiler error because the parameters are expected to be int data types. \nsample = sample.substring(1.0, 4.0); \n\n\n###\n\n","completion":" Question: Given the following code, what is the final value stored in p?\nString word = \"boottool\";\nint p = word.indexOf(\"oo\");\nword.substring(p + 2);\np = word.indexOf(\"oo\");\nCorrect: 1\nIncorrect: 0\nIncorrect: 2\nIncorrect: 5\nIncorrect: 6END"}
{"prompt":"An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets—these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it’s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet’s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet’s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn’t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array’s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array\/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total \/ len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total \/ len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nfinal int[] a1 = {1, 2};\nint[] b1 = {3, 4};\na1 = b1;\nSystem.out.print(a1[1]);\n\nWhat is printed as a result of executing the code segment?\nCorrect: Nothing is printed due to a compile-time error.\nIncorrect: 2\nIncorrect: 3\nIncorrect: 4\nIncorrect: Nothing is printed due to a run-time error.\n\nEND"}
{"prompt":"An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets—these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it’s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet’s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet’s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn’t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array’s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array\/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total \/ len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total \/ len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint [] a = {1, 2, 3};\nint [] b = {4, 5, 6};\na = b;\nfor (int i = 0; i < b.length; i++)\n{\n    b[i] *= 2;\n}\nSystem.out.println(a[0]);\n\nWhat is printed as a result of executing the code segment?\nCorrect: 8\nIncorrect: 1\nIncorrect: 4\nIncorrect: Nothing is printed due to a compile-time error.\nIncorrect: Nothing is printed due to a run-time error.\n\nEND"}
{"prompt":"An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets—these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it’s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet’s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet’s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn’t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array’s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array\/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total \/ len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total \/ len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\n###\n\n","completion":" Question: Consider the following incomplete method:\npublic static int mod3(int[] a)\n{\n    int count = 0;\n    \/\/ code not shown\n    return count;\n}\n\nMethod Mod3 is intended to return the number of integers in the array that are evenly divisible by 3. Which of the following code segments could be used to replace \/\/ code not shown so that Mod3 will work as intended?\nI. for (int i = 0; i < a.length; i++)\n{\n    if (i % 3 == 0)\n    {\n        count++;\n    }\n}\nII. for (int i = 0; i < a.length; i++)\n{\n    if (a[i] % 3 == 0)\n    {\n        count++;\n    }\n}\nIII. int i = 0;\nwhile (a[i] % 3 == 0)\n{\n    count++;\n    i++;\n}\nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II\nIncorrect: II and III\n\nEND"}
{"prompt":"An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets—these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it’s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet’s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet’s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn’t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array’s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array\/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total \/ len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total \/ len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\n###\n\n","completion":" Question: Consider the following code:\npublic int[] someMethod (int[] array, int value) {\n    for (int i = 1, i < array.length – 1; i++)\n        array[i - 1] += value;\n    return array;\n}\n\nWhich of the following statements is true about the method someMethod?\nCorrect: The method will not increment the last element of the array by value.\n\n\nIncorrect: The method will not return the first value in the array.\nIncorrect: The method will return the last value in the array.\nIncorrect: The method will cause a run-time error.\nIncorrect: The method will not increment the first element of the array by value.END"}
{"prompt":"An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets—these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it’s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet’s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet’s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn’t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array’s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array\/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total \/ len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total \/ len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\n###\n\n","completion":" Question: Consider the following code:\npublic int[] mystery (int[] array, int num)\n{\n    for(int i = 1, i < array.length - 1; i++)\n        array[i] = 0;\n    return array[0];\n}\n\nThere is an error in method mystery. Which of the following modifications is needed to correct the compiler error?\nCorrect: Change the return statement to return array;.\nIncorrect: Change int[] array in the method header parameter to int[] numbers.\nIncorrect: Change array.length - 1 to array.length in the loop statement.\nIncorrect: Change array[i] = 0; to array[i - 1] = 0;.\nIncorrect: None of these choices will make the method compile.\n\nEND"}
{"prompt":"Once data is stored in an array, a common task is to methodically search the array for given data. Consider a line of parked cars in the “Curbside To Go” section of your local chain restaurant. When the server is taking the food to a particular car, she must use a given attribute—say, a license plate number —to find the correct car. Once the correct car is found, the server can deliver the food and then go back inside for the next order, beginning the process all over again…and again…and again.\nThis same technique is used for searching an array. In APCS, we have two methods of searching arrays, the sequential search and the binary search. Since each of these search methods uses a distinct formula to search through the arrays, they are commonly referred to as search algorithms.\nThe chain restaurant example given above is an example of a sequential search. All of the cars are “lined up” and the server begins with the first car, checking its license plate number against the one she is looking for. If it’s correct, the server delivers the food and returns. If not, she moves on to the next car and repeats the process; this all ends when either (1) the correct car is found or (2) the correct car is not in the line at all. This sequential process works just fine, although it can be very tedious. The server would have to do much more work if the desired car were at the end of the line, as opposed to at the beginning. Remember, we are programming a computer; the server cannot simply “look” at all of the plates at once, as we might in real life. The computer does not know how to “look,” unless we know how to write the program that enables it!\nA code segment that performs a linear search for a number target in an array of integers nums might look like this:\nfor (int i = 0; i < nums.length; i++)\n\tif (nums[i] == target)\n\t\tSystem.out.print(“Found at \" + i);\n\nThis segment will correctly traverse the array, searching for target, starting with index 0 and continuing to index length - 1, as desired. Remember that nums.length is the size of the array and therefore nums[length] would be out of bounds. When target is found, the print statement displays its index number. This process will continue until the end of the array is reached. Note that, if target is never found, there will be no output.\nWhen writing algorithms that traverse arrays, programmers often implement the enhanced-for loop, which is designed specifically for traversing entire arrays. In cases which traversing the entire array is not the intent or would cause a run-time error, the enhanced-for loop should not be used. Assuming nums from the previous example would not cause such a problem, the same code segment can be written as an enhanced-for loop structure like this:\nint loc = 0;\nfor (int num : nums)\n{\n\tif (num == target)\n\t\tSystem.out.print(“found at ” + loc);\n\ti++;\n}\n\nEach time the loop iterates, num will be assigned the value of the next element in the array. This structure automatically ensures that the loop does not go out of bounds. In this case, loc is the location or index in which the target is found.\nIt is important to note that the enhanced-for loop provides a variable that will hold each element of the array. It will NOT automatically provide the index of that element. You will have to add code to keep track of the index if you want to use it.\nA binary search is much more efficient; think of it as a “divide-and conquer” mechanism. Instead of our restaurant server starting with the beginning of the line of cars, she will start with the middle car. Depending on whether the license plate is “greater” or “less” than the car she is looking for, the server will move in the appropriate direction.\nThere is a huge obstacle with binary searches, however, or at least, for us with our current level of Java knowledge: these searches work only when there is an inherent order in the data. Suppose the top 21 students in the senior class are lined up in a row. You are looking for a student within that top 21 named Kathy, whom you have never met, but you are not sure where she is in the line. If the students are not lined up in a particular order, a sequential search is your only option, and you might need all 21 tries to find her if she is the last person in the lineup. If they are sorted in alphabetical order by first name, though, you can divide and conquer. Go to the middle person and find out her name…if her name is Sara, you would move toward the front of the line and ignore the back. You then perform the same process, asking the name of the person halfway between the front of the line and Sara, and then ignore the appropriate side. Within a few tries, you will have Kathy.\nHere is a code example of how a binary search might look for array nums when searching for target, assuming nums is sorted:\nint front = 0, back = nums.length - 1, middle = 0; boolean isFound = false;\nwhile((front <= back) && (!isFound))\n{\n\tmiddle = (front + back) \/ 2;\n\tif (nums[middle] < target)\n\t{\n\t\tfront = middle + 1;\n\t}\n\telse if(nums[middle] > target)\n\t{\n\t\tback = middle - 1;\n\t}\n\telse\n\t{\n\t\tisFound = true;\n\t}\n}\nif (isFound)\n{\n System.out.println(\"Found at\" + middle);\n}\nelse\n{\n System.out.println(\"Target Not Found\");\n}\nOn the AP Exam, you will not be required to write a search algorithm; however, you will be required to recognize a search algorithm and trace it, which can be done the easy way if you understand the algorithm, or the hard way by actually tracing the code, step by step. Try to identify the key characteristics of each search; for example, the “sum divided by 2” line is a good indicator of a binary search. The enhanced-for loop will traverse the entire array, which may indicate a sequential search.\n\n\n###\n\n","completion":" Question: Which of the following statements is true regarding search algorithms?\nCorrect: None of these\n\n\nIncorrect: Searching for a Twix in a row of unsorted candy is most efficient using a sequential search.\nIncorrect: Searching for a Twix in a row of unsorted candy is most efficient using a binary search.\nIncorrect: Searching for a Twix in a row of sorted candy is most efficient using a sequential search.\nIncorrect: Searching for a Twix in a row of sorted candy is most efficient using a binary search.END"}
{"prompt":"Once data is stored in an array, a common task is to methodically search the array for given data. Consider a line of parked cars in the “Curbside To Go” section of your local chain restaurant. When the server is taking the food to a particular car, she must use a given attribute—say, a license plate number —to find the correct car. Once the correct car is found, the server can deliver the food and then go back inside for the next order, beginning the process all over again…and again…and again.\nThis same technique is used for searching an array. In APCS, we have two methods of searching arrays, the sequential search and the binary search. Since each of these search methods uses a distinct formula to search through the arrays, they are commonly referred to as search algorithms.\nThe chain restaurant example given above is an example of a sequential search. All of the cars are “lined up” and the server begins with the first car, checking its license plate number against the one she is looking for. If it’s correct, the server delivers the food and returns. If not, she moves on to the next car and repeats the process; this all ends when either (1) the correct car is found or (2) the correct car is not in the line at all. This sequential process works just fine, although it can be very tedious. The server would have to do much more work if the desired car were at the end of the line, as opposed to at the beginning. Remember, we are programming a computer; the server cannot simply “look” at all of the plates at once, as we might in real life. The computer does not know how to “look,” unless we know how to write the program that enables it!\nA code segment that performs a linear search for a number target in an array of integers nums might look like this:\nfor (int i = 0; i < nums.length; i++)\n\tif (nums[i] == target)\n\t\tSystem.out.print(“Found at \" + i);\n\nThis segment will correctly traverse the array, searching for target, starting with index 0 and continuing to index length - 1, as desired. Remember that nums.length is the size of the array and therefore nums[length] would be out of bounds. When target is found, the print statement displays its index number. This process will continue until the end of the array is reached. Note that, if target is never found, there will be no output.\nWhen writing algorithms that traverse arrays, programmers often implement the enhanced-for loop, which is designed specifically for traversing entire arrays. In cases which traversing the entire array is not the intent or would cause a run-time error, the enhanced-for loop should not be used. Assuming nums from the previous example would not cause such a problem, the same code segment can be written as an enhanced-for loop structure like this:\nint loc = 0;\nfor (int num : nums)\n{\n\tif (num == target)\n\t\tSystem.out.print(“found at ” + loc);\n\ti++;\n}\n\nEach time the loop iterates, num will be assigned the value of the next element in the array. This structure automatically ensures that the loop does not go out of bounds. In this case, loc is the location or index in which the target is found.\nIt is important to note that the enhanced-for loop provides a variable that will hold each element of the array. It will NOT automatically provide the index of that element. You will have to add code to keep track of the index if you want to use it.\nA binary search is much more efficient; think of it as a “divide-and conquer” mechanism. Instead of our restaurant server starting with the beginning of the line of cars, she will start with the middle car. Depending on whether the license plate is “greater” or “less” than the car she is looking for, the server will move in the appropriate direction.\nThere is a huge obstacle with binary searches, however, or at least, for us with our current level of Java knowledge: these searches work only when there is an inherent order in the data. Suppose the top 21 students in the senior class are lined up in a row. You are looking for a student within that top 21 named Kathy, whom you have never met, but you are not sure where she is in the line. If the students are not lined up in a particular order, a sequential search is your only option, and you might need all 21 tries to find her if she is the last person in the lineup. If they are sorted in alphabetical order by first name, though, you can divide and conquer. Go to the middle person and find out her name…if her name is Sara, you would move toward the front of the line and ignore the back. You then perform the same process, asking the name of the person halfway between the front of the line and Sara, and then ignore the appropriate side. Within a few tries, you will have Kathy.\nHere is a code example of how a binary search might look for array nums when searching for target, assuming nums is sorted:\nint front = 0, back = nums.length - 1, middle = 0; boolean isFound = false;\nwhile((front <= back) && (!isFound))\n{\n\tmiddle = (front + back) \/ 2;\n\tif (nums[middle] < target)\n\t{\n\t\tfront = middle + 1;\n\t}\n\telse if(nums[middle] > target)\n\t{\n\t\tback = middle - 1;\n\t}\n\telse\n\t{\n\t\tisFound = true;\n\t}\n}\nif (isFound)\n{\n System.out.println(\"Found at\" + middle);\n}\nelse\n{\n System.out.println(\"Target Not Found\");\n}\nOn the AP Exam, you will not be required to write a search algorithm; however, you will be required to recognize a search algorithm and trace it, which can be done the easy way if you understand the algorithm, or the hard way by actually tracing the code, step by step. Try to identify the key characteristics of each search; for example, the “sum divided by 2” line is a good indicator of a binary search. The enhanced-for loop will traverse the entire array, which may indicate a sequential search.\n\n\n###\n\n","completion":" Question: Assuming target is in array a, which of the following methods will correctly return the index of target in sorted array a?\nI. public int findTarget(int[] a, int target)\n{\n    for (int x = 0; x < a.length; x++)\n        if (a[x] == target)\n    return x;\n}\nII. public int findTarget(int[] a, int target)\n{\n    int k = 0;\n    for (int x : a)\n    {\n        if (x == target)\n            return k;\n        k++;\n    }\n    return -1;\n}\nIII. public int findTarget(int[] a, int target)\n{\n    int f = 0, h = a.length, g = 0;\n    for (int i = 0; i < h; i++)\n    {\n        g = (f + h)\/2;\n        if (a[g] < target)\n            f = g + 1;\n        else if (a[g] > target)\n            h = g – 1;\n    }\n    if (a[g] == target)\n        return g;\n    return -1;\n}\nCorrect: II and III only\nIncorrect: I only\nIncorrect: II only\nIncorrect: I and II only\nIncorrect: I, II, and III\n\nEND"}
{"prompt":"An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets—these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it’s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet’s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet’s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn’t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array’s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array\/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total \/ len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total \/ len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\n###\n\n","completion":" Question: What is the length of the array numbers after the following code executes?\nString word = \"Bear\";\nint[] numbers = new int[word.length() - 1];\n\nCorrect: 3\nIncorrect: 1\nIncorrect: 4\nIncorrect: 6\nIncorrect: The array will not be created due to a compile-time error.\n\nEND"}
{"prompt":"An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets—these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it’s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet’s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet’s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn’t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array’s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array\/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total \/ len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total \/ len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nString[] s = new String[2];\nString[] t = {\"Michael\", \"Megan\", \"Chelsea\"};\ns = t;\nSystem.out.print(s.length);\n\nWhat is printed as a result of executing the code segment?\nCorrect: 3\nIncorrect: 1\nIncorrect: 2\nIncorrect: Nothing will be printed due to a compile-time error.\nIncorrect: Nothing will be printed due to a run-time error.\n\nEND"}
{"prompt":"An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets—these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it’s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet’s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet’s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn’t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array’s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array\/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total \/ len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total \/ len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nfinal int[] a1 = {1, 2};\nint[] b1 = {3, 4};\na1 = b1;\nSystem.out.print(a1[1]);\n\nWhat is printed as a result of executing the code segment?\nCorrect: Nothing will be printed due to a compile-time error.\nIncorrect: 2\nIncorrect: 3\nIncorrect: 4\nIncorrect: Nothing will be printed due to a run-time error.\n\nEND"}
{"prompt":"An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets—these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it’s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet’s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet’s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn’t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array’s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array\/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total \/ len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total \/ len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nfinal int[] myArray = {1, 2};\nmyArray[1] = 3;\nSystem.out.print(myArray[1]);\n\nWhat is printed as a result of executing the code segment?\nCorrect: 3\nIncorrect: 1\nIncorrect: 2\nIncorrect: Nothing will be printed due to a run-time error.\nIncorrect: Nothing will be printed due to a compile-time error.\n\nEND"}
{"prompt":"Once data is stored in an array, a common task is to methodically search the array for given data. Consider a line of parked cars in the “Curbside To Go” section of your local chain restaurant. When the server is taking the food to a particular car, she must use a given attribute—say, a license plate number —to find the correct car. Once the correct car is found, the server can deliver the food and then go back inside for the next order, beginning the process all over again…and again…and again.\nThis same technique is used for searching an array. In APCS, we have two methods of searching arrays, the sequential search and the binary search. Since each of these search methods uses a distinct formula to search through the arrays, they are commonly referred to as search algorithms.\nThe chain restaurant example given above is an example of a sequential search. All of the cars are “lined up” and the server begins with the first car, checking its license plate number against the one she is looking for. If it’s correct, the server delivers the food and returns. If not, she moves on to the next car and repeats the process; this all ends when either (1) the correct car is found or (2) the correct car is not in the line at all. This sequential process works just fine, although it can be very tedious. The server would have to do much more work if the desired car were at the end of the line, as opposed to at the beginning. Remember, we are programming a computer; the server cannot simply “look” at all of the plates at once, as we might in real life. The computer does not know how to “look,” unless we know how to write the program that enables it!\nA code segment that performs a linear search for a number target in an array of integers nums might look like this:\nfor (int i = 0; i < nums.length; i++)\n\tif (nums[i] == target)\n\t\tSystem.out.print(“Found at \" + i);\n\nThis segment will correctly traverse the array, searching for target, starting with index 0 and continuing to index length - 1, as desired. Remember that nums.length is the size of the array and therefore nums[length] would be out of bounds. When target is found, the print statement displays its index number. This process will continue until the end of the array is reached. Note that, if target is never found, there will be no output.\nWhen writing algorithms that traverse arrays, programmers often implement the enhanced-for loop, which is designed specifically for traversing entire arrays. In cases which traversing the entire array is not the intent or would cause a run-time error, the enhanced-for loop should not be used. Assuming nums from the previous example would not cause such a problem, the same code segment can be written as an enhanced-for loop structure like this:\nint loc = 0;\nfor (int num : nums)\n{\n\tif (num == target)\n\t\tSystem.out.print(“found at ” + loc);\n\ti++;\n}\n\nEach time the loop iterates, num will be assigned the value of the next element in the array. This structure automatically ensures that the loop does not go out of bounds. In this case, loc is the location or index in which the target is found.\nIt is important to note that the enhanced-for loop provides a variable that will hold each element of the array. It will NOT automatically provide the index of that element. You will have to add code to keep track of the index if you want to use it.\nA binary search is much more efficient; think of it as a “divide-and conquer” mechanism. Instead of our restaurant server starting with the beginning of the line of cars, she will start with the middle car. Depending on whether the license plate is “greater” or “less” than the car she is looking for, the server will move in the appropriate direction.\nThere is a huge obstacle with binary searches, however, or at least, for us with our current level of Java knowledge: these searches work only when there is an inherent order in the data. Suppose the top 21 students in the senior class are lined up in a row. You are looking for a student within that top 21 named Kathy, whom you have never met, but you are not sure where she is in the line. If the students are not lined up in a particular order, a sequential search is your only option, and you might need all 21 tries to find her if she is the last person in the lineup. If they are sorted in alphabetical order by first name, though, you can divide and conquer. Go to the middle person and find out her name…if her name is Sara, you would move toward the front of the line and ignore the back. You then perform the same process, asking the name of the person halfway between the front of the line and Sara, and then ignore the appropriate side. Within a few tries, you will have Kathy.\nHere is a code example of how a binary search might look for array nums when searching for target, assuming nums is sorted:\nint front = 0, back = nums.length - 1, middle = 0; boolean isFound = false;\nwhile((front <= back) && (!isFound))\n{\n\tmiddle = (front + back) \/ 2;\n\tif (nums[middle] < target)\n\t{\n\t\tfront = middle + 1;\n\t}\n\telse if(nums[middle] > target)\n\t{\n\t\tback = middle - 1;\n\t}\n\telse\n\t{\n\t\tisFound = true;\n\t}\n}\nif (isFound)\n{\n System.out.println(\"Found at\" + middle);\n}\nelse\n{\n System.out.println(\"Target Not Found\");\n}\nOn the AP Exam, you will not be required to write a search algorithm; however, you will be required to recognize a search algorithm and trace it, which can be done the easy way if you understand the algorithm, or the hard way by actually tracing the code, step by step. Try to identify the key characteristics of each search; for example, the “sum divided by 2” line is a good indicator of a binary search. The enhanced-for loop will traverse the entire array, which may indicate a sequential search.\n\n\n###\n\n","completion":" Question: Consider the following incomplete method:\npublic static int mod3(int[] numbers)\n{\n    int count = 0;\n    for (int i = 0; i < numbers.length; i++)  {\n        \/* mystery code *\/\n    }\n    return count;\n}\n\nMethod mod3 is intended to return the number of integers in the array numbers that are evenly divisible by 3. Which of the following code segments could be used to replace \/ * mystery code * \/ so that mod3 will work as intended?\nI. if (i % 3 == 0)\n{\n    count++;\n}\nII. if (numbers[i] % 3 == 0)\n{\n    count++;\n}\nIII. while (numbers[i] % 3 == 0)\n{\n    count++;\n}\nCorrect: II only\nIncorrect: I only\nIncorrect: III only\nIncorrect: I and II\nIncorrect: II and III\n\nEND"}
{"prompt":"Probably the most useful algorithms you will learn in AP Computer Science A are sorting algorithms—but they are also probably the most difficult to understand. If you’ve been keeping up within this book so far, then you have a good start. \nAs the name implies, sorting algorithms will take data in an array and rearrange it into a particular order. We already know that this technique is useful if we want to search for data using the binary search algorithm. But imagine this automated process in real life: a process that automatically sorts the cups in your cabinet in height order, a process that automatically takes your homework assignments and arranges them in time order, and a process that sorts your to-do list in priority order. Needless to say: sorting algorithms are extremely powerful. \nThe selection sort is the first sorting algorithm we will discuss, and one of the three sorting algorithms you need to know for the AP Exam. This is a search-and-swap algorithm, so you should remember that the selection sort searches and swaps. Similar to a sequential search, the sort will first traverse the array for the lowest value. Once it finds the lowest value, it will swap its position in the array with the data at index 0. Now the first element is sorted. The process then repeats for index 1. The rest of the array will be searched for the lowest value and swapped with the data at index 1. Note that if the lowest value is already in position, it will stay there. \nConsider the array below. We would like to sort this array from least to greatest.\n8 6 10 2 4\n\nOur strategy will be to first find the smallest element in the array and put it in the first position. We will then find the smallest of the remaining elements and put that in the second position. We will continue to do this until the array is ordered. \nWe can start by looking at every element in the array (starting with the first element) and finding the smallest element. It’s easy for a person to quickly glance through the array and see which element is smallest, but the sorting algorithm that we will implement can compare only two elements at once. So here’s how we can find the smallest element: take the number in the first cell in the array and assign it to a variable called smallestSoFar. We’ll also assign the position of that value to a variable called position. In this case, smallestSoFar will equal 8 and position will be 0. Note that even though we are assigning 8 to smallestSoFar, the first cell of the array will contain 8; we didn’t actually remove it. \nsmallestSoFar = 8; \nposition = 0; \n\n8 6 10 2 4\n\nNext we’ll walk through the array and compare the next value to smallestSoFar. The next value is 6, which is less than 8, so smallestSoFar becomes 6 and position becomes 1. \nsmallestSoFar = 6; \nposition = 1; \n\n8 6 10 2 4\n\nNow let’s look at the next value in the array. 10 is larger than 6, so smallestSoFar remains 6.\nsmallestSoFar = 6; \nposition = 1; \n\n8 6 10 2 4\n\nThe next value in the array is 2: 2 is smaller than 6. \nsmallestSoFar = 2; \nposition = 3; \n\n8 6 10 2 4\n\nAnd finally, we look at the last element, 4. Because 4 is greater than 2, and we are at the end of the array, we know that 2 is the smallest element. \nsmallestSoFar = 2; \nposition = 3; \n\n8 6 10 2 4\n\nNow we know that 2 is the smallest element in the array. Because we want to order the array from least to greatest, we need to put 2 in the first cell in the array. We don’t simply want to overwrite the 8 that is in the first cell, though. What we’ll do is swap the 2 with the 8 to get \n\n2 6 10 8 4\n\nWe now have the smallest element in place. Next we’ll need to find the second smallest element in the array. We can do this using the same approach we employed to find the smallest element. Because we know that 2 is the smallest element, we have to look at the elements only in positions 1 to 4 for the second smallest element. \nStart by assigning 6 to smallestSoFar and 1 to position and then compare 6 to 10. Six is the smaller element. Next, compare 6 to 8; 6 is still the smaller element. Finally, compare 6 to 4; 4 is smaller, and because we have no more elements in the array, 4 must be the second smallest element in the array. \nSwap 4 with the second element in the array to get \n\n2 4 10 8 6\n\nMake another pass through the array to find the third smallest element, and swap it into the third cell. The third smallest element is 6. \n\n2 4 6 8 10\n\nFinally, we look at the last two elements. Eight is smaller than 10, so we don’t need to do anything. Our array is now sorted from least to greatest. \n\nHere is how a selection sort can be implemented in Java. The following implementation will sort the elements from least to greatest and will begin by sorting the smallest elements first. \n\/\/precondition: numbers is an array of ints \n\/\/postcondition: numbers is sorted in ascending order \n1 public static void selectionSort1(int[] numbers) 2 { \n3 for (int i = 0; i < numbers.length – 1; i++) 4 { \n5 int position = i; \n6 for (int k = i + 1; k < numbers.length; k++) 7 { \n8 if (numbers[k] < numbers[position]) \n9 { \n10 position = k; \n11 } \n12 } \n13 int temp = numbers[i];\n14 numbers[i] = numbers[position]; \n15 numbers[position] = temp; \n16 } \n17 } \nHow could this be useful? Consider a case in which you have an unsorted array of 1,000 Student objects, and each Student object has a method that returns a grade point average for that Student. What if you would like to find the five students with the highest grade point average? In this case, it would be a waste of time to sort the entire array. Instead, we can just run through five cycles of the second implementation of the selection sort shown above, and the top five students will be sorted. \n\n\n###\n\n","completion":" Question: Assume that an array arr of integer values has been declared and initialized with random numbers.\nWhich of the following code segments correctly swaps the values stored in arr[0] and arr[3]?\nCorrect: int k = arr[3];\narr[3] = arr[0];\narr[0] = k;\nIncorrect: arr[0] = 3;\narr[3] = 0;\nIncorrect: arr[0] = arr[3];\narr[3] = arr[0];\nIncorrect: int k = arr[3];\narr[0] = arr[3];\narr[3] = k;\nIncorrect: int k = arr[0];\narr[3] = arr[0];\narr[0] = k;\n\nEND"}
{"prompt":"Once data is stored in an array, a common task is to methodically search the array for given data. Consider a line of parked cars in the “Curbside To Go” section of your local chain restaurant. When the server is taking the food to a particular car, she must use a given attribute—say, a license plate number —to find the correct car. Once the correct car is found, the server can deliver the food and then go back inside for the next order, beginning the process all over again…and again…and again.\nThis same technique is used for searching an array. In APCS, we have two methods of searching arrays, the sequential search and the binary search. Since each of these search methods uses a distinct formula to search through the arrays, they are commonly referred to as search algorithms.\nThe chain restaurant example given above is an example of a sequential search. All of the cars are “lined up” and the server begins with the first car, checking its license plate number against the one she is looking for. If it’s correct, the server delivers the food and returns. If not, she moves on to the next car and repeats the process; this all ends when either (1) the correct car is found or (2) the correct car is not in the line at all. This sequential process works just fine, although it can be very tedious. The server would have to do much more work if the desired car were at the end of the line, as opposed to at the beginning. Remember, we are programming a computer; the server cannot simply “look” at all of the plates at once, as we might in real life. The computer does not know how to “look,” unless we know how to write the program that enables it!\nA code segment that performs a linear search for a number target in an array of integers nums might look like this:\nfor (int i = 0; i < nums.length; i++)\n\tif (nums[i] == target)\n\t\tSystem.out.print(“Found at \" + i);\n\nThis segment will correctly traverse the array, searching for target, starting with index 0 and continuing to index length - 1, as desired. Remember that nums.length is the size of the array and therefore nums[length] would be out of bounds. When target is found, the print statement displays its index number. This process will continue until the end of the array is reached. Note that, if target is never found, there will be no output.\nWhen writing algorithms that traverse arrays, programmers often implement the enhanced-for loop, which is designed specifically for traversing entire arrays. In cases which traversing the entire array is not the intent or would cause a run-time error, the enhanced-for loop should not be used. Assuming nums from the previous example would not cause such a problem, the same code segment can be written as an enhanced-for loop structure like this:\nint loc = 0;\nfor (int num : nums)\n{\n\tif (num == target)\n\t\tSystem.out.print(“found at ” + loc);\n\ti++;\n}\n\nEach time the loop iterates, num will be assigned the value of the next element in the array. This structure automatically ensures that the loop does not go out of bounds. In this case, loc is the location or index in which the target is found.\nIt is important to note that the enhanced-for loop provides a variable that will hold each element of the array. It will NOT automatically provide the index of that element. You will have to add code to keep track of the index if you want to use it.\nA binary search is much more efficient; think of it as a “divide-and conquer” mechanism. Instead of our restaurant server starting with the beginning of the line of cars, she will start with the middle car. Depending on whether the license plate is “greater” or “less” than the car she is looking for, the server will move in the appropriate direction.\nThere is a huge obstacle with binary searches, however, or at least, for us with our current level of Java knowledge: these searches work only when there is an inherent order in the data. Suppose the top 21 students in the senior class are lined up in a row. You are looking for a student within that top 21 named Kathy, whom you have never met, but you are not sure where she is in the line. If the students are not lined up in a particular order, a sequential search is your only option, and you might need all 21 tries to find her if she is the last person in the lineup. If they are sorted in alphabetical order by first name, though, you can divide and conquer. Go to the middle person and find out her name…if her name is Sara, you would move toward the front of the line and ignore the back. You then perform the same process, asking the name of the person halfway between the front of the line and Sara, and then ignore the appropriate side. Within a few tries, you will have Kathy.\nHere is a code example of how a binary search might look for array nums when searching for target, assuming nums is sorted:\nint front = 0, back = nums.length - 1, middle = 0; boolean isFound = false;\nwhile((front <= back) && (!isFound))\n{\n\tmiddle = (front + back) \/ 2;\n\tif (nums[middle] < target)\n\t{\n\t\tfront = middle + 1;\n\t}\n\telse if(nums[middle] > target)\n\t{\n\t\tback = middle - 1;\n\t}\n\telse\n\t{\n\t\tisFound = true;\n\t}\n}\nif (isFound)\n{\n System.out.println(\"Found at\" + middle);\n}\nelse\n{\n System.out.println(\"Target Not Found\");\n}\nOn the AP Exam, you will not be required to write a search algorithm; however, you will be required to recognize a search algorithm and trace it, which can be done the easy way if you understand the algorithm, or the hard way by actually tracing the code, step by step. Try to identify the key characteristics of each search; for example, the “sum divided by 2” line is a good indicator of a binary search. The enhanced-for loop will traverse the entire array, which may indicate a sequential search.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint [] scores = {75, 63, 52, 80};\nfor (int s : scores)\n{\n    if (s < 75)\n    {\n        s += 5;\n    }\n}\nfor (int s : scores)\n{\n    System.out.print(s + \" \");\n}\n\nWhat is printed as a result of executing the code segment?\nCorrect: 75 63 52 80\nIncorrect: 75 68 57 80\nIncorrect: 80 68 57 80\nIncorrect: 80 68 57 85\nIncorrect: Nothing will be printed due to a compile-time error.\n\nEND"}
{"prompt":"An array is a data structure that makes handling like (as in similar) data easier. An array may store primitive data values or object references. Each piece of data is called an element, and an index is used to specify the location of the element we wish to access. Imagine an airline that sells more than a thousand tickets a day. If we want to process that data to accumulate statistics on origin cities or prices of tickets, each ticket could be instantiated separately, using a unique object reference variable for each ticket. Imagine then invoking a method on each of those object reference variables. By putting the data into an array, and then using a loop to access each element of the array, the code becomes much more efficient.\nIn order to instantiate an array, you must first decide what type of data will be contained in the array. Suppose you are creating a program that will keep track of your test grades in your APCS class. Since grades are usually represented by integer numbers, you will create an array of integers. The syntax for instantiating an array of integers is\nint [] <identifier> = new int [<array size>];\n\nThis format is used if you do not yet know the values that will be stored in the array. Alternatively, if you already know the data values, you can instantiate the array using an initializer list:\nint [] <identifier> = {<data1>, <data2>, ..., <data n>};\n\nNotice the square brackets—these are standard symbols in Java that signify an array is present. The braces (curly brackets) indicate an initializer list. In the beginning of the semester, you do not yet know your grades. In order to create an array called testGrades that will eventually store your first 5 test grades, you could write a statement like this:\nint [] testGrades = new int[5];\n\nThis array object will store your test grades and keep them organized using index numbers (or locations). Just as your tests might be organized as Chapter 1 Test, Chapter 2 Test, etc., your data will be accessed through the identifier of the array and index number. The tricky part is that array indices start with the number 0 instead of 1. Therefore, if your Chapter 1 Test is the first test score in the array, it will be stored at index 0. If the first test you have in APCS reviews a previous course, then it’s Chapter 0 instead of Chapter 1. If you did not instantiate the array using an initializer list, then you will assign data values using the index numbers; you will do the same process to access the data regardless of how you created the array. For example, if you scored a 95 on the first test, you could write the line:\ntestGrades[0] = 95;\n\nCreating an array with five scores at once might look like this, int [ ] testScores = {90, 80, 100, 85, 92};\nLet’s say that, after looking over your test, you realize that your teacher made a grading error and you actually scored a 98. You can either increment the data value or reassign it:\ntestGrades[0] += 3;\nor\ntestGrades[0] = 98;\n\nYou can also perform any integer operation, and also display the value to the user, with that same format.\nLet’s step it up a notch. Suppose, after all 5 tests are complete, your teacher feels that the scores are too high and decides to deflate the grades. (You didn’t think this book would discuss only nice teachers, did you?) The programmer can use a simple loop in order to traverse the array and change every value accordingly, rather than writing 5 separate lines. Since an array’s length is well-defined, a for loop is usually appropriate for arrays. Provided that the array is full, meaning all 5 values are assigned, the following loop will traverse the array and subtract 2 points from every grade:\nfor (int index = 0; index < 5; index++)\n\ttestGrades[index] -= 2;\n\nNote the values of index will be 0, 1, 2, 3, and 4, even though it stores 5 elements. Since the index numbers start at 0, you must stop traversing the array before index 5, or your will receive an ArrayIndexOutOfBoundsException and the program execution will be interrupted. Free Response Questions on the AP Exam often test your ability to write code that does not go out of bounds.\nAn array also has a constant value returned by < arrayName >, length that will return the number of elements in the array. The above loop could be written:\nfor (int index = 0; index < testgrades.length; index++)\n\ttestGrades(index) -= 2;\n\nMuch better than writing multiple lines, right? The loop systematically changes every value in the array. We are just scratching the surface of the usefulness of arrays, and we have already improved our coding efficiency.\nThe AP Exam will require you to create, traverse, and modify arrays; freeresponse questions are loaded with arrays and will specifically state that an array must be created. The Course and Exam Description states, specifically, that free response questions 3 and 4 have to do with arrays (3 is Array\/ArrayList and 4 is 2D Array).\nThe programmer needs to ensure that every element of the array contains a meaningful value, or undesired results may occur. In an array of integers, the value of an unassigned element will default to 0. Consider the following code segment that will calculate the average of your 5 test grades:\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int index = 0; index < len; index++)\n\ttotal += testGrades[index];\naverage = (double) total \/ len;\n\nIf all 5 of your test grades are stored in the array, this code segment will calculate the average correctly. If you did not input one of your scores, however, it will remain stored as 0 and incorrectly drag down your average, which is (definitely) an undesired result.\nThere is an alternative way to execute the previous code segment. This involves using an enhanced-for loop. An enhanced-for loop can be used to automatically go through each element of an array.\nint total = 0, len = testGrades.length;\ndouble average;\nfor (int grade : testGrades)\n\ttotal += grade;\naverage = (double)total \/ len;\n\nIn the enhanced-for statement, a previously declared array or an ArrayList (more on ArrayLists later) must be referenced after the colon. The loop will iterate for each element in the list, from index 0 to index length - 1. However, no variable is used to refer to the current index. Instead, the element located at the current index is stored as the variable declared before the colon. (The variable must be of the same type stored in the array.) Therefore, the enhanced-for loop above stores each element, one at a time in increasing order by index, of the array testGrades as grade. It then adds grade to total. Thus, the enhanced-for loop has the same functionality as the for loop in the previous example. The benefits of the enhanced-for loop are that it will not cause an ArrayIndexOutOfBoundsException when traversing an array and that it shortens the notation of the element considerably.\n\n\n###\n\n","completion":" Question: Consider the following code segment:\nString [] names = {\"Abi\", \"Brianna\", \"Jada\", \"Kiara\", \"Tiffany\", \"Vanessa\"};\nint middle = names.length\/2 - 1;\nfor (int x = 0; x < middle; x++)\n{\n    String hold = names[x];\n    names[x] = names [names.length - x - 1];\n    names[names.length - x - 1] = hold;\n}\nfor (String n: names)\n{\n    System.out.print(n + \" \");\n}\nWhat is printed as a result of executing the code segment?\nCorrect: Vanessa Tiffany Jada Kiara Brianna Abi\nIncorrect: Abi Brianna Jada Kiara Tiffany Vanessa\nIncorrect: Abi Jada Brianna Vanessa Kiara Tiffany\nIncorrect: Vanessa Tiffany Kiara Jada Brianna Abi\nIncorrect: Vanessa Brianna Jada Kiara Tiffany Abi\nEND"}
{"prompt":"Computer Science (CS) is an official name used for many aspects of computing, usually on the developing end; its areas include computer programming, which is exactly what we will be doing in AP Computer Science A (APCS). APCS focuses on the language Java and its components, and in many cases, you will be the programmer. Although the person using your program (the user) will typically see only the end result of your program, CS gives you the tools to write statements (code) that will ideally make the user’s experience both functional and enjoyable. \nComputer programming is similar to a foreign language; it has nouns, verbs, and other parts of speech, and it has different forms of style, just like speaking languages. Just as you might use different words and ways of speaking—tone, expressions, etc.—with your family versus your friends, CS has many different languages and, within each language, its own ways of getting the job done. In both the CS world and the APCS world, a particular programming style is expected in order to show fluency in the language. A company that might hire you for a CS job will likely expect you to conform to its own unique programming style; similarly, the College Board will expect you to conform to its accepted programming style based on its research of CS styles accepted at universities around the world. \nCommenting is an extremely vital style technique in the programming world. Comments do not actually cause the program to behave any differently, however, comments serve many purposes, including: allowing programmers to make “notes” within the program that they may want to reference later allowing the person reading and\/or using the program (“the reader” and\/or “the user”) to understand the code in a less cryptic way, when applicablerevealing to the programmer\/reader\/user aspects of the program that are required to make the program operate as intended and\/or are produced as a result of the program’s execution \nThere are two types of commenting in Java. In-line, or short, comments appear after or near a statement and are preceded by two forward slashes (“\/\/”) followed by the comment. Long comments that extend beyond a single line of code are surrounded by special characters; they begin with (“\/*”) and end with (“*\/”). \n\nFor example, \n\/\/ This is a short comment \n\/* This is a \nlong comment *\/ \n\nIdentifiers are names that are given to represent data stored in the memory of the computer during the program’s execution. Rather than using a nonsensical memory address code to reference data, Java allows the programmer to name an identifier to perform this job. When we name identifiers in Java, there are guidelines that we must use and guidelines that the College Board expects us to use: \nAn identifier may contain any combination of letters, numbers, and underscore (“_”), but must begin with a letter and may not contain any other characters than these, including spaces. An identifier should be a logical name that corresponds to the data it is associated with; for example, an identifier associated with the side of a triangle would be more useful as side1 instead of s. An identifier should begin with a lowercase letter and, if it is composed of several words, should denote each subsequent word with a capital letter. If we decided to create an identifier associated with our triangle’s number of sides, numberOfSides or numOfSides would conform to this style; NumberOfSides and numofsides would not.\n\nWhite space is another element of style that does not affect the overall functionality of the program. Rather, it enhances the readability of the program by allowing the programmer to space out the code to separate specific statements or tasks from others. Much like a book may leave empty space at the end of a chapter and begin the next chapter on the next page without affecting the overall story, white space has a similar effect. \nWhen the programmer writes Java code, statements are written that are understood within a Java development environment. The computer, however, does not understand this language, much like you would likely not understand a foreign language that you have never studied, spoken in its native environment. Therefore, an interpreter is used within the developer environment, enabling the computer to understand the Java code. A computer operates using code written only in binary (zeroes and ones, literally!), and so the interpreter “translates” your Java code into binary. This process is called compiling. As a result, in most instances as well as on the AP Exam, modern computer programmers do not need to understand binary code directly. \nWhen an interactive development environment (“IDE”) is used to compile your code, the code will be automatically checked for basic programming errors. If an error is found within the code, the compiling is halted and an error message is produced (this feedback is where the “interactive” part comes in); this situation is called a compile-time error. Although the error message\/code is not always helpful in a direct way, it does allow the programmer to troubleshoot the issue in a more directed way. Unfortunately, since the AP Exam is a pencil-and-paper test, you will have access to neither a computer nor a compiler. Your code must be absent of errors in order to receive full credit for the response (or any credit if it’s a multiple-choice question).\nA logical error is more difficult to troubleshoot, as opposed to a problem with the syntax of the Java code itself. A logical error lies in the desired output\/purpose of the program. Similar to ordering dinner and receiving a perfectly prepared dessert instead, you are getting a good result, but it is not appropriate for the desired task. \nA run-time error is an error that is not caught by the compiler, yet produces an error during the execution of the program. In many ways, this is the worst (and most embarrassing) error for the programmer, because it is not realized until the task is supposedly “done.” An example might be a crash that occurs when you are editing your favorite image in a graphics program. It’s frustrating for the user and annoying for the programmer when you leave negative feedback on the company’s website! \n\n\n###\n\n","completion":" Question: Assuming all other statements in the program are correct, each of the following statements will allow the program to compile EXCEPT\nCorrect: All of the above statements will compile.\n\n\nIncorrect: \/\/ This is a comment\nIncorrect: \/* This is a comment *\/\nIncorrect: \/\/ myName is a good identifier name\nIncorrect: \/\/ myname is a good identifier nameEND"}
{"prompt":"Computer Science (CS) is an official name used for many aspects of computing, usually on the developing end; its areas include computer programming, which is exactly what we will be doing in AP Computer Science A (APCS). APCS focuses on the language Java and its components, and in many cases, you will be the programmer. Although the person using your program (the user) will typically see only the end result of your program, CS gives you the tools to write statements (code) that will ideally make the user’s experience both functional and enjoyable. \nComputer programming is similar to a foreign language; it has nouns, verbs, and other parts of speech, and it has different forms of style, just like speaking languages. Just as you might use different words and ways of speaking—tone, expressions, etc.—with your family versus your friends, CS has many different languages and, within each language, its own ways of getting the job done. In both the CS world and the APCS world, a particular programming style is expected in order to show fluency in the language. A company that might hire you for a CS job will likely expect you to conform to its own unique programming style; similarly, the College Board will expect you to conform to its accepted programming style based on its research of CS styles accepted at universities around the world. \nCommenting is an extremely vital style technique in the programming world. Comments do not actually cause the program to behave any differently, however, comments serve many purposes, including: allowing programmers to make “notes” within the program that they may want to reference later allowing the person reading and\/or using the program (“the reader” and\/or “the user”) to understand the code in a less cryptic way, when applicablerevealing to the programmer\/reader\/user aspects of the program that are required to make the program operate as intended and\/or are produced as a result of the program’s execution \nThere are two types of commenting in Java. In-line, or short, comments appear after or near a statement and are preceded by two forward slashes (“\/\/”) followed by the comment. Long comments that extend beyond a single line of code are surrounded by special characters; they begin with (“\/*”) and end with (“*\/”). \n\nFor example, \n\/\/ This is a short comment \n\/* This is a \nlong comment *\/ \n\nIdentifiers are names that are given to represent data stored in the memory of the computer during the program’s execution. Rather than using a nonsensical memory address code to reference data, Java allows the programmer to name an identifier to perform this job. When we name identifiers in Java, there are guidelines that we must use and guidelines that the College Board expects us to use: \nAn identifier may contain any combination of letters, numbers, and underscore (“_”), but must begin with a letter and may not contain any other characters than these, including spaces. An identifier should be a logical name that corresponds to the data it is associated with; for example, an identifier associated with the side of a triangle would be more useful as side1 instead of s. An identifier should begin with a lowercase letter and, if it is composed of several words, should denote each subsequent word with a capital letter. If we decided to create an identifier associated with our triangle’s number of sides, numberOfSides or numOfSides would conform to this style; NumberOfSides and numofsides would not.\n\nWhite space is another element of style that does not affect the overall functionality of the program. Rather, it enhances the readability of the program by allowing the programmer to space out the code to separate specific statements or tasks from others. Much like a book may leave empty space at the end of a chapter and begin the next chapter on the next page without affecting the overall story, white space has a similar effect. \nWhen the programmer writes Java code, statements are written that are understood within a Java development environment. The computer, however, does not understand this language, much like you would likely not understand a foreign language that you have never studied, spoken in its native environment. Therefore, an interpreter is used within the developer environment, enabling the computer to understand the Java code. A computer operates using code written only in binary (zeroes and ones, literally!), and so the interpreter “translates” your Java code into binary. This process is called compiling. As a result, in most instances as well as on the AP Exam, modern computer programmers do not need to understand binary code directly. \nWhen an interactive development environment (“IDE”) is used to compile your code, the code will be automatically checked for basic programming errors. If an error is found within the code, the compiling is halted and an error message is produced (this feedback is where the “interactive” part comes in); this situation is called a compile-time error. Although the error message\/code is not always helpful in a direct way, it does allow the programmer to troubleshoot the issue in a more directed way. Unfortunately, since the AP Exam is a pencil-and-paper test, you will have access to neither a computer nor a compiler. Your code must be absent of errors in order to receive full credit for the response (or any credit if it’s a multiple-choice question).\nA logical error is more difficult to troubleshoot, as opposed to a problem with the syntax of the Java code itself. A logical error lies in the desired output\/purpose of the program. Similar to ordering dinner and receiving a perfectly prepared dessert instead, you are getting a good result, but it is not appropriate for the desired task. \nA run-time error is an error that is not caught by the compiler, yet produces an error during the execution of the program. In many ways, this is the worst (and most embarrassing) error for the programmer, because it is not realized until the task is supposedly “done.” An example might be a crash that occurs when you are editing your favorite image in a graphics program. It’s frustrating for the user and annoying for the programmer when you leave negative feedback on the company’s website! \n\n\n###\n\n","completion":" Question: Assuming all other statements in the program are correct, each of the following statements will allow the program to compile EXCEPT\nCorrect: System.out.print(side1);\nIncorrect: System.out.print(1);\nIncorrect: System.out.print(\"1\");\nIncorrect: System.out.print(\"side1\");\nIncorrect: All of the above statements will compile.\n\nEND"}
{"prompt":"In order for your program to “do anything” from the user’s perspective (at this level, anyway!), it must produce output to the screen. A program may produce output to many devices, including storage drives and printers, but APCS requires us to produce output only to the screen. \n\nThere are two similar statements that we use to produce output to the screen in this course: \nSystem.out.print(…); \nSystem.out.println(…); \n\nThe ellipses in these statements stand for the data and\/or identifiers that will be displayed on the screen. We will see the difference between these statements in a minute. \nFor example, if a triangle has a side length of 2 stored in the memory using the identifier side1 and we wanted to output that information to the screen, we could use one of the following two commands: \nSystem.out.print(2); \nSystem.out.print(side1); \n\nSince both 2 and side1 represent numerical values, they can be outputted to the screen in this way. If we wanted to display non-numerical data, however, we would use a string literal (or simply a string) to accomplish this task. A string literal is simply one or more characters combined into a single unit. The previous sentence, and this sentence, can be considered string literals. In a Java program, string literals must be surrounded by double quotes (“”) to avoid a compile error. In our triangle example, we can use a string literal to make the output more user-friendly: \nSystem.out.println(\"The length of side 1 is:\"); \nSystem.out.print(side1); \n\/\/ side1 may be simply substituted with 2, in this case \n\nNote the usage of the println statement rather than the print statement. While print will display the next output on the same line, println will output the string literal and then put the cursor at the beginning of the next line for further output. Note, also, that the statement \nSystem.out.print(side1); \n\nwill display the value stored using the side1 identifier, 2. In contrast, the statement \nSystem.out.print(\"side1\"); \n\nwill literally display \nside1 \nbecause the double quotes create a string literal here. The College Board loves to ask multiple-choice questions that determine whether you understand these differences. \n\nIf quotation marks are how programmers signal the beginning and end of a string literal, how would they display quotation marks? For example, what if an instructional program was intended to display \nBe sure to display the value of side1, not \"side 1\".\n\nThe command below might seem like an appropriate solution but would actually cause a compile-time error. \nSystem.out.print(\"Be sure to display the value of side1, not \"side 1\".\"); \n\nThe complier will interpret the quotation mark in front of side1 as the close of the string and will not know what to do with the rest of it. To display a quotation mark, the programmer must use an escape sequence, a small piece of coding beginning with a backslash (\\) used to indicate specific characters. To successfully display the above live, use the command \nSystem.out.print(“Be sure to print the value of side1, not \\\"side1\\\".\"); \n\nSimilarly, the escape sequence \\n can be used to create a line break in the middle of a string. For example the command \nSystem.out.print(\"The first line\\nThe second line\");\n\nwill display \nThe first line \nThe second line \n\nSo if a backslash indicates an escape sequence, how does a programmer print a backslash? This is done using another escape sequence, \\\\. The following command \nSystem.out.println(\"Use \\\\n to indicate a new line.\"); will display \n\nUse \\n to indicate a new line.\nThere are other escape sequences in Java, but only these three appear on the AP Computer Science A Exam. \n\nAs you might imagine, input is also important in programming. Although you may learn some techniques for getting user input (the Scanner class, for example), the AP Exam will not test any input methods or classes. Instead, the input will be assumed and given as a comment in the coding. It may be similar to this. \nint k = ..., \/\/read user input \nYou will not be asked to prompt the user for input, unless there is pre-existing code in the task that does it for you. Nice.\nLet’s put those identifiers to work. \nIn order to actually “create” an identifier, we need to assign a data value to that identifier. This task is done by writing an assignment statement. \nThe syntax of an assignment statement is \ntype identifier = data; \n\nContinuing with our triangle example, if we wanted to actually assign the data value of 2 to a new identifier called side1, we could use this statement: \nint side1 = 2; \n\nThis statement tells the compiler that (1) our identifier is called side1, (2) the data assigned to that identifier should be 2, and (3) our data is an integer (more on this in the next section). The equals sign (“=”) is called an assignment operator and is required by Java. The semicolon, which we also saw in the output statements above, denotes that the statement is finished. Note that an assignment statement does NOT produce any output to the screen. \nWhen data is associated with an identifier, the identifier is called a variable. The reason we use this term is that, as in math, the value of the variable can be changed; it can vary! Look at the following code: \n\nint myFavoriteNumber = 22; \nmyFavoriteNumber = 78; \nSystem.out.print(\"My favorite number is \" + myFavoriteNumber); \n\nCan you predict the output? The variable myFavoriteNumber is first assigned the value of 22, but it is then reassigned to the value 78. Therefore, the original value is no longer stored in the computer’s memory and the 78 remains. The output would be\nMy favorite number is 78 \n\nA few items to note in this example: \nOnce a variable is given a type (again, more on this later), its type should not be restated. This fact explains why the second assignment statement is missing int. \nThe string literal is outputted as written, but the variable’s value, not its name, is outputted. \nIn order to output a string literal and a numerical value using the same output statement, use the concatenation operator between the two items. Although this operator looks like a typical + sign, it does not “add” the values in the traditional sense; instead, it simply outputs the two values next to each other. For example, two plus two equals four in the mathematical sense, but 2 concatenated with 2 produces 22. \n\n\n###\n\n","completion":" Question: Assuming all other statements in the program are correct, each of the following statements will allow the program to compile EXCEPT\nCorrect: System.out.print(1 + \"love\" + Java\");\nIncorrect: System.out.print(\"Ilove Java\");\nIncorrect: System.out.println(\"Ilove\" + \"Java\");\nIncorrect: System.out.println(1 + \"love\" + \"Java\");\nIncorrect: System.out.print(\"I love\" + \" \" + \"Java\");\n\nEND"}
{"prompt":"The most primitive uses for the first computers were to perform complex calculations. They were basically gigantic calculators. As a result, one of the most basic operations we use in Java involves arithmetic. \nThe symbols +, -, *, and \/ represent the operations addition, subtraction, multiplication, and division, respectively. The operator % is also used in Java: called the “modulus” operator, this symbol will produce the numerical remainder of a division. For example, 3 % 2 would evaluate to 1, since 3 divided by 2 yields 1, with 1 as a remainder. These operations can be performed intuitively on numerical values; they can also be performed on variables that store numerical values.\nSpeaking of math, back to our triangle example… \nConsider the following statement in a program: \nint side2 = 2, side3 = 3; \n\n(Note that you can write multiple assignment statements in a single line, as long as the data types are the same.) \nIf we wanted to write a statement that found the sum of these data and assigned the result to another variable called sumOfSides, we could easily write \nsumOfSides = 2 + 3; \/\/ method 1 \n\nBut this statement is less useful than \nsumOfSides = side2 + side3; \/\/ method 2 \n\nSince the data is assigned to variables, for which values can vary, method 2 will reflect those changes while method 1 will not. \nThis same technique can be applied to all of the mathematical operators. Remember that a mixture of mathematical operations follows a specific order of precedence. Java will perform the multiplication and division operations (including modulus), from left to right, followed by the addition and subtraction operations in the same order. If programmers want to change the order of precedence of the operators, they can use parentheses. \nConsider these lines of code: \nSystem.out.print(3 - 4\/5); \/\/ statement 3 \nSystem.out.print(3 -(4\/5)); \/\/ statement 4 \nSystem.out.print((3 - 4)\/5); \/\/ statement 5\n\nIn statement 3, the division occurs first, followed by the subtraction (3 minus the answer). \nIn statement 4, the same thing happens, so it is mathematically equivalent to statement 3. \nIn statement 5, the parentheses override the order of operations, so the subtraction occurs, and then the answer is divided by 5. \nOkay, here’s where it gets crazy. Can you predict the output of these statements? Believe it or not, the output of statements 3 and 4 is 3; the output of statement 5 is 0. These results demonstrate the fact that data in Java is strongly typed. \nWhen you perform a mathematical operation on two integers, Java will return the answer as an integer, as well. Therefore, although 4\/5 is actually 0.8, Java will return a value of 0. Likewise, Java will evaluate 5\/4 to be 1. The decimal part is cut off (not rounded), so that the result will also be an integer. Negative numbers work the same way. Java will return –4\/5 as 0 and –5\/4 as –1. Strange, huh? \n\nAs is true with all computer science, there is a workaround for this called casting. Casting is a process through which data is forced to “look like” another type of data to the compiler. Think of someone who is cast in a show to play a part; although actors have personal identities, they assume new identities for the audience. The following modifications to statement 3 demonstrate different ways of casting: \nSystem.out.print(3 - (double)(4)\/5); \/\/ statement 3.1\nSystem.out.print(3 - 4\/(double)5); \/\/ statement 3.2 \n\nThese statements will cast 4 and 5, respectively, to be double values of 4.0 and 5.0. As a result, the division will be “upgraded” to a division between double values, not integers, and the desired result will be returned. The following statements, although they will compile without error, will not display the desired result of 2.2. \nSystem.out.print((double)3 - 4\/5); \/\/ statement 3.3 \nSystem.out.print(3 - (double)(4\/5)); \/\/ statement 3.4 \n\nCasting has a higher precedence than arithmetic operators, except parentheses, of course. Therefore, statement 3.3 will first convert 3 to 3.0, but will then perform integer division before completing the subtracting. The result is 3.0. In statement 3.4, the result of dividing the integers is cast to a double; since the integer division evaluates to 0, the cast will simply make the result 0.0, yielding an output of 3.0 once again. Very tricky! \nThe increment operator (++) is used to increase the value of a number by one. For example, if the value of a variable x is 3, then x++ will increment the value of x to 4. This has the exact same effect as writing x = x + 1, and is nothing more than convenient shorthand. \nConversely, the decrement operator (--) is used to quickly decrease the value of a number by one. For example, if the value of a variable named x is 3, then x-- decreases the value of x to 2. This has the exact same effect as writing x = x – 1. \nOther shortcut operators include +=, -=, *=, \/=, and %=. These shortcuts perform the indicated operation and assign the result to the original variable. For example, \na += b; \n\nis an equivalent command to \na = a + b;\nHumans are pretty smart when it comes to guessing intent For instance, you probably noticed that there’s a missing period between this sentence and the one before it. (If not, slow down: AP Computer Science A Exam questions require close reading when looking for errors.) Computers, on the other hand, are literal—more annoyingly so, probably, than those teachers who ask whether you’re physically capable of going to the bathroom when you ask whether you can go. To that end, then, it’s crucial that you end each complete statement (i.e., sentence) with a semicolon, which is our way of telling the Java compiler that it’s reached the end of a step. This doesn’t mean that you need to place a semicolon after every line— remember that line breaks exist only to make code more readable to humans —but you must place one after any complete declaration or statement. \n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint a = 3;\nint b = 6;\nint c = 8;\nint d = a \/ b;\nc \/= d;\nSystem.out.print(c);\n\nWhich of the following will be output by the code segment?\nCorrect: There will be no output because of a run-time error.\n\n\nIncorrect: 4\nIncorrect: 8\nIncorrect: 12\nIncorrect: 16END"}
{"prompt":"The most primitive uses for the first computers were to perform complex calculations. They were basically gigantic calculators. As a result, one of the most basic operations we use in Java involves arithmetic. \nThe symbols +, -, *, and \/ represent the operations addition, subtraction, multiplication, and division, respectively. The operator % is also used in Java: called the “modulus” operator, this symbol will produce the numerical remainder of a division. For example, 3 % 2 would evaluate to 1, since 3 divided by 2 yields 1, with 1 as a remainder. These operations can be performed intuitively on numerical values; they can also be performed on variables that store numerical values.\nSpeaking of math, back to our triangle example… \nConsider the following statement in a program: \nint side2 = 2, side3 = 3; \n\n(Note that you can write multiple assignment statements in a single line, as long as the data types are the same.) \nIf we wanted to write a statement that found the sum of these data and assigned the result to another variable called sumOfSides, we could easily write \nsumOfSides = 2 + 3; \/\/ method 1 \n\nBut this statement is less useful than \nsumOfSides = side2 + side3; \/\/ method 2 \n\nSince the data is assigned to variables, for which values can vary, method 2 will reflect those changes while method 1 will not. \nThis same technique can be applied to all of the mathematical operators. Remember that a mixture of mathematical operations follows a specific order of precedence. Java will perform the multiplication and division operations (including modulus), from left to right, followed by the addition and subtraction operations in the same order. If programmers want to change the order of precedence of the operators, they can use parentheses. \nConsider these lines of code: \nSystem.out.print(3 - 4\/5); \/\/ statement 3 \nSystem.out.print(3 -(4\/5)); \/\/ statement 4 \nSystem.out.print((3 - 4)\/5); \/\/ statement 5\n\nIn statement 3, the division occurs first, followed by the subtraction (3 minus the answer). \nIn statement 4, the same thing happens, so it is mathematically equivalent to statement 3. \nIn statement 5, the parentheses override the order of operations, so the subtraction occurs, and then the answer is divided by 5. \nOkay, here’s where it gets crazy. Can you predict the output of these statements? Believe it or not, the output of statements 3 and 4 is 3; the output of statement 5 is 0. These results demonstrate the fact that data in Java is strongly typed. \nWhen you perform a mathematical operation on two integers, Java will return the answer as an integer, as well. Therefore, although 4\/5 is actually 0.8, Java will return a value of 0. Likewise, Java will evaluate 5\/4 to be 1. The decimal part is cut off (not rounded), so that the result will also be an integer. Negative numbers work the same way. Java will return –4\/5 as 0 and –5\/4 as –1. Strange, huh? \n\nAs is true with all computer science, there is a workaround for this called casting. Casting is a process through which data is forced to “look like” another type of data to the compiler. Think of someone who is cast in a show to play a part; although actors have personal identities, they assume new identities for the audience. The following modifications to statement 3 demonstrate different ways of casting: \nSystem.out.print(3 - (double)(4)\/5); \/\/ statement 3.1\nSystem.out.print(3 - 4\/(double)5); \/\/ statement 3.2 \n\nThese statements will cast 4 and 5, respectively, to be double values of 4.0 and 5.0. As a result, the division will be “upgraded” to a division between double values, not integers, and the desired result will be returned. The following statements, although they will compile without error, will not display the desired result of 2.2. \nSystem.out.print((double)3 - 4\/5); \/\/ statement 3.3 \nSystem.out.print(3 - (double)(4\/5)); \/\/ statement 3.4 \n\nCasting has a higher precedence than arithmetic operators, except parentheses, of course. Therefore, statement 3.3 will first convert 3 to 3.0, but will then perform integer division before completing the subtracting. The result is 3.0. In statement 3.4, the result of dividing the integers is cast to a double; since the integer division evaluates to 0, the cast will simply make the result 0.0, yielding an output of 3.0 once again. Very tricky! \nThe increment operator (++) is used to increase the value of a number by one. For example, if the value of a variable x is 3, then x++ will increment the value of x to 4. This has the exact same effect as writing x = x + 1, and is nothing more than convenient shorthand. \nConversely, the decrement operator (--) is used to quickly decrease the value of a number by one. For example, if the value of a variable named x is 3, then x-- decreases the value of x to 2. This has the exact same effect as writing x = x – 1. \nOther shortcut operators include +=, -=, *=, \/=, and %=. These shortcuts perform the indicated operation and assign the result to the original variable. For example, \na += b; \n\nis an equivalent command to \na = a + b;\nHumans are pretty smart when it comes to guessing intent For instance, you probably noticed that there’s a missing period between this sentence and the one before it. (If not, slow down: AP Computer Science A Exam questions require close reading when looking for errors.) Computers, on the other hand, are literal—more annoyingly so, probably, than those teachers who ask whether you’re physically capable of going to the bathroom when you ask whether you can go. To that end, then, it’s crucial that you end each complete statement (i.e., sentence) with a semicolon, which is our way of telling the Java compiler that it’s reached the end of a step. This doesn’t mean that you need to place a semicolon after every line— remember that line breaks exist only to make code more readable to humans —but you must place one after any complete declaration or statement. \n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint a = 10;\ndouble b = 10.7;\ndouble c = a + b;\nint d = a + c;\nSystem.out.println(c + \" \" + d);\n\nWhat will be output as a result of executing the code segment?\nCorrect: Nothing will be printed because of a compile-time error.\n\n\nIncorrect: 20 20\nIncorrect: 20.0 30\nIncorrect: 20.7 31\nIncorrect: 20.730.7END"}
{"prompt":"The most primitive uses for the first computers were to perform complex calculations. They were basically gigantic calculators. As a result, one of the most basic operations we use in Java involves arithmetic. \nThe symbols +, -, *, and \/ represent the operations addition, subtraction, multiplication, and division, respectively. The operator % is also used in Java: called the “modulus” operator, this symbol will produce the numerical remainder of a division. For example, 3 % 2 would evaluate to 1, since 3 divided by 2 yields 1, with 1 as a remainder. These operations can be performed intuitively on numerical values; they can also be performed on variables that store numerical values.\nSpeaking of math, back to our triangle example… \nConsider the following statement in a program: \nint side2 = 2, side3 = 3; \n\n(Note that you can write multiple assignment statements in a single line, as long as the data types are the same.) \nIf we wanted to write a statement that found the sum of these data and assigned the result to another variable called sumOfSides, we could easily write \nsumOfSides = 2 + 3; \/\/ method 1 \n\nBut this statement is less useful than \nsumOfSides = side2 + side3; \/\/ method 2 \n\nSince the data is assigned to variables, for which values can vary, method 2 will reflect those changes while method 1 will not. \nThis same technique can be applied to all of the mathematical operators. Remember that a mixture of mathematical operations follows a specific order of precedence. Java will perform the multiplication and division operations (including modulus), from left to right, followed by the addition and subtraction operations in the same order. If programmers want to change the order of precedence of the operators, they can use parentheses. \nConsider these lines of code: \nSystem.out.print(3 - 4\/5); \/\/ statement 3 \nSystem.out.print(3 -(4\/5)); \/\/ statement 4 \nSystem.out.print((3 - 4)\/5); \/\/ statement 5\n\nIn statement 3, the division occurs first, followed by the subtraction (3 minus the answer). \nIn statement 4, the same thing happens, so it is mathematically equivalent to statement 3. \nIn statement 5, the parentheses override the order of operations, so the subtraction occurs, and then the answer is divided by 5. \nOkay, here’s where it gets crazy. Can you predict the output of these statements? Believe it or not, the output of statements 3 and 4 is 3; the output of statement 5 is 0. These results demonstrate the fact that data in Java is strongly typed. \nWhen you perform a mathematical operation on two integers, Java will return the answer as an integer, as well. Therefore, although 4\/5 is actually 0.8, Java will return a value of 0. Likewise, Java will evaluate 5\/4 to be 1. The decimal part is cut off (not rounded), so that the result will also be an integer. Negative numbers work the same way. Java will return –4\/5 as 0 and –5\/4 as –1. Strange, huh? \n\nAs is true with all computer science, there is a workaround for this called casting. Casting is a process through which data is forced to “look like” another type of data to the compiler. Think of someone who is cast in a show to play a part; although actors have personal identities, they assume new identities for the audience. The following modifications to statement 3 demonstrate different ways of casting: \nSystem.out.print(3 - (double)(4)\/5); \/\/ statement 3.1\nSystem.out.print(3 - 4\/(double)5); \/\/ statement 3.2 \n\nThese statements will cast 4 and 5, respectively, to be double values of 4.0 and 5.0. As a result, the division will be “upgraded” to a division between double values, not integers, and the desired result will be returned. The following statements, although they will compile without error, will not display the desired result of 2.2. \nSystem.out.print((double)3 - 4\/5); \/\/ statement 3.3 \nSystem.out.print(3 - (double)(4\/5)); \/\/ statement 3.4 \n\nCasting has a higher precedence than arithmetic operators, except parentheses, of course. Therefore, statement 3.3 will first convert 3 to 3.0, but will then perform integer division before completing the subtracting. The result is 3.0. In statement 3.4, the result of dividing the integers is cast to a double; since the integer division evaluates to 0, the cast will simply make the result 0.0, yielding an output of 3.0 once again. Very tricky! \nThe increment operator (++) is used to increase the value of a number by one. For example, if the value of a variable x is 3, then x++ will increment the value of x to 4. This has the exact same effect as writing x = x + 1, and is nothing more than convenient shorthand. \nConversely, the decrement operator (--) is used to quickly decrease the value of a number by one. For example, if the value of a variable named x is 3, then x-- decreases the value of x to 2. This has the exact same effect as writing x = x – 1. \nOther shortcut operators include +=, -=, *=, \/=, and %=. These shortcuts perform the indicated operation and assign the result to the original variable. For example, \na += b; \n\nis an equivalent command to \na = a + b;\nHumans are pretty smart when it comes to guessing intent For instance, you probably noticed that there’s a missing period between this sentence and the one before it. (If not, slow down: AP Computer Science A Exam questions require close reading when looking for errors.) Computers, on the other hand, are literal—more annoyingly so, probably, than those teachers who ask whether you’re physically capable of going to the bathroom when you ask whether you can go. To that end, then, it’s crucial that you end each complete statement (i.e., sentence) with a semicolon, which is our way of telling the Java compiler that it’s reached the end of a step. This doesn’t mean that you need to place a semicolon after every line— remember that line breaks exist only to make code more readable to humans —but you must place one after any complete declaration or statement. \n\n\n###\n\n","completion":" Question: Consider the following code segment:\nint a = 10;\ndouble b = 10.7;\nint d = a + b;\n\nLine 3 will not compile in the code segment above. With which of the following statements could we replace this line so that it compiles?\nI. int d = (int) a + b;\nII. int d = (int) (a + b);\nIII. int d = a + (int) b;\nCorrect: II and III only\n\n\nIncorrect: I only\nIncorrect: II only\nIncorrect: III only\nIncorrect: I and III onlyEND"}
{"prompt":"The most primitive uses for the first computers were to perform complex calculations. They were basically gigantic calculators. As a result, one of the most basic operations we use in Java involves arithmetic. \nThe symbols +, -, *, and \/ represent the operations addition, subtraction, multiplication, and division, respectively. The operator % is also used in Java: called the “modulus” operator, this symbol will produce the numerical remainder of a division. For example, 3 % 2 would evaluate to 1, since 3 divided by 2 yields 1, with 1 as a remainder. These operations can be performed intuitively on numerical values; they can also be performed on variables that store numerical values.\nSpeaking of math, back to our triangle example… \nConsider the following statement in a program: \nint side2 = 2, side3 = 3; \n\n(Note that you can write multiple assignment statements in a single line, as long as the data types are the same.) \nIf we wanted to write a statement that found the sum of these data and assigned the result to another variable called sumOfSides, we could easily write \nsumOfSides = 2 + 3; \/\/ method 1 \n\nBut this statement is less useful than \nsumOfSides = side2 + side3; \/\/ method 2 \n\nSince the data is assigned to variables, for which values can vary, method 2 will reflect those changes while method 1 will not. \nThis same technique can be applied to all of the mathematical operators. Remember that a mixture of mathematical operations follows a specific order of precedence. Java will perform the multiplication and division operations (including modulus), from left to right, followed by the addition and subtraction operations in the same order. If programmers want to change the order of precedence of the operators, they can use parentheses. \nConsider these lines of code: \nSystem.out.print(3 - 4\/5); \/\/ statement 3 \nSystem.out.print(3 -(4\/5)); \/\/ statement 4 \nSystem.out.print((3 - 4)\/5); \/\/ statement 5\n\nIn statement 3, the division occurs first, followed by the subtraction (3 minus the answer). \nIn statement 4, the same thing happens, so it is mathematically equivalent to statement 3. \nIn statement 5, the parentheses override the order of operations, so the subtraction occurs, and then the answer is divided by 5. \nOkay, here’s where it gets crazy. Can you predict the output of these statements? Believe it or not, the output of statements 3 and 4 is 3; the output of statement 5 is 0. These results demonstrate the fact that data in Java is strongly typed. \nWhen you perform a mathematical operation on two integers, Java will return the answer as an integer, as well. Therefore, although 4\/5 is actually 0.8, Java will return a value of 0. Likewise, Java will evaluate 5\/4 to be 1. The decimal part is cut off (not rounded), so that the result will also be an integer. Negative numbers work the same way. Java will return –4\/5 as 0 and –5\/4 as –1. Strange, huh? \n\nAs is true with all computer science, there is a workaround for this called casting. Casting is a process through which data is forced to “look like” another type of data to the compiler. Think of someone who is cast in a show to play a part; although actors have personal identities, they assume new identities for the audience. The following modifications to statement 3 demonstrate different ways of casting: \nSystem.out.print(3 - (double)(4)\/5); \/\/ statement 3.1\nSystem.out.print(3 - 4\/(double)5); \/\/ statement 3.2 \n\nThese statements will cast 4 and 5, respectively, to be double values of 4.0 and 5.0. As a result, the division will be “upgraded” to a division between double values, not integers, and the desired result will be returned. The following statements, although they will compile without error, will not display the desired result of 2.2. \nSystem.out.print((double)3 - 4\/5); \/\/ statement 3.3 \nSystem.out.print(3 - (double)(4\/5)); \/\/ statement 3.4 \n\nCasting has a higher precedence than arithmetic operators, except parentheses, of course. Therefore, statement 3.3 will first convert 3 to 3.0, but will then perform integer division before completing the subtracting. The result is 3.0. In statement 3.4, the result of dividing the integers is cast to a double; since the integer division evaluates to 0, the cast will simply make the result 0.0, yielding an output of 3.0 once again. Very tricky! \nThe increment operator (++) is used to increase the value of a number by one. For example, if the value of a variable x is 3, then x++ will increment the value of x to 4. This has the exact same effect as writing x = x + 1, and is nothing more than convenient shorthand. \nConversely, the decrement operator (--) is used to quickly decrease the value of a number by one. For example, if the value of a variable named x is 3, then x-- decreases the value of x to 2. This has the exact same effect as writing x = x – 1. \nOther shortcut operators include +=, -=, *=, \/=, and %=. These shortcuts perform the indicated operation and assign the result to the original variable. For example, \na += b; \n\nis an equivalent command to \na = a + b;\nHumans are pretty smart when it comes to guessing intent For instance, you probably noticed that there’s a missing period between this sentence and the one before it. (If not, slow down: AP Computer Science A Exam questions require close reading when looking for errors.) Computers, on the other hand, are literal—more annoyingly so, probably, than those teachers who ask whether you’re physically capable of going to the bathroom when you ask whether you can go. To that end, then, it’s crucial that you end each complete statement (i.e., sentence) with a semicolon, which is our way of telling the Java compiler that it’s reached the end of a step. This doesn’t mean that you need to place a semicolon after every line— remember that line breaks exist only to make code more readable to humans —but you must place one after any complete declaration or statement. \n\n\n###\n\n","completion":" Question: Consider the following code segment.\nint a = 11;\nint b = 4;\ndouble x = 11;\ndouble y = 4;\nSystem.out.print(a \/ b);\nSystem.out.print(\", \");\nSystem.out.print(x \/ y);\nSystem.out.print(\", \");\nSystem.out.print(a \/ y);\n\nWhat is printed as a result of executing the code segment?\nCorrect: 2, 2.75, 2.75\nIncorrect: 3, 2.75, 3\nIncorrect: 3, 2.75, 2.75\nIncorrect: 2, 3, 2\nIncorrect: Nothing will be printed because of a compile-time error.\n\nEND"}
{"prompt":"The most primitive uses for the first computers were to perform complex calculations. They were basically gigantic calculators. As a result, one of the most basic operations we use in Java involves arithmetic. \nThe symbols +, -, *, and \/ represent the operations addition, subtraction, multiplication, and division, respectively. The operator % is also used in Java: called the “modulus” operator, this symbol will produce the numerical remainder of a division. For example, 3 % 2 would evaluate to 1, since 3 divided by 2 yields 1, with 1 as a remainder. These operations can be performed intuitively on numerical values; they can also be performed on variables that store numerical values.\nSpeaking of math, back to our triangle example… \nConsider the following statement in a program: \nint side2 = 2, side3 = 3; \n\n(Note that you can write multiple assignment statements in a single line, as long as the data types are the same.) \nIf we wanted to write a statement that found the sum of these data and assigned the result to another variable called sumOfSides, we could easily write \nsumOfSides = 2 + 3; \/\/ method 1 \n\nBut this statement is less useful than \nsumOfSides = side2 + side3; \/\/ method 2 \n\nSince the data is assigned to variables, for which values can vary, method 2 will reflect those changes while method 1 will not. \nThis same technique can be applied to all of the mathematical operators. Remember that a mixture of mathematical operations follows a specific order of precedence. Java will perform the multiplication and division operations (including modulus), from left to right, followed by the addition and subtraction operations in the same order. If programmers want to change the order of precedence of the operators, they can use parentheses. \nConsider these lines of code: \nSystem.out.print(3 - 4\/5); \/\/ statement 3 \nSystem.out.print(3 -(4\/5)); \/\/ statement 4 \nSystem.out.print((3 - 4)\/5); \/\/ statement 5\n\nIn statement 3, the division occurs first, followed by the subtraction (3 minus the answer). \nIn statement 4, the same thing happens, so it is mathematically equivalent to statement 3. \nIn statement 5, the parentheses override the order of operations, so the subtraction occurs, and then the answer is divided by 5. \nOkay, here’s where it gets crazy. Can you predict the output of these statements? Believe it or not, the output of statements 3 and 4 is 3; the output of statement 5 is 0. These results demonstrate the fact that data in Java is strongly typed. \nWhen you perform a mathematical operation on two integers, Java will return the answer as an integer, as well. Therefore, although 4\/5 is actually 0.8, Java will return a value of 0. Likewise, Java will evaluate 5\/4 to be 1. The decimal part is cut off (not rounded), so that the result will also be an integer. Negative numbers work the same way. Java will return –4\/5 as 0 and –5\/4 as –1. Strange, huh? \n\nAs is true with all computer science, there is a workaround for this called casting. Casting is a process through which data is forced to “look like” another type of data to the compiler. Think of someone who is cast in a show to play a part; although actors have personal identities, they assume new identities for the audience. The following modifications to statement 3 demonstrate different ways of casting: \nSystem.out.print(3 - (double)(4)\/5); \/\/ statement 3.1\nSystem.out.print(3 - 4\/(double)5); \/\/ statement 3.2 \n\nThese statements will cast 4 and 5, respectively, to be double values of 4.0 and 5.0. As a result, the division will be “upgraded” to a division between double values, not integers, and the desired result will be returned. The following statements, although they will compile without error, will not display the desired result of 2.2. \nSystem.out.print((double)3 - 4\/5); \/\/ statement 3.3 \nSystem.out.print(3 - (double)(4\/5)); \/\/ statement 3.4 \n\nCasting has a higher precedence than arithmetic operators, except parentheses, of course. Therefore, statement 3.3 will first convert 3 to 3.0, but will then perform integer division before completing the subtracting. The result is 3.0. In statement 3.4, the result of dividing the integers is cast to a double; since the integer division evaluates to 0, the cast will simply make the result 0.0, yielding an output of 3.0 once again. Very tricky! \nThe increment operator (++) is used to increase the value of a number by one. For example, if the value of a variable x is 3, then x++ will increment the value of x to 4. This has the exact same effect as writing x = x + 1, and is nothing more than convenient shorthand. \nConversely, the decrement operator (--) is used to quickly decrease the value of a number by one. For example, if the value of a variable named x is 3, then x-- decreases the value of x to 2. This has the exact same effect as writing x = x – 1. \nOther shortcut operators include +=, -=, *=, \/=, and %=. These shortcuts perform the indicated operation and assign the result to the original variable. For example, \na += b; \n\nis an equivalent command to \na = a + b;\nHumans are pretty smart when it comes to guessing intent For instance, you probably noticed that there’s a missing period between this sentence and the one before it. (If not, slow down: AP Computer Science A Exam questions require close reading when looking for errors.) Computers, on the other hand, are literal—more annoyingly so, probably, than those teachers who ask whether you’re physically capable of going to the bathroom when you ask whether you can go. To that end, then, it’s crucial that you end each complete statement (i.e., sentence) with a semicolon, which is our way of telling the Java compiler that it’s reached the end of a step. This doesn’t mean that you need to place a semicolon after every line— remember that line breaks exist only to make code more readable to humans —but you must place one after any complete declaration or statement. \n\n\n###\n\n","completion":" Question: Consider the following statement:\nint i = x % 50;\n\nIf x is a positive integer, which of the following could NOT be the value of i after the statement above executes?\nCorrect: 50\nIncorrect: 0\nIncorrect: 10\nIncorrect: 25\nIncorrect: 40END"}
