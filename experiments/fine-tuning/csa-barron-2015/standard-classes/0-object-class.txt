Think of Object as the superclass of the universe. Every class automatically extends Object, which means that Object is a direct or indirect superclass of every other class. In a class hierarchy tree, Object is at the top.
There are many methods in Object, all of them inherited by every other class. Since Object is not an abstract class, all of its methods have implementations. The expectation is that these methods will be overridden in any class where the default implementation is not suitable. The methods of Object in the AP Java subset are toString and equals.

public String toString()
This method returns a version of your object in String form.
When you attempt to print an object, the inherited default toString method is invoked, and what you will see is the class name followed by an @ followed by a meaningless number (the address in memory of the object). For example,
SavingsAccount s = new SavingsAccount(500);
System.out.println(s);
produces something like
SavingsAccount@fea485c4
To have more meaningful output, you need to override the toString method for your own classes. Even if your final program doesn’t need to output any objects, you should define a toString method for each class to help in debugging.

Example 1
public class OrderedPair
{
    private double x;
    private double y;
    //constructors and other methods ...
    /** @return this OrderedPair in String form */
    public String toString()
    {
        return "(" + x + "," + y + ")";
    }
}
Now the statements
OrderedPair p = new OrderedPair(7,10);
System.out.println(p);
will invoke the overridden toString method and produce output that looks like an ordered pair:
(7,10)

Example 2
For a BankAccount class the overridden toString method may look something like this:
/** @return this BankAccount in String form */
public String toString()
{
    return "Bank Account: balance = $" + balance;
}

The statements
BankAccount b = new BankAccount(600);
System.out.println(b);
will produce output that looks like this:
Bank Account: balance = $600

NOTE
1. The + sign is a concatenation operator for strings (see p. 178).
2. Array objects are unusual in that they do not have a toString method. To print the elements of an array, the array must be traversed and each element must explicitly be printed.

public boolean equals(Object other)
All classes inherit this method from the Object class. It returns true if this object and other are the same object, false otherwise. Being the same object means referencing the same memory slot. For example,
Date d1 = new Date("January", 14, 2001);
Date d2 = d1;
Date d3 = new Date("January", 14, 2001);

The test if (d1.equals(d2)) returns true, but the test if (d1==d3) returns false, since d1 and d3 do not refer to the same object. Often, as in this example, you may want two objects to be considered equal if their contents are the same. In that case, you have to override the equals method in your class to achieve this. Some of the standard classes described later in this chapter have overridden equals in this way. You will not be required to write code that overrides equals on the AP exam.

NOTE
1. The default implementation of equals is equivalent to the == relation for objects: In the Date example above, the test if (d1 == d2) returns true; the test if (d1 == d3) returns false.
2. The operators <, >, and so on, are not overloaded in Java. To compare objects, one must use either the equals method or define a compareTo method for the class.

THE hashCode METHOD
Every class inherits the hashCode method from Object. The value returned by hashCode is an integer produced by some formula that maps your object to an address in a hash table. A given object must always produce the same hash code. Also, two objects that are equal should produce the same hash code; that is, if obj1.equals(obj2) is true, then obj1 and obj2 should have the same hash code. Note that the opposite is not necessarily true. Hash codes do not have to be unique—two objects with the same hash code are not necessarily equal.
To maintain the condition that obj1.equals(obj2) is true implies that obj1 and obj2 have the same hash code, overriding equals means that you should override hashCode at the same time. You will not be required to do this on the AP exam.

You should, however, understand that every object is associated with an integer value called its hash code, and that objects that are equal have the same hash code.
