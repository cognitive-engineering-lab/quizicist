For each method in a class, list all of the other classes needed to implement that particular method. These classes are called collaborators. A class that has no collaborators is independent.
To implement the classes, often an incremental, bottom-up approach is used. This means that independent classes are fully implemented and tested before being incorporated into the overall project. Typically, these are the basic objects of the program, like StockItem, Card, and BingoCard. Unrelated classes in a programming project can be implemented by different programmers.
Note that a class can be tested using a dummy Tester class that will be discarded when the methods of the class are working. Constructors, then methods, should be added, and tested, one at a time. A driver class that contains a main method can be used to test the program as you go. The purpose of the driver is to test the class fully before incorporating it as an object in a new class.
When each of the independent classes is working, classes that depend on just one other class are implemented and tested, and so on. This may lead to a working, bare bones version of the project. New features and enhancements can be added later.
Design flaws can be corrected at each stage of development. Remember, a design is never set in stone: It simply guides the implementation.

In a top-down design, the programmer starts with an overview of the program, selecting the highest-level controlling object and the tasks needed. During development of the program, subsidiary classes may be added to simplify existing classes.
A good programmer avoids chunks of repeated code wherever possible. To this end, if several methods in a class require the same task, like a search or a swap, you should use helper methods. The reduce method in the Rational class on p. 118 is an example of such a method. Also, wherever possible you should enhance the readability of your code by using helper methods to break long methods into smaller tasks. The use of helper methods within a class is known as procedural abstraction and is an example of top-down development within a class. This process of breaking a long method into a sequence of smaller tasks is sometimes called stepwise refinement.
Instance variables and helper methods are generally declared as private, which prevents client classes from accessing them. This strategy is called information hiding.
Sometimes it makes more sense in the development of a class to test a calling method before testing a method it invokes. A stub is a dummy method that stands in for a method until the actual method has been written and tested. A stub typically has an output statement to show that it was called in the correct place, or it may return some reasonable values if necessary.
An algorithm is a precise step-by-step procedure that solves a problem or achieves a goal. Don’t write any code for an algorithm in a method until the steps are completely clear to you.

Example 1
A program must test the validity of a four-digit code number that a person will enter to be able to use a photocopy machine. The number is valid if the fourth digit equals the remainder when the sum of the first three digits is divided by seven.
Classes in the program may include an IDNumber, the four-digit code; Display, which would handle input and output; and IDMain, the driver for the program. The data structure used to implement an IDNumber could be an instance variable of type int, or an instance variable of type String, or four instance variables of type int—one per digit, and so on.
A top-down design for the program that tests the validity of the number is reflected in the steps of the main method of IDMain:
Create Display
Read in IDNumber
Check validity
Print message
Each method in this design is tested before the next method is added to main. If the display will be handled in a GUI (graphical user interface), stepwise refinement of the design might look like this:
Create Display
    Construct a Display
    Create window panels
    Set up text fields
    Add panels and fields to window
Read in IDNumber
    Prompt and read
Check validity of IDNumber
    Check input
        Check characters
        Check range
    Separate into digits
    Check validity property
Print message
    Write number
    State if valid

NOTE
1. The IDNumber class, which contains the four-digit code, is responsible for the following operations:
    Split value into separate digits
    Check condition for validity
The Display class, which contains objects to read and display, must also contain an IDNumber object. It is responsible for the following operations:
    Set up display
    Read in code number
    Display validity message
Creating these two classes with their data fields (instance variables) and operations (methods) is an example of encapsulation.

2. The Display method readCodeNumber needs private helper methods to check the input: checkCharacters and checkRange. This is an example of procedural abstraction (use of helper methods) and information hiding (making them private).
3. Initially the programmer had just an IDNumber class and a driver class. The Display class was added as a refinement, when it was realized that handling the input and message display was separate from checking the validity of the IDNumber. This is an example of top-down development (adding an auxiliary class to clarify the code).
4. The IDNumber class contains no data fields that are objects. It is therefore an in dependent class. The Display class, which contains an IDNumber data member, has a composition relationship with IDNumber (Display has-a IDNumber).
5. When testing the final program, the programmer should be sure to include each of the following as a user-entered code number: a valid four-digit number, an invalid four-digit number, an n-digit number, where n 6= 4, and a “number” that contains a nondigit character. A robust program should be able to deal with all these cases.

Example 2
A program must create a teacher’s grade book. The program should maintain a class list of students for any number of classes in the teacher’s schedule. A menu should be provided that allows the teacher to
• Create a new class of students.
• Enter a set of scores for any class.
• Correct any data that’s been entered.
• Display the record of any student.
• Calculate the final average and grade for all students in a class.
• Print a class list, with or without grades.
• Add a student, delete a student, or transfer a student to another class.
• Save all the data in a file.
