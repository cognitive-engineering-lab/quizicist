Inheritance is the quintessential way—and the only way, for our purposes —to create direct relationships between classes. An inheritance hierarchy is designed in order to quantify this relationship, much like a family tree, and it defines the “parent” class and all of its “child” classes. A carefully designed hierarchy implemented as an inheritance relationship between classes is arguably the most powerful programming technique that you will learn in this course. 
The designing of the hierarchy is critical in implementing inheritance. As the programmer, you have limitless ways to design a hierarchy, so the importance of the planning process cannot be overstated. 
The first decision for the programmer/designer—yes, there are programmers who focus solely on design—is to define the parent class of the situation. Typically, the parent class (superclass) is the most general form of the objects that will be instantiated in the overall program. Every other class in the program will lie lower in the hierarchy (subclasses of the superclass), but their objects will be more specific versions of the overall parent class. This setup creates an IS-A relationship between the parent and the child classes. 
Let’s use potato chips as our example for this discussion. If we are designing a hierarchy of classes to properly represent potato chips, there are a ridiculous number of possibilities—would the parent class be PotatoChip? Potato? Snack? SaltySnack? JunkFood? So we have to make a decision based on the situation that we are given; if the programmer receives no context whatsoever, the design is very difficult and will produce unpredictable—yet all viable—results. 
In this case, let’s use Snack as the superclass. A Snack object is very general; there may be many subclasses in our situation. Let’s define two subclasses for Snack, one for our purposes and an extra for practice: PotatoChip and Cookie. Since a potato chip is a snack (as is a cookie), the setup makes intuitive sense. Note how we define the relationship from the bottom (lowest subclasses) of the hierarchy to the top (highest superclass). Let us then define another, lower set of classes that will be subclasses of PotatoChip: BBQChip and OnionChip. 
As you can see, there are several IS-A relationships here. A BBQChip IS-A PotatoChip, which IS-A Snack. A BBQChip also IS-A Snack, by inheritance. All of these relationships as designed in the hierarchy should make intuitive sense and/or conform to the given specifications. 
Let’s discuss the benefits of the setup we have created. When we are ready to implement code, we should decide which variables and methods should be implemented, as well as their locations within the hierarchy. These variables and methods have a HAS-A relationship with the class to which they belong. This task is more formidable than it might seem; very general variables and methods should be closer to the top of the hierarchy, while more specific variables and methods should reside in lower subclasses. For example, virtually every snack food has some kind of flavor. Therefore, code to address the flavor of the snack food should be implemented in Snack, and it will be subsequently inherited by all of the subclasses: Since a Snack object HAS-A flavor, and a PotatoChip object IS-A Snack, a PotatoChip object also HAS-A flavor. What about an OnionChip object? It also HAS-A flavor, as described above. 
Now consider code that addresses the crunch of an object in the hierarchy. Without any detail in specification, let’s conclude that it is arguable whether a cookie is crunchy, but all potato chips are crunchy. As a result, code that addresses the crunchy aspect of the program should NOT be implemented in Snack; that way Cookie does not inherit the code. Since all potato chips are crunchy, the appropriate location for the crunchy code would be in PotatoChip, and BBQChip and OnionChip will inherit the aspects and functionalities of that code.
If we wanted to address the spiciness of an object in our hierarchy, we might determine that, out of all of these classes, only the BBQChip has a spice factor worth quantifying. The spiciness code should then appear in BBQChip and will not be inherited, because BBQChip does not have any subclasses. 
It is also worth mentioning here that a class may not have more than one direct superclass. This design is called multiple inheritance and it is NOT allowed in Java. 
It is important to note here that instantiating a BBQChip object will automatically instantiate an object each of both PotatoChip and Snack. In order for this to occur correctly, however, Java requires us to address their instantiation explicitly. Therefore, the constructor BBQChip must first make a call to super(), which invokes the constructor of PotatoChip, its superclass. If the super constructor requires (a) parameter(s), then the super() call must include those parameters as well. Java will otherwise invoke super() on its own, often resulting in undesired results and an easily avoided missed point on a free-response question. As a rule, all classes in Java will instantiate the Object class, which is the ultimate generalization—think: if I look around the room right now, what isn’t an object? 

Now, suppose there is functionality in a superclass that is inherited, but should be changed based on the level of inheritance. For example, all snacks can be eaten, so the programmer appropriately implements an eat()
method in Snack. As a result, all subclasses will inherit this method and its functionality. But what if, say, an OnionChip must be eaten differently than the other snacks? Perhaps after a few chips, “eaters” have to wipe their hands before continuing to eat. The desired eat() method—possessing the identical name, parameters, and return type—would be implemented in OnionChip, and all objects of that class (and only that class, in this example) would use this new eat() method. The superclass’s eat() method has been overridden by this new version. The workaround for this situation would be to use the super keyword: super.eat(). 
Though no longer part of the official Course Description, it’s pretty cool to know that another level of overriding involves method abstraction. Suppose that the programmer wants to force all subclasses to have the eat() method, but decides that an eat() method’s code in Snack is inappropriate; for example, all Snack objects can be eaten but the WAY they are eaten depends so much on the type of snack that superclass code for the method seems inappropriate. 
(You would not eat a chip the same way you would eat a cookie, would you? Go with it.) The eat() method can be declared abstract; in this design, the Snack class has now mandated every subclass to either (1) override the abstract method with code or (2) declare the method abstract once again, forcing its subclasses to override the abstract method. 
