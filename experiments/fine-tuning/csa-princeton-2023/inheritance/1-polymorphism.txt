Polymorphism is a technique that, in a way, breaks all of the rules we think would happen in inheritance—and yet, it conforms to them at the same time. 
Using our Snack example from above, including the overridden method in OnionChip, suppose several objects from various levels in the hierarchy reside in an untyped ArrayList. The programmer would like to, using a simple loop, simulate the user “eating” the chips in the list, regardless of their type. The loop will iterate through the list and automatically invoke the appropriate eat() method, including the overridden method for OnionChip objects, as desired. This is an example of polymorphism.
The word polymorphism, which means “many forms,” can also apply to programs in a more profound manner. This process, directly or indirectly, involves virtually every technique we have learned in this book. 
Suppose an interface called Eatable is implemented by all of the classes in the Snack hierarchy. Every class has either overridden the abstract methods from the interface, as normally required, or passed the abstraction to a subclass. 
Have you ever seen those snack bags that have multiple forms of snacks (for example, potato chips AND pretzels AND nacho chips…) in them? This example is similar; if you instantiated the “bag” as either a typed ArrayList or an array, you could fill the structure with instances of all of these classes by declaring the type as Eatable. Once the eat() method is invoked on all of the components of the list structure using a loop, each object will automatically invoke its corresponding eat method! Pretty awesome. 