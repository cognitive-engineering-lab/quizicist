chapter,text,question,correct,incorrect1,incorrect2,incorrect3
codehs-csa-data-types,"Variables allow us to store information such as numbers, words, or true/false expressions. A variable can be thought of as a box that stores information inside.

In Java, variables are composed of three things: a name, type, and value.In Java you must specify what type of information you want our variables to hold. There are two types that are used in Java: primitive and reference. You must always give your variable a type before naming it, and specifying the value it holds. (Ex. int myVariable = 10;)

As seen above, primitive numeric types in Java include both integers and doubles.

Integers are whole numbers, or counting numbers. (Ex. -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5). In Java you declare an integer using int before the variable name. Here are a couple of examples:

int itemsInStore = 10; 
int numberOfMessages = 8;

doubles are like integers, but can have decimals. (Ex. -54.34, 90.21, 0.1223). In Java you declare a double using double before the variable name. Here are a couple of examples:

double costOfApple = 1.24;
double milesToRun = 5.64;

Characters represent a single character. In Java you declare a character using char before the variable name. You also use single quotes to identify a character (Ex. ‘A’). Here are a couple of examples:

char currentGrade = 'A';
char favoriteLetter = 'W';

Booleans are variables that hold a true or a false value. In Java you declare a boolean using boolean before the variable name. Here are a couple of examples:

boolean passedCalculus = true;
boolean hasDog = false;

While primitive types are considered the building blocks of programming languages, reference types are types that have been created by programmers using those primitive types. String for example, is a variable type that was created using char variable types, and has its own functionality that has been created by programmers.

One of the primary differences between primitive types and reference types is how they are stored in memory. When you assign a value to a variable, you are actually associating that variable with binary data. Computers store all data in binary, and associate that variable with the binary data associated with the value that its been assigned. When primitives are given values, they are associated directly with those values. If the value of one variable changes, then the primitive value that it stores also changes.

In this example, the value of first is being changed to equal the value stored in second. Both first and second now store the value b.

Reference types store an address that points to where the value is located in memory.

Strings are variables that hold text. Strings are not a primitive type, so you must declare them using String with a capital S. Unlike characters, you need to use double quotes when assigning strings (Ex. ""This is my string.""). Here are a couple of examples:

String fishName = ""Dog"";
String myUniversity = ""Arizona State University"";

Variables can be protected from alteration if the keyword final is included before the data type. If there is an attempt to change the variable value, then an error will be called indicating that variable has already been assigned. This is often used as a security measure in more complex programs to ensure that values cannot be modified by others.

final int numApples = 5;
numApples = 0;

In this example, the program will throw an error because the value of numApples cannot be changed if the keyword final is added to the variable declaration.

Giving your variables meaningful names throughout your code is very important. Proper variable names allow others to easily read and understand your code. A good way to name your variables is to give them as descriptive of a name as possible, without making it too long.

For example,int numberOfApplesOnTheTree = 10; is a very long name, and can easily be replaced with a name like int numApples = 10;

Variable Naming Conventions:
- Variable names must start with a letter, $ symbol, or _ symbol.
- Variable names are case sensitive so myVariable is different thanMyVariable
- Variable names, after the first character, can contain letters, numbers, or other characters.","If you were to create a variable to store your age, which of the following would be best considering the variable type and Java naming conventions?",int age;,double Age;,int number;,int Age;
codehs-csa-expressions,"Arithmetic expressions allow your to perform mathematical operations within Java. Such expressions can be used for basic math and even more complex algorithms.

The addition operator allows you to add values together. Here is an example of the addition operator in Java:

public class AdditionOperator
{
  public static void main(String[] args)
  {
    int firstVal = 5;
    int secondVal = 2;

    int firstPlusSecond = firstVal + secondVal;

    // The output will be '7'
    System.out.println(firstPlusSecond);
  }
}

The subtraction operator allows you to subtract values from one another. Here is an example of the subtraction operator in Java:

public class SubtractionOperator
{
  public static void main(String[] args)
  {
    int firstVal = 4;
    int secondVal = 2;

    int firstMinusSecond = firstVal - secondVal;

    // The output will be '2'
    System.out.println(firstMinusSecond);
  }
}

The multiplication operator allows you to multiply values. Here is an example of the multiplication operator in Java:

public class MultiplicationOperator
{
  public static void main(String[] args)
  {
    int firstVal = 4;
    int secondVal = 2;

    int firstMultSecond = firstVal * secondVal;

    // The output will be '8'
    System.out.println(firstMultSecond);
  }
}

The division operator allows you to divide values. Here is an example of the division operator in Java:

public class DivisionOperator
{
  public static void main(String[] args)
  {
    int firstVal = 6;
    int secondVal = 3;

    int firstDivSecond = firstVal / secondVal;

    // The output will be '2'
    System.out.println(firstDivSecond);
  }
}

There are multiple types of division that can be performed in Java. These forms include: integer division, double division, and mixed division.

Integer Division
If you divide two integers you will be returned an integer value.

So in this case, while 2 / 5 equals 2.5, in Java 2 / 5 = 2. This always holds true, unless the type is specified as a double. Whenever you divide two integers, the return value is always truncated.

Double Division
Dividing doubles is different from dividing integers.

When you divide two doubles you will be returned a double. In this case,2.0 / 5.0 = 2.5 will be your result.

Mixed Division
Mixed division is when you divide a double by an integer or an integer by a double.

When you use mixed division in your program you will be returned a double. This is true, unless the type is specifically defined as an integer.

Consider the following piece of code:

double x = 2;
int y = 5;

double outXY = x / y;   // 0.4

double outYX = y / x;   // 2.5

int outInt = (int)(y / x);  // 2

No matter which data type you use, dividing by zero will cause your programs to throw an ArithmeticException. Exceptions are unwanted or unexpected events which occur during the execution of a program. In this case, dividing by zero causes the variable to store the value of undefined, which cannot be used in arithmetic expression. The program throws the ArithmeticException to warn programmers that there is an issue that needs to be resolved.

The modulus operator allows you to divide two numbers and get the remainder. Here is an example of the modulus operator in Java:

public class ModulusOperator
{
  public static void main(String[] args)
  {
    int firstVal = 17;
    int secondVal = 5;

    int firstModSecond = firstVal % secondVal;

    // The output will be '2' since the remainder of 17 / 5 is 3.
    System.out.println(firstModSecond);
  }
}

It is important to remember that the order of operations still applies. In instances where you have multiple operators with the same precedence the order will be left to right.
","What is the result of this expression?

54 % 5",4,10,10.8,11
codehs-csa-casting,"Casting allows you to change a variable’s type to better suit our needs.

Let’s say you want to turn a double into an integer, or an integer into a double. To change a variable’s type you just add the type in between parentheses to cast it.

Consider the following:

int doubleToInt = (int)10.95;
// This will become '10'

To cast an integer value to a double you add double in front of the variable.

int intVal = 10;

// Our 'doubleVal' variable is now '10.0'
double doubleVal = (double)intVal;

Programs can also cast an int value to a double automatically since the value doesn’t change.

int intVal = 10;

// Our 'doubleVal' variable is now '10.0'
double doubleVal = intVal; // cast automatically

To cast a double to an integer you add (int) in front of the variable. It is important to remember your new integer value will truncate the decimal.

double doubleVal = 7.6;

// Our 'intVal' variable is now '7'
int intVal = (int)doubleVal;

Note that the change from casting is temporary. In the above example, intVal has a value of 7, but the value of doubleVal remains 7.6.

Truncating the value may not be the desired result. If you want to round the value, you can do this programmatically by adding half to the original value before truncating.

If you divide two integers, even if you are setting them to a double, you will always be returned an integer.

int currResidents = 50;
int floorTotal = 56;

double average = floorTotal / currResidents;
// 'average' will return the value '1'

We can get the correct answer by casting one of the variables to a double.

int currResidents = 50;
int floorTotal = 56;

double average = (double)floorTotal / currResidents;
// We now have the value of '1.12'

As you begin to explore numerical values in greater depth, it’s important to know about the existing range of variables. When you assign a value to a variable, you are actually associating that variable with binary data. Computers store all data in binary, and associate that variable with the binary data associated with the value that it has been assigned. int values are represented by 32 bits, or binary digits!

While that may seem like a lot, it actually does give you a finite limit to the numbers that you can store. Since ints are represented by 32 bits, the total possible combination of different values that can exist is 4,294,967,296. This range is split nearly evenly between negative and positive numbers, so you are able to store values from -2,147,483,648 to 2,147,483,647.

What happens if you go over the maximum or less than the minimum? If you go over or under the max and min, the value actually wraps around. This is called overflow. It’s important to note that overflow doesn’t always act as intended, and can create unexpected results. You will still get a value, but it may not be the value you expect.

A data type of lower size (occupying less memory) is assigned to a data type of higher size (more memory). This is done implicitly by the Java Virtual Machine, unlike the explicit casting we did in previous examples (so by the programmer). The lower size is widened to a higher size. This is also called automatic type conversion.

int x = 10;                    // occupies 4 bytes
double y = x;                  // occupies 8 bytes
System.out.println(y);         // prints 10.0

In the above code, the 4 bytes integer value is assigned to 8 bytes double value.

Integer values in Java are represented by values of type int, which are stored using a finite amount (4 bytes) of memory. Therefore, an int value must be in the range from Integer.MIN_VALUE to Integer.MAX_ VALUE inclusive.

We can print the maximum, minimum and bit-length of the integer primitive types. The maximum, minimum and bit-size of int are kept in built-in constants Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.SIZE.

The expected outputs are:

The minimium integer value in Java is -2147483648
The maximum integer value in Java is 2147483647
The total bit size for an integer in Java is 32","What will this java expression evaluate to?
(int) 5.6",5,6,5.6,6.0
codehs-csa-objects,"Classes and Objects are utilized in Java as part of the object-oriented programming model. This model focuses on objects and the data and actions associated with the objects.

Objects are variables of user-defined data types. You can refer to these as reference type variables. Just as you initialize and declare primitive types, reference types are also declared and initialized. The initialized form of a reference type is referred to as an object.

Objects are structures that contain a state and behavior. Everyday objects you commonly use have states and behaviors. For example, a car is an object with both a state and behavior.

State
The state contains information about the specific object. An example of a state for a car would be how much fuel it has.

Behavior
The behavior is the actions that can be performed on a specific object. A behavior of the car may be to get the mileage from the remaining fuel.

Classes are the templates you use for creating objects.

Here is an example of a class that lets us create a rectangle, and get its area:

public class Rectangle
{
  private double width;
  private double height;

  public Rectangle(double rectWidth, double rectHeight)
  {
    width = rectWidth;
    height = rectHeight;
  }

  public int getWidth()
  {
    return width;
  }

  public int getHeight()
  {
    return height;
  }

  public int getArea()
  {
    return width * height;
  }

  public String toString()
  {
    String rectInfo = ""Rectangle with width "" + width + "" and height "" + height + 
     "" and area "" + getArea();

    return rectInfo;
  }
}

Here is another example of a class that lets us create new animal objects:

public class Animal
{
  private String name;
  private boolean isPet;
  private int age;

  public Animal(String animalName, boolean isAnimalPet, int animalAge)
  {
    name = animalName;
    isPet = isAnimalPet;
    age = animalAge;
  }

  public String getName()
  {
    return name;
  }

  public boolean getPetStatus()
  {
    return isPet;
  }

  public int getAge()
  {
    return age;
  }

  public String toString()
  {
    String aInfo = ""This animal's name is "" + name + "". They are currently a pet: "" +
      isPet + "". The animal is "" + age + "" years old."";

    return aInfo;
  }
}

Here is another example of a class that takes in a vehicle type, its age, and how many miles it has:

public class Vehicle
{
  private String vehicleType;
  private int vehicleAge;
  private double vehicleMiles;

  public Vehicle(String vType, int vAge, double vMiles)
  {
    vehicleType = vType;
    vehicleAge = vAge;
    vehicleMiles = vMiles;
  }

  public String getType()
  {
    return vehicleType;
  }

  public int getAge()
  {
    return vehicleAge;
  }

  public double getMiles()
  {
    return vehicleMiles;
  }

  public double estimateMilesPerYear()
  {
    return vehicleMiles / vehicleAge;
  }
}

It is important to remember that classes are just templates for creating new objects. A class is a formal implementation, or blueprint, of the attributes and behaviors of an object.

An object on the other hand is a specific instance of a class with defined attributes. Objects contain both a state and behavior, and are an instance of a class.

Instances
An instance is a specific version of an object that can differ in numerous ways. Going back to the previous section, Rectangle, Animal, and Vehicle are all classes. If you create two different vehicles they would be specific instances of the Vehicle class. Or in other words, they would be two different vehicle objects. Remember, an object is an instance of a class.

Examples:

public class ExampleClass
{
 public static void main(String[] args)
 {
  // `Animal` is our class.

  // `myDog` and `myCat` are objects, because
  // they are specific instances of our `Animal` class.
  Animal myDog = new Animal(""Cujo"", true, 7);
  Animal myCat = new Animal(""Kerby"", true, 2);
 }
}

public class ExampleClass
{
 public static void main(String[] args)
 {
   // `Rectangle` is our class.

   //`mySquare` and `myRectangle` are objects, because
   // they are specific instances of our `Rectangle` class.
   Rectangle mySquare = new Rectangle(20, 20);
   Rectangle myRectangle = new Rectangle(5, 10);
 }
}","Consider this class definition of Weather.

public class Weather
{
    private boolean isRaining;
    private String forecast;
    private double temperature;

    // Rest of class goes here
}

When we use this class to create Weather objects, which of the following is guaranteed to be true?",Every Weather object will have the same attributes.,Every Weather object will have a temperature of 50.,Every Weather object must choose which attributes it wants.,It is impossible to know what attributes the Weather objects will have since the objects are not listed here.
codehs-csa-creating-objects,"In Java, you can think of everything as a class. If you want to write a program to act as a grade book, GradeBook is a class. Because of this, you can bundle classes and their functionality. You can even use classes that are written by other people without knowing exactly how they work. In this section, you will explore how to create objects from pre-existing classes.

To better understand how to create an object, let’s first look at the different parts of a class. There are 3 main parts to any class:

The instance variables, or attributes, hold the state of the object. These are declared at the beginning of the class. When declaring them, they are typically declared as private, which means that they are only accessible within the class.

Instance variables are not usually initialized when you declare them. For primitive variables, that means that these variables are created with default values. When an object has not been created, or “instantiated”, it isn’t pointing to any particular object data. When that happens, the object, in this case, is considered to be a null object. The keyword null is a special value used to indicate that a reference variable is not associated with any object.

The constructor is used to instantiate – create an instance of – an object. Anytime a new object is created, the constructor is run. Notice that the constructor has a different header (first line) compared to other methods. The constructor header has the same name as the class, is always declared public, and has no return type (you will learn more about return type later in this section). A class contains constructors that are invoked to create objects.

The third part of the class is the methods. These make up the behaviors of the object. There can be any number of methods, some of which take an input, some of which return a value, and some that do either both or neither. You will discuss methods later in this unit.

Let’s take a closer look at the constructor. The first line of the constructor (and other methods) is known as the method signature. A signature consists of the constructor name and the parameter list.

The parameter list, in the header of a constructor, lists the types of the values that are passed in and their variable names. These are often referred to as formal parameters. Parameters allow values to be passed to the constructor to establish the initial state of the object.

To create a new rectangle, you call the constructor and pass values that correspond to the parameter list. For example, to create a rectangle with a width of 5 and a height of 3, you would call it from the main function like this.

Rectangle rect = new Rectangle(5, 3);

In the above example, the 5 and 3 are known as arguments. An argument is a value that is passed into a constructor (or any method) when called. These are often referred to as actual parameters. The actual parameters passed to a constructor must be compatible with the types identified in the formal parameter list.

Arguments are passed to the object using call by value. Call by value initializes the formal parameters with copies of the actual parameters.

As you saw in the example above, every object is created using the keyword new followed by a call to the class’ constructor. The call to the constructor must contain the list of parameters that match the formal parameters.

Once you create a new object, Java allocates memory for this object. Unlike primitive variables that store the object address, the memory associated with a variable of a reference type holds an object reference value or, if there is no object, null. This value is the memory address of the referenced object.

To create an object, the arguments need to match the formal parameters, but what if you want to specify a different set of parameters? For example, maybe you want to create a square and only provide one side length.

In Java, you can do this with what is called a constructor overload. Let’s take a look at an example:

public class Rectangle
{
  private int width;
  private int height;
  public Rectangle(int rectWidth, int rectHeight)
  {
    width = rectWidth;
    height = rectHeight;
  }
  public Rectangle(int sidelength)
  {
    width = sidelength;
    height = sidelength;
  }
}

Constructors are said to be overloaded when there are multiple constructors with the same name but a different signature. In the example above, you see two constructors with the name Rectangle. One constructor takes two integers and the other takes one. Since the formal parameter lists are different, the signatures are different, and you can say that the constructor is overloaded. Now you can create a rectangle object by passing either one or two arguments in the call to the class constructor.

You have seen here how you can create the Rectangle class and instantiate new objects, but you can also use existing classes and class libraries to create objects. When you do this, you need to make use of documentation.

Documentation is a great resource to use to see how a class works. As long as you can read the documentation, you don’t need to know how the class works.

The documentation for a class tells us how to use the class constructor and various methods that the class provides.","/** 
 * The Plant class describes a plant.
 * 
 * Every plant has a type and number of watering days.
 * 
 */ 

public class Plant
{
    // Attributes
    private String plantType;
    private int wateringDays;

   public Shark(String type, int days)
   {
          plantType = type;
          wateringDays = wateringDays;
   }
}

Which of the following choices is a formal parameter of the constructor?",days,plantType,int,Plant
codehs-csa-void-method,"As stated earlier, objects have both state and behavior. The state of the object is stored in the instance variables and can be initialized through the constructor. An object’s behavior refers to what the object can do (or what can be done to it) and is defined by methods. Methods are procedures that allow us to control and define the behavior of an object.

In this section, you are going to look at methods that do not take any input and do not return any values. In subsequent sections, you will take a look at methods that take an input and/or return a value.

As you saw with constructors, methods have a signature that consists of the name of the method and the parameter list. A method signature for a method without parameters consists of the method name and an empty parameter list. Here are some examples:

public void printHello();
public void printWidth();

Each method signature has four parts:

public - The public statement tells Java which classes can see and use the method. In this course, you will see public methods that allow other classes to call the methods and private methods which are only available to that particular class.

void - After the public or private declaration, the signature contains the return type. You will explore return value in a subsequent section, but when a method doesn’t return a value, you use void as the return type. Some return type or void is required for all methods, but not for the constructor.

methodName - After the return type, you see the name of the method. While the name can be anything, it is important to give methods names that make sense. For example, if you want a method to print the value of a rectangle width, you may name it printWidth() so that the user would know what to expect from the method.

() - Finally you have a set of parentheses that hold the parameter list. In this case, you have no parameters, so you include an empty set of parentheses.

Methods allow programmers to perform a specific task without having to know the details of how that method was written. This is known as procedural abstraction. The programmer only needs to know what the method does, including any inputs and any outputs to the method.

When calling a method (or constructor), the call interrupts the sequential execution of statements, causing the program to first execute the statements in the method or constructor before continuing. Once the last statement in the method or constructor has been executed or a return statement is executed, the flow of control is returned to the point immediately following where the method or constructor was called.

Methods can be called from any other method, including the main method or another method in a class. How a method is called depends on the type of method that you are calling. In this section, you are going to look at calling non-static void methods. Non-static methods are called through objects of a class and you need to create an object before you can call them. In contrast, static methods can be called without creating a particular instance of an object.

User input is an important part of any user program. While this course will not go into a lot of detail on user input, it is important to understand the basics to help make interactive programs.

User input in this course will be accomplished using a scanner object. A scanner object is a type of variable that allows you to read from the console.

Here is the basic setup for using the scanner.

import java.util.Scanner;
class MyProgram 
{
    public static void main(String[] args) 
    {
        Scanner input = new Scanner(System.in);
     }
}

Notice that the program imports the Scanner from the java.util library. Java uses import statements to load additional libraries that are not available by default.

Once imported, you create an input variable using the Scanner class. In this case, the scanner is reading from System.in which is the console.

After creating the scanner object, you can then use the variable to read different values in from the user. Depending on the value type, you use will use a different method to import the value.

Let’s take a look at an example with the Rectangle class below.

Notice in this example how the two objects, r1, and r2 are created using the Rectangle constructor. To call the printArea() function, the dot operator is used along with the object name.

It is important to note that an object must be instantiated to call a method. If the object is only declared, any attempt to call a method on that object will result in a NullPointerException being thrown. For example:

Rectangle r1;  // Declared but not instantiated
r1.printArea();  // Will throw NullPointerException

Since a void method doesn’t have a return type, it must be called as a separate call, not as part of an expression. As you saw in the example above, the printArea() method was called on a separate line. Calling it to assign a value or as part of a print statement will cause an error.

Rectangle r1 = new Rectangle(10, 2);
r1.printArea(); // Valid
double a = r1.printArea();  // Invalid since printArea doesn't return a value
System.out.println(r1.printArea()); // Also invalid","Which of the following is a correctly written method for the class below?

public class Alarm 
{
    private int startMin;
    private int length;

    public Alarm(int minute, int duration)
    {
        startMin = minute;
        length = duration;
    }

    public Alarm(int duration)
    {
        startMin = 0;
        length = duration;
    }
}","public void addTenMinutes()
{
    length = length + 10;
}","public addTenMinutes()
{
    length = length + 10;
}","addTenMinutes()
{
    length = length + 10;
}","public void addTenMinutes
{
    length = length + 10;
}"
codehs-csa-void-method-with-parameters,"As you saw in the section above, you can use methods to help control and define procedures for your objects. In the last section, you looked at methods that took no input and returned no values. In this section, you are going to look at methods that take an input value, but do not return a value.

Recall that methods are like blocks of code that do a particular thing. You can write a method that prints out “hello” when called or a method that draws a circle. But what if you want to create a method to add ten to a number?

You would expect an addTen() method to add 10 to any number it is given. If you give it 3, the method will give us 13. Were you to give it 32, it would give us 42. This pattern can be generalized even more: if you give the method any number x, it will give us x + 10 in return. The action that the addTen() method takes is the same every time – it adds 10 – the only thing that changes is the number you give to the method. The number that you pass to the method is called a parameter.

Let’s write the addTen() method in code:

public void addTen(int x)
{
  int xPlusTen = x + 10;
  System.out.println(xPlusTen);
}

Notice that there is an x that is being taken in and used by the method. This is the parameter. Its value will be whatever the user decides to “pass” to the method. Also, note that the x parameter can be used as a regular variable in the body of the method.

Now that the addTen() method is defined, it’s time to call the method. Let’s first add ten to the number 5:

addTen(5);

This will result in 15 being printed to the console.

This works with variables as well. You can create a variable y that stores a number, then pass y to the addTen() method:

int y = 115;
addTen(y);

The variable 115 is passed as an argument to the addTen() method. The method accepts 115 as the parameter, adds 10 to it, and then prints 125 to the console. Note that the argument type needs to match the parameter type.

When we pass an argument to a method, it is said to be passed by value, which means a copy of that argument is made to use in the method. As a result, any change to the formal parameter will not be reflected in the actual parameters from the original calling function.

It’s often helpful to write methods that can take in more than one parameter. For example, if you were to write a generic add() method, you would want to be able to input two numbers. To include more than one parameter, you can simply write more than one parameter, separated by a comma. The code below takes in two numbers, represented by x and y, and adds them:

public void add(int x, int y)
{
  int sum = x + y;
  System.out.println(sum);
}

You call the method in a similar manner. If you give the function the following calls:

add(10, 90);
add(635, 1000);
int first = 72;
int second = 14;
add(first, second);

then the program will print the following to the console:

100
1635
86

Using parameters allows us to write code that is flexible and reusable. Writing a method is like telling the program to do something (for example, add two numbers or draw a rectangle on the canvas). Parameters are like giving that method specific instructions (“I want to add 3 and 7” or “I want my greeting message to say their name and my name”).

For example, if you wanted to print several greetings, you’d likely want them to contain different text depending on the person receiving the greeting. If each of these pieces of information was hard-coded into the method, you would need a separate method for each greeting!

Using parameters allows you to write one printMessage method that can be used to send many greeting messages:

public void printMessage(String to, String from, String salutation, String message)
{
  System.out.println(""-------------"");
  System.out.println(salutation + "" "" + to + "","");
  System.out.println(message);
  System.out.println(""Best regards,"");
  System.out.println(from);
  System.out.println(""-------------"");
}

If Karel wants to send a birthday message to Bill Gates and a Halloween card to Steve Wozniak, Karel could write:

printMessage(""Bill Gates"", ""Karel"", ""Howdy"", ""Wishing you a happy birthday!"");
String halloweenMessage = ""Hope you have a spooky Halloween!"";
printMessage(""Steve Wozniak"", ""Karel"", ""Hi"", halloweenMessage);
Java
This would print two letters to the console:

-------------
Howdy Bill Gates,
Wishing you a happy birthday!
Best regards,
Karel
-------------
-------------
Hi Steve Wozniak,
Hope you have a spooky Halloween!
Best regards,
Karel
-------------

It’s very important to pass arguments to methods in the proper order. Using the printMessage example above, you may know that Karel is the name of the person sending the message and that you want it to start with “Howdy”, but the computer does not know this information. The way that the computer finds out which argument goes to which parameter is by the order in which your code passes the arguments into the method.

For example, if you wrote:

printMessage(""Howdy"", ""Karel"", ""Wishing you a happy birthday!"", ""Bill Gates"");

you would end up with a mixed-up message:

-------------
Wishing you a happy birthday! Howdy,
Bill Gates
Best regards,
Karel
-------------
Plain text
As you can see, order matters when you are using parameters.

As you saw with constructors, you can also overload methods. Recall that a method signature consists of the method name and the ordered list of parameter types. You can overload a method by giving the method the same name as another method, but a different signature by having a different ordered list.

Here is an example of a proper overload:

public int add(int a, int b) {  }
public int add(int a, int b, int c) {  }

Notice in the example above how one method takes two integers as an input and the other takes 3 integers. It is important to note that the variable names do not make a difference, it is only the type and order of the parameters. Given a method signature like this:

public int add(int x, int y, int z) {  }

The above would not overload the methods above since there is already a method that takes three integers. Changing the variable names doesn’t impact whether a method is overloaded.","Suppose there is a class called Athlete. One of the methods is given below. It sets the instance variable isAllStar to the parameter value.

public void setAllStarStatus(boolean status)
{
    isAllStar = status;
}

Using the Athlete object called karel, which of the following is the correct way to set karel’s all-star status to false?",karel.setAllStarStatus(false);,karel.setAllStarStatus(status=false);,karel.isAllStar = false;,karel.setAllStarStatus(isAllStar = false);
codehs-csa-nonvoid-method,"Similar to how methods can take in values as parameters, methods can also return values.

Recall the addTen() method from the previous section:

public void addTen(int x)
{
  int xPlusTen = x + 10;
  System.out.println(xPlusTen);
}

This method takes in a parameter, x, and adds 10 to it. Lastly, the program prints the value to the console.

But what if you wanted to store the value of x + 10? In the method above, x + 10 is stored into a local variable called xPlusTen. However, this variable is lost when the method is finished – it cannot be accessed outside of the method.

Using a return statement will allow you to pass a value back out of the method. That return value can be stored into a variable for later use.

Here’s how to rewrite addTen() to return a value instead of printing:

public int addTen(int x)
{
  int xPlusTen = x + 10;
  return xPlusTen;
}

There are a few differences here.

First, the return statement on line 4 replaces the print statement and does not require parentheses. Second, take a look at the first line of the method: public int addTen(int x). Instead of void, you now use int. This tells the program that the addTen() method will return a value that is an int. This is called the return type of the method.

Non-void methods return a value that is the same type as the return type in the signature. To use the return value when calling a non-void method, it must be stored in a variable or used as part of an expression. Up to this point, you’ve only used the void return type, which indicates that the method does not return anything. Because the addTen() method will return an integer, you set the return type to int.

When returning a value, it’s important to note that that method is not printing the value to the console, but rather sending back to the method call statement. This is similar to how passing in a value as an argument does not print the value to the console.

A return value by itself would not be very useful, given that it does not print to the console. Fortunately, you can store a method’s return value into a variable. Take a look at the following code:

int num = 7;
int tenAdded = addTen(num);

First, you create a variable named num and initialize it to 7. Then, you create another variable called tenAdded. Notice that tenAdded is not given a normal value. Instead, you are setting it equal to addTen(num). This means that the tenAdded variable will hold the result of whatever the method call addTen(num) returns. You know that addTen(num) will return 17, so tenAdded will be 17.

Return values work in many situations. For example, you can rewrite the add method from the previous section to return the sum instead of print it to the screen:

public int add(int x, int y)
{
    int sum = x + y;
    return sum;
}

You can now call the method and store its return values

int sum = add(10, 90);
System.out.println(sum);

which would print 100 to the console.","Suppose you have a class called Rollercoaster. The Rollercoaster class has a method called goingDown, partially defined below

public boolean goingDown()
{
    // code omitted
}

Which of the following statements correctly stores the return value of goingDown when it is called on the Rollercoaster object called ferrisWheel?",boolean down = ferrisWheel.goingDown();,int down = ferrisWheel.goingDown();,double down = ferrisWheel.goingDown();,String down = ferrisWheel.goingDown();
codehs-csa-string-objects,"As you have learned, a character is one of the primitive data types in Java. You use the char keyword to declare it. A character is a single letter. 'A', 'a', 'D', and 'Z' are all examples of characters. It is great that you have an easy way to represent a single character, but what if you wanted to represent words or sentences? How can you do this?

A String is a sequence of characters. You use Strings to represent full words and sentences. For example, the famous ""Hello World"" is a String. Some more examples of Strings:

""I am a String. A sequence of characters strung together to form words and/or sentences.""
""CodeHS is the best coding website ever! Everyone loves CodeHS!""
""She sells seashells by the seashore.""
""Strings!""
""abcdefghijklmnopqrstuvwxyz""

A String is not a primitive type like int, char, boolean, and double. Primitive types always start with lowercase letters, but a String starts with a capital letter. This makes it an object.

You can create Strings using a string literal or calling the String constructor. A string literal is a string inside of quotes, as you saw above. The String constructor takes a string literal as an input.

String strLiteral = ""karel""; // String Literal
String strConstr = new String(""karel""); // String constructor

Both options will create a String variable. The constructor method will force Java to create a new String value in the heap, while the String literal may allow Java to reuse an existing value in the heap.

Concatenate is a fancy word for joining or linking two things together. To concatenate two or more Strings means that you are joining them together to form one String. You can do this in Java by using the addition operator, +, or +=.

In this example, you concatenate two separate Strings, ""Mc"" and ""Donald's"", to form one String, ""McDonald's"".

String one = ""Mc"";
String two = ""Donald's"";
String concatenate = one + two;
System.out.println(concatenate);

After running the program, the concatenated String ""McDonald's"" gets printed to the screen.

It is important to note that String objects are immutable, meaning that strings cannot be changed by methods or concatenation. Instead, when you run methods or concatenate values with Strings, you are actually overwriting the existing String with a new String.

You are not limited to concatenating strings with other strings. You can concatenate Strings with other data types. Here you are concatenating a string and an integer together:

int number = 24;
System.out.println(""This String is concatenated with an integer at the end: "" + number);

Look familiar? You have been doing this all the time in previous programs when printing out results to the screen! After running the program, you get:

This String is concatenated with an integer at the end: 24
Plain text
You can also concatenate Strings with other primitive types like char, boolean, and double. When you concatenate a String with a primitive variable, there is an implicit conversion of the primitive variable to a String to perform the conversion.

In Java, you create string literals using quotation marks, but what if you want to print a string with quotes, for example ""Hello, Karel,"" said Tracy.

Java uses the concept of an escape sequence to essentially send a signal to the compiler to treat a character a little differently. In Java, the escape character is a backslash, \. When Java sees a backslash inside of quotation marks, it knows that it is a signal to treat the next character differently within the literal string. For example, if you want to include quotation marks in your output, you would use a \"".

// Print ""Hello, Karel,"" said Tracy
System.out.println(""\""Hello, Karel,\"" said Tracy"");
","What would be printed by this code snippet?

String subject = ""Computer Science"";
String opinion = "" is for everyone!"";

System.out.println(subject + opinion);",Computer Science is for everyone!,Computer Science,Computer Scienceis for everyone!,This code would not compile. You can’t add Strings.
codehs-csa-string-methods,"In this section, you will examine the different methods that can be run on String objects to create new, transformed String objects. You will also take a look at how Java uses libraries and documentation to help programmers implement more complex programs.

Like physical town libraries, Java libraries and APIs (Application Programming Interface) are collections of written works made by other authors. An API is typically used to interface two systems and make using them easier. For example, if you wanted to program a robot in Java, you may use a set of commands from an API to control the motors. In contrast, libraries tend to be extensions of the main programming language that can help simplify your code since it takes common tasks and allows you to implement them without having to write out your own code.

Libraries can be broken down into a series of packages. Each package is then subdivided into specific classes with specific methods that can be run for that class.

To help you do this, Java provides documentation. Documentation for APIs and libraries are essential to understanding the attributes and behaviors of an object of a class. This section will focus on the Java String documentation, but you can find all the documentation for Java here: https://docs.oracle.com/javase/8/docs/api/

As a note, String objects are found in the java.lang package and are available by default in your programs.

Just like you can concatenate primitive data types with strings, you can also concatenate reference data types with strings. In doing so, the reference data type’s toString() method gets called and concatenated to the existing String. The toString() method provides the string representation of the given object and is called anytime the object is referenced where it needs to be shown as a string, for example in a print statement.

Let’s look at an example of the Nickname class.

public class Nickname
{
  private String firstName;
  private String lastName;
  private String nickname;
  public Nickname(String realFirstName, String realLastName, String moniker)
  {
    firstName = realFirstName;
    lastName = realLastName;
    nickname = moniker;
  }
  public String toString()
  {
    return firstName + "" ("" + nickname + "") "" + lastName;
  }
}

Any Nickname object that is created has three different instance variables, so how does Java know what to use when you want to print out the name? It uses the toString() method. For example, if you create an object like this:

Nickname karel = new Nickname(""Karel"", ""Dog"", ""the Dog"");

Then print the object using the following statement:

System.out.println(karel);

You will get the following out:

Karel (the Dog) Dog

Notice in the example above that you don’t specifically call the toString() method. The method is called implicitly when you use the object in a situation where a string is needed.

If you want to concatenate the output with another string, you can.

System.out.println(karel + "" went to a movie."");

Results:

Karel (the Dog) Dog went to a movie.

You will remember that strings are a sequence of characters. Let’s look at this example String below:

String str = ""Hello World"";

Each character in this string has a position from 0 to 10. For example, the first character, 'H', is at position 0. The second character, 'e', is at position 1. The last character, 'd', is at position 10. Note that the space between the two words, ' ', is also a character and is located at position 5.

A character’s particular position in a string is formally known as its index. A String object has index values from 0 to the length of the string - 1. Attempting to access indices outside this range will result in an IndexOutOfBoundsException.

Many useful String methods make use of the string’s index value. While there are many different String methods, there are several that are widely used within the AP Java programming course.

String str2 = new String(str)	Constructs a new String object that represents the same sequence of characters as str
name.length()	Returns the number of characters in a String object
name.substring(2, 6)	Returns the substring beginning at index 2 and ending at index 5.
name.substring(index, index + 1)	Returns the string identical to the single element substring at position index
name.indexOf(""d"")	Returns the index of the first occurrence of d; returns -1 if not found.
name.equals(""Karel"")	Returns true if name is equal to Karel; returns false otherwise
name.compareTo(""Karel"")	Returns a value < 0 if name is less than Karel; returns zero if name is equal to Karel; returns a value > 0 if name is greater than Karel.",What method must a class implement in order to concatenate an object of the class with a String object?,toString,A constructor,length,print
codehs-csa-wrapper-classes,"As you saw with strings, using Java packages can make your program easier to implement. In this section, you are going to explore two other members of the java.lang package, the Integer and Double classes.

A wrapper class in Java is a class that contains or “wraps” primitive data types as an object. You will find wrapper classes for all of our primitive data types. One thing to note about the wrapper classes is that they have similar (if not the same) names as the primitive data types, but they all begin with capital letters.

The wrapper classes in Java actually serve two purposes. First, as their name implies, they can take primitive data types and convert them into an object. Later in the course, you will see some examples of when you need to use an object representation of primitive data.

Second, wrapper classes provide static methods that allow you to perform some basic number operations, such as converting data from a string to a number. This means you can do some basic operations without creating an instance of the object. This section will take a closer look at some of these methods within the Integer and Double classes.

Creating wrapper objects, such as Integer and Double objects can be done in a similar way to other objects. The constructor takes a single value and converts it into the object version of that value.

Integer y = new Integer(17);
Double z = new Double(3.14);

Fortunately, you don’t need to explicitly create Integer and Double objects every time you need to use them. Java provides a process called autoboxing. Autoboxing is the automatic conversion that the Java compiler makes between primitive types and their corresponding object wrapper classes. This includes converting an int to an Integer and a double to a Double.

The Java compiler applies autoboxing when a primitive value is passed as a parameter to a method that expects an object or if a primitive value is assigned to a variable of the corresponding wrapper class.

Similarly, Java has a process for unboxing. Unboxing is the automatic conversion that the Java compiler makes from the wrapper class to the primitive type. This includes converting an Integer to an int and a Double to a double. The Java compiler applies unboxing when a wrapper class object is passed as a parameter to a method that expects a value of the corresponding primitive type or a wrapper class object is assigned to a variable of the corresponding primitive type.

In addition to creating objects, the wrapper classes also provide several useful methods, some of which are static. As a reminder, a static method is a method that can be used without creating an instance of the object. You use the class name followed by a dot and the method name to call static methods.","Java automatically converts between objects and primitives in the process of autoboxing and unboxing.

What happens when an Integer is unboxed?",An Integer is unboxed when it is converted to a primitive value.,An Integer is unboxed when it is converted to a Double.,An Integer is unboxed when it is passed to a method.,An Integer is unboxed when it is converted to an Integer value.
codehs-csa-math-class,"In this section, you are going to take a look at another class in the java.lang package, the Math class. The Math class is a class that only contains static methods that are used for specific purposes.

Several of the methods that are used from the Math class perform basic math functions. These are listed in the table below.

Math.abs(x)	Returns the absolute value of x. This can take either an int or a double.
Math.pow(base, exponent)	Returns the value of base raised to the power of exponent.
Math.sqrt(x)	Returns the positive square root of x.

As a reminder, since the math class contains only static methods, you do not need to instantiate an object to use it. Static methods are called using the dot operator along with the class name.

Another useful method from the Math class is the random method. The random method takes no input and returns a random number from zero to one, inclusive of zero, but not inclusive of one.

// Generate a random number
double ranNum = Math.random();

Now you may be thinking that a random number between zero and one is not that useful, however, the number can be manipulated to generate a random number in any range. Using three basic operations, you can convert the output of Math.random() into any random number you need.

Multiply - By multiplying the results of Math.random(), you can create values from 0 up to (but not including) the number you multiple by.

// Generates a random value from 0 to 10
double ranNum = Math.random() * 10;

Add - Adding to the results offsets the range that you will get from the random number.

// Generates a random value from 100 to 110
double ranNum = Math.random() * 10 + 100;

Casting to an integer - Finally, if you cast the value to an integer, you will truncate the value and only have random whole numbers.

// Generates random integers between 50 and 75 (not including 75)
int ranNum = (int)(Math.random() * 25) + 50;

Watch out! Be careful, a common mistake that programers make is to cast the value at the wrong place. You must include the multiplier inside parentheses along with the random call. If you do not, you will end up casting only the Math.random() part, and since it is always less than one, your random function will always result in zero. The offset addition operation can either be inside or outside the parentheses.

// Same as above, but without the parentheses
// The result is zero every time
int ranNum = (int)Math.random() * 25 + 50;","What range of numbers would be generated by using:

int num  = (int) (Math.random() * 201);",0 - 200,"
1 - 200",1 - 201,0 - 201
codehs-csa-boolean-expressions,"How do you write code that tells us whether a user is logged in to our program? Booleans are the solution to these questions.

A boolean refers to a value that is true or false. Those are the only values of a boolean expression, and these are useful if you want to check if something is true or false.

Let’s meet the fellow behind the name, “booleans,” George Boole. Mr. Boole was an English-born mathematician, philosopher, and logician. He introduced boolean algebra in The Mathematical Analysis of Logic (1847) and Investigation of the Laws of Thought (1854). Many consider him to be one of the founders of Computer Science.

Let’s start with an example – create a variable, set it equal to true or false, then print the value.

You first want to declare the variable, loggedIn, and initialize its value.

boolean loggedIn = false;

You can similarly set the variable to true instead:

boolean loggedIn = true;

You can imagine a boolean variable as a box that can hold only the values true or false.

Notice that you do not need to have quotations around true or false.

The full example looks like:

boolean loggedIn = false;
System.out.println(""User logged in?: "" + loggedIn);

Comparison operators allow you to compare two values against one another. A comparison returns a boolean result of either true or false.

The table below lists each of the common comparison operators and their usages:

Operator	Usage
>	Greater Than
<	Less Than
>=	Greater Than Or Equal To
<=	Less Than Or Equal To
==	Equal To
!=	Not Equal To

In the following example, you compare two variables x and y. You store the result of this comparison in variable z.

int x = 10;
int y = 8;
boolean z = x > y;
System.out.println(z);

What will get printed to the screen? The above comparison, x > y is evaluating if 10 is greater than 8. Because 10 is indeed greater than 8, z is assigned a value of true. Thus, true will get printed to the screen.

Let’s get a little more practice. Take a look at the following code segment below. Pay close attention to each comparison and the operator being used.

// Declare some integer variables to use for practice comparisons below.
int a = 3;
int b = 5;
int c = 2;
int d = 3;

// You store the boolean results of each comparison into boolean variables t-z.
boolean t = a > 0; // true
boolean u = a == d; // true
boolean v = d >= b; // false
boolean w = b > c; // true
boolean x = a != d; // false
boolean y = d < = a; // true
boolean z = 4 < = c; // false

In addition to integers, it is possible to compare other data types too. In the example below, the boolean variables are storing the results of a comparison between some of the boolean values computed above.

boolean boolComparison1 = t == u; // true
boolean boolComparison2 = t == w; // true
boolean boolComparison3 = t != u; // false
boolean boolComparison4 = x != y; // true

Suppose you want to write a program that restricts people under a certain height from riding on a roller coaster. For this particular roller coaster, people who are under 4 feet (48 inches) are not allowed on the ride. How would you do this?

int heightInInches = readInt(""How tall are you (in inches)? "");
boolean isTallEnough = heightInInches >= 48;
System.out.println(""Can ride on the roller coaster: "" + isTallEnough);

After getting the potential rider’s height in inches, you do a comparison to ensure that they are over 48 inches. The result of this comparison is then printed out.

A common mistake is using = when you actually want to use ==. = is used for assignment of variables whereas == is used for comparing the equality of two values.
For example, x = 5 stores the value 5 into the variable x. However, x == 5 tests to see if the value 5 is equal to the variable x and then returns either true or false. They are not the same thing!",Which of the following is NOT a relational operator?,=,>,!=,<=
codehs-csa-if-statements,"In the previous section, you learned all about logical operators and comparison operators. These form the basis for writing boolean expressions in if statements.

The if statement is a conditional statement that can be used to alter the flow of a program. You use if statements to run a segment of code only if some boolean expression first evaluates to true.

An if statement takes the following basic form:

if (boolean expression)
{
   // Segment of code that will run if the boolean expression is true
}

If the boolean expression evaluates to false, nothing will happen. The code within the if statement is ignored.

As mentioned above, the if statement affects the flow of the program and the code that executes based on whether the boolean expression evaluates to true or false.

if statements by themselves are known as a one-way selection. A set of statements only executes if the condition of the boolean expression is true.","What is the output of this program?

int phLevel = 7;
if(phLevel < 7)
{
    System.out.println(""It is acidic!"");
}
if(phLevel > 7)
{
    System.out.println(""It is basic!"");
}
if(phLevel == 7)
{
    System.out.println(""It is neutral!"");    
}",It is neutral!,It is acidic!,It is basic!,"It is acidic!
It is basic!
It is neutral!"
codehs-csa-if-else-statements,"In the previous section, you saw how an if statement allowed you to use a conditional statement to determine if a block of code would be executed. In this section, you are going to extend that concept into an else statement.

You can add the else keyword to our if statement block. Using an else statement allows for a two-way selection, a set of code to execute if the statement is true and another set of code to execute if the statement is false.

In this case, if the boolean expression in our if statement evaluates to false, the code within the else segment will run. If the boolean expression evaluates to true, the code within the if segment will run.

if (boolean expression) {
   // Segment of code that will run if the boolean expression is true
}
else {
   // Segment of code that will run if the boolean expression is false
}","Consider the following code snippet

if ( x == y)
{
    // Statement A
} 
else 
{
    // Statement B
}

Which statement will be executed if x = 20 and y = 15?",Statement B,Statement A,Statement A and Statement B,Neither Statement
codehs-csa-else-if-statement,"Building on the previous two sections, you are going to look at adding the else if clause to our if blocks. The else if clause allows for a multi-way selection by using different conditional statements to represent different conditions.

You can add the else if keyword between your if and your else statement. If boolean expression one evaluates to false, then boolean expression two gets evaluated next. If boolean expression two also turns out to be false, the code within the else segment will run.

if (boolean expression one) {
   // Segment of code that will run if boolean expression one is true
}
else if (boolean expression two) {
   // Segment of code that will run if boolean expression one is false and two is true
}
else {
   // Segment of code that will run if boolean expression one and boolean expression two are both false
}

It is important to note that you can have as many else if statements as you want, or you can have none. When looking at conditional blocks of code, the only required statement is the if statement. This can optionally be followed with any number of else if statements, and then optionally one else statement.","What is the output of the following code snippet?

double ticketPrice = 15.75;

if(ticketPrice > 15)
{
   System.out.println(""Too expensive!"");
}
if(ticketPrice > 10)
{
   System.out.println(""Typical"");
}
else if(ticketPrice > 5)
{
   System.out.println(""Great deal!"");
}
else 
{
    System.out.println(""Must be a scam"");
}","Too expensive!
Typical",Must be a scam,Typical,Too expensive!
codehs-csa-compound-boolean,"In the previous sections, you looked at how boolean expressions can be used in an if-else if-else statement. In this section, you are going to take a step back and look at the boolean expressions used in those conditional statements.

Boolean variables can only take on one of two possible values, true or false. Logical operators allow you to combine and connect booleans in useful ways. When you use logical operators, the resulting expression will result in a single boolean value.

There are three fundamental logical operators:

- NOT
- OR
- AND

These should look quite familiar; in fact, you use them in speech every day! The NOT operator is used on a single boolean, whereas AND and OR are used across multiple boolean values.

Logical operators can be used to help avoid nested if statements. A nested if statement consists of an if statement within an if statement. For example:

if (temp > 70) {
    if (sunny) {
        System.out.println(""Time to get outside!"");
   }
}

Using logical operators, you can condense a nested if statement into a single statement, for example:

if (temp > 70 && sunny) {
    System.out.println(""Time to get outside!"");
}

AND is represented in Java as: &&. An expression using AND is true only when all its component parts are true. If any of the boolean values are false, the whole expression evaluates to false.

For example, if it is 6:30am AND it is a school day, you should wake up. You can test the expression of “6:30am AND a school day.” If both are true, then the whole expression evaluates to true. If either or both are false, then the whole expression is false, and you should stay in bed.

boolean sixThirty = true;
boolean schoolDay = false;
System.out.println(sixThirty && schoolDay);  // because both values aren't true, it prints ""false""

For variables p and q that can be true or false:

p	q	p AND q
true	true	true
true	false	false
false	true	false
false	false	false

OR is represented in Java as ||. An expression using OR is true when all or any of its parts are true. It is only false when all of the boolean values are false.

Say that you are trying to decide whether to wear a coat today. You’ll wear your coat if it is raining right now or if it is cold outside. You can evaluate this expression based on the answers to those two boolean values. If it’s raining, cold, or raining and cold, then you will wear your coat. The only case in which you would not wear your coat is if it’s neither raining nor cold.

boolean isRaining = true;
boolean isCold = false;
System.out.println(isRaining || isCold); // it's not cold, but it is raining, so it prints true

For variables p and q that can be true or false:

p	q	p OR q
true	true	true
true	false	true
false	true	true
false	false	false

Since AND expressions evaluate to false if any condition is false, and OR expressions will evaluate to true if any condition is true, there is a shortcut that Java uses to make your programs run more efficiently. If the first value of the boolean expression is false in an AND operation, or the first value is true in an OR operation, the remaining conditions are irrelevant!

Because these expressions will always evaluate to false and true respectively, regardless of what the other expression evaluates to, Java will not evaluate the second expression. This process of skipping the second condition in a boolean expression is called short circuit evaluation.

Expression	Result
first && second	If first is false, then the whole expression must be false. Don’t bother evaluating second.
first || second	If first is true, then the whole expression must be true. Don’t bother evaluating second.

NOT is represented in Java as !. When placed in front of a boolean value, NOT causes the boolean to take on its opposite value. For example “NOT true” gives the answer “false.” This is fairly intuitive – if something is not true, then it must be false. Similarly, if something is not false, then it must be true.

The example below sets up a variable hungry as being true. Then it prints out NOT hungry.

boolean hungry = true;
System.out.println(!hungry);  // prints ""false""

For a variable p that can be true or false:

p	!p
true	false
false	true

Just like mathematical expressions have an order of operations, boolean operators also follow an order of operations. In the case of Booleans, the ! operator takes precedence over &&, and && takes precedence over ||. Here is an example:

boolean a = true;
boolean b = false;
boolean c = a && b || b

In this example, c evaluates to false. The first part of the expression to be evaluated would be the a && b since AND takes precedence over OR. Since that part evaluates to false, the expression short circuits and returns false.",Which of the following will result in a logical short circuit assuming a is true and b is false?,a || b,a && b,b || a,!b && a
codehs-csa-equivalent-boolean,"In this section, you will apply some of the concepts of booleans and logical expressions as you evaluate expressions to determine whether they are equivalent.

Augustus De Morgan was a British mathematician who devised two laws to help understand equivalent boolean expressions.

- not(A and B) is the same as (not A) or (not B)
- not(A or B) is the same as (not A) and (not B)

Collectively these two laws are known as De Morgan’s Law. At the heart of these laws, De Morgan is saying that you can transform one expression into an equivalent expression. In terms of boolean expressions, you saw that 2 expressions are equivalent if they both evaluate to the same value for all cases. In the case of De Morgan’s law, that means that regardless of whether A is true or false and B is true or false, not(A and B) will always be the same as (not A) or (not B). Likewise, not(A and B) will always be the same as (not A) and (not B).

To help better understand De Morgan’s Law, you can use truth tables. Truth tables look at various values of boolean variables and expressions and can be used to prove boolean identities such as De Morgan’s Law.

De Morgan’s First Law states that not(A and B) is the same as (not A) or (not B). If you were to put this in terms of Java, it would look like this:

!(A && B) == !A || !B

Let’s break this down in a truth table.

A	B	A&&B	!(A&&B)	!A	!B	!A || !B
T	T	T	F	F	F	F
T	F	F	T	F	T	T
F	T	F	T	T	F	T
F	F	F	T	T	T	T

Notice in the table above how our two columns that contain expressions show the same values for each expression for all 4 possible combinations of values for A and B. As a result, you can see that the two expressions are equivalent.

Turning now to De Morgan’s Second Law, you can do the same thing. Expressed as a Java expression, De Morgan’s second law states:

!(A || B) == !A && !B

Let’s take a look at the truth table for this law.

A	B	A||B	!(A||B)	!A	!B	!A && !B
T	T	T	F	F	F	F
T	F	T	F	F	T	F
F	T	T	F	T	F	F
F	F	F	T	T	T	T

Again, if you focus on the two highlighted columns, you can see that the two sides of the expression in De Morgan’s second law are also equivalent.

Truth tables can be powerful tools to help determine if two or more expressions are equivalent. To use a truth table, it is best to break down expressions into small pieces and then build them back up. Let’s take a look at this expression:

A && !B || !A && B 

Under what circumstances would this expression evaluate to true? You can use a truth table to answer that question. You should lay the truth table out to follow the order of operations, which means you will evaluate the NOT operators first, then the AND operators, and finally the OR operator.

A	B	!B	A && !B	!A	!A && B	A && !B || !A && B
T	T	F	F	F	F	F
T	F	T	T	F	F	T
F	T	F	F	T	T	T
F	F	T	F	T	F	F

When you lay out the results in a truth table, it is easy to see that the expression will evaluate to true anytime A and B have opposite values.","Which of the following logical statements is equivalent to

!(A || B)

Where A and B are boolean values.",!A && !B,A && B,!A || !B,!A || B
codehs-csa-comparing-objects,"In this section, you are going to look at how to compare objects. As you may recall from previous sections, objects, or reference variables, differ in several ways from primitive variables. The important difference that you will explore in this lesson is the way that the values are stored. Recall that primitive variables store actual values for the variable while objects store a reference to the memory location of the value.

The == comparison operator is designed to compare the value of two variables. Since the value that is stored for a reference variable is the memory location, using == will return whether or not the two objects have the same reference. When two objects have the same reference, they are said to be aliases.

If the objects are aliases of one another, then you know that they will also be equal.

Take a look at the example below:

Rectangle one = new Rectangle(3,7);
Rectangle two = one;

boolean same = one == two; // Will be true

In this example, the two rectangles are the same and they are also aliases of one another. As a result, comparing the objects with == returns true.

You can also do this comparison with != to check if two objects are not aliases, and both can be used to compare to null to determine whether the reference is actually to an object.

Rectangle three;
boolean isSet = three != null; // Will be false

In this example, you can see the isSet variable will be set to false since variable three has not yet been set to reference an object.

Using == allowed us to find if two reference variables were aliases, but what if you want to find if two reference variables are the same?

For example:

Rectangle one = new Rectangle(3,7);
Rectangle two = new Rectangle(3,7);

Are rectangles one and two the same? In this case, they appear to be, however, if you test them with ==, Java will return false. Why is that?

Recall above that you saw how == compares the memory locations of the variables. Since both rectangles were instantiated as separate objects, they are stored in a different place in memory, so using == will return false.

Objects can have several pieces of information associated with them. As a result, an object needs to have a specific method that can be used to determine if they are equal. For example, what would make two rectangles equal? Would it be that the rectangles have the same dimensions or can two rectangles be equal if they have different dimensions, but the same area?

In Java, the method that is used is called .equals(). This method is called from a variable and it passes a parameter to compare to in order to determine if the values are equal.

If you assume that one rectangle equals another rectangle if they have the same width and height, then .equals() can return true if the method compares the width and height of two rectangles and finds them to be the same.

Take a look at the example below:

Rectangle one = new Rectangle(3,7);
Rectangle two = new Rectangle(3,7);
boolean isAlias = one == two; // Will be set to false
boolean isEqual = one.equals(two); // Will be set to true

In this example, you can see that one and two are not aliases of one another. If you compare them with the comparison operator, it will return false. Since both rectangles were created the same way, it seems logical that they are in fact equal and by using the .equals(), you can see that this is the case.",What is the proper way to compare String values in Java?,The .equals() String method,The = operator,The == operator,The && operator
codehs-csa-while-loops,"while loops are a way to change the flow of control by repeating a block of code so long as some condition remains true. The condition is written in the form of a boolean expression.

The basic structure of a while loop is shown below.

while(boolean expression)
{
   // code block inside of while loop to execute if the boolean expression is true
}
   // code outside of while loop to execute if the boolean expression is false

As long as the boolean expression remains true, code within the while loop will be executed. The moment that the boolean expression becomes false, code outside of the while loop will be executed; the loop is done.

The boolean expression evaluates before the loop executes each time, including the first time. It is possible that the condition is false initially and the loop body is never executed.

Here is a basic example of a countdown.

int i = 5;
System.out.println(""Initiating countdown:"");
while(i >= 0) {
  System.out.println(i + ""..."");
  i--;
}

You first declare a variable i and set it equal to 5. Before the while loop, you print out a message letting the user know that the countdown is about to begin. Your while loop starts by checking to see if the boolean expression, i >= 0, is true. The current value of i is 5. 5 >= 0 is true, so the code within the while loop gets executed. It prints out the number 5 and then decrements it by subtracting 1.

i is now set to 4. Our while loop then checks to see if 4 >= 0. Since this condition is still true, the code within the while loop gets executed again. This will continue until i gets down to 0. After 0 gets printed to the screen, you decrement i so that it is now set to -1. Your while loop tests to see if -1 >= 0. Since -1 is not greater than or equal to 0, the boolean expression is false. The code within the while loop is skipped. The while loop has finished its execution.

After you run the above program, this is what gets printed to the screen:

Initiating countdown:
5...
4...
3...
2...
1...
0

You must exercise caution when using while loops to avoid the dreaded infinite loop. An infinite loop is a loop that always evaluates to true and therefore, never terminates. It never finishes its execution. It will continue to repeat until the end of time! Infinite loops will often cause a program to freeze and crash.

The countdown program above has been rewritten below, but it is missing an essential line of code. This will cause an infinite loop:

int i = 5;
System.out.println(""Initiating countdown:"");
while(i >= 0) {
  System.out.println(i + ""..."");
}

But why? Why does this cause an infinite loop?

With the omission of i--, you are no longer changing our variable. i will forever be set to 5. Our while loop will repeatedly check to see if 5 >= 0. Since this condition is always true, the code within the while loop body will execute forever. The while loop will never terminate.

Your program will just keep printing a value of 5 over and over again. Thus, after running the program, your output will look something like this (assuming the browser does not freeze and crash):

Initiating countdown:
5...
5...
5...
5...
5...
5...
5...
5...
5...
5...
5...
5...
5...
5

[NOTE: This will continue printing “5…” forever!]

In the CodeHS editor, you can manually stop the program by clicking on the “STOP” button next to the “RUN CODE” button. Otherwise, it will continue spamming the number 5 at us until the end of time.

One way to break out of a loop, infinite or otherwise is to execute a return statement. If a while loop is set up to run in a method and a return statement is placed inside the while loop, executing the return statement will return the program to the original calling point, thus exiting the loop.

Here is an example:

int sumTo(int num) {
    int i = 1;
    int sum = 0;
    while (true) {
        sum += i;
        if (sum > num) {
            return i;
        }
        i++;
    }
}

In the example above, notice that you potentially have an infinite loop since true will always evaluate to true. The loop will not continue forever though. Once sum is greater than num the return statement will execute and exit the loop and the method.

As you start writing more and more programs, you will find many applications of while loops. You saw one application above where the while loop was used to sum numbers. Similar loops can be used to calculate average, mode, minimum, or maximum for a set of numbers.

Another application that is typically used with a while loop is to split out individual digits of a number. Here is an example of a loop that can do that.

int num = 345;

while (num > 0) {
  // get the first digit by using the mod function
  int digit = num % 10;
  System.out.println(digit);

  // Divide the number by 10
  num /= 10; // Integer division truncates the number
}

In the example above, notice how you can use mod and division to separate out each digit. If you start with the number 345, mod 10 returns the 5. When you then use integer division and divide 345 by 10, you get 34. Since 34 is greater than 0, the while loop executes again. Now the mod function splits off 4 and the division function reduces the number to 3. The program then enters the while loop again, printing out 3. When it divides 3 by 10, it gets zero. Now zero is no longer greater than 0, so the loop is complete.

Other uses of while loops include identifying if an integer is or is not evenly divisible by another integer and determining the frequency with which a specific criterion is met.","What will this while loop do?

while(false)
{
    System.out.println(""Welcome"");
}",Nothing,Print Welcome one time,Print Welcome until program receives user input,Print Welcome in an infinite loop
codehs-csa-for-loops,"Like while loops, for loops are a way to change the flow of control by repeating a block of code. for loops allow us to repeat code a fixed number of times.

A basic for loop is structured like this:

for (int i = 0; i < COUNT; i++) 
{  
    // Code segment that is executed COUNT times. 
}

A for loop can be divided into three major parts. The first part initializes the loop variable, the second part tests some condition and the third part increments or decrements the loop variable. Each part of the for loop is separated by a semicolon (;).

Let’s break down the following example into its three major parts:

Part 1: Initialize
The first part of a for loop initializes some variable. In the example above, int i = 0 initially sets the variable i equal to 0.

Part 2: Condition
The second part of a for loop tests a condition. If the condition is true, the code within the for loop executes. If the condition is false, the code within the for loop is skipped. In the example above, i < 3 compares the current value of our variable i to determine if it is less than 3. Each time i is less than 3, the value of i will be printed to the screen. This happens three times.

Part 3: Increment/Decrement
The third part of a for loop changes the variable after each time the loop runs. Remember, i++ means 1 is added to i. It is incremented. Conversely, i-- means 1 is subtracted from i. It is decremented.

When a for loop runs, each of the 3 parts runs in a particular order. The initialization step only runs one time before the boolean expression is evaluated the first time. After this, the boolean expression is evaluated and if it is true, the loop executes. After the loop execution, the increment/decrement statement executes before the is evaluated again.

What happens when you run the example for loop? What gets printed to the screen?

The first part of our for loop, int i = 0, initializes our variable. It sets our loop variable i equal to 0. Next, the condition part of the loop is evaluated. Is i< 3? Since i is currently set to 0, and 0 is indeed less than 3, the condition i < 3 is true. Thus, the code within the for loop is executed. 0 is printed to the screen. After this, i is incremented. i++ means you add 1 to i, so i is now set to 1.

Since i is now set to 1, the condition i < 3 is re-evaluated. It is still true. 1 is now printed to the screen. i is incremented again and becomes set to 2.

The condition i < 3 is re-evaluated. Since i is now set to 2, our condition is still true. 2 is printed to the screen. i is incremented again and becomes set to 3.

Finally, when the condition i < 3 is re-evaluated, our condition is false. 3 is not less than 3, so the code within the for loop is skipped. Nothing else gets printed. The for loop is done.

Thus, our output would be:

0
1
2

for loops and while loops can be interchangeable. A for loop can be rewritten as a while loop and vice versa. Take a look at the countdown while loop from earlier.

int i = 100;
System.out.println(""Initiating countdown:"");
while(i >= 0) {
  System.out.println(i + ""..."");
  i--;
}

In this countdown example, i is initially set to 100. The while loop checks the condition and insider the loop, i is decremented. The same process can happen in a for loop.

Each piece that you saw in the while loop is still present as one of the three parts of the for loop.

One thing to be cautious of is off by one errors. Off by one errors occur when your loop doesn’t start or stop at the correct place. Think about summing the numbers from 1 to 100. You may think of setting up your for loop like this:

for (int i = 1; i < 100; i++) {  ...  }

Doing so will cause an off by one error since you are missing the 100. Since you want to include 100, you need to use a <= (less than or equal) instead of just a less than. Here is a correct loop to sum the numbers from 1 to 100.","What does the following code print?

for (int i = 4; i < 8; i++)
{
   System.out.print(i + "", "");
}","4, 5, 6, 7,","4, 5, 6, 7, 8,","0, 1, 2, 3, 4, 5, 6, 7,",This code will produce an infinite loop.
codehs-csa-algorithm-using-strings,"You looked at several string methods that can be used for a variety of functions such as taking substrings, searching Strings, and comparing them to other Strings. In this section, you will take a look at several common algorithms that can be performed with Strings.

Traversing is the process of going through a String one character at a time, often using loops. for loops tend to be common for this type of task since the string length is fixed. Here is an example of a String traversal that will translate a string into a vertical column.

In this example, notice how you loop from 0 to less than the print length and then use the substring function to print the current index to the next index, which will print one character.

Using this idea, you can take a look at different algorithm examples.

One application of a substring traversal is to determine if a particular substring meets a criteria or alternately, count the number of times that it meets that criteria. Take a look at the method below where you count the number of vowels in a String:

public int numUpperCase(String string){
    int counter = 0;
    for(int i = 0; i < string.length(); i++) {
        String letter = string.substring(i, i+1);
        if(letter.equals(letter.toUpperCase())) {
            counter++;
        }
    }
    return counter;
}

In this example, notice how you traverse the String and grab one letter each time through. Then, by checking if the letter is equal to the uppercase version of the letter, you can determine if it matches the criteria. If so, then you can increase the counter.

Another common string algorithm is to reverse a String. In the example below, a String is reversed by creating a new empty String and then adding one letter at a time to that String.

Notice in this example how the loop starts at the end of the current String and loops to the beginning of the String. Each time, it still grabs a letter in the same manner as the original loop.

String original = ""Let's reverse this string!"";
System.out.println(original);

String newString = """";
for(int i = original.length() - 1; i >= 0; i--)
{
    String character = original.substring(i, i+1);
    newString += character;
}
System.out.println(""The original string reversed = "" + newString);",What is the general formula for traversing a String character by character?,"for(int i = 0; i < string.length(); i++)
{
    String character = string.substring(i, i +1);
}","for(int i = 0; i <= string.length(); i++)
{
    String character = string.substring(i, i +1);
}","for(int i = 0; i < string.substring(i, i+1); i++)
{
    String character = string.length();
}","for(int i = string.length(); i > 0; i++)
{
    String character = string.substring(i, i +1);
}"
codehs-csa-nested-iteration,"Earlier in this unit, you saw how to use a loop for a repeated task. For example, if you wanted to print the numbers 1 through 5 on a line, you could use a loop like this:

for(int count = 1; count < 6; count++) 
{ 
   System.out.print(count + "" ""); 
}

What if you wanted to print something like this?

1 2 3 4 5
2 4 6 8 10
3 6 9 12 15
4 8 12 16 20
5 10 15 20 25 

You could use 5 loops, one for each line and each loop starting and stopping at different values. This would get repetitive and you saw how you could use loops to avoid repetitive code. In this section, you are going to explore the concept of a nested loop.

Just as you saw with if statements, putting a loop inside another loop is called nesting. A nested iteration statement is an iteration statement that appears in the body of another iteration statement.

In the example above, you can achieve the five-by-five print out using a nested for loop.

// New loop outside
for (int row = 1; row < 6; row++) {
    // Original loop inside
    for(int count = 1; count < 6; count++) {
        System.out.print(count * row + "" "" );
    }
    System.out.println();
}

The original loop is now wrapped inside of a second loop. Notice how each of the loops uses a different loop variable.

Each time through the outer loop, the inside loop starts over and runs to completion. After completing the inside loop and printing a row, a line feed is added, then the outer loop loops around and starts the next row.

In this example, the inner loop executes 5 times each time it is called. The outer loop also executes 5 times, each time creating a new inner loop. So each line of code inside the inner loop actually executes 25 times!

Just as there are nested for loops, you can also have nested while loops, or even mixed nested loops with a for loop inside a while loop, or vice versa.

int line = 1;
while(line < 6) {
    int number = 1;
    while(number < 6) {
        System.out.print(number*line +"" "");
        number++;
    }
    System.out.println()
    line++;
}",How often is the inner loop of a nested loop run?,Each time the outer loop runs,Infinitely,Twice as often as the outer loop,One less time than the outer loop runs
codehs-csa-informal-code-analysis,"Throughout this course, you have spent a considerable amount of time developing algorithms. Algorithms are a step-by-step process that solves a problem. Many, if not all, of the programs that you have developed, are considered algorithms because they solve a problem.

You also use algorithms in our daily lives and don’t think about it. Most of the tasks that you perform on a daily basis are routinized and have procedures that you follow so that you can complete them as planned. Making a PBJ sandwich is an example of a practice that you do that has a procedural, step-by-step nature.

makePBJ()
{
    takeBread();
    spreadJelly();
    spreadPeanutButter();
    if (likeToasted){
        toast();
    }
}

So what makes a good algorithm?

- Correctness
- Easy to understand by someone else
- Efficiency (run time and memory requirements)

Correctness refers to whether the algorithm solves the given problem. Easy to understand can be a function of how the code is laid out, using appropriate variable names, and the use of comments. Efficiency can be looked at in several ways, which you will explore in this section.

Program efficiency is important because it affects both the speed and cost to execute a program. Oftentimes speed and cost are impacted by the physical computer’s specification and as a programmer, you do not have much control over this.

To help estimate the cost and efficiency of a program, you can use an informal code analysis by looking at the number of statements that a program needs to execute. A statement execution count indicates the number of times a statement is executed by the program, which can be a good indicator of the cost and speed of the program.

The Statement Execution Count is the number of times a statement is executed by the program. When comparing different algorithms, you can estimate the costs for each by looking at the number of statements that need to be executed to run the program.

An execution statement might refer to:

- an arithmetic operation ( + , * )
- an assignment (int value = 2)
- a test (x == 0)
- an input/output

Take a look at the example below:

public void computeSum (int n) {
    int sum = 0; 
    int n = 10;

    for (int i = 0; i < n; i++) {
        sum += i; 
    }
    System.out.println(sum); 
}

In this example, the code executes the first two assignment statements before the loop. Then the loop executes n times, followed by one additional statement. The total number of steps executes for this algorithm would be n + 3.","How many times does the following loop iterate?

// x has been initialized with a positive int value
for (int count = 0; count <x; count++) 
{
    System.out.print(""*"");
}",x times,x + 1 times,x - 1 times,Infinite number of times
codehs-csa-anatomy-of-class,"In Unit 2, you had the opportunity to explore classes from the perspective of a user of the class. In this unit you will take a deeper dive and look at how you can create classes of your own. Classes allow you to create custom objects that can make your program easier to implement.

In Java, there are two main access levels that you will see in this course, private and public. Private access is used when an element (such as a variable or method) should only be able to be accessed within the declaring class. What does that mean? Access in the class is when other statements in the same class try to access a value or function. For example given the class definition below:

public class Sample {
    private int value;
}

Any statement in the Sample class will be able to access value, but any other class that may create a Sample object will not have access to value since it is private.

In contrast, public access allows for an element to be accessed by any other class. Take a look at the updated class definition below:

public class Sample {
    private int value;

    public int getValue(){
        return value; 
    }
}

In this example, you will notice that the getValue method is public. In this case, if a Sample object was created in another class, you would be able to call the getValue method, and thus get indirect access to value.

When creating classes, classes should always be declared public since they need to be accessed by other classes. Likewise, a constructor in the class should always be public since it needs to be called by external classes.

When designing a class, programmers can make certain decisions about which elements should be public or private, however there are some basic governing rules that should be followed.

When it comes to instance variables, all instance variables should be designated private to keep access internal to the class. There are several reasons why you should always declare instance variables private.

The first reason revolves around the idea of data encapsulation. Data encapsulation is a technique in which the implementation of details of the class are kept hidden from the user. By using the private level access, instance variables are encapsulated in the class.

When designing a class, programmers make decisions about what data to make accessible and modifiable from an external class. Each piece of data can be either accessible or modifiable, or it can be both or neither. This access is accomplished through accessor and mutator methods (getters and setters).

In addition to data encapsulation, private access to instance variables can be used to help manage complexity. For example, think about a student object that may have an instance variable for grade and another variable to designate school level (such as middle school or high school). A programmer may decide to limit modifications to only the grade level and within the grade mutator method they also make updates to the school level. Not only does this streamline the update process, but it also controls the process to make sure you don’t have a 12th grade middle school student.

While instance variables are always declared private, methods can be declared either public or private, making them either external or internal to the class. Many behaviors need to be available externally, so oftentimes methods are declared public, but there are times when private access is preferable.

Private access is usually used with helper methods. For example, think back to the student object described above. The programmer may decide to write a public mutator method to change the grade. Once the grade is changed, the school level needs to be checked and possibly changed. If the programmer decided to do this check and make the change using another method, then that method would be private. As a private method, it can be called from the grade mutator method, but the end user cannot call the method directly from the other class.

Programmers will use private methods when they want to have a method to use in their class, but do not want that method called and used from an instance of the object.",Which of the following class members should NOT be public?,Instance Variables,Constructors,Accessors/Mutators,Methods the user needs to manipulate the objects of the class
codehs-csa-constructors,"Constructors are essentially object creators. You use constructors to create new objects using a class. When you create new objects using constructors, you also set any initial values of instance variables if necessary. These initial values of instance variables can be set either with or without the use of parameters.

An object is said to have state and behaviors. The state of an object represents the attributes and their values at a given time and is defined by instance variables belonging to the object. These instance variables create a “has-a” relationship. For example, if you think about a Rectangle object, you can say that the Rectangle has a length and the Rectangle has a width. At any given point in time, the state of the rectangle can be defined by the length and width of the Rectangle.

Constructors are used to set the initial state of an object, which should include initial values for all instance variables.

As you saw back in unit 2, the constructor is used to instantiate a new object and is called anytime an object is created. Constructors can serve multiple purposes, but one purpose is to set the initial state of variables. Take a look at the example showing how you would write a constructor:

public class Dog
{
    // Instance variables
    private String name;
    private int age;
    private double weight;
    private boolean isAlive;

    // Constructor
    public Dog(String theName, int theAge, double theWeight, boolean isThisAlive)
    {
        // Instance variable initialization
        name = theName;
        age = theAge;
        weight = theWeight;
        isAlive = isThisAlive;
    }
}

The constructor parameters are local to the constructor only. Because of this, you will notice how the local constructor parameters are used inside the constructor to set the initial value of the instance variables. Additionally, it is important to note that when a mutable object is passed as a parameter, the instance variable is initialized with a copy of the variable. As a result, any modifications to the instance variable will not be reflected in the original object.

While a constructor does play an important role, it is possible to create a class without a constructor. When no constructor is provided, Java provides what is known as a no-argument constructor. The no-argument constructor executes anytime an object is created and sets any instant variable to their default value.

Example:

public class Dog
{
    private String name;
    private int age;
    private double weight;
    private boolean isAlive;
}

In this example, when a Dog object is created, the instance variables will be set to their default values, which is zero for the integer and double, an empty string for name, and false for the Boolean value.",An object’s state is defined by the object’s,instance variables and their values,methods and instance variables,access modifiers of the instance variables,methods and their return values
codehs-csa-documentation-with-comments,"There are two parts to writing a program: One part is getting it to work (the functionality). The other part is the style: How did you write the program? Did you break it down into parts? Is it clear to read? This is where comments come into play!

Comments are a way for you to leave notes about what your code is doing in plain English so that other people can understand it.

Why comment?

Even though code is run by computers, it is read by other people. Comments help others understand your code. If you read your code ten years from now, would you be able to understand what it does?

The computer that runs your program knows to ignore comments if they are written as multi-line, single line, or Javadoc comments.

Use multi-line comments to leave a comment so a reader understands what your program or method is doing. The start of a multi-line comment uses /*, each line following with a single *, and ending the multi-line comment with */.

/* 
* This program does ______. 
*/

Use single line comments to leave a comment for a single line in your code. For each single line comment, put two backslashes (//) before the comment.

//This line does ______.

Another important part of commenting is using preconditions and postconditions. You can leave notes at the top of our methods about assumptions that you make.

Preconditions: A precondition is a condition that must be true just prior to the execution of a section of program code in order for the method to behave as expected. There is no expectation that the method will check to ensure preconditions are satisfied.

Postconditions: A postcondition is a condition that must always be true after the execution of a section of program code. Postconditions describe the outcome of the execution in terms of what is being returned or the state of an object.

This helps you think about the problem and make sure our methods line up.",Which of the following is NOT a valid comment?,"// Comment
    Comment //",// Comment,// Comment //,"/* Comment
    Comment */"
codehs-csa-accessor-methods,"One key aspect of writing classes in Java is that you can control how the class is used. As mentioned earlier, instance variables are kept private in your Java classes, but that doesn’t mean that users can’t access them via public methods. Access to variables is controlled by the developer through accessor methods.

An accessor method is a method that is used to return the value of an instance (or static) variable to the user. Since the method is returning a value to the user, the method header should contain the return type in place of the keyword void.

When creating accessor methods there is a common convention you should follow. When naming your method you should always use this format: get[Variable Name] for the name. Some examples of this would be: getWidth(), getHeight(), and getColor(). As a result of this naming convention, accessor methods are sometimes referred to as “getter” methods.

Here is an examples of how this would look:

private int width = 10;
private int height = 3;
private Color rectCol = Color.blue;

public int getWidth()
{
  return width;
}

public int getHeight()
{
  return height;
}

public Color getColor()
{
  return rectCol;
}

As a non-void method, the accessor method returns a single value. This value needs to be compatible with the return type in the method header, for example a string needs to return a string, or a double return type needs to return a number (an int or double is compatible with a double).

When returning a value, a copy of that value is returned to the calling method, whether the value is a primitive or an object. This is referred to as “return by value.”

As soon as the return keyword is used, the program returns to the point immediately following where the method was called. This can be used to return a value or to interrupt the progress execution and end the method execution.

The toString method is a specific method that is used to return a string representation of the object. The method is often included in many classes as a way to override the default object description and provides a description of the object. It will generally include some of the values stored in instance variables, or a calculation with those values, but it doesn’t have to.

While the method can be called with using the standard dot syntax, such as obj.toString(), the method is also called by default for print statements.

For example, if there is a Shape class that has a toString method, the toString would be called int he following situation:

Shape s1 = new Shape(""Rectangle"");
System.out.println(s1); // calls the toString for s1

Shape s2 = new Shape(""Circle"");
System.out.print(s2); // calls the toString for s2",Which of the following method signatures would be appropriate as an accessor method for an String instance variable called name?,public String getName(),public void getName(),private void getName(),private String getName()
codehs-csa-mutator-methods,"Just like you can control which instance variables an end user can access, developers can also control access to updating variables. This access is controlled by the mutator methods.

A mutator method is a method that is used to update the value of an instance (or static) variable. Since the method is designed to update a value, the method header often contains the void keyword since it doesn’t return a value.

Mutator methods set a new value. As such, they are often referred to as setter methods. Setter methods allow us to set the values of an object’s instance variables.

As with accessor/getter methods you use a common convention when creating mutator methods. When creating mutator methods you should always use: set[Variable Name]. Some common examples include: setWidth(int width), setHeight(int height), setColor(Color color). Here are some examples of how to create these setter methods:

private int width = 10;
private int height = 3;
private Color rectCol = Color.blue;

public void setWidth(int newWidth)
{
  width = newWidth;
}

public void setHeight(int newHeight)
{
  height = newHeight;
}

public void setColor(Color color)
{
  rectCol = color;
}",Which of the following is NOT a characteristic of a mutator?,Mutator methods are generally private methods,Mutator methods generally have a void return type,Mutator method generally have a parameter,Mutator methods generally update instance variables
codehs-csa-writing-methods,"The last two sections looked at creating two specific types of class method focused on accessing and updating instance variables. What if you want to do something else, like perform a calculation or print out a result? Using class methods, you can write your own behaviors for a class.

Recall from Unit 2 where you first methods, a method header is the first line that is used to define a method. For example:

public int addFive(int num)

In the above example, since the method is a non-void method with a parameter, the method would take the formal parameter (parameter in the method) value in, use it, and then return a computed value. The return value needs to match the return type.

When a primitive value is passed to the method, the formal parameter is initialized with a copy of the value. In other words, any changes to the formal parameter in the method will not change the actual parameter in the calling method.

Here is an example. Given a Numbers class:

public class Numbers {
  public int addFive(int num) {
    num += 5;
    return num;
  }
}

If the following code is executed to call the addFive method:

Numbers myNum = new Numbers();
int a = 12;
System.out.println(myNum.addFive(a));

The output will be 17 however, the value of a will remain unchanged at 12.

In contrast, when an object is passed to a function as a parameter, the formal parameter is initialized with a copy of the reference, not a copy of the object. What does this mean?

As a copy of the reference, both the original reference and the copy point back to the same object. This makes the actual parameter and formal parameter aliases that refer to the same object. Assuming the object is mutable, updates in the method will be reflected in the original value also getting updated.

As a note, it is good programming practice to not modify mutable objects that are passed as parameters unless required in the specification.

If the formal parameter is a reference object, you can actually access the private data associated with that reference if the method has been written in the object’s class file. In the example below, because MyProgram is not the file that the Rectangle class was written in, you have to use rect.setWidth() and rect.setHeight() to access the instance variables.

MyProgram.java

public void resetRect(Rectangle rect) {
  rect.setWidth(0);
  rect.setHeight(0);
}

If the method was written inside the Rectangle class file, then you could access the object’s data by using the .variable notation. Notice that instead of using setWidth and setHeight, you can just change the value of width and height by writing rect.width and rect.height. This works when the parameter reference object is the same as the class file.

Rectangle.java

public void resetRect(Rectangle rect) {
  rect.setWidth(0);
  rect.setHeight(0);
}",Each of the methods below can be found in the Student class. Which of the following methods would have access to the parameter object’s private data and methods?,public void copy(Student other),public void copy(Person other),public void setId(Integer newId),public void setName(String newName)
codehs-csa-static-variables,"Recall that an object is an instance of a class. The class is like the blueprint from which instances can be built. Each instance can have its own state and behavior. An object’s state is stored in instance variables, and its behavior is carried out with instance methods. These are called instance variables and instance methods because they belong to a single instance of the class. But what if you wanted to keep track of a single variable or have a shared behavior across all the members of a class? Because each object has its own instance variables and methods, these won’t work to store information for the entire class.

Sometimes it is useful to store information that is shared across all the objects of an entire class. A class variable (also referred to as a static variable) is a variable or attribute of a class that is common to all instances of a class. A class method (or static method) is a method of a class that is common to all instances of a class and is not called on any specific object instance.

A new static variable defined by adding the keyword static to the variable declaration. Static variables can be either public or private.

Likewise, static methods also use the keyword static. Classes can have both instance variables and static variables, but static methods can only update static variables. As a result, static methods cannot use the this reference and are unable to use non-static variables or methods.

A method to return the total number of birds of the Bird class may look like:

private static int getTotalBirds()
{
  return totalBirds;
}

For example, if you run your own indoor skate park, you may want to keep track of the skaters at the park. In order to use the park, a new skater would sign up and a new instance of the Skater class would be created. What information would be useful to track about each skater? You may want to know a skater’s name, age, experience level, and a history of times he or she arrived at and left the park. These are all unique to each skater and could be stored as instance variables.

It would also be useful to know how many skaters have ever skated at the park. This is a useful stat to know, but it is affected by all the skaters, not just one. Because this information is shared across the whole class, it can be stored in a class variable. The Skater class could be defined to include these:

public class Skater
{
  private static int totalSkaters = 0;

  public Skater()
  {
    totalSkaters++;
  }

  public static int getTotalSkaters()
  {
    return totalSkaters;
  }
}

Whenever a new skater is added, the static variable totalSkaters is increased. The totalSkaters variable is shared across all instances of the Skater class. Each object in the class has the same value for this variable, and you can get the value of this variable with the static getTotalSkaters method.

Because static methods and variables are available across an entire class, they don’t need to be called on a particular instance of the class. You do not need to create a new object just to call a class method.

To find out how many skaters have been to the skate park, you can write:

Skater.getTotalSkaters();

This will call the getTotalSkaters() method on the Skater class without requiring an instance of the class to be created.

If a static variable were to be declared as public, you could also access it using the dot notation, such as:

Skater.totalSkaters; // Only works if variable is public",Static methods can access,Only other static instance variables and class methods,"Any class method, but not the instance variables",All instance variables and class methods,Only private instance variables and private class methods
codehs-csa-scope,"Think back to some of the examples where you had variables in methods. Some of these variables had the same name as other variables in your program, but they didn’t have the same values. How can that be? Each variable has a specific scope and access level where that variable is defined. Outside that scope, a different variable can be defined with the same name. In this section, you will look at how variable scope is determined.

When declaring a variable inside the body a constructor or a method, you create a local variable for that method. What does this mean? By local variable, it means that the variable is only defined for that specific constructor or method. These variables may only be used within the constructor or method and cannot be declared to be public or private.

Likewise, another variable with the same name can be used outside the constructor or method and it will be considered a different variable.

public void addFive() {
  int num = 10; // num is only defined inside the addFive method
  int result = num + 5;
  System.out.println(result); // prints 15
}

public void addTen() {
  int num = 20; // This is a different num variable that needs to be declared
  int result = num + 10;
  System.out.println(result); // prints 30
}

Sometimes you will see a local variable inside a method or constructor sharing the same name as an instance variable. When this happens, the variable name in the method by default will refer to the local variable instead of the instance variable.

public class MyClass {
  private int myNum = 10;

  public void addFive() {
    int myNum = 7;
    // Will print 12 since the local myNum is used instead
    // of the instance variable.
    System.out.println(myNum + 5); 
  }
}

When variables are declared as formal parameters, they act the same as a variable that has been declared inside a constructor or method. That means that they are only available inside the constructor or method where they are declared and that they will take precedence over any instance variables that have the same name.

public class Name {
  private String name = ""Karel"";

  public Name(String name) {
    // Will print the value passed in, not the value of the instance variable
    System.out.println(name); 
  }
}

Method decomposition is the process of breaking down large problems into smaller sub-problems by creating methods to solve the individual sub-problems.

For example, if you want to create a program that asks users a random trivia question and informs them if they got the answer correct, you could break the problem into several parts:

- Build a Trivia class.
- Create Program that uses Trivia class.

You can then break each of these problems into several parts. For example, the program that uses the trivia class might break into the following parts:

1. Create a Trivia Object
2. Ask User a random trivia question
3. Allow User to Respond
4. Check if Response Matches Answer
5. Provide User with a Reply

By breaking the problem down into smaller parts, you create sub-problems that are easy to solve and combined together, they can solve a much more complicated problem.","What would be printed the first time printGreeting was called from main?

public class Greeting
{
    private static String greet = ""Hi there!"";

    public static void printGreeting()
    {
        String phrase = ""Hello!"";
        System.out.println(phrase);
        phrase = ""Hola!"";
    }
}",Hello!,Hi there!,Hola!,Hi There!Hello!
codehs-csa-this,"As discussed in the previous section, when you use a variable in a method or constructor that shares the same name as an instance variable, by default, the local variable in the method or constructor is used. What if you want to refer to the instance variable?

It can often be confusing to know whether a variable in a constructor is referring to an instance variable or a variable that was passed in as an argument to the constructor. One way around this is to use different variable names for the instance variables and parameters, however using different names can get a little confusing.

Fortunately, Java has a way of specifying when you are referring to the object itself: this.

this refers to the current object. The this keyword allows you to be very clear whether you are referring to the object’s instance variable or a parameter:

public class BMX
{
  private String frameSize;
  private int numPegs;

  public BMX(String frameSize, int numPegs)
  {
    this.frameSize = frameSize;
    this.numPegs = numPegs;
  }
}

Notice in the above example how you can use the same variable name. When the variable name is preceded by this., the variable is referring to the instance variable, otherwise it refers to the local variable.

As noted above, the this keyword is used to represent the current object. With that in mind, you can use this to represent the current object as needed.

public class Rectangle {
  public int getArea(Rectangle rect) {
    return rect.getWidth() * rect.getHeight();
  }

  public boolean hasGreaterArea(Rectangle otherRect)
  {
    return getArea(this) > getArea(otherRect);
  }
}

Notice in the example above how the getArea method is called using this as an actual parameter for input into the getArea method.",Which of the following correctly uses the this keyword?,"public boolean isEqual(Student other)
{
    return this.name.equals(other.name);
}","public boolean isEqual(Student other)
{
    return name.equals(this.other.name);
}","public boolean isEqual(Student other)
{
    return name.equals(this.name);
}","public boolean isEqual(Student other)
{
    return name.this.equals(other.name);
}"
codehs-csa-ethics,"In this lesson, you will look at the professional computing code of ethics, system reliability, legal issues and intellectual property concerns, and bias in computing.

This is a time of rapid advancements in technology and automation. Software and hardware engineers increasingly have significant impacts on everyday lives with the tools and applications that they create. You see software and hardware solutions in nearly every aspect of your lives, such as the cars you drive, your bank accounts, the electrical grid, and nearly all communication such as email, text, and phone calls. If these systems fail, your lives would be greatly impacted.

Part of understanding the impact of these tools and applications is understanding system reliability. System reliability is when all programs and code will work as intended. Its challenging to ensure system reliability when there are many inputs, parameters and outputs in any given programming application. System reliability is limited and programmers should make an effort to maximize system reliability. Software and hardware engineers need to be aware of the legal, social and ethical implications of the hardware and programmatic systems that they create.

While programs are designed to achieve a specific purpose, they may have unintended consequences. Computing systems have affected humans, society, economy, and culture in many ways, both positively and negatively.

One substantial impact of computing systems is the access to information. There are several open databases of scientific publications on the internet, some of which are free and some are subscription based. This allows scientific papers to be read by anyone, not just a graduate student at a research institution. Now anyone can read these cutting edge scientific publications.

But there’s a big question as to whether access to all information is actually a good thing. For example, there’s a website called Wikileaks that posts classified information that either governments or corporations are trying to keep secret. On one hand this is a good thing because it promotes the transparency of information. It makes it so corporations and the governments can’t keep secrets from its citizens. However, there’s potential danger in having classified secrets being public. For example, our military or national security could be at risk if someone posts our government secrets to the world.

Legal issues and intellectual property concerns arise when creating programs. As programmers, you have a responsibility to make sure that our programs are socially, legally, and ethically acceptable.

Computer science follows the following ACMs or Association for Computing Machinery professional code of ethics. ACM has professional principles as well, but they are beyond the scope of this course. According to the ACM, a computing professional should:

- Contribute to society and to human well-being, acknowledging that all people are stakeholders in computing.
- Avoid harm.
- Be honest and trustworthy.
- Be fair and take action not to discriminate.
- Respect the work required to produce new ideas, inventions, creative works, and computing artifacts.
- Respect privacy.
- Honor confidentiality.

Remember that knowledge is power as everyone lives together in our digital world. Use your knowledge of computing for good purposes so you and everyone else can be safe and enjoy the benefits of computing.",A computing system that is biased is likely to,give preferential treatment to some users,be created by a small company,treat all users the same,operate slower
codehs-csa-array,"An array is a list of data. Arrays can store many different types of information. For example, if you had a shopping list, you could store the shopping list as an array.

The information stored in an array is kept in order. The items in an array are often referred to as members or elements of the array. What makes arrays unique is that they store a fixed number of elements. Once an array is created, the size of the array cannot be changed.

It is important to note that in computer science, we usually start counting from 0. So the first item in the array is actually at index position 0, the second item in the array is at index position 1, and so on.

Let’s say our grocery list contained these items, in this order: apples, dog food, donuts, celery, and orange juice. If we were to draw out the array, it would look something like this:

index position:	0	1	  2		3	4
list item:		apples	dog food  donuts	celery	orange juice

We can see that dog food is at index 1 and celery is at index 3.

To create an array in Java, you must first know what type of data you want to store and how many elements the array will hold. In the grocery list example above, we created an array of Strings, but it’s just as easy to create arrays of integers or any other data type. Arrays can store both primitive and object data types.

The format for creating an array is:

type[] arrayName = new type[numberOfElements];

Let’s take apart the array declaration:

- type[]: This tells us what type of data is being stored in the array. For example, a list of integers would be int[]. The brackets [] indicate that this is an array and not a single int.
- arrayName: The name by which the array will be known. It’s best to pick a descriptive name, like groceryList instead of just things.
- new: The new keyword indicates that a new array is being created.
- type[numberOfElements]: The type of elements is mentioned again, as well as the number of items the array will store. For example, if an array int[6] were created, the array would store six int values. Once an array has been created, the number of items that can be stored in the array cannot change. This array will always store 6 items - no more, no less!

For example, if you wanted to create an array that contained 6 integers, the initialization of the array would look like this:

// Create an empty array that will store 6 integers
int[] newNumberList = new int[6];

When an array is initially created, each index in the array is set to a default value. Java assigns a specific value for each item in the array depending on the type. int and doubles default to zero, booleans default to false, and objects (including strings) default to null.

Type	Default Value
int	0
double	0.0
boolean false
Objects null

Arrays can also be created and initialized with specific values. To do so, simply include the elements that will be stored in the array between curly braces in the initialization. Here’s a list of 6 numbers:

int[] numberList = {10,20,30,40,50,60};

Elements in an array can be accessed using the index position of the array. Let’s create a new empty array of numbers, then add in two numbers:

// Create an empty array that will store 6 integers
int[] newNumberList = new int[6];

// Add the number 11 to index position 0
newNumberList[0] = 11;

// Add the number 13 to index position 1
newNumberList[1] = 13;

The array now contains two integers:

Index Position:	0	1	2	3	4	5
Array Item:		11	13	0	0	0	0

Notice that the rest of the indices in the array are set to the default value 0. The [] syntax can also be used to change elements in a list. Let’s change 13 to 21:

newNumberList[1] = 21;

Index Position:	0	1	2	3	4	5
Array Item:		11	21	0	0	0	0

Accessing an element in a list uses a similar syntax. We can get and store the number at index 0 into a variable:

// This variable will contain the number 11
int firstNumber = newNumberList[0];

// Two ways to print out the number 11 to the console
System.out.println(firstNumber);
System.out.println(newNumberList[0]);

// Now print out the number at index position 1 to the console
System.out.println(newNumberList[1]);

The output from the code will be:

11
11
21

Accessing a value in an array that’s outside the current index value list will result in an ArrayIndexOutOfBoundsException. For example, a new double array is created with 5 values:

double[] example = new double[5];

Because there are only five values in this array, attempting to access an index greater than or equal to five will throw an error:

double value = example[6];   //This results in an ArrayIndexOutOfBoundsException

This program would throw an ArrayIndexOutOfBoundsException, as index six is unavailable in this particular array. If you see this error in a program, it most likely means that you’re accessing an array incorrectly!",How do you initialize an array called arr of 10 double with default values?,double[] arr = new double[10];,double[] arr = new double[11];,double arr = new double[10];,double arr = new double;
codehs-csa-traversing-arrays,"Arrays are utilized for many operations in various programs. Since arrays store data in order, you can iterate through them to access this data. Let’s say you are creating an online store that sells oranges. You would want to store the customer orders in an array so you can honor the first orders before the orders that come later.

Let’s say you have an array that stores the order data from your market. Here is the array:

Index:		0		1		2		3		4		5
Orders:	10 Oranges	3 Oranges	6 Oranges	4 Oranges	5 Oranges	1 Orange
In Java the array will look like this:

int[] orangeOrders = {10, 3, 6, 4, 5, 1};

Individual elements can be accessed by using the [] notation:

int orderOne = orangeOrders[0];  //returns 10 to orderOne

Since this list of orders is fairly small, it’s easy to access the individual orders that are being made, but oftentimes, arrays can have hundreds, thousands, or even millions of values. How is it possible to access all values when it’s not clear where a specific value might be stored? There needs to be a systematic way to access all of these values! Luckily, iteration, or traversing, an array can provide a simple solution.

In order to iterate through the items in an array, it’s absolutely necessary to know how many elements there are in the array - otherwise, how would you know how many elements you need to search through?

Finding the size of an array is done by using the keyword .length. .length returns the current size of an array. An array with six values is considered an array of length 6. The length of an array corresponds to the number of elements in an array, not the last index value in an array.

If you recall, arrays start at index 0 - an array with six elements will start at 0 and end at index 5:

Index:		0		1		2		3		4		5
Orders:	10 Oranges	3 Oranges	6 Oranges	4 Oranges	5 Oranges	1 Orange

Iterating over an array requires the use of a for or while loop:

for(int i = 0; i < orangeOrders.length; i++)
{
   // This prints out the ith element!
   System.out.println(orangeOrders[i]);
}

This for loop iterates through every value in the orangeOrders list, and prints out the value at every index.

Notice that the for loop starts at the first element (zero) and ends at the last element (array.length - 1). The for loop is set to i < orangeOrders.length, so that the greatest value of i will always be one less than the length of the array. Therefore, the last index in an array will always be array.length - 1.

Each time through the loop, the value of i accesses the element at index i. This simple for loop is able to loop through the array, regardless of how many items there are in the array.

This traversal can also be written using a while loop:

int index = 0;
while(index < orangeOrders.length)
{
   System.out.println(orangeOrders[index]);
   index++;
}

Notice that the variable index is outside of the while loop. This ensures that the variable index isn’t reset to 0 every time the while loop starts a new iteration. The value of index is increased by one at the end of the while loop, ensuring that the next index in the array will be accessed.

When developing iterative programs for use with arrays, it’s important to pay attention to which values are being set as the starting and ending indices. A common mistake programmers make is setting the ending index to the length of the array, not the last index value:

int index = 0;
while (index <=orangeOrders.length)
{
   System.out. println(orangeOrders[index]);
   index++;
}

In this example, the final value of index will be 6, even though the last index in orangeOrders is 5. As a result, this program will lead to an ArrayIndexOutOfBoundsError. This type of error is referred to as an “off by one” error, as the program iterates one too many times over the array.","What is the output after this code snippet runs?

double[] prices = {3.45, 1.00, 2.25, 5.22, 4.50};

for (int i = 0; i < prices.length; i += 2)
{
       System.out.println(scores[i] = prices[i]  -  1);
}","2.45
1.25
3.50","2.45
1.25","2.45
0.00
1.25
4.22
3.50","3.45
2.25
4.50"
codehs-csa-enhanced-array-for-loops,"In both the for and while loop array traversals, a counter was used to determine the correct index at which an array element could be found:

//for loop
for(int i = 0; i < array.length; i++){
   // Do something
}  

//while loop
int counter = 0;
while(counter < array.length) { 
   // Do something
   counter++;
} 

Arrays can also be traversed without the use of counters by using an enhanced for loop.

Enhanced for loops are an alternate method of traversing an array:

int[] numList = {5,6,7,4,2};
for(int number: numList)
{
   System.out. println(number);
}

Instead of initializing a variable for looping, the enhanced for loop header initializes a new variable, number known as the enhanced for loop variable. The type of this variable needs to match the value type of the array. In this example, since numList is an array of integers, number also needs to be an integer.

After the enhanced for loop variable is defined, the header is completed by placing a colon and the name of the array being iterated on (numList).

Inside the loop, the enhanced for loop variable is assigned a copy of each value of the array without using the array index. On each iteration, the value of number changes to match an element in the array. The first value of number in this loop is 5. The second value will be 6, as it is the next item in the array. The enhanced for loop iterates in the order that the elements are found in the array, from first to last. Making changes to the enhanced for loop variable does not change the original value in the array.

Standard for loops can be rewritten as enhanced for loops, and vice versa:

String[] classroom = {""julian"", ""larisa"", ""amada"", ""mikka"", ""jay""};

//Enhanced For Loop:
for(String student : classroom)
{
   System.out.println(student);
}


//Standard For Loop:
for(int i = 0; i < classroom.length; i ++)
{
    System.out.println(classroom[i]);
}

Both standard and enhanced for loops are useful in different contexts. For example, since enhanced for loops make a copy of each element value, they are incapable of changing the value of the elements in an array. If elements need to be altered, standard for loops are more appropriate. In contrast, if elements just need to be accessed, enhanced for loops provide a more streamlined way to access elements without the need for a counter, or a potential ArrayIndexOutOfBounds error.","What is the output of the following code snippet?

int[] temperatures = {80, 92, 91, 68, 88};

for(int temperature : temperatures)
{
    System.out.println(temperature);
}","80
92
91
68
88",80 92 91 68 88,ArrayIndexOutOfBounds exception will be thrown,temperature
codehs-csa-algorithms-using-arrays,"Programmers use data structures to store data. Data is often stored so that it can be used or analyzed at some point in the future. Array traversals have several important applications in regards to how data is used and analyzed. They can be used in:

Mathematical Analysis
- Determine a minimum or maximum value
- Compute a sum, average, or mode

Analyzing Element Properties
- Determine if at least one element has a particular property
- Determine if all elements have a particular property
- Access all consecutive pairs of elements
- Determine the presence or absence of duplicate elements
- Determine the number of elements meeting specific criteria

Reordering Elements
- Shift or rotate elements left or right
- Reverse the order of the elements

Each of these subsets uses a distinct algorithm to analyze arrays.

Computing mathematical results, such as the sum of integers in an array or finding the average of each value in an array requires the use of a similar algorithm:

int[] scores = {80, 92, 91, 68, 88};

//Initialize value here
int valueToFind = 0;

for (int i = 0; i < scores.length; i++){
   //Perform calculation on valueToFind
}

//Report results of valueToFind

In each case, the algorithm requires the initialization of a value that will be used to store the result of a given computation outside of the for loop. Inside the loop, the initialized value, valueToFind, will be altered depending on the desired output, and the results will be displayed after the loop has terminated.

For a better understanding of this, consider this implementation of computing a sum:

int[] scores = {80, 92, 91, 68, 88};
int sum = 0;
for (int i = 0; i < scores.length; i++){
   sum += scores[i];
}
System.out.println(sum);

The value of sum is changed each iteration through the for loop, adding the current score to the value of sum. This algorithm looks awfully similar to the one used to find the average value of an array:

int[] scores = {80, 92, 91, 68, 88};
int sum = 0;
for (int i = 0; i < scores.length; i++){
   sum += scores[i];
}
System.out.println((double) sum / scores.length);

In both cases, the initialized value is declared before the for loop, used in mathematical computations within, and then displayed after its termination.

To determine if an element or a set of elements in an array meets specific criteria or has a specific set of properties, the following general algorithm can be used:

String[] grades = {""A"",""C"",""B"",""A"",""B""};

//Initialize tracker variable
for (int i = 0; i < grades.length; i++){
   //Conditionally check properties
}

//Report results here

Similar to mathematical analysis, property analysis sets an initial tracker variable before the start of the for loop, and checks through each iteration if the element at a specific index meets the criteria. It then reports the findings after the loop has terminated.

In the following example, the tracker variable checks how many A’s there are in the grade array:

String[] grades = {""A"",""C"",""B"",""A"",""B""};

//Initialize tracker variable
int numAs = 0;

for (int i = 0; i < grades.length; i++){
//Conditionally check properties
   if (grades[i].equals(""A"")){
      numAs++;
   }
}

System.out.print(""Number of A's: "");
System.out.println(numAs);

In this case, the value of the tracker variable numAs increments if the element at each index is an A. These tracker variables can also be used to store a single value that changes depending on the condition. For example, finding the minimum value of a list looks similar to the previous example, but only stores a single value:

int[] scores = {80, 92, 91, 68, 88};

int minIndex = 0;

for (int i = 1; i < scores.length; i++){
   if (scores[i] < scores[minIndex]){
      minIndex= i;
   }
}
System.out.println(minIndex);

Rather than increment, this tracker keeps track of the current minimum value in the list. If the value at the current index is less than the existing minimum, then the tracker is changed to reflect that.

Another common array algorithm involves reordering or reversing our arrays. While this can be done in a few different ways, a common method is to create a new temporary array where a copy of the new order for values is stored. Once the new order is copied into the temporary array, it overwrites the original array with the temporary one:

int[] numbers = {1, 2, 3, 4, 5};
int[] temp = new int[numbers.length]; //Create default array

//Loop, but stop at the last element (edge case)
for (int i = 0; i < numbers.length - 1; i++){
    temp[i + 1] = numbers[i]; 
}
temp[0] = numbers[numbers.length - 1]; //Edge case
numbers = temp; //Copy over to the original array

In this example, the algorithm is shifting the values in the array to the right by one. Rather than move the values in the existing array, a new array is created to store the values in the specified order. This removes the possibility that the original array gets altered accidentally, and that changes to the new array do not impact the original.","What will the following code segment output?

String[] grades = {""A"",""C"",""B"",""C"",""B"", ""A""};

int mystery = 0;

for (int i = 0; i < grades.length; i++)
{
    if (grades[i].equals(""B"")) 
    {
        mystery ++;
    }
}

System.out.println(mystery);",2,0,1,3
codehs-csa-arraylist,"In the last unit, you learned how to store data more efficiently using arrays. Arrays are able to store a list of values of the same type in one variable, making it easier to store and keep track of data that you need for your programs. One of the limitations of using arrays to store data is the fact that they have a fixed number of items that can be added or changed. Elements can only be added to an array by creating a new array of a different size and copying the data from the initial array to the new one:

int[] setSize = new int[5];
int[] newSize = new int[6];
setSize = newSize;

This process is tedious, and requires a high degree of difficulty, especially if the list being used is going to change in size often. A more convenient way to create adjustable arrays is by using the ArrayList class.

ArrayLists are similar to arrays, except that they are a mutable list of object references, meaning that the size of the list can be adjusted freely. Creating an ArrayList is as simple as initializing a new ArrayList in a program:

import java.util.ArrayList;

public static void main(String[] args)
{
  ArrayList<E> list = new ArrayList<E>();
}

In order to use the ArrayList class, the ArrayList class needs to be imported from the java util package. This can be done by writing import java.util.ArrayList at the top of the class file.

ArrayList objects are created in the same fashion as other object classes. The primary difference with ArrayLists is that the element type of the ArrayList must be specified using angled bracket <>. In this example, E represents the data type that will be used in the ArrayList. This can be replaced by an object data type:

ArrayList<String> list = new ArrayList<String>();

The declaration type for an ArrayList must match the initialization type. In this case, both types reference the String data type.

When this line of code is executed, the ArrayList list will store an empty ArrayList with no index values. Unlike arrays, the number of items that will be stored in an ArrayList does not need to be specified. Values can be added to the ArrayList after the ArrayList is initialized. This will be explored more in the next chapter.

ArrayLists can actually be declared without specifying the type that will be included in the ArrayList:

ArrayList list = new ArrayList();

While this appears to be a simpler initialization process, specifying the data type is highly recommended because it allows the compiler to find errors before run time. This makes it easier to find errors, and program more efficiently, as the program will indicate if there is an issue before any code is run.

While arrays and ArrayLists are fairly similar data structures, the key differences between them lie in their creation, mutability, and the types of data that they can store.

Arrays are a fixed size, whereas ArrayLists can contract and expand. ArrayLists are only able to store objects, whereas arrays can store both primitive and object values. Foruntuantley, autoboxing and unboxing allows you to send many primitive variables into an ArrayList, but the ArrayList still needs to be set up using the object type.

When choosing to use a data structure, it’s important to know if the data being stored should be a fixed, or unfixed size in length. Which data structure you choose will depend on how frequently that data needs to be updated or accessed.",How do you create an ArrayList of integers?,ArrayList<Integer> list = new ArrayList<Integer>();,int[] list = new int[];,ArrayList<int> list = new ArrayList<int>();,ArratList(int) list = new ArrayList(int);
codehs-csa-arraylist-methods,"ArrayLists provide flexibility and functionality that arrays do not. You can think of an ArrayList as a container that will resize as you add and remove objects from it. In order to do so, there are several helper methods that are used to alter the state of an ArrayList, and get information about its content.

Objects can be added to an ArrayList using the add method. The add method has several method signatures:

boolean add(E obj)
void add(int index, E obj)

The single parameter add method will add an element to the end of the ArrayList:

import java.util.ArrayList;

ArrayList<Integer> list = new ArrayList<Integer>();
list.add(5);

Since the ArrayList starts with no values, the call to add will add the element 5 to the 0th index of the ArrayList. If the call list.add(8) were added to this code segment, the element 8 would be added to the 1st index position. Like arrays, ArrayLists begin at index 0. The add method returns true if the element was successfully added to the ArrayList.

The second add method signature will add an element at a specified index:

ArrayList<Integer> list = new ArrayList<Integer>();
list.add(5);
list.add(1, 4);  //Adds the value 4 at index 1.

The specified index must be between the value 0, and the current size of the ArrayList. To determine the size of the ArrayList, the method size can be used to return the current length of an ArrayList:

ArrayList<Integer> list = new ArrayList<Integer>();
list.add(5);
System.out.println(list.size()); //returns 1
list.add(1, 4);
System.out.println(list.size()); //returns 2

Notice that the size of the ArrayList increases when a new value is added to the list. When add(int index, E obj) is called, the list items from index - size() shift up one index to allow the new value to slot in to the correct index position.

Elements in an ArrayList can be accessed using the get(int index) method:

ArrayList<Integer> list = new ArrayList<Integer>();
list.add(5);
list.add(3);
list.add(10);
list.add(4);

int val = list.get(1);
System.out.println(val); //prints the value 3

The method get returns an element at the specified index. In this case, the value stores at index 1 (3), is being stored in the variable val, and printed to the console.

Individual elements in an ArrayList can be changed using the set(int index, E obj) method:

ArrayList<Integer> list = new ArrayList<Integer>();
list.add(5);
list.add(3);
list.add(10);
list.add(4);

int val = list.get(2);
System.out.println(val); //prints the value 10

//change the value at index 2
list.set(2, 34);
val = list.get(2);
System.out.println(val); //prints the value 34

In this example, the value at index 2 is changed from the value 10 to the value 34. It’s important to note that the values can only be changed to another value of the same data type.

The set method also returns the value that is being replaced to the existing program. The value that has been replaced can then be stored in a variable of its own:

ArrayList<Integer> list = new ArrayList<Integer>();
list.add(5);
list.add(3);
list.add(10);
list.add(4);

int val = list.set(2, 34);
System.out.println(val); //prints the value 10

int newVal = list.get(2);
System.out.println(newVal); //prints the value 34

Just as elements can be added, they can be removed from an ArrayList using the remove(int index) method. Like the set method, the remove method also returns the value that is being removed from the specified index.

ArrayList<Integer> list = new ArrayList<Integer>();
list.add(5);
list.add(3);
list.add(10);
list.add(4);
System.out.println(list.size()); // prints the value 4

int val = list.remove(0);
System.out.println(val); //prints the value 5

System.out.println(list.size()); // prints the value 3

In the program above, notice that the size of the ArrayList decreases by one when the element is removed from the ArrayList. All values at the index higher will move down one index once an element is removed from an ArrayList.

Many of the methods used to access and manipulate ArrayLists are functionally similar in nature to arrays:

Feature	Arrays				ArrayLists
Initialize	int[] arr = new int[5];	ArrayList array = new ArrayList();
Get Value	arr[index]			array.get(index)
Get Size	arr.length			array.size()
Set Value	arr[index] = value;		array.set(index, value)

When considering which data structure to use, it’s important to determine early on if it’s necessary to add or remove values at future points in the program. If that’s the case, then ArrayLists may serve better.","What value will be printed in the console after this series of commands? Assume that the ArrayList package has been imported.

ArrayList<Integer> array = new ArrayList<Integer>();
array.add(1);
array.add(9);
array.add(10);
array.remove(1);
array.add(1);
array.set(0, 3);
int num = array.get(1);
System.out.println(num);",10,9,3,1
codehs-csa-traversing-arraylists,"As covered in Unit 6, traversing is the process of moving through all the items in an array or data structure. Loops can be used to traverse arrays by using the incremental variable to access each individual element in an array:

int[] scores = {80, 92, 91, 68, 88};
for(int i = 0; i < scores.length; i++) 
{ 
    // This prints out the ith element! 
    System.out.println(scores[i]);
}

The same process is applicable to traversing elements in an ArrayList:

ArrayList<Integer> scores = new ArrayList<Integer>();

for(int i = 0; i < scores.size(); i++)
{
    // This prints out the ith element!
    System.out.println(scores.get(i));
}

The primary difference between array and ArrayList traversal lies in the methods used to access each element. For ArrayLists, size is used to determine the number of iterations of the increment variable, and get is used to access the element at a given index. This same difference applies to ArrayList while loop traversals and enhanced for loops:

// while loop traversal
int i = 0;
while(i < scores.size())
{
    System.out.println(scores.get(i));
    i++;
}

// Enhanced for loop traversal
for(int score: scores)
{
    System.out.println(score);
}

Because ArrayLists can change size, it’s necessary to take caution when traversing them, as the changing size of the ArrayList can affect which elements are being accessed.

Consider the following list, and associated method:

list

0	1	2	3	4
“I”	“am”	“Andrew”	“Aardvark”	“Jr.”
//Removes all Strings from an ArrayList that begin with the letter 'A'
public void removeA(ArrayList<String> list)
{
  for(int i = 0; i < list.size(); i++)
  {
    if (list.get(i).startsWith(""A""))
    {
      list.remove(i);
    }
  }
}

This method intends to remove each element in a list that starts with the letter A. The implementation of this however, has unintended consequences. When i = 2, the conditional if statement will remove the item at index 2 from the list. It then will return to the for loop header, and increment the value of i to i = 3.

When remove is used on this list, each value in the list after index 2 shifts one space down in the ArrayList:

list

0	1	2	3
“I”	“am”	“Aardvark”	“Jr.”
However, the value of i in the for loop header is now 3. When the conditional statement checks for a word that starts with “A” at index 3, there is none. The value “Aardvark” unintentionally stays in the list, even though the method was designed to remove all instances of words that start with “A”.

The solution to this problem is adding a decrement after the list item is removed:

//Removes all Strings from an ArrayList that begin with the letter 'A'

public void removeA(ArrayList<String> list)
{
  for(int i = 0; i < list.size(); i++)
  {
    if (list.get(i).startsWith(""A""))
    {
       list.remove(i);
       i --; //decrease the value of i by one!
    }
  }
}

Now when the list item is removed at index 2, the value of i is decreased to 1. When the for loop iterates again, the value of i will increase from 1 to 2 again, allowing the program to check the new value at index 2 after the elements shift position.

When using these traversal methods, there are several common Exceptions that may occur if the traversal is implemented incorrectly:

1. IndexOutOfBounds Exception:

When iterating through an ArrayList, it’s common that the iteration includes an index that is outside of the current index range. For example, if the for loop conditional statement occurs from i = 0 to i <= list.size(), then the iteration will include one extra iteration that searches for an index at position list.get(list.size()), even though ArrayList indices only range from 0 - list.size() - 1. Accessing an index that is not within the range of the existing ArrayList will result in an IndexOutOfBounds Exception, commonly known as an “off by one” error.

2. ConcurrentModification Exception

This exception occurs when attempting to remove an item from an ArrayList during an enhanced for loop. This error occurs when objects are being modified while they are being iterated on, which is what happens when enhanced loops are used on ArrayLists. Generally speaking, removing and adding items from an ArrayList should not be done while using enhanced for loops.",What is the standard method used to traverse an ArrayLists?,"for(int index = 0; index < array.size(); index++)
{
     array.get(index);
}","for(int index = array.size(); index < 0; index++)
{
     array.get(index);
}","for(int index = 0; index <= array.length(); index++)
{
     array[index];
}","for(int index = 0; index <= array.size(); index++)
{
     array.get(index);
}"
codehs-csa-developing-algorithms-arraylist,"Just as arrays have standard algorithms that can be applied in different situations, ArrayLists too, have standard algorithms.

In the last chapter, you learned of one such standard algorithm - the ability to remove an item from an ArrayList. While the example in the last chapter removed all elements from an ArrayList that started with the letter A, this algorithm can be repurposed for use with any condition:

public void removeElem(ArrayList<Type> list, E element)
{
    for(int i = 0; i < list.size(); i++)
    {
        if (list.get(i).equals(element))
        {
            list.remove(i);
            i--;
        }
    }
}

In this example, the variable element represents the property or value that is meant to be removed from the ArrayList. Remember that i-- must be included to ensure that all elements in the ArrayList are being evaluated.

Just as elements can be removed from an ArrayList, they can also be added using a standard algorithm:

public void addElem(ArrayList<Type> list, E element)
{
    for(int index = 0; index < list.size(); index++)
    {
        if() //Condition for adding element
        {
            list.add(index, element);
            index++;
        }
    }
}

Notice in this case, that index is incremented when a new element is added to the list. Including this increment largely depends on the condition that is being set to add new elements to the ArrayList. For example, if a programmer were to add odd integers to an ArrayList of even integers {2,4,6,8} in the index position of the existing element, then the increment would be necessary to avoid an infinite loop.

ArrayList traversals have several important applications in regards to how data is used and analyzed.

These various applications generally belong to a larger subset of applications:

Mathematical Analysis
- Determine a minimum or maximum value
- Compute a sum, average, or mode

Analyzing Element Properties
- Determine if at least one element has a particular property
- Determine if all elements have a particular property
- Access all consecutive pairs of elements
- Determine the presence or absence of duplicate elements
- Determine the number of elements meeting specific criteria
Reordering Elements
- Shift or rotate elements left or right
- Reverse the order of the elements

Each of these subsets uses a distinct algorithm to analyze arrays.

Computing mathematical results, such as the sum of integers in an array or finding the average of each value in an array requires the use of a similar algorithm:

ArrayList<Integer> scores = new ArrayList<Integer>();
//add values to scores

//Initialize value here
int valueToFind = 0;
for (int i = 0; i < scores.size(); i++){
    //Perform calculation on valueToFind
}
//Report results of valueToFind

In each case, the algorithm requires the initialization of a value that will be used to store the result of a given computation outside of the for loop. Inside the loop, the initialized value, valueToFind, will be altered depending on the desired output, and the results will be displayed after the loop has terminated.

For a better understanding of this, consider this implementation of computing a sum:

ArrayList<Integer> scores = new ArrayList<Integer>();
//add values to scores

int sum = 0;
for (int i = 0; i < scores.size(); i++){
    sum += scores.get(i);
}
System.out.println(sum);

The value of sum is changed each iteration through the for loop, adding the current score to the value of sum. This algorithm looks awfully similar to the one used to find the average value of an array:

ArrayList<Integer> scores = new ArrayList<Integer>();
//add values to scores

int sum = 0;
for (int i = 0; i < scores.size(); i++){
    sum += scores.get(i);
}
System.out.println((double) sum / scores.size());

In both cases, the initialized value is declared before the for loop, used in mathematical computations within, and then displayed after its termination.

To determine if an element, or a set of elements in an ArrayList meets a specific criteria or has a specific set of properties, the following general algorithm can be used:

ArrayList<String> grades = new ArrayList<String>();
//add values to grades

//Initialize tracker variable
for (int i = 0; i < grades.size(); i++){
    //Conditionally check properties
}
//Report results here

Similar to mathematical analysis, property analysis sets an initial tracker variable before the start of the for loop, and checks through each iteration if the element at a specific index meets the criteria. It then reports the findings after the loop has terminated.

In the following example, the tracker variable checks how many A’s there are in the grade array:

ArrayList<String> grades = new ArrayList<String>();
//add values to grades

//Initialize tracker variable
int numAs = 0;

for (int i = 0; i < grades.size(); i++){
    //Conditionally check properties
    if (grades.get(i).equals(""A"")) {
        numAs++;
    }
}

System.out.print(""Number of A's: "");
System.out.println(numAs);

In this case, the value of the tracker variable numAs increments if the element at each index is an A. These tracker variables can also be used to store a single value that changes depending on the condition. For example, finding the minimum value of a list looks similar to the previous example, but only stores a single value:

ArrayList<Integer> scores = new ArrayList<Integer>();
//add values to scores

int minIndex = 0;

for (int i = 1; i < scores.size(); i++){
    if (scores.get(i) < scores.get(minIndex) {
        minIndex = i;
    }
}
System.out.println(minIndex);

Rather than increment, this tracker keeps track of the current minimum value in the list. If the value at the current index is less than the existing minimum, then the tracker is changed to reflect that.

Another common ArrayList algorithm involves reordering or reversing our arrays. While this can be done in a few different ways, a common method is to create a new temporary array where a copy of the new order for values is stored. Once the new order is copied into the temporary array, it overwrites the original array with the temporary one:

ArrayList<Integer> numbers = new ArrayList<Integer>();
//add values to scores

ArrayList<Integer> temp = new ArrayList<Integer>();
//add values to scores

//Edge case
temp.add(numbers.get(numbers.size() - 1));

//Loop, but stop at the last element (edge case)
for (int i = 0; i < numbers.size() - 1; i++){
    temp.add(i + 1, numbers.get(i));
}

numbers = temp; //Copy over to the original ArrayList

In this example, the algorithm is shifting the values in the array to the right by one. Rather than move the values in the existing ArrayList, a new ArrayList is created to store the values in the specified order. This removes the possibility that the original ArrayList gets altered accidentally, and that changes to the new ArrayList do not impact the original. Note that the edge case is added before the for loop. This ensures that the ArrayList add method will work, as it can only add values to index values from 0 - size().

Some algorithms require ArrayLists to be traversed simultaneously. One such example would be if you wanted to sum the indices of two ArrayLists:

0	1	2	3	4
5	2	4	5	0
list1
+

0	1	2	3	4
3	5	6	9	12
list2
=

0	1	2	3	4
8	7	10	14	12
summedList

Creating the summedList requires that both list1 and list2 are traversed simultaneously to access and sum the individual values at each index:

ArrayList<Integer> summedList = new ArrayList<Integer>();
for(int index = 0; index < list1.size(); index++)
{
    int sum = list1.get(index) + list2.get(index);
    summedList.add(sum);
}",Which of these method implementations would correctly insert an element into an ArrayList after every even index?,"{
   for(int index = 0; index < array.size(); index++)
   {
      if(index %2 == 0)
      {
         array.add(index + 1, element);
         index++;
      }
   }
}","{
   for(int index = 0; index < array.size(); index++)
   {
      if(index %2 == 0)
      {
         array.add(index, element);
         index++;
      }
   }
}","{
   for(int index = 0; index < array.size(); index++)
   {
      if(index %2 == 0)
      {
         array.add(index + 1, element);
      }
   }
}","{
   for(int index = 0; index < array.size(); index++)
   {
      if(index %2 == 0)
      {
         array.add(index, element);
      }
   }
}"
codehs-csa-searching,"As the amount of data stored in an array or ArrayList begins to grow, a common necessity is knowing where and if certain data can be found within a dataset. For example, a user is interested in buying a new car. They want to find a used car that is within their price range and a certain color. Given a database of cars, this user should be able to find the exact car that they are looking for, provided that the car exists in the database! This process of finding data, or pieces of data, that fit a specific criteria is called searching.

A common way to search through a list of items is to start at the beginning of the list and continue through the list until the desired item is found. If the desired item is not found, then that means it is not in the list.

Suppose that you are given a set of raffle tickets at a school raffle. Each ticket has its own number on it:

Ticket	0	1	2	3	4	5
Number	44	53	12	51	64	15
The 0th ticket has number 44, and the ticket at index 4 has raffle number 64. The school will randomly select a number between 1 and 100. If you have the ticket with that number, you win!

What if the school picks 51 as the winning number? As a human, it’s easy to look over the whole list and see that you have the ticket with 51 on it, but computers need a more programmatic approach to looking through the list.

The process of searching each item in a list until the desired item is found is called linear, or sequential search.

Linear search is fairly easy to implement. To programmatically search the list of raffle ticket numbers, you just need to iterate through the list one number at a time. At each new number, if the number matches the desired number, then the desired number is in the list, and the program can stop searching and return the index position of the number. If the program makes it all the way to the end of the list and hasn’t spotted the desired number, then that means it’s not in the list.

Here’s what it looks like in pseudocode:

for every index in the list:
get the current number at that index position
if the current number matches our target number:
return the index
return not found

That pseudocode can be used to implement a working linear search:

public int linearSearch(int[] array, int key)
{
    for(int i = 0; i < array.length; i++)
    {
        int element = array[i];
        if(element == key)
        {
            return i;
        }
    }
    return -1;
}

In the example above, key represents the value that is being searched for in the given list. If the key is an element in the list, then the index where that value can be found is returned to the program, otherwise, the value -1 will be returned.

This method can also be implemented using ArrayList:

public int linearSearch(ArrayList<Integer> arrayL, int key)
{
    for(int i = 0; i < arrayL.size(); i++)
    {
        int element = arrayL.get(i);
        if(element == key)
        {
            return i;
        }
    }
    return -1;
}

While linear search is a fairly easy algorithm to implement and understand, linear search is limited by the number of elements that are being searched. The longer the data set is, the longer linear search takes, as it must iterate through all values in order to find the correct one.

Suppose the 1 millionth item in a data set were the element that you were looking for- linear search would have to iterate through the data set 1 million times in order to find it! When deciding how to search for values in a data set, it’s important to consider the pros and cons of using the search mechanism.",How does Linear Search work?,"Linear Search traverses a list in order until the desired value is found, or until the end of the list.","Linear Search uses a while loop to traverse a list for the desired value, or until the end of the array.",Linear Search traverses a list from the last value to the first value until the desired value is found.,"Linear Search searches for desired values by searching the the next highest value in a list, and seeing if that is the desired value."
codehs-csa-sorting,"As datasets get larger, it’s important to be able to manage and sort through data to find results and values more quickly and efficiently. When data is disorganized, it can be hard to find values easily. To find values, it’s much easier to do so if they are in the correct order. That way, searches can be organized at specific points, which in turn can make sure that programs will look through less values as they search.

Take this dataset for example:

1	2	7	44	5	76	9	0	72	4	325	2	753	345	234	53
Finding the value 4 in this list requires you to search from the beginning all the way to the end - since the data isn’t in a particular order, there is no way of knowing for certain where the element 4 will be found.

If this list were organized by smallest number to greatest:

0	1	2	2	4	5	7	9	44	53	72	76	234	325	345	753
Then finding 4 would be a much easier process, as you can search certain sections of the list for the element in question where it is most likely to be found.

In programming, there are standard algorithms that can be used to sort data in ways that make finding data more manageable. Two standards algorithms that will be explored in this chapter are Selection and Insertion Sort.

Selection sort sorts arrays by repeatedly finding the minimum value in an array, and moving it to the front. Consider the following, unorganized array:

5	3	4	1	6	2
Using selection sort to sort this array, the first index in the array is picked to start.

5	3	4	1	6	2
Then, the list is traversed to find the minimum value in the rest of the list, which in this case is 1. The value 1 is then swapped from its current position to the position where 5 was:

1	3	4	5	6	2
Now the value 1 at index 0 is considered sorted, and the next unsorted element at index 1 will be chosen. The value at index 1 will be compared with the rest of the unsorted items until a minimum value is found. In this case, the value 2 at index 5 is the minimum value, and it is swapped with the value at index 1.

1	2	4	5	6	3
This process continues until the entire list is sorted from least - greatest.

Here is what this process looks like in pseudocode:

traverse each index up to the second to last element
find the minimum in the rest of the list
swap the index and minIndex
// now everything up to curIndex is sorted

This can then be used to create a working algorithm for selection sort:

public static void selectionSort(int[] array)
{
    for(int index = 0; index < array.length - 1; index++)
    {
        int minIndex = index;
        for(int i = index; i < array.length; i ++)
        {
            if(array[i] < array[minIndex])
            {
                minIndex = i;
            }
        }
        int tempValue = array[index];
        array[index] = array[minIndex];
        array[minIndex] = tempValue;
    }
}

The initial traversal goes from the first element to the second to last element (array.length - 1) because the final element in the array is considered sorted if every other element in the array has been sorted correctly. The second traversal looks for the minimum value in the array from the current element until the end of the list. It does not search the list for already sorted elements. Once the minimum element is found, it swaps positions with the current element.

Selection sort is a particularly useful sorting algorithm when the elements in a list are in reverse order:

6	5	4	3	2	1
In this case, the algorithm only needs to swap values a few times, as each swap successfully puts each element in its correct position.

Insertion sort sorts an array by sorting each element compared to the elements already sorted to their left.

Given the same list as the previous example, insertion sort marks the first element in the list as sorted:

5	3	4	1	6	2
The next element, 3, is then selected as the next element to sort:

5	3	4	1	6	2
Rather than find the minimum value in the unsorted segment like selection sort, insertion sort compares unsorted elements to the sorted ones, placing the element in the correct position within the sorted list:

3	5	4	1	6	2
The element 3 is now considered sorted, and the sort continues on to the next element, 4, and sorts it within the already sorted list:

3	4	5	1	6	2
This continues until all elements in the list are sorted from least to greatest.

Here is a pseudocode implementation of insertion sort:

traverse each element starting from index 1
traverse sorted elements to find current element position
shift sorted elements to place current element

This can be used to create a working algorithm for insertion sort:

public static void insertionSort(int[] array)
{
    for(int index = 1; index < array.length; index++)
    {
        int currentIndexValue = array[index];
        int sortedIndex = index - 1;

        while(sortedIndex > -1 && array[sortedIndex] > currentIndexValue)
        {
            array[sortedIndex + 1] = array[sortedIndex];
            sortedIndex--;
        }

        array[sortedIndex + 1] = currentIndexValue;
    }
}

Insertion sort traverses all elements from index 1 until the end of the array. Each element then traverses the sorted segment of the array, looking for the correct place in the sorted list to go. This is done using a while loop, as the number of iterations depends largely on the content of the sorted list. As the element moves through the sorted list, each element it searches through is shifted one index higher. This ensures that the element can be placed in the correct index without removing any of the pre-sorted elements from the list.

Insertion sort is most useful when a list is mostly sorted:

1	2	3	4	6	5
When lists are almost sorted, the number of times that insertion sort needs to iterate through the list items is limited. In this case, the while loop will not execute for the first 5 index values in this array, limiting the execution count, and reducing the amount of time the algorithm spends sorting items.

When choosing which sorting algorithm to use, it’s important to pay attention to the composition of the existing list, and determine which method will be most efficient, especially as the datasets grow.",When is it more appropriate to use Insertion Sort than Selection Sort?,When the array is already mostly sorted at the start.,"Insertion sort is always faster than selection sort, so any array is appropriate.",When the array is sorted in reverse order.,"Insertion sort is always slower than selection sort, so no array is appropriate."
codehs-csa-data-ethics,"On a daily basis, humans are creating more data than ever before. This is creating new challenges around protecting and securing that data for individual users, large companies, banks, small startups, doctors, movie makers, and everyone in between. This means it’s more important than ever to be smart about security and privacy in the digital age of computing.

In order to understand the impact of data collection on privacy and security, it’s important to understand what each of these terms mean.

Privacy is the right to be free from unwarranted intrusion and to keep certain matters from public view.

Security is the state of being free from danger or threat. Its the warm, fuzzy feeling you have when you don’t have to worry about feeling threatened by harm from others or things in the world around us!

Digital technology has forever changed the way society is operating and the way people live. Everyday, there are new ways to work and to play which include new methods of interacting with one another. As people’s digital footprints grow, people form their own online identities.

Digital security is the protection of these online identities.

A digital footprint is the information about a particular person that exists on the Internet as a result of their online activity. This includes emails you send, comments you leave, pictures you post, your search history, and apps you use. Even your work on CodeHS is part of your digital footprint! All of these ways and more are the ways that you are sharing your own data! Any time you use the Internet you are building your digital footprint. Every time you use a device, your data can be collected!

A lot of people think that hackers are going to steal their data, which they can and do, but truthfully, most people give up their data freely without thinking about it too much. It’s important to be aware of your own personal data and how you choose to share your data with others so that you can keep your data secure and private.

Here are some quick tips to maintain your digital footprint and protect your personal data.

- First, use privacy settings on apps and sites to limit your exposure.
- Review posts that your friends tag you in and address questionable content.
- Delete any old social media accounts you don’t really use.
- Search yourself to see what other people see when they search for you on Google.
- Use strong passwords for every account you have.
- Stay on secure sites by sticking with httpS, not just http…if you see a site that starts with http, it is not a secure site!
- Be sure to monitor your webcam and microphone use and make sure you don’t leave them on when you are not using them.
- Be aware of your location sharing on apps like Find Friends or whenever Google or a site asks if you want to share your location.
- Skim privacy policies and see if anything jumps out that concerns you about how the site or app shares or uses your data.
- Watch for phishing attempts in emails. If someone you don’t know sends you an email that seems odd or sounds too good to be true, don’t click through any links or download any content until you’ve looked into it more.
- Be careful logging into public computers like at a library, for example. Your data is logged on those devices and may not always be wiped to a clean state after you use it.
- Stay up to date on the best web security practices like 2-factor authentication where you have to enter a code that is sent to your phone before you can proceed on an app or site. This code confirms you are who you say you are and not someone trying to pretend to be you!
- If you think your personal data has been compromised, contact your parent or guardian, the company that owns the site or app, and/or a school IT person so you can get help or advice.

All data is shared on the internet via what are called protocols. Protocols for data sharing on the internet are rules and conventions for communication between network devices.

The Internet is a packet-switched system through which digital data is sent by breaking the data into blocks of bits called packets. Packets contain both the data being transmitted and control information, or metadata, that helps route the data. It is only able to work because all machines have agreed to use the same protocols for creating and reading packets. Your computer and any server are able to share data because they use the same protocols. They are agreeing to talk in the same language.

Computer use and the creation of programs have an impact on personal security that can be beneficial and/or harmful.

Beneficial Impacts:

- Instant Communication: You share data whenever you email, make a video call, or post on social media. All of these have made it possible to communicate instantly with others and consume information at a very rapid pace.

- Improved Collaboration: Sharing data enables collaborative problem solving on a very large scale. Foldit is an example of citizen science that harnesses the problem solving capacity from hundreds of thousands of citizens on the internet to solve really complicated problems. Foldit is an online game where players attempt to solve the folding structures of very important proteins. By determining the structures of these proteins, researchers are able to develop vaccines and understand diseases better. Once the foldit game went live on the internet, players were able to produce an accurate structure of an AIDs causing virus in only 10 days. This virus had been unsolved by computer simulations and researchers for 15 years!

- Increased Access to Goods and Services: You share your data whenever you make an online purchase. Sharing data has provided online shopping that has enabled you to buy directly from retailers. You can easily purchase from other people who don’t have the funds to run a physical store. You are able to find the best product at the lowest price, rather than being disadvantaged by location or lack of knowledge because you can view ratings and reviews across all retailers.

- Access to Information: Sharing data allows more access to information. Anyone on the internet can read cutting edge scientific publications now.

- GPS and Location Sharing: GPS has completely changed how you navigate the world. You can leave your home with just your smartphone and you’ll generally have no problem finding the place that you need to be. You share your current location, which is data, and you are provided data around your position such as images and directions.

- Entertainment: When you upload videos to YouTube, you share your data! There are also online gaming communities so you can play games with someone in another country who speaks a different language or you could be playing a video game with hundreds of other players simultaneously. You share things like your location and more with them, as well. When companies like NetFlix and Hulu stream videos to your home TV or device, theres a big exchange of data, too. They share digital content with you and your family must share payment information and device information to allow access.

For all of the amazing things that data sharing can provide, there are some substantial negative drawbacks as well.

Harmful Impacts:

- Access to Confidential Information: The website called Wikileaks posts classified information that either governments or corporations are trying to keep secret. On one hand, this is a good thing because it promotes the transparency of information. It makes it so corporations and the governments cant keep secrets from its citizens. However, there’s potential danger in having classified secrets being public, especially if that information is protecting people from harm or hiding their location purposefully.

- Illegal Sharing/Downloading: Peer-to-peer networks allow people to share content or data that they have on their computers. This is fine if the files are their own creation, but oftentimes shared content is NOT owned by the people sharing it. It’s easier than ever to distribute information or content that is not your own, such as copyrighted works of art or copyrighted software.

- Anonymity: You can tell who internet users are by the data they share. How identifiable should Internet users be? On one hand, anonymity supports equality for all on the Internet. If all users are anonymous, users wont be targeted or discriminated against like for their gender or race, because that information won’t be available. However, having complete anonymity provides opportunities for cyber bullying. If all users are anonymous, no one is accountable for their actions.

Regardless of the positive impacts that certain technologies might have on society, they can also have unintended consequences that have a negative impact on society, law, and ethics. Programmers have a responsibility to make sure that their programs are socially, legally, and ethically acceptable.

A computing professional should:

- Contribute to society and to human well-being, acknowledging that all people are stakeholders in computing.
- Avoid harm.
- Be honest and trustworthy.
- Be fair and take action not to discriminate.
- Respect the work required to produce new ideas, inventions, creative works, and computing artifacts.
- Respect privacy.
- Honor confidentiality.
- Remember that knowledge is power as you live with others in this digital world. Use your knowledge of computing for good purposes so you and everyone else can be safe and enjoy the benefits of computing.","Which of the following are some good ways to protect your own personal data?

I. Use privacy settings to limit exposure
II. Post often on social media while traveling
III. Permanently delete old social media accounts you don’t use
IV. Google yourself on a regular basis
V. Use short, easy to remember passwords so you don’t have to write them down
Vi. Stay on sites with http://","Only I, III, IV, VI","Only III, IV, V, VI","Only I, III, IV, V, VI",All of these
codehs-csa-2d-arrays,"In Unit 6, you learned how to create arrays, which store a fixed number of elements of the same type in one variable. Arrays can store a series of data in list form to make it easier to access information. Imagine you were a teacher trying to keep track of student scores on exams. This could be done easily using an array:

int[] exam1 = {90, 87, 86, 56, 96}; 
System.out.println(""Student 1's score: "" + exam1[0]); 

Each index in exam1 corresponds to a different student in the class, allowing you as the teacher to access student scores. Even this process can become tedious if the amount of data begins to grow consistently. Suppose there were 20 exams in the school year - keeping track of exams 1-20 in 20 different variables can be tedious and can lead to careless mistakes if you aren’t careful.

Luckily, there is a way to store all of this exam information in a single variable. Because arrays store elements of the same type, we can actually store an array of arrays:

int[] exam1 = {90, 87, 86, 56, 96};
int[] exam2 = {34, 25, 100, 56, 45};
int[] exam3 = {65, 76, 34, 74, 90};

//An array that stores a list of int[] 
int[][] exams = {exam1, exam2, exam3}; 

Arrays that store a list of arrays is referred to as a 2D array.

As noted above, 2D arrays can be declared by including an additional [] at the end of the declaration:

int[][] exams;

Notice that the type of the array still needs to be declared. Arrays can only store values of the same type, so a 2D array can only store arrays of the same type. This 2D array can only store integer arrays.

To initialize a 2D array, an additional [] also needs to be used to indicate the length of each array in the 2D array:

int[][] exams = new int[3][3];

This indicates that a new 2D array of three integer arrays will be created that each store three integer values. This can be visualized as such:

exams:

int[]	0	0	0
int[]	0	0	0
int[]	0	0	0
2D arrays can also be initialized using array values, as demonstrated above:

int[] exam1 = {90, 87, 86, 56, 96};
int[] exam2 = {34, 25, 100, 56, 45};
int[] exam3 = {65, 76, 34, 74, 90};

//An array that stores a list of int[] 
int[][] exams = {exam1, exam2, exam3};

Arrays that store arrays are referred to as 2D arrays because the way they store elements is akin to a two-dimensional shape. As discussed in unit 6, arrays can access elements in an array by using the [] notation:

int[] exam1 = {90, 87, 86, 56, 96};
System.out.println(""Student 1's score: "" + exam1[0]);  //prints out 90

In a 2D array, accessing an index will return an array:

int[] exam1 = {90, 87, 86, 56, 96};
int[] exam2 = {34, 25, 100, 56, 45};
int[] exam3 = {65, 76, 34, 74, 90};

//An array that stores a list of int[] 
int[][] exams = {exam1, exam2, exam3};
System.out.println(exams[0]); // will print a reference address for exam1

That array can then be indexed to return a particular element:

int[] exam1 = {90, 87, 86, 56, 96};
int[] exam2 = {34, 25, 100, 56, 45};
int[] exam3 = {65, 76, 34, 74, 90};

//An array that stores a list of int[] 
int[][] exams = {exam1, exam2, exam3};

System.out.println(exams[0][0]); //will print 90

To access a single element in a 2D array, the specific list that the element is located in needs to be accessed, then the element itself needs to be accessed from that array:

int score = exams[2][3];
System.out.println(score);  // will print 74

Index Value	Array	0	1	2	3	4
0	exam1	90	87	86	56	96
1	exam2	34	25	100	56	45
2	exam3	65	76	34	74	90
As evident in the visualization, each list in the 2D array can be thought of as a row in the 2D array, and each element in a list can be thought of as a column. Thus, the general format for accessing an element in a 2D array is exams[row][column].

Elements in a 2D array can also be modified using the [row][column] notation. The second element in exam1, can be changed to 41 by writing:

exams[0][1] = 41;

Now, the 2D array has an updated value at index 1 of array exam1:

Index Value	Array	0	1	2	3	4
0	exam1	90	41	86	56	96
1	exam2	34	25	100	56	45
2	exam3	65	76	34	74	90","double[][] table = new double[3][4]

What is the value of table[0].length?",4,0,3,12
codehs-csa-traversing-2d-arrays,"As discussed in the previous lesson, individual elements in a 2D array can be accessed using [row][column] indexing:

String[][] cities = {{""New York City"",""Albany"", ""Ithaca""},
{""Los Angeles"", ""San Francisco"", ""San Jose""},
{""Houston"", ""Dallas"", ""San Antonio""}}; 

System.out.println(cities[1][1]);  // prints San Francisco

The process of accessing an individual element can be used during a 2D array traversal, which can be used to return all elements in a 2D array.

Traversing a 1D array required the use of a for loop to iterate through each element in the array:

int[] nums = {1,2,3,4,5};
for(int index = 0; index < nums.length; index++)
{
   System.out.println(nums[index]);
}

For a 2D array, this initial traversal is used to access each array in the 2D array, and a nested for loop is needed to access each element within the selected array:

int[][] nums = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}};
for(int row = 0; row < nums.length; row++)
{
   for(int col = 0; col < nums[row].length; col++)
   {
      System.out.println(nums[row][col]);
   }
}

The outer for loop accesses each list in the 2D array nums, while the inner for loop accesses each value within the list. During the first iteration of the outer for loop, the value of row is 0. When the inner for loop iterates, the value of col will increase each time. The values nums[0][0], nums[0][1], nums[0][2], nums[0][3], nums[0][4] will all be printed to the console, and then the value of row will increase to 1. This process will continue until all values in the 2D array have been printed.

Notice that the inner for loop uses the length of the individual list that is being accessed. This ensures that each element in the array will be iterated over.

This form of iteration is referred to as row-major order. Row-major order is the practice of iterating over each row in an array. In the example above, each list is searched from beginning to end before the next list is searched:

2D arrays can also be searched in column-major order, where a single column in a 2D array is searched before the next column is iterated over:

Column major order requires a slight alteration to the row-major traversal algorithm:

//column-major order
int[][] nums = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}};
for(int col = 0; col < nums[0].length; row++)
{
   for(int row = 0; row < nums.length; row++)
   {
      System.out.println(nums[row][col]);
  }
}

For column-major order, the inner for loop iterates through all row values, while the outer for loop iterates through each column. During the first iteration of the outer for loop, the value of col is 0. When the inner loop iterates, the value of row increases by one until the entire 2D array has been searched. The values num[0][0], nums[1][0], nums[2][0] will be printed to the console before the value of col increases to 1.

While column-row major can be useful when iterating through 2D arrays, Java is more efficient at iterating over row-major order iterations. For smaller 2D arrays, this difference is inconsequential, but for larger 2D arrays, column-major order iteration may take a substantial amount of time compared to row-major iteration.

2D arrays can also be iterated over using an enhanced for loop:

//enhanced for loop
int[][] nums = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}};
for(int[] list: nums)
{
   for(int num: list)
   {
      System.out.println(num);
   }
}

Enhanced for loops with 2D arrays still require the use of nested loops. In the outer for loop, the enhanced for loop is accessing each list in the 2D array. Notice that the data type int[] is included in the for loop call, indicating that the variable list in each iteration will be an array of integers. The inner for loop then iterates over each item in the list, and prints out the integer which has been stored in the variable num. The type of the variable in the inner for loop should match the same type of the array.

Because enhanced for loops iterate through each array in a 2D array, enhanced for loops always use row-major order to iterate through a 2D array.

Just as arrays used linear search to find elements, 2D arrays can also use linear search to find values. Here is the general algorithm for searching a 2D array:

public String search(int[][] array2D, int key)
{
   for(int rowIndex = 0; rowIndex < array2D.length; rowIndex++)
   {
      for(int colIndex = 0; colIndex < array2D[rowIndex].length; colIndex++)
      {
         if(array2D[rowIndex][colIndex] == key) 
         {
            return key + "" is located at: "" + rowIndex + "","" + colIndex;
         }
      }
   }
   return key + ""is not in this 2D array."";
}

In the case of 2D arrays, each row needs to be searched individually. The outer loop simply accesses each individual row of the 2D array while the inner loop is applying search to the array. If the item is not found in any of the arrays, then the return value indicating that the key cannot be found should be placed outside of both for loops. This is to ensure that this only returns if none of the arrays in the 2D array contain that particular value.

2D arrays have a series of standard algorithms that can be used to traverse their values:

Mathematical Analysis
- Determine a minimum or maximum value
- Compute a sum, average, or mode

Analyzing Element Properties
- Determine if at least one element has a particular property
- Determine if all elements have a particular property
- Access all consecutive pairs of elements
- Determine the presence or absence of duplicate elements
- Determine the number of elements meeting specific criteria

Reordering Elements
- Shift or rotate elements left or right
- Reverse the order of the elements

Each of these subsets uses a distinct algorithm to analyze arrays:

Mathematical Analysis
Mathematical analysis is done by initializing a value, like sum before the nested for loops, and then performing calculations on the array values within the inner for loop so that all values in the 2D array are added to the final calculation. The results can be reported after the nested loop is finished executing:

int[][] scores = {{2,3,4,5,6},{7,6,5,4,3}}

//Initialize value here
for(int[] row : scores)
{
   for (int i = 0; i < row.length; i++){
   //Perform calculation here

   }
}

//Report results here

Analyzing Element Properties
To determine if elements have a particular property, initialize a tracker value before the nested for loop traversal, and then conditionally check for that tracker while traversing the array:

int[][] scores = {{2,3,4,5,6},{7,6,5,4,3}}

//Initialize tracker variable
for(int[] row : scores)
{
   for (int i = 0; i < row.length; i++){
      //Conditionally check properties
      if(condition){ ... }
   }
}

//Report results here

Reordering Elements

To make alterations to the list, such as reverse the order or shifting elements, the general format requires that a new 2D is created that will then hold the values in the order that they should be rearranged. Each iteration through the initial array will add a value from the initial array to the altered array:

int[][] scores = {{2,3,4,5,6},{7,6,5,4,3}}
int[][] alteredScores;
for(int row = 0; row < scores.length; row++)
{
   for (int col = 0; col < scores[row].length; col++){
      //add values from grade to alteredArray

   }
}

//Report results here","A 2D double array is declared and initialized to track the terrain of a city park. Each value in the 2D array represents the height of a particular latitude and longitude above sea level. Longitude is represented by the columns in the 2D array and latitude is represented by each row in the 2D array.

The creator of this 2D array would like to look at the height of the city park along the latitude 100.0 - which traversal method would make the most sense in order to do so?",Row-Major Order,Column-Major Order,Enhanced for loop,This isn’t possible given the 2D array.
codehs-csa-inheritance,"Large classes often rely on several different instance variables in order to successfully create comprehensive programming solutions. For example, a Person class might have several instance variables, like name or birthday. These instance variables are said to have a “Has-A” relationship to their class objects. A Person has a name, and has a birthday. Values that use a “has a” relationship represent instance variables in our projects.

Another type of relationship in object-oriented programming is the “Is-A” relationship. “Is-A” is used when one thing is a more specific version of another thing. As an example, think about the relationship of a Student to a Person. A Student does not have a Person, but rather, a Student is a Person. In this example, a Student is a more specific example of a Person. While it’s possible to say that every Student is a Person, it’s not possible to say that every Person is a Student. The Person class is a more general class and the Student class is a more specific class. Some other examples of is-a relationships are:

- A Dog is an Animal.
- A Square is a Rectangle.
- San Francisco is a City.
- Computer science is a Class.

Since many classes, like Person and Student, have an is-a relationship, they share some common attributes. Just as a Person has a name, and a birthday, a Student has the same attributes. Since these two classes share many of the same attributes, there should be a way to consolidate these two classes so as to avoid writing the same attributes and instance variables in each class.

In Java, the is-a relationship is expressed in the form of superclasses and subclasses. A class hierarchy can be developed by putting common attributes and behaviors of related classes into a single class called a superclass. In the current example, the attributes name and birthday belong to both Person and Student, so they should be written in a superclass.

Subclasses inherit the public attributes and behaviors from the superclass. As a result, a subclass object can use any public attribute or behavior without having to repeat these in its code. A superclass object does not have access to the attributes and behaviors of the subclass class. In this case, a Student object will have access to all the attributes and behaviors of both the Student class, like GPA and grade level, and the Person class, but the Person object will only have access to the attributes and behaviors of the Person class.

To create a superclass/subclass relationship, the keyword extends is added to a class header followed by the name of the superclass:

public class Student extends Person
{
   //Student class implementation

}

This creates the subclass. Student, in this case, is a subclass of Person, which is the superclass. Subclasses are only capable of extending a single superclass. While a class can only extend one class, it can extend a class that has already been extended:

public class Person {
   // Person class implementation
}

public class Student extends Person {
   // Student class implementation
}

public class HighSchoolStudent extends Student {
   // HighSchoolStudent class implementation
}

In this case, a HighSchoolStudent object will have access to all the attributes and behaviors of the HighSchoolStudent class, the Student class, and the Person class.

As programs become more complicated, oftentimes creating a hierarchy of classes allows for the reuse of common attributes and behaviors. Figuring out which variables and methods are shared across class implementations is the first step to developing a successful hierarchical structure.",Which of the following best describes a Subclass / Superclass relationship?,Banana / Fruit,Banana / Color,Banana / Peel,Banana / Count
codehs-csa-override-methods,"Classes can form a hierarchy where each of the subclasses has access to all of the public methods of a parent, or superclass. But what if a subclass doesn’t want to inherit a method from the superclass? For example, what if the Student class wants to use a different toString() method than the Person class to include additional pieces of information about the object?

Person Class:

public String toString()
{
   return name + "" was born "" + birthday;
}

Student Class:

public String toString() {
   return super.getName() + "" is in grade "" + grade; 
} 

Classes like Student are able to use their own toString method through a process called method overriding. In a method override, a subclass can redefine a method instead of inheriting that method from the superclass.

A method override occurs when a public method in a subclass has the same method signature as a public method in the superclass. When something has the same method signature, it means that the methods have the same name and input parameters. In the example above, both toString() methods in Person and Student have the same name and input parameters - the Student toString(), when called in the Student class, will override the toString() method from Person.

To denote an override in Java, the best practice is to use the @Override keyword in the line above the method signature. It is important to note that a method overrides a superclass when it has the same method signature, not because it includes the @Override keyword.

Student Class:

@Override
public String toString() {
    return super.getName() + "" is in grade "" + grade;
}

Including @Override is not required, but is considered best practice for two main reasons. First, using the @Override signals to Java that you are trying to override a superclass method. The Java compiler will check to make sure it actually does override a method correctly and will throw an error if you do not override correctly. Second, it helps to make your code more readable by telling other programmers that a particular method is being used over a similar method in the superclass.

When designing class hierarchies, methods and variables that will be used by all the classes are generally put in the superclass. Subclasses are built to add additional methods and instance variables for more specific classes.

As an example, consider the Person and Student classes again. The Person superclass will have name and birthday as the instance variables and may have a toString() and age() method.

The Student class would still need the name and birthday, but will also need a grade and GPA as instance variables. These are specific only to a student, so they are added to the subclass, not the superclass. Likewise, it may include a change grade method and a modified toString() method with an override.

When calling methods for an object, Java starts by looking in that object class for that method signature. If it finds it there, it will use that particular method, otherwise, it will go to the superclass and look for the method. This will continue until it reaches the top of the class hierarchy. Any method that is called must be defined someplace in this class hierarchy, otherwise, Java will throw an error.",Why might we want to override a superclass method? Select the best option.,We override a method because a subclass needs to define a behavior in a different way than the superclass.,We override methods so that we can see how a method is working within the class.,We override methods because superclasses cannot correctly define most subclass behaviors.,We override methods to make Java run more efficiently.
codehs-csa-super,"When a subclass object is created, a superclass object is created in the process. This is evident in the initial call to super that is made in the constructor:

public class Student extends Person { 
   private int grade;
   private double gpa;

   public Student (String name, String birthday, int grade, double gpa) {
      super(name,birthday);
      this.grade = grade; this.gpa = gpa;
   }

   public int getGrade(){
      return grade;
   }
} 

In addition to creating the superclass object, the super keyword can be used to reference the super object in other methods within the subclass.

The keyword super is similar to the keyword this. this refers to the current object, while super refers to the superclass object. Just as it’s possible to reference methods and pass parameters using the this keyword, methods can be referenced and passed parameters using the super keyword.

super refers to the superclass object and can call methods using:

super.methodName(parameters)

Here is a sample superclass Animal:

public class Animal {

   private String type;
   private String sound;

   public Animal (String type, String sound) {
      this.type = type;
      this.sound = sound;
   }

   public void speak(int number){
      for (int i = 0; i < number; i++)
         System.out.println(sound);
      }
   }

The Dog class extends the Animal class, inheriting its methods and instance variables:

public class Dog extends Animal {

   public Dog () {
      super(""Dog"", ""Bark"");
   }

   public void bark(int number){
      super.speak(number);
   }

}

In this example, the Dog subclass constructor uses the super keyword to call the Animal constructor. The Dog class bark() method also calls the superclass speak() method by passing it a parameter that will then get used in the speak() method.","Given the following code, what is the correct way for the subclass to call the speak method in the Person class?

public class Person {

    public void speak(String sound) {
        System.out.println(sound);
    }
}

public class EnglishSpeaker extends Person {

    public void greet() {
        /* Missing code */
    }
}","super.speak(""Hello"");","super(""Hello"");","speak(""Hello"");","Person.speak(""Hello"");"
codehs-csa-references-using-inheritance,"Up to this point, every object declaration and initialization that you’ve written has created objects where the Reference type matched the Object type.

While this is often the way that objects should be written, the object type and reference type can be different. The Reference type of an object variable can be declared with a superclass, then instantiated with a subclass:

Person student1 = new Student();

Doing so facilitates polymorphism. Polymorphism is the capability of a method to do different things depending on the object it is acting upon. In Java and other object-oriented programming languages, the concept of polymorphism means that an object can take on different forms depending on its implementation. Java can call the correct method even when an object is disguised as a more generic reference type.

In standard Java Documentation, superclasses are denoted with the letter T, while subclasses are denoted with the letter S. If class S is a class T, then S is a subclass to the T superclass.

This terminology will be used throughout this chapter to refer to the relationship between superclasses and subclasses.

As mentioned earlier, the superclass can be used as the reference type for an object instantiated with a subclass.

Person student1 = new Student();

More broadly, this means that when the Superclass is used as a reference type, then an object can be created as either the Superclass T, or any Subclass S. For example, the Person reference type can be used when instantiating an object as a Person, Student, or Worker, so long as the instantiated type is a subclass of the Person class:

Person student1 = new Person();
Person student1 = new Worker();
Person student1 = new Student();

The ability to declare an object with the superclass Reference type enables the use of polymorphism, where methods are able to change their behavior. This is most useful and evident in the following ways:

It enables the use of type T as a formal parameter in a method, which can then pass any object of type T or S.
It enables the creation of arrays and ArrayList of type T that stores any type T or S objects.
For the former, consider the following method:

public static void greeting(Person person)
{
    System.out.println(""Hello "" + person.getName());
}

The formal parameter in this method specifies that the object type that is being passed is of type Person. A Student object can still be passed to this method if it is declared with the Person reference type:

Person karel = new Student(""Karel"");
greeting(karel); //prints 'Hello Karel'

This same concept applies to storing values in an array or ArrayList. If an array is declared with type Person, then Student objects are still able to be added when declared as type Person:

Person karel = new Student(""Karel"");
Person jeremy = new Person(""Jeremy"");
Person[] people = {karel, jeremy};

This process illustrates how polymorphism can be used to broaden the use of methods and data structures to include objects of multiple classes within a hierarchy.","Given the following class structure:

public class Vehicle {
   /* implementation not shown */
}

public class Truck extends Vehicle {
   /* implementation not shown */
}

Which of the following objects can be created?

Vehicle obj1 = new Vehicle();
Vehicle obj2 = new Truck();
Truck obj3 = new Truck();
Truck obj4 = new Vehicle();","obj1, obj2, obj3",obj3 & obj1,"obj1, obj3, obj4",All of these are valid
codehs-csa-polymorphism,"As discussed in the previous chapter, polymorphism is the capability of a method to do different things depending on the object it is acting upon. This process allows for the declaration of objects using a superclass that can then be instantiated as a specific subclass. This enables Arrays and methods to utilize polymorphism.

Polymorphism is also capable of calling the correct method for an object even when that object is disguised as a more generic reference type. This process is evident when looking at how object methods are called in compile time and run time.

At the time a program gets compiled, methods in or inherited by the declared type determine the correctness of a non-static method call. During the process of compiling a program, Java checks the declared type of an object to determine if all of the called methods exist:

Person person1 = new Student();
person1.getName();

The Java compiler will only check the Person class to see if the getName method exists. It will only successfully compile if it exists in the Person class, regardless of whether or not it exists in the Student class. This means that objects declared as a superclass type but instantiated as a subclass type can only call methods that exist in both classes.

At the time a program runs, the methods in the actual object type get executed. If the method doesn’t exist there, Java looks to the superclass for the method. From the previous example, at run time, Java will look for the getName method in the Student class first. If it doesn’t exist, it will look in the parent class.","In order for a program to compile, any method that an object uses …",Must be defined in the class where the object is declared.,Must be defined in the class where the object is instantiated.,Must be defined in both the class where the object is declared and where it is instantiated.,Doesn’t have to be defined anywhere. Java only checks for the method at run time.
codehs-csa-object-superclass,"Classes can form a hierarchy where each of the subclasses has access to all of the public methods of a parent. At the top of the hierarchy is the Object class, which is a part of the built-in java.lang package. All other classes can use the Object class through inheritance.

The Object class contains several useful methods that are used and inherited by its subclasses. Two such methods are equals() and toString().

The equals method compares two objects and is often overridden by a subclass. Using the Object level version of the equals() method, Java returns true only if the two objects are represented by the same object in memory. This is often not very helpful, as == also returns the same result, which is why this method is often overridden by subclasses.

One example where equals() is overridden is the String class. The String class equals() method compares each character of the string to determine if they are the same, not just if they are the same objects.

The toString() method is another commonly used and commonly overridden method from the Object class. When an object name is called with no method, the toString() is returned as a String representation of the object. The generic toString() for an object is to return the object type followed by an @ symbol and then the unsigned hexadecimal representation of the object. This has limited value, which is why it is often overridden.

Object obj1 = new Object();
System.out.println(obj1);   //prints java.lang.Object@27c170f0

There are many examples where the toString() method is overridden. For example, in the Person class you’ve created earlier in this chapter, the toString() method is overridden to return the name of the person:

Person person1 = new Person(""Steve"");
System.out.println(person1);  //prints Steve",Which of the following methods would you find in the Object class?,toString,comparesTo,delete,override
codehs-csa-recursion,"As discussed in previous chapters, iteration is a useful programming tool that makes programs more efficient and readable. So far, you’ve used for loops and while loops to create iterative programs:

public int sum(int num)
{
    int sum = 0; 
    for(int i = 0; i <= num; i++)
    {
        sum += i;
    }
    return sum;
}

In addition to these iterative control structures, iteration can be implemented in programs using a process called recursion.

Recursion is an iterative approach where a method calls itself. Recursion is used to break a complex problem down into a slightly simpler version. This is done until the problem is so small that it is easily solvable.

The example summing algorithm written above can actually be written using a recursive algorithm. If the call sum(10) were made to the method, each value from 0 - 10 would be summed together:

sum(10) = 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0

When looking at the summation this way, a pattern begins to emerge. Within the call to sum(10) is actually a call to sum(9), as sum(9) will sum all values from 0 - 9.

Thus, we can rewrite our original summation as:

sum(10) = 10 + sum(9)

Since sum(9) is inherent in the sum of all values 0 - 10, sum(8) must be a part of the solution for sum(9). This pattern continues until the smallest value 0 is reached:

sum(9) = 9 + sum(8)
sum(8) = 8 + sum(7)
…
sum(1) = 1 + sum(0)
sum(0) = 0

Each time through, the problem gets a little simpler. When the process gets to the point where it can’t be simplified anymore, the final result is considered the base case. In this example, the base case is sum(0) = 0. If there isn’t a base case, then the recursion would continue on forever.

All of the other numbers can be represented generically with a formula such as the one below:

sum(n) = n + sum(n - 1)

The generic formula is considered the recursive case. The recursive case is the step that the algorithm takes to make the problem one step smaller so that it moves towards the base case.

If the recursive case doesn’t simplify or make the program smaller, then the recursion would go on forever as well. The base case and the recursive case need to be designed in tandem so that they eventually lead to a method that terminates.

These two cases can be used to create a full recursive version of the sum method:

public static int sum(int n)
{
    if (n == 0)
    {
        return 0;
    }

    return n + sum(n - 1);
}

When the call sum(3) is made to this method, the first call to the method will return the value 3 + sum(2). This will call the sum method again, this time with the actual parameter of 2. The value returned by this call will be 2 + sum(1). This process continues until sum(0), when the value 0 will be returned to the program. When this call happens, all previous return values are returned to each call of the sum method, and the final result is returned:

sum(3)	sum(2)	sum(1)	sum(0)
Value of num	3	2	1	0
Result of num == 0	False	False	False	True
return value	3 + sum(2)	2 + sum(1)	1 + sum(0)	0

As illustrated in the table above, each recursive call has its own set of local variables, including the formal parameters. These parameter values capture the progress of a recursive process, much like loop control variable values capture the progress of a loop. Just like the other iterative structures, recursion can be used to traverse Strings, arrays and ArrayLists.",Why do we use recursion?,We use it to break complex problems down into simpler problems that become easier to solve.,Recursion is always a more efficient way to use iteration.,Both of these,Neither of these
codehs-csa-recursive-searching,"As discussed in previous chapters, searching and sorting data is an integral part of data storage and management in Java. Searching algorithms, such as Insertion and Selection sort, rely on the use of iterative control structures, like for loops and while loops, to traverse data structures and find a desired value:

//Selection sort relies on iteration to traverse data structures
for(int index = 0; index < array.length - 1; index++)
{
    int minIndex = index;
    for(int i = index; i < array.length; i ++)
    {
        if(array[i] < array[minIndex])
        {
            minIndex = i;
        }
    }
    int tempValue = array[index]; array[index] = array[minIndex];
    array[minIndex] = tempValue;
}

Just as for loops and while loops can be used for traversals, recursion too can be applied to searching algorithms.

One search method that relies on the use of recursion is binary search.

A binary search finds the middle of an array and tests that point. If the target is greater than the midpoint value, then the search eliminates the lower half. Likewise, if the target is less than the midpoint value, the top half can be eliminated. This process is then repeated, finding a new midpoint each time. It’s important to note that the array must be sorted for a binary search to work properly.

Notice how each iteration eliminates half of the values. While this process is slightly more efficient for smaller arrays, it is significantly more efficient for larger arrays. A linear search of 10,000 records could have a worst case scenario of 10,000 comparisons. With binary search, the worst case is only 15 comparisons to find the value.

When comparing Linear Search to Binary Search, there are a few significant differences. First, binary searches are much more efficient than linear searches. Second, linear searches will work on any array, but binary searches only work on a sorted array. Finally, the algorithm for binary searches is a little more complex than our linear search.

Linear	Binary
Not efficient	Very efficient
Works on sorted or unsorted arrays.	Only works on sorted arrays.
Easy to code	Slightly more complex to code

Here is a non-recursive implementation of binary search:

public int binaryLoop(int[] array, int target) {
    int begin = 0;
    int end = array.length - 1;

    while (begin <= end) {
        int mid = (begin + end) / 2;
        if (target < array[mid]) {
            end = mid - 1;
        }
        else if (target > array[mid]) {
            begin = mid + 1;
        }
        else if (target == array[mid]) { 
            return mid;
        }
    }
    return -1; // not found
}

Notice in the loop how the midpoint is calculated, then tested before updating the beginning and ending points each time based on the results. Initially, the array is passed to the method, where the values begin and end are set to the first index and the last index in the array. The while loop then checks that begin is less than end, and calculates the midpoint of the array. The method then checks if the target value is greater than, less than, or equal to the midpoint. If the target is greater than the midpoint, then the method removes the begin to midpoint values from the search. As noted earlier, this only works if the values are sorted before being searched. The method then returns to the beginning of the while loop, and finds a new midpoint between the new begin value and end. It does so until the target has been found, or the array has been fully halved and searched.

This method can also be written using recursion. Since recursion attempts to create a simpler version of a problem each time a recursive method is called, binary search lends itself well to its use, as the array is reduced in size each time, all the way to a single value at times. Here is the implementation of binary search with recursion:

public int binaryRec(int[] array, int target, int begin, int end) {
    if (begin <= end)
    {
        int mid = (begin + end) / 2;

        if (target == array[mid]) { 
            return mid; // Base Case
        }

        if (target < array[mid]) {
            return binaryRec(array, target, begin, mid - 1);
        }

        if (target > array[mid]) {
            return binaryRec(array, target, mid + 1, end);
        }
    }
    return -1;  //Alternate Base Case
}

The biggest change at the start of this code is that the beginning and ending values are being passed into the method. From there, the midpoint is calculated the same way as before.

The base case is where the value is found. In the first iteration, the base case is skipped, and the recursive case is called. The recursive call passes the original array, the target value, but then updates the starting point as it makes the call. Once the value is found, the index value of the target is then returned back through each of the recursive return statements until it eventually gets back to the original call statement.","Using the binary search algorithm, what is the maximum number of iterations needed to find an element in an array containing 128 elements?",7,6,64,128
codehs-csa-recursive-sorting,"Just as recursion can be used to search data structures, it can be used to sort them. One of the most common recursive sorting algorithms is called merge sort.

A merge sort is a sort where the list is divided then merged back together in the correct order. This is done recursively as the list is repeatedly divided in half until it is only one item long. Then each of these lists gets combined back together in the correct order.

Merge sort starts at the top with the entire list, then it breaks this list into two halves.

It continues this process on both of the halves by breaking it down further. The halves continue to break down until they get to individual items.

Once it gets broken down, it then starts putting it back together in the correct order.

This occurs on each halve in the order that they appear in the array.

As it runs through, note how it only works on a portion of the items in the list. You can see how it works on the first half of the data, segment by segment. After completing the first half, the process is repeated on the second half before finally joining the two pieces together. As it joins the two halves, it moves each value from one half or the other into its final sorted place.

The merge sort is generally more efficient than the insertion sort or selection sort, and its performance is independent of the initial state of our array. In other words, a randomly sorted array and a nearly sorted array perform at the same speed.

The downside to the merge sort is that the implementation uses a fairly complex recursive algorithm. The implementation usually involves two methods - the merge sort method to break down the array and a helper method to reassemble it in the correct order.

Here is an implementation of mergeSort:

public static void mergeSort(int[] current, int length) {
    if (length < 2) {
      return;
    }
    int mid = length / 2;
    int[] left = new int[mid];
    int[] right = new int[length - mid];

    for (int i = 0; i < mid; i++) {
      left[i] = current[i];
    }
    for (int i = mid; i < length; i++) {
      right[i - mid] = current[i];
    }
    mergeSort(left, mid);
    mergeSort(right, length - mid);

    merge(current, left, right);
}

The main purpose of this method is to break the array into smaller pieces, then when it can’t go any further, this method calls the merge method to start combining arrays. Using recursion, the base case is when there is only one element in the array. If the base case is not called, the middle part of this method creates two arrays, a left and a right, and puts half the current array into each of these new arrays. A recursive call is made with each half of the array.

When the base case is reached with an array length of 1, the recursive calls return. The method is then ready to combine the left and right array in the correct order. This is accomplished using the merge method:

public static void merge(
  int[] current, int[] left, int[] right) {

  int leftSize = left.length;
  int rightSize = right.length;

  int i = 0, j = 0, k = 0;
  while (i < leftSize && j < rightSize) {
    if (left[i] <= right[j]) {
      current[k++] = left[i++];
    }
    else {
      current[k++] = right[j++];
    }
  }
  while (i < leftSize) {
    current[k++] = left[i++];
  }
  while (j < rightSize) {
    current[k++] = right[j++];
  }
}

The merge method takes the current array as well as the left and right arrays as input. It will then go through the two arrays to merge them. Notice that it doesn’t return anything. This is because the actual array object is passed to the method and updated. Changes can then be read in other methods.

The merge method walks through the next element in each array, determining if the left or right array has the smaller value, then inserting into the current array. Once it’s finished going through one of the arrays, there may still be elements remaining in either the left or right array. This last step adds any remaining elements to the end of the current array.",Which of the following is NOT true about a merge sort?,The merge sort code is not as complex as other sort codes,Merge sorts work well on all different types of lists,Merge sorts use recursion to make the process easier,"A merge sort works by dividing a list into parts, then merging it back together in the correct order."