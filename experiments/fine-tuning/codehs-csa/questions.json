[{"prompt": "Variables allow us to store information such as numbers, words, or true/false expressions. A variable can be thought of as a box that stores information inside.\n\nIn Java, variables are composed of three things: a name, type, and value.In Java you must specify what type of information you want our variables to hold. There are two types that are used in Java: primitive and reference. You must always give your variable a type before naming it, and specifying the value it holds. (Ex. int myVariable = 10;)\n\nAs seen above, primitive numeric types in Java include both integers and doubles.\n\nIntegers are whole numbers, or counting numbers. (Ex. -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5). In Java you declare an integer using int before the variable name. Here are a couple of examples:\n\nint itemsInStore = 10; \nint numberOfMessages = 8;\n\ndoubles are like integers, but can have decimals. (Ex. -54.34, 90.21, 0.1223). In Java you declare a double using double before the variable name. Here are a couple of examples:\n\ndouble costOfApple = 1.24;\ndouble milesToRun = 5.64;\n\nCharacters represent a single character. In Java you declare a character using char before the variable name. You also use single quotes to identify a character (Ex. \u2018A\u2019). Here are a couple of examples:\n\nchar currentGrade = 'A';\nchar favoriteLetter = 'W';\n\nBooleans are variables that hold a true or a false value. In Java you declare a boolean using boolean before the variable name. Here are a couple of examples:\n\nboolean passedCalculus = true;\nboolean hasDog = false;\n\nWhile primitive types are considered the building blocks of programming languages, reference types are types that have been created by programmers using those primitive types. String for example, is a variable type that was created using char variable types, and has its own functionality that has been created by programmers.\n\nOne of the primary differences between primitive types and reference types is how they are stored in memory. When you assign a value to a variable, you are actually associating that variable with binary data. Computers store all data in binary, and associate that variable with the binary data associated with the value that its been assigned. When primitives are given values, they are associated directly with those values. If the value of one variable changes, then the primitive value that it stores also changes.\n\nIn this example, the value of first is being changed to equal the value stored in second. Both first and second now store the value b.\n\nReference types store an address that points to where the value is located in memory.\n\nStrings are variables that hold text. Strings are not a primitive type, so you must declare them using String with a capital S. Unlike characters, you need to use double quotes when assigning strings (Ex. \"This is my string.\"). Here are a couple of examples:\n\nString fishName = \"Dog\";\nString myUniversity = \"Arizona State University\";\n\nVariables can be protected from alteration if the keyword final is included before the data type. If there is an attempt to change the variable value, then an error will be called indicating that variable has already been assigned. This is often used as a security measure in more complex programs to ensure that values cannot be modified by others.\n\nfinal int numApples = 5;\nnumApples = 0;\n\nIn this example, the program will throw an error because the value of numApples cannot be changed if the keyword final is added to the variable declaration.\n\nGiving your variables meaningful names throughout your code is very important. Proper variable names allow others to easily read and understand your code. A good way to name your variables is to give them as descriptive of a name as possible, without making it too long.\n\nFor example,int numberOfApplesOnTheTree = 10; is a very long name, and can easily be replaced with a name like int numApples = 10;\n\nVariable Naming Conventions:\n- Variable names must start with a letter, $ symbol, or _ symbol.\n- Variable names are case sensitive so myVariable is different thanMyVariable\n- Variable names, after the first character, can contain letters, numbers, or other characters.\n\n###\n\n", "completion": "Question: If you were to create a variable to store your age, which of the following would be best considering the variable type and Java naming conventions?\nCorrect: int age;\nIncorrect: double Age;\nIncorrect: int number;\nIncorrect: int Age;END"}, {"prompt": "Arithmetic expressions allow your to perform mathematical operations within Java. Such expressions can be used for basic math and even more complex algorithms.\n\nThe addition operator allows you to add values together. Here is an example of the addition operator in Java:\n\npublic class AdditionOperator\n{\n  public static void main(String[] args)\n  {\n    int firstVal = 5;\n    int secondVal = 2;\n\n    int firstPlusSecond = firstVal + secondVal;\n\n    // The output will be '7'\n    System.out.println(firstPlusSecond);\n  }\n}\n\nThe subtraction operator allows you to subtract values from one another. Here is an example of the subtraction operator in Java:\n\npublic class SubtractionOperator\n{\n  public static void main(String[] args)\n  {\n    int firstVal = 4;\n    int secondVal = 2;\n\n    int firstMinusSecond = firstVal - secondVal;\n\n    // The output will be '2'\n    System.out.println(firstMinusSecond);\n  }\n}\n\nThe multiplication operator allows you to multiply values. Here is an example of the multiplication operator in Java:\n\npublic class MultiplicationOperator\n{\n  public static void main(String[] args)\n  {\n    int firstVal = 4;\n    int secondVal = 2;\n\n    int firstMultSecond = firstVal * secondVal;\n\n    // The output will be '8'\n    System.out.println(firstMultSecond);\n  }\n}\n\nThe division operator allows you to divide values. Here is an example of the division operator in Java:\n\npublic class DivisionOperator\n{\n  public static void main(String[] args)\n  {\n    int firstVal = 6;\n    int secondVal = 3;\n\n    int firstDivSecond = firstVal / secondVal;\n\n    // The output will be '2'\n    System.out.println(firstDivSecond);\n  }\n}\n\nThere are multiple types of division that can be performed in Java. These forms include: integer division, double division, and mixed division.\n\nInteger Division\nIf you divide two integers you will be returned an integer value.\n\nSo in this case, while 2 / 5 equals 2.5, in Java 2 / 5 = 2. This always holds true, unless the type is specified as a double. Whenever you divide two integers, the return value is always truncated.\n\nDouble Division\nDividing doubles is different from dividing integers.\n\nWhen you divide two doubles you will be returned a double. In this case,2.0 / 5.0 = 2.5 will be your result.\n\nMixed Division\nMixed division is when you divide a double by an integer or an integer by a double.\n\nWhen you use mixed division in your program you will be returned a double. This is true, unless the type is specifically defined as an integer.\n\nConsider the following piece of code:\n\ndouble x = 2;\nint y = 5;\n\ndouble outXY = x / y;   // 0.4\n\ndouble outYX = y / x;   // 2.5\n\nint outInt = (int)(y / x);  // 2\n\nNo matter which data type you use, dividing by zero will cause your programs to throw an ArithmeticException. Exceptions are unwanted or unexpected events which occur during the execution of a program. In this case, dividing by zero causes the variable to store the value of undefined, which cannot be used in arithmetic expression. The program throws the ArithmeticException to warn programmers that there is an issue that needs to be resolved.\n\nThe modulus operator allows you to divide two numbers and get the remainder. Here is an example of the modulus operator in Java:\n\npublic class ModulusOperator\n{\n  public static void main(String[] args)\n  {\n    int firstVal = 17;\n    int secondVal = 5;\n\n    int firstModSecond = firstVal % secondVal;\n\n    // The output will be '2' since the remainder of 17 / 5 is 3.\n    System.out.println(firstModSecond);\n  }\n}\n\nIt is important to remember that the order of operations still applies. In instances where you have multiple operators with the same precedence the order will be left to right.\n\n\n###\n\n", "completion": "Question: What is the result of this expression?\n\n54 % 5\nCorrect: 4\nIncorrect: 10\nIncorrect: 10.8\nIncorrect: 11END"}, {"prompt": "Casting allows you to change a variable\u2019s type to better suit our needs.\n\nLet\u2019s say you want to turn a double into an integer, or an integer into a double. To change a variable\u2019s type you just add the type in between parentheses to cast it.\n\nConsider the following:\n\nint doubleToInt = (int)10.95;\n// This will become '10'\n\nTo cast an integer value to a double you add double in front of the variable.\n\nint intVal = 10;\n\n// Our 'doubleVal' variable is now '10.0'\ndouble doubleVal = (double)intVal;\n\nPrograms can also cast an int value to a double automatically since the value doesn\u2019t change.\n\nint intVal = 10;\n\n// Our 'doubleVal' variable is now '10.0'\ndouble doubleVal = intVal; // cast automatically\n\nTo cast a double to an integer you add (int) in front of the variable. It is important to remember your new integer value will truncate the decimal.\n\ndouble doubleVal = 7.6;\n\n// Our 'intVal' variable is now '7'\nint intVal = (int)doubleVal;\n\nNote that the change from casting is temporary. In the above example, intVal has a value of 7, but the value of doubleVal remains 7.6.\n\nTruncating the value may not be the desired result. If you want to round the value, you can do this programmatically by adding half to the original value before truncating.\n\nIf you divide two integers, even if you are setting them to a double, you will always be returned an integer.\n\nint currResidents = 50;\nint floorTotal = 56;\n\ndouble average = floorTotal / currResidents;\n// 'average' will return the value '1'\n\nWe can get the correct answer by casting one of the variables to a double.\n\nint currResidents = 50;\nint floorTotal = 56;\n\ndouble average = (double)floorTotal / currResidents;\n// We now have the value of '1.12'\n\nAs you begin to explore numerical values in greater depth, it\u2019s important to know about the existing range of variables. When you assign a value to a variable, you are actually associating that variable with binary data. Computers store all data in binary, and associate that variable with the binary data associated with the value that it has been assigned. int values are represented by 32 bits, or binary digits!\n\nWhile that may seem like a lot, it actually does give you a finite limit to the numbers that you can store. Since ints are represented by 32 bits, the total possible combination of different values that can exist is 4,294,967,296. This range is split nearly evenly between negative and positive numbers, so you are able to store values from -2,147,483,648 to 2,147,483,647.\n\nWhat happens if you go over the maximum or less than the minimum? If you go over or under the max and min, the value actually wraps around. This is called overflow. It\u2019s important to note that overflow doesn\u2019t always act as intended, and can create unexpected results. You will still get a value, but it may not be the value you expect.\n\nA data type of lower size (occupying less memory) is assigned to a data type of higher size (more memory). This is done implicitly by the Java Virtual Machine, unlike the explicit casting we did in previous examples (so by the programmer). The lower size is widened to a higher size. This is also called automatic type conversion.\n\nint x = 10;                    // occupies 4 bytes\ndouble y = x;                  // occupies 8 bytes\nSystem.out.println(y);         // prints 10.0\n\nIn the above code, the 4 bytes integer value is assigned to 8 bytes double value.\n\nInteger values in Java are represented by values of type int, which are stored using a finite amount (4 bytes) of memory. Therefore, an int value must be in the range from Integer.MIN_VALUE to Integer.MAX_ VALUE inclusive.\n\nWe can print the maximum, minimum and bit-length of the integer primitive types. The maximum, minimum and bit-size of int are kept in built-in constants Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.SIZE.\n\nThe expected outputs are:\n\nThe minimium integer value in Java is -2147483648\nThe maximum integer value in Java is 2147483647\nThe total bit size for an integer in Java is 32\n\n###\n\n", "completion": "Question: What will this java expression evaluate to?\n(int) 5.6\nCorrect: 5\nIncorrect: 6\nIncorrect: 5.6\nIncorrect: 6.0END"}, {"prompt": "Classes and Objects are utilized in Java as part of the object-oriented programming model. This model focuses on objects and the data and actions associated with the objects.\n\nObjects are variables of user-defined data types. You can refer to these as reference type variables. Just as you initialize and declare primitive types, reference types are also declared and initialized. The initialized form of a reference type is referred to as an object.\n\nObjects are structures that contain a state and behavior. Everyday objects you commonly use have states and behaviors. For example, a car is an object with both a state and behavior.\n\nState\nThe state contains information about the specific object. An example of a state for a car would be how much fuel it has.\n\nBehavior\nThe behavior is the actions that can be performed on a specific object. A behavior of the car may be to get the mileage from the remaining fuel.\n\nClasses are the templates you use for creating objects.\n\nHere is an example of a class that lets us create a rectangle, and get its area:\n\npublic class Rectangle\n{\n  private double width;\n  private double height;\n\n  public Rectangle(double rectWidth, double rectHeight)\n  {\n    width = rectWidth;\n    height = rectHeight;\n  }\n\n  public int getWidth()\n  {\n    return width;\n  }\n\n  public int getHeight()\n  {\n    return height;\n  }\n\n  public int getArea()\n  {\n    return width * height;\n  }\n\n  public String toString()\n  {\n    String rectInfo = \"Rectangle with width \" + width + \" and height \" + height + \n     \" and area \" + getArea();\n\n    return rectInfo;\n  }\n}\n\nHere is another example of a class that lets us create new animal objects:\n\npublic class Animal\n{\n  private String name;\n  private boolean isPet;\n  private int age;\n\n  public Animal(String animalName, boolean isAnimalPet, int animalAge)\n  {\n    name = animalName;\n    isPet = isAnimalPet;\n    age = animalAge;\n  }\n\n  public String getName()\n  {\n    return name;\n  }\n\n  public boolean getPetStatus()\n  {\n    return isPet;\n  }\n\n  public int getAge()\n  {\n    return age;\n  }\n\n  public String toString()\n  {\n    String aInfo = \"This animal's name is \" + name + \". They are currently a pet: \" +\n      isPet + \". The animal is \" + age + \" years old.\";\n\n    return aInfo;\n  }\n}\n\nHere is another example of a class that takes in a vehicle type, its age, and how many miles it has:\n\npublic class Vehicle\n{\n  private String vehicleType;\n  private int vehicleAge;\n  private double vehicleMiles;\n\n  public Vehicle(String vType, int vAge, double vMiles)\n  {\n    vehicleType = vType;\n    vehicleAge = vAge;\n    vehicleMiles = vMiles;\n  }\n\n  public String getType()\n  {\n    return vehicleType;\n  }\n\n  public int getAge()\n  {\n    return vehicleAge;\n  }\n\n  public double getMiles()\n  {\n    return vehicleMiles;\n  }\n\n  public double estimateMilesPerYear()\n  {\n    return vehicleMiles / vehicleAge;\n  }\n}\n\nIt is important to remember that classes are just templates for creating new objects. A class is a formal implementation, or blueprint, of the attributes and behaviors of an object.\n\nAn object on the other hand is a specific instance of a class with defined attributes. Objects contain both a state and behavior, and are an instance of a class.\n\nInstances\nAn instance is a specific version of an object that can differ in numerous ways. Going back to the previous section, Rectangle, Animal, and Vehicle are all classes. If you create two different vehicles they would be specific instances of the Vehicle class. Or in other words, they would be two different vehicle objects. Remember, an object is an instance of a class.\n\nExamples:\n\npublic class ExampleClass\n{\n public static void main(String[] args)\n {\n  // `Animal` is our class.\n\n  // `myDog` and `myCat` are objects, because\n  // they are specific instances of our `Animal` class.\n  Animal myDog = new Animal(\"Cujo\", true, 7);\n  Animal myCat = new Animal(\"Kerby\", true, 2);\n }\n}\n\npublic class ExampleClass\n{\n public static void main(String[] args)\n {\n   // `Rectangle` is our class.\n\n   //`mySquare` and `myRectangle` are objects, because\n   // they are specific instances of our `Rectangle` class.\n   Rectangle mySquare = new Rectangle(20, 20);\n   Rectangle myRectangle = new Rectangle(5, 10);\n }\n}\n\n###\n\n", "completion": "Question: Consider this class definition of Weather.\n\npublic class Weather\n{\n    private boolean isRaining;\n    private String forecast;\n    private double temperature;\n\n    // Rest of class goes here\n}\n\nWhen we use this class to create Weather objects, which of the following is guaranteed to be true?\nCorrect: Every Weather object will have the same attributes.\nIncorrect: Every Weather object will have a temperature of 50.\nIncorrect: Every Weather object must choose which attributes it wants.\nIncorrect: It is impossible to know what attributes the Weather objects will have since the objects are not listed here.END"}, {"prompt": "In Java, you can think of everything as a class. If you want to write a program to act as a grade book, GradeBook is a class. Because of this, you can bundle classes and their functionality. You can even use classes that are written by other people without knowing exactly how they work. In this section, you will explore how to create objects from pre-existing classes.\n\nTo better understand how to create an object, let\u2019s first look at the different parts of a class. There are 3 main parts to any class:\n\nThe instance variables, or attributes, hold the state of the object. These are declared at the beginning of the class. When declaring them, they are typically declared as private, which means that they are only accessible within the class.\n\nInstance variables are not usually initialized when you declare them. For primitive variables, that means that these variables are created with default values. When an object has not been created, or \u201cinstantiated\u201d, it isn\u2019t pointing to any particular object data. When that happens, the object, in this case, is considered to be a null object. The keyword null is a special value used to indicate that a reference variable is not associated with any object.\n\nThe constructor is used to instantiate \u2013 create an instance of \u2013 an object. Anytime a new object is created, the constructor is run. Notice that the constructor has a different header (first line) compared to other methods. The constructor header has the same name as the class, is always declared public, and has no return type (you will learn more about return type later in this section). A class contains constructors that are invoked to create objects.\n\nThe third part of the class is the methods. These make up the behaviors of the object. There can be any number of methods, some of which take an input, some of which return a value, and some that do either both or neither. You will discuss methods later in this unit.\n\nLet\u2019s take a closer look at the constructor. The first line of the constructor (and other methods) is known as the method signature. A signature consists of the constructor name and the parameter list.\n\nThe parameter list, in the header of a constructor, lists the types of the values that are passed in and their variable names. These are often referred to as formal parameters. Parameters allow values to be passed to the constructor to establish the initial state of the object.\n\nTo create a new rectangle, you call the constructor and pass values that correspond to the parameter list. For example, to create a rectangle with a width of 5 and a height of 3, you would call it from the main function like this.\n\nRectangle rect = new Rectangle(5, 3);\n\nIn the above example, the 5 and 3 are known as arguments. An argument is a value that is passed into a constructor (or any method) when called. These are often referred to as actual parameters. The actual parameters passed to a constructor must be compatible with the types identified in the formal parameter list.\n\nArguments are passed to the object using call by value. Call by value initializes the formal parameters with copies of the actual parameters.\n\nAs you saw in the example above, every object is created using the keyword new followed by a call to the class\u2019 constructor. The call to the constructor must contain the list of parameters that match the formal parameters.\n\nOnce you create a new object, Java allocates memory for this object. Unlike primitive variables that store the object address, the memory associated with a variable of a reference type holds an object reference value or, if there is no object, null. This value is the memory address of the referenced object.\n\nTo create an object, the arguments need to match the formal parameters, but what if you want to specify a different set of parameters? For example, maybe you want to create a square and only provide one side length.\n\nIn Java, you can do this with what is called a constructor overload. Let\u2019s take a look at an example:\n\npublic class Rectangle\n{\n  private int width;\n  private int height;\n  public Rectangle(int rectWidth, int rectHeight)\n  {\n    width = rectWidth;\n    height = rectHeight;\n  }\n  public Rectangle(int sidelength)\n  {\n    width = sidelength;\n    height = sidelength;\n  }\n}\n\nConstructors are said to be overloaded when there are multiple constructors with the same name but a different signature. In the example above, you see two constructors with the name Rectangle. One constructor takes two integers and the other takes one. Since the formal parameter lists are different, the signatures are different, and you can say that the constructor is overloaded. Now you can create a rectangle object by passing either one or two arguments in the call to the class constructor.\n\nYou have seen here how you can create the Rectangle class and instantiate new objects, but you can also use existing classes and class libraries to create objects. When you do this, you need to make use of documentation.\n\nDocumentation is a great resource to use to see how a class works. As long as you can read the documentation, you don\u2019t need to know how the class works.\n\nThe documentation for a class tells us how to use the class constructor and various methods that the class provides.\n\n###\n\n", "completion": "Question: /** \n * The Plant class describes a plant.\n * \n * Every plant has a type and number of watering days.\n * \n */ \n\npublic class Plant\n{\n    // Attributes\n    private String plantType;\n    private int wateringDays;\n\n   public Shark(String type, int days)\n   {\n          plantType = type;\n          wateringDays = wateringDays;\n   }\n}\n\nWhich of the following choices is a formal parameter of the constructor?\nCorrect: days\nIncorrect: plantType\nIncorrect: int\nIncorrect: PlantEND"}, {"prompt": "As stated earlier, objects have both state and behavior. The state of the object is stored in the instance variables and can be initialized through the constructor. An object\u2019s behavior refers to what the object can do (or what can be done to it) and is defined by methods. Methods are procedures that allow us to control and define the behavior of an object.\n\nIn this section, you are going to look at methods that do not take any input and do not return any values. In subsequent sections, you will take a look at methods that take an input and/or return a value.\n\nAs you saw with constructors, methods have a signature that consists of the name of the method and the parameter list. A method signature for a method without parameters consists of the method name and an empty parameter list. Here are some examples:\n\npublic void printHello();\npublic void printWidth();\n\nEach method signature has four parts:\n\npublic - The public statement tells Java which classes can see and use the method. In this course, you will see public methods that allow other classes to call the methods and private methods which are only available to that particular class.\n\nvoid - After the public or private declaration, the signature contains the return type. You will explore return value in a subsequent section, but when a method doesn\u2019t return a value, you use void as the return type. Some return type or void is required for all methods, but not for the constructor.\n\nmethodName - After the return type, you see the name of the method. While the name can be anything, it is important to give methods names that make sense. For example, if you want a method to print the value of a rectangle width, you may name it printWidth() so that the user would know what to expect from the method.\n\n() - Finally you have a set of parentheses that hold the parameter list. In this case, you have no parameters, so you include an empty set of parentheses.\n\nMethods allow programmers to perform a specific task without having to know the details of how that method was written. This is known as procedural abstraction. The programmer only needs to know what the method does, including any inputs and any outputs to the method.\n\nWhen calling a method (or constructor), the call interrupts the sequential execution of statements, causing the program to first execute the statements in the method or constructor before continuing. Once the last statement in the method or constructor has been executed or a return statement is executed, the flow of control is returned to the point immediately following where the method or constructor was called.\n\nMethods can be called from any other method, including the main method or another method in a class. How a method is called depends on the type of method that you are calling. In this section, you are going to look at calling non-static void methods. Non-static methods are called through objects of a class and you need to create an object before you can call them. In contrast, static methods can be called without creating a particular instance of an object.\n\nUser input is an important part of any user program. While this course will not go into a lot of detail on user input, it is important to understand the basics to help make interactive programs.\n\nUser input in this course will be accomplished using a scanner object. A scanner object is a type of variable that allows you to read from the console.\n\nHere is the basic setup for using the scanner.\n\nimport java.util.Scanner;\nclass MyProgram \n{\n    public static void main(String[] args) \n    {\n        Scanner input = new Scanner(System.in);\n     }\n}\n\nNotice that the program imports the Scanner from the java.util library. Java uses import statements to load additional libraries that are not available by default.\n\nOnce imported, you create an input variable using the Scanner class. In this case, the scanner is reading from System.in which is the console.\n\nAfter creating the scanner object, you can then use the variable to read different values in from the user. Depending on the value type, you use will use a different method to import the value.\n\nLet\u2019s take a look at an example with the Rectangle class below.\n\nNotice in this example how the two objects, r1, and r2 are created using the Rectangle constructor. To call the printArea() function, the dot operator is used along with the object name.\n\nIt is important to note that an object must be instantiated to call a method. If the object is only declared, any attempt to call a method on that object will result in a NullPointerException being thrown. For example:\n\nRectangle r1;  // Declared but not instantiated\nr1.printArea();  // Will throw NullPointerException\n\nSince a void method doesn\u2019t have a return type, it must be called as a separate call, not as part of an expression. As you saw in the example above, the printArea() method was called on a separate line. Calling it to assign a value or as part of a print statement will cause an error.\n\nRectangle r1 = new Rectangle(10, 2);\nr1.printArea(); // Valid\ndouble a = r1.printArea();  // Invalid since printArea doesn't return a value\nSystem.out.println(r1.printArea()); // Also invalid\n\n###\n\n", "completion": "Question: Which of the following is a correctly written method for the class below?\n\npublic class Alarm \n{\n    private int startMin;\n    private int length;\n\n    public Alarm(int minute, int duration)\n    {\n        startMin = minute;\n        length = duration;\n    }\n\n    public Alarm(int duration)\n    {\n        startMin = 0;\n        length = duration;\n    }\n}\nCorrect: public void addTenMinutes()\n{\n    length = length + 10;\n}\nIncorrect: public addTenMinutes()\n{\n    length = length + 10;\n}\nIncorrect: addTenMinutes()\n{\n    length = length + 10;\n}\nIncorrect: public void addTenMinutes\n{\n    length = length + 10;\n}END"}, {"prompt": "As you saw in the section above, you can use methods to help control and define procedures for your objects. In the last section, you looked at methods that took no input and returned no values. In this section, you are going to look at methods that take an input value, but do not return a value.\n\nRecall that methods are like blocks of code that do a particular thing. You can write a method that prints out \u201chello\u201d when called or a method that draws a circle. But what if you want to create a method to add ten to a number?\n\nYou would expect an addTen() method to add 10 to any number it is given. If you give it 3, the method will give us 13. Were you to give it 32, it would give us 42. This pattern can be generalized even more: if you give the method any number x, it will give us x + 10 in return. The action that the addTen() method takes is the same every time \u2013 it adds 10 \u2013 the only thing that changes is the number you give to the method. The number that you pass to the method is called a parameter.\n\nLet\u2019s write the addTen() method in code:\n\npublic void addTen(int x)\n{\n  int xPlusTen = x + 10;\n  System.out.println(xPlusTen);\n}\n\nNotice that there is an x that is being taken in and used by the method. This is the parameter. Its value will be whatever the user decides to \u201cpass\u201d to the method. Also, note that the x parameter can be used as a regular variable in the body of the method.\n\nNow that the addTen() method is defined, it\u2019s time to call the method. Let\u2019s first add ten to the number 5:\n\naddTen(5);\n\nThis will result in 15 being printed to the console.\n\nThis works with variables as well. You can create a variable y that stores a number, then pass y to the addTen() method:\n\nint y = 115;\naddTen(y);\n\nThe variable 115 is passed as an argument to the addTen() method. The method accepts 115 as the parameter, adds 10 to it, and then prints 125 to the console. Note that the argument type needs to match the parameter type.\n\nWhen we pass an argument to a method, it is said to be passed by value, which means a copy of that argument is made to use in the method. As a result, any change to the formal parameter will not be reflected in the actual parameters from the original calling function.\n\nIt\u2019s often helpful to write methods that can take in more than one parameter. For example, if you were to write a generic add() method, you would want to be able to input two numbers. To include more than one parameter, you can simply write more than one parameter, separated by a comma. The code below takes in two numbers, represented by x and y, and adds them:\n\npublic void add(int x, int y)\n{\n  int sum = x + y;\n  System.out.println(sum);\n}\n\nYou call the method in a similar manner. If you give the function the following calls:\n\nadd(10, 90);\nadd(635, 1000);\nint first = 72;\nint second = 14;\nadd(first, second);\n\nthen the program will print the following to the console:\n\n100\n1635\n86\n\nUsing parameters allows us to write code that is flexible and reusable. Writing a method is like telling the program to do something (for example, add two numbers or draw a rectangle on the canvas). Parameters are like giving that method specific instructions (\u201cI want to add 3 and 7\u201d or \u201cI want my greeting message to say their name and my name\u201d).\n\nFor example, if you wanted to print several greetings, you\u2019d likely want them to contain different text depending on the person receiving the greeting. If each of these pieces of information was hard-coded into the method, you would need a separate method for each greeting!\n\nUsing parameters allows you to write one printMessage method that can be used to send many greeting messages:\n\npublic void printMessage(String to, String from, String salutation, String message)\n{\n  System.out.println(\"-------------\");\n  System.out.println(salutation + \" \" + to + \",\");\n  System.out.println(message);\n  System.out.println(\"Best regards,\");\n  System.out.println(from);\n  System.out.println(\"-------------\");\n}\n\nIf Karel wants to send a birthday message to Bill Gates and a Halloween card to Steve Wozniak, Karel could write:\n\nprintMessage(\"Bill Gates\", \"Karel\", \"Howdy\", \"Wishing you a happy birthday!\");\nString halloweenMessage = \"Hope you have a spooky Halloween!\";\nprintMessage(\"Steve Wozniak\", \"Karel\", \"Hi\", halloweenMessage);\nJava\nThis would print two letters to the console:\n\n-------------\nHowdy Bill Gates,\nWishing you a happy birthday!\nBest regards,\nKarel\n-------------\n-------------\nHi Steve Wozniak,\nHope you have a spooky Halloween!\nBest regards,\nKarel\n-------------\n\nIt\u2019s very important to pass arguments to methods in the proper order. Using the printMessage example above, you may know that Karel is the name of the person sending the message and that you want it to start with \u201cHowdy\u201d, but the computer does not know this information. The way that the computer finds out which argument goes to which parameter is by the order in which your code passes the arguments into the method.\n\nFor example, if you wrote:\n\nprintMessage(\"Howdy\", \"Karel\", \"Wishing you a happy birthday!\", \"Bill Gates\");\n\nyou would end up with a mixed-up message:\n\n-------------\nWishing you a happy birthday! Howdy,\nBill Gates\nBest regards,\nKarel\n-------------\nPlain text\nAs you can see, order matters when you are using parameters.\n\nAs you saw with constructors, you can also overload methods. Recall that a method signature consists of the method name and the ordered list of parameter types. You can overload a method by giving the method the same name as another method, but a different signature by having a different ordered list.\n\nHere is an example of a proper overload:\n\npublic int add(int a, int b) {  }\npublic int add(int a, int b, int c) {  }\n\nNotice in the example above how one method takes two integers as an input and the other takes 3 integers. It is important to note that the variable names do not make a difference, it is only the type and order of the parameters. Given a method signature like this:\n\npublic int add(int x, int y, int z) {  }\n\nThe above would not overload the methods above since there is already a method that takes three integers. Changing the variable names doesn\u2019t impact whether a method is overloaded.\n\n###\n\n", "completion": "Question: Suppose there is a class called Athlete. One of the methods is given below. It sets the instance variable isAllStar to the parameter value.\n\npublic void setAllStarStatus(boolean status)\n{\n    isAllStar = status;\n}\n\nUsing the Athlete object called karel, which of the following is the correct way to set karel\u2019s all-star status to false?\nCorrect: karel.setAllStarStatus(false);\nIncorrect: karel.setAllStarStatus(status=false);\nIncorrect: karel.isAllStar = false;\nIncorrect: karel.setAllStarStatus(isAllStar = false);END"}, {"prompt": "Similar to how methods can take in values as parameters, methods can also return values.\n\nRecall the addTen() method from the previous section:\n\npublic void addTen(int x)\n{\n  int xPlusTen = x + 10;\n  System.out.println(xPlusTen);\n}\n\nThis method takes in a parameter, x, and adds 10 to it. Lastly, the program prints the value to the console.\n\nBut what if you wanted to store the value of x + 10? In the method above, x + 10 is stored into a local variable called xPlusTen. However, this variable is lost when the method is finished \u2013 it cannot be accessed outside of the method.\n\nUsing a return statement will allow you to pass a value back out of the method. That return value can be stored into a variable for later use.\n\nHere\u2019s how to rewrite addTen() to return a value instead of printing:\n\npublic int addTen(int x)\n{\n  int xPlusTen = x + 10;\n  return xPlusTen;\n}\n\nThere are a few differences here.\n\nFirst, the return statement on line 4 replaces the print statement and does not require parentheses. Second, take a look at the first line of the method: public int addTen(int x). Instead of void, you now use int. This tells the program that the addTen() method will return a value that is an int. This is called the return type of the method.\n\nNon-void methods return a value that is the same type as the return type in the signature. To use the return value when calling a non-void method, it must be stored in a variable or used as part of an expression. Up to this point, you\u2019ve only used the void return type, which indicates that the method does not return anything. Because the addTen() method will return an integer, you set the return type to int.\n\nWhen returning a value, it\u2019s important to note that that method is not printing the value to the console, but rather sending back to the method call statement. This is similar to how passing in a value as an argument does not print the value to the console.\n\nA return value by itself would not be very useful, given that it does not print to the console. Fortunately, you can store a method\u2019s return value into a variable. Take a look at the following code:\n\nint num = 7;\nint tenAdded = addTen(num);\n\nFirst, you create a variable named num and initialize it to 7. Then, you create another variable called tenAdded. Notice that tenAdded is not given a normal value. Instead, you are setting it equal to addTen(num). This means that the tenAdded variable will hold the result of whatever the method call addTen(num) returns. You know that addTen(num) will return 17, so tenAdded will be 17.\n\nReturn values work in many situations. For example, you can rewrite the add method from the previous section to return the sum instead of print it to the screen:\n\npublic int add(int x, int y)\n{\n    int sum = x + y;\n    return sum;\n}\n\nYou can now call the method and store its return values\n\nint sum = add(10, 90);\nSystem.out.println(sum);\n\nwhich would print 100 to the console.\n\n###\n\n", "completion": "Question: Suppose you have a class called Rollercoaster. The Rollercoaster class has a method called goingDown, partially defined below\n\npublic boolean goingDown()\n{\n    // code omitted\n}\n\nWhich of the following statements correctly stores the return value of goingDown when it is called on the Rollercoaster object called ferrisWheel?\nCorrect: boolean down = ferrisWheel.goingDown();\nIncorrect: int down = ferrisWheel.goingDown();\nIncorrect: double down = ferrisWheel.goingDown();\nIncorrect: String down = ferrisWheel.goingDown();END"}, {"prompt": "As you have learned, a character is one of the primitive data types in Java. You use the char keyword to declare it. A character is a single letter. 'A', 'a', 'D', and 'Z' are all examples of characters. It is great that you have an easy way to represent a single character, but what if you wanted to represent words or sentences? How can you do this?\n\nA String is a sequence of characters. You use Strings to represent full words and sentences. For example, the famous \"Hello World\" is a String. Some more examples of Strings:\n\n\"I am a String. A sequence of characters strung together to form words and/or sentences.\"\n\"CodeHS is the best coding website ever! Everyone loves CodeHS!\"\n\"She sells seashells by the seashore.\"\n\"Strings!\"\n\"abcdefghijklmnopqrstuvwxyz\"\n\nA String is not a primitive type like int, char, boolean, and double. Primitive types always start with lowercase letters, but a String starts with a capital letter. This makes it an object.\n\nYou can create Strings using a string literal or calling the String constructor. A string literal is a string inside of quotes, as you saw above. The String constructor takes a string literal as an input.\n\nString strLiteral = \"karel\"; // String Literal\nString strConstr = new String(\"karel\"); // String constructor\n\nBoth options will create a String variable. The constructor method will force Java to create a new String value in the heap, while the String literal may allow Java to reuse an existing value in the heap.\n\nConcatenate is a fancy word for joining or linking two things together. To concatenate two or more Strings means that you are joining them together to form one String. You can do this in Java by using the addition operator, +, or +=.\n\nIn this example, you concatenate two separate Strings, \"Mc\" and \"Donald's\", to form one String, \"McDonald's\".\n\nString one = \"Mc\";\nString two = \"Donald's\";\nString concatenate = one + two;\nSystem.out.println(concatenate);\n\nAfter running the program, the concatenated String \"McDonald's\" gets printed to the screen.\n\nIt is important to note that String objects are immutable, meaning that strings cannot be changed by methods or concatenation. Instead, when you run methods or concatenate values with Strings, you are actually overwriting the existing String with a new String.\n\nYou are not limited to concatenating strings with other strings. You can concatenate Strings with other data types. Here you are concatenating a string and an integer together:\n\nint number = 24;\nSystem.out.println(\"This String is concatenated with an integer at the end: \" + number);\n\nLook familiar? You have been doing this all the time in previous programs when printing out results to the screen! After running the program, you get:\n\nThis String is concatenated with an integer at the end: 24\nPlain text\nYou can also concatenate Strings with other primitive types like char, boolean, and double. When you concatenate a String with a primitive variable, there is an implicit conversion of the primitive variable to a String to perform the conversion.\n\nIn Java, you create string literals using quotation marks, but what if you want to print a string with quotes, for example \"Hello, Karel,\" said Tracy.\n\nJava uses the concept of an escape sequence to essentially send a signal to the compiler to treat a character a little differently. In Java, the escape character is a backslash, \\. When Java sees a backslash inside of quotation marks, it knows that it is a signal to treat the next character differently within the literal string. For example, if you want to include quotation marks in your output, you would use a \\\".\n\n// Print \"Hello, Karel,\" said Tracy\nSystem.out.println(\"\\\"Hello, Karel,\\\" said Tracy\");\n\n\n###\n\n", "completion": "Question: What would be printed by this code snippet?\n\nString subject = \"Computer Science\";\nString opinion = \" is for everyone!\";\n\nSystem.out.println(subject + opinion);\nCorrect: Computer Science is for everyone!\nIncorrect: Computer Science\nIncorrect: Computer Scienceis for everyone!\nIncorrect: This code would not compile. You can\u2019t add Strings.END"}, {"prompt": "In this section, you will examine the different methods that can be run on String objects to create new, transformed String objects. You will also take a look at how Java uses libraries and documentation to help programmers implement more complex programs.\n\nLike physical town libraries, Java libraries and APIs (Application Programming Interface) are collections of written works made by other authors. An API is typically used to interface two systems and make using them easier. For example, if you wanted to program a robot in Java, you may use a set of commands from an API to control the motors. In contrast, libraries tend to be extensions of the main programming language that can help simplify your code since it takes common tasks and allows you to implement them without having to write out your own code.\n\nLibraries can be broken down into a series of packages. Each package is then subdivided into specific classes with specific methods that can be run for that class.\n\nTo help you do this, Java provides documentation. Documentation for APIs and libraries are essential to understanding the attributes and behaviors of an object of a class. This section will focus on the Java String documentation, but you can find all the documentation for Java here: https://docs.oracle.com/javase/8/docs/api/\n\nAs a note, String objects are found in the java.lang package and are available by default in your programs.\n\nJust like you can concatenate primitive data types with strings, you can also concatenate reference data types with strings. In doing so, the reference data type\u2019s toString() method gets called and concatenated to the existing String. The toString() method provides the string representation of the given object and is called anytime the object is referenced where it needs to be shown as a string, for example in a print statement.\n\nLet\u2019s look at an example of the Nickname class.\n\npublic class Nickname\n{\n  private String firstName;\n  private String lastName;\n  private String nickname;\n  public Nickname(String realFirstName, String realLastName, String moniker)\n  {\n    firstName = realFirstName;\n    lastName = realLastName;\n    nickname = moniker;\n  }\n  public String toString()\n  {\n    return firstName + \" (\" + nickname + \") \" + lastName;\n  }\n}\n\nAny Nickname object that is created has three different instance variables, so how does Java know what to use when you want to print out the name? It uses the toString() method. For example, if you create an object like this:\n\nNickname karel = new Nickname(\"Karel\", \"Dog\", \"the Dog\");\n\nThen print the object using the following statement:\n\nSystem.out.println(karel);\n\nYou will get the following out:\n\nKarel (the Dog) Dog\n\nNotice in the example above that you don\u2019t specifically call the toString() method. The method is called implicitly when you use the object in a situation where a string is needed.\n\nIf you want to concatenate the output with another string, you can.\n\nSystem.out.println(karel + \" went to a movie.\");\n\nResults:\n\nKarel (the Dog) Dog went to a movie.\n\nYou will remember that strings are a sequence of characters. Let\u2019s look at this example String below:\n\nString str = \"Hello World\";\n\nEach character in this string has a position from 0 to 10. For example, the first character, 'H', is at position 0. The second character, 'e', is at position 1. The last character, 'd', is at position 10. Note that the space between the two words, ' ', is also a character and is located at position 5.\n\nA character\u2019s particular position in a string is formally known as its index. A String object has index values from 0 to the length of the string - 1. Attempting to access indices outside this range will result in an IndexOutOfBoundsException.\n\nMany useful String methods make use of the string\u2019s index value. While there are many different String methods, there are several that are widely used within the AP Java programming course.\n\nString str2 = new String(str)\tConstructs a new String object that represents the same sequence of characters as str\nname.length()\tReturns the number of characters in a String object\nname.substring(2, 6)\tReturns the substring beginning at index 2 and ending at index 5.\nname.substring(index, index + 1)\tReturns the string identical to the single element substring at position index\nname.indexOf(\"d\")\tReturns the index of the first occurrence of d; returns -1 if not found.\nname.equals(\"Karel\")\tReturns true if name is equal to Karel; returns false otherwise\nname.compareTo(\"Karel\")\tReturns a value < 0 if name is less than Karel; returns zero if name is equal to Karel; returns a value > 0 if name is greater than Karel.\n\n###\n\n", "completion": "Question: What method must a class implement in order to concatenate an object of the class with a String object?\nCorrect: toString\nIncorrect: A constructor\nIncorrect: length\nIncorrect: printEND"}, {"prompt": "As you saw with strings, using Java packages can make your program easier to implement. In this section, you are going to explore two other members of the java.lang package, the Integer and Double classes.\n\nA wrapper class in Java is a class that contains or \u201cwraps\u201d primitive data types as an object. You will find wrapper classes for all of our primitive data types. One thing to note about the wrapper classes is that they have similar (if not the same) names as the primitive data types, but they all begin with capital letters.\n\nThe wrapper classes in Java actually serve two purposes. First, as their name implies, they can take primitive data types and convert them into an object. Later in the course, you will see some examples of when you need to use an object representation of primitive data.\n\nSecond, wrapper classes provide static methods that allow you to perform some basic number operations, such as converting data from a string to a number. This means you can do some basic operations without creating an instance of the object. This section will take a closer look at some of these methods within the Integer and Double classes.\n\nCreating wrapper objects, such as Integer and Double objects can be done in a similar way to other objects. The constructor takes a single value and converts it into the object version of that value.\n\nInteger y = new Integer(17);\nDouble z = new Double(3.14);\n\nFortunately, you don\u2019t need to explicitly create Integer and Double objects every time you need to use them. Java provides a process called autoboxing. Autoboxing is the automatic conversion that the Java compiler makes between primitive types and their corresponding object wrapper classes. This includes converting an int to an Integer and a double to a Double.\n\nThe Java compiler applies autoboxing when a primitive value is passed as a parameter to a method that expects an object or if a primitive value is assigned to a variable of the corresponding wrapper class.\n\nSimilarly, Java has a process for unboxing. Unboxing is the automatic conversion that the Java compiler makes from the wrapper class to the primitive type. This includes converting an Integer to an int and a Double to a double. The Java compiler applies unboxing when a wrapper class object is passed as a parameter to a method that expects a value of the corresponding primitive type or a wrapper class object is assigned to a variable of the corresponding primitive type.\n\nIn addition to creating objects, the wrapper classes also provide several useful methods, some of which are static. As a reminder, a static method is a method that can be used without creating an instance of the object. You use the class name followed by a dot and the method name to call static methods.\n\n###\n\n", "completion": "Question: Java automatically converts between objects and primitives in the process of autoboxing and unboxing.\n\nWhat happens when an Integer is unboxed?\nCorrect: An Integer is unboxed when it is converted to a primitive value.\nIncorrect: An Integer is unboxed when it is converted to a Double.\nIncorrect: An Integer is unboxed when it is passed to a method.\nIncorrect: An Integer is unboxed when it is converted to an Integer value.END"}, {"prompt": "In this section, you are going to take a look at another class in the java.lang package, the Math class. The Math class is a class that only contains static methods that are used for specific purposes.\n\nSeveral of the methods that are used from the Math class perform basic math functions. These are listed in the table below.\n\nMath.abs(x)\tReturns the absolute value of x. This can take either an int or a double.\nMath.pow(base, exponent)\tReturns the value of base raised to the power of exponent.\nMath.sqrt(x)\tReturns the positive square root of x.\n\nAs a reminder, since the math class contains only static methods, you do not need to instantiate an object to use it. Static methods are called using the dot operator along with the class name.\n\nAnother useful method from the Math class is the random method. The random method takes no input and returns a random number from zero to one, inclusive of zero, but not inclusive of one.\n\n// Generate a random number\ndouble ranNum = Math.random();\n\nNow you may be thinking that a random number between zero and one is not that useful, however, the number can be manipulated to generate a random number in any range. Using three basic operations, you can convert the output of Math.random() into any random number you need.\n\nMultiply - By multiplying the results of Math.random(), you can create values from 0 up to (but not including) the number you multiple by.\n\n// Generates a random value from 0 to 10\ndouble ranNum = Math.random() * 10;\n\nAdd - Adding to the results offsets the range that you will get from the random number.\n\n// Generates a random value from 100 to 110\ndouble ranNum = Math.random() * 10 + 100;\n\nCasting to an integer - Finally, if you cast the value to an integer, you will truncate the value and only have random whole numbers.\n\n// Generates random integers between 50 and 75 (not including 75)\nint ranNum = (int)(Math.random() * 25) + 50;\n\nWatch out! Be careful, a common mistake that programers make is to cast the value at the wrong place. You must include the multiplier inside parentheses along with the random call. If you do not, you will end up casting only the Math.random() part, and since it is always less than one, your random function will always result in zero. The offset addition operation can either be inside or outside the parentheses.\n\n// Same as above, but without the parentheses\n// The result is zero every time\nint ranNum = (int)Math.random() * 25 + 50;\n\n###\n\n", "completion": "Question: What range of numbers would be generated by using:\n\nint num  = (int) (Math.random() * 201);\nCorrect: 0 - 200\nIncorrect: \n1 - 200\nIncorrect: 1 - 201\nIncorrect: 0 - 201END"}, {"prompt": "How do you write code that tells us whether a user is logged in to our program? Booleans are the solution to these questions.\n\nA boolean refers to a value that is true or false. Those are the only values of a boolean expression, and these are useful if you want to check if something is true or false.\n\nLet\u2019s meet the fellow behind the name, \u201cbooleans,\u201d George Boole. Mr. Boole was an English-born mathematician, philosopher, and logician. He introduced boolean algebra in The Mathematical Analysis of Logic (1847) and Investigation of the Laws of Thought (1854). Many consider him to be one of the founders of Computer Science.\n\nLet\u2019s start with an example \u2013 create a variable, set it equal to true or false, then print the value.\n\nYou first want to declare the variable, loggedIn, and initialize its value.\n\nboolean loggedIn = false;\n\nYou can similarly set the variable to true instead:\n\nboolean loggedIn = true;\n\nYou can imagine a boolean variable as a box that can hold only the values true or false.\n\nNotice that you do not need to have quotations around true or false.\n\nThe full example looks like:\n\nboolean loggedIn = false;\nSystem.out.println(\"User logged in?: \" + loggedIn);\n\nComparison operators allow you to compare two values against one another. A comparison returns a boolean result of either true or false.\n\nThe table below lists each of the common comparison operators and their usages:\n\nOperator\tUsage\n>\tGreater Than\n<\tLess Than\n>=\tGreater Than Or Equal To\n<=\tLess Than Or Equal To\n==\tEqual To\n!=\tNot Equal To\n\nIn the following example, you compare two variables x and y. You store the result of this comparison in variable z.\n\nint x = 10;\nint y = 8;\nboolean z = x > y;\nSystem.out.println(z);\n\nWhat will get printed to the screen? The above comparison, x > y is evaluating if 10 is greater than 8. Because 10 is indeed greater than 8, z is assigned a value of true. Thus, true will get printed to the screen.\n\nLet\u2019s get a little more practice. Take a look at the following code segment below. Pay close attention to each comparison and the operator being used.\n\n// Declare some integer variables to use for practice comparisons below.\nint a = 3;\nint b = 5;\nint c = 2;\nint d = 3;\n\n// You store the boolean results of each comparison into boolean variables t-z.\nboolean t = a > 0; // true\nboolean u = a == d; // true\nboolean v = d >= b; // false\nboolean w = b > c; // true\nboolean x = a != d; // false\nboolean y = d < = a; // true\nboolean z = 4 < = c; // false\n\nIn addition to integers, it is possible to compare other data types too. In the example below, the boolean variables are storing the results of a comparison between some of the boolean values computed above.\n\nboolean boolComparison1 = t == u; // true\nboolean boolComparison2 = t == w; // true\nboolean boolComparison3 = t != u; // false\nboolean boolComparison4 = x != y; // true\n\nSuppose you want to write a program that restricts people under a certain height from riding on a roller coaster. For this particular roller coaster, people who are under 4 feet (48 inches) are not allowed on the ride. How would you do this?\n\nint heightInInches = readInt(\"How tall are you (in inches)? \");\nboolean isTallEnough = heightInInches >= 48;\nSystem.out.println(\"Can ride on the roller coaster: \" + isTallEnough);\n\nAfter getting the potential rider\u2019s height in inches, you do a comparison to ensure that they are over 48 inches. The result of this comparison is then printed out.\n\nA common mistake is using = when you actually want to use ==. = is used for assignment of variables whereas == is used for comparing the equality of two values.\nFor example, x = 5 stores the value 5 into the variable x. However, x == 5 tests to see if the value 5 is equal to the variable x and then returns either true or false. They are not the same thing!\n\n###\n\n", "completion": "Question: Which of the following is NOT a relational operator?\nCorrect: =\nIncorrect: >\nIncorrect: !=\nIncorrect: <=END"}, {"prompt": "In the previous section, you learned all about logical operators and comparison operators. These form the basis for writing boolean expressions in if statements.\n\nThe if statement is a conditional statement that can be used to alter the flow of a program. You use if statements to run a segment of code only if some boolean expression first evaluates to true.\n\nAn if statement takes the following basic form:\n\nif (boolean expression)\n{\n   // Segment of code that will run if the boolean expression is true\n}\n\nIf the boolean expression evaluates to false, nothing will happen. The code within the if statement is ignored.\n\nAs mentioned above, the if statement affects the flow of the program and the code that executes based on whether the boolean expression evaluates to true or false.\n\nif statements by themselves are known as a one-way selection. A set of statements only executes if the condition of the boolean expression is true.\n\n###\n\n", "completion": "Question: What is the output of this program?\n\nint phLevel = 7;\nif(phLevel < 7)\n{\n    System.out.println(\"It is acidic!\");\n}\nif(phLevel > 7)\n{\n    System.out.println(\"It is basic!\");\n}\nif(phLevel == 7)\n{\n    System.out.println(\"It is neutral!\");    \n}\nCorrect: It is neutral!\nIncorrect: It is acidic!\nIncorrect: It is basic!\nIncorrect: It is acidic!\nIt is basic!\nIt is neutral!END"}, {"prompt": "In the previous section, you saw how an if statement allowed you to use a conditional statement to determine if a block of code would be executed. In this section, you are going to extend that concept into an else statement.\n\nYou can add the else keyword to our if statement block. Using an else statement allows for a two-way selection, a set of code to execute if the statement is true and another set of code to execute if the statement is false.\n\nIn this case, if the boolean expression in our if statement evaluates to false, the code within the else segment will run. If the boolean expression evaluates to true, the code within the if segment will run.\n\nif (boolean expression) {\n   // Segment of code that will run if the boolean expression is true\n}\nelse {\n   // Segment of code that will run if the boolean expression is false\n}\n\n###\n\n", "completion": "Question: Consider the following code snippet\n\nif ( x == y)\n{\n    // Statement A\n} \nelse \n{\n    // Statement B\n}\n\nWhich statement will be executed if x = 20 and y = 15?\nCorrect: Statement B\nIncorrect: Statement A\nIncorrect: Statement A and Statement B\nIncorrect: Neither StatementEND"}, {"prompt": "Building on the previous two sections, you are going to look at adding the else if clause to our if blocks. The else if clause allows for a multi-way selection by using different conditional statements to represent different conditions.\n\nYou can add the else if keyword between your if and your else statement. If boolean expression one evaluates to false, then boolean expression two gets evaluated next. If boolean expression two also turns out to be false, the code within the else segment will run.\n\nif (boolean expression one) {\n   // Segment of code that will run if boolean expression one is true\n}\nelse if (boolean expression two) {\n   // Segment of code that will run if boolean expression one is false and two is true\n}\nelse {\n   // Segment of code that will run if boolean expression one and boolean expression two are both false\n}\n\nIt is important to note that you can have as many else if statements as you want, or you can have none. When looking at conditional blocks of code, the only required statement is the if statement. This can optionally be followed with any number of else if statements, and then optionally one else statement.\n\n###\n\n", "completion": "Question: What is the output of the following code snippet?\n\ndouble ticketPrice = 15.75;\n\nif(ticketPrice > 15)\n{\n   System.out.println(\"Too expensive!\");\n}\nif(ticketPrice > 10)\n{\n   System.out.println(\"Typical\");\n}\nelse if(ticketPrice > 5)\n{\n   System.out.println(\"Great deal!\");\n}\nelse \n{\n    System.out.println(\"Must be a scam\");\n}\nCorrect: Too expensive!\nTypical\nIncorrect: Must be a scam\nIncorrect: Typical\nIncorrect: Too expensive!END"}, {"prompt": "In the previous sections, you looked at how boolean expressions can be used in an if-else if-else statement. In this section, you are going to take a step back and look at the boolean expressions used in those conditional statements.\n\nBoolean variables can only take on one of two possible values, true or false. Logical operators allow you to combine and connect booleans in useful ways. When you use logical operators, the resulting expression will result in a single boolean value.\n\nThere are three fundamental logical operators:\n\n- NOT\n- OR\n- AND\n\nThese should look quite familiar; in fact, you use them in speech every day! The NOT operator is used on a single boolean, whereas AND and OR are used across multiple boolean values.\n\nLogical operators can be used to help avoid nested if statements. A nested if statement consists of an if statement within an if statement. For example:\n\nif (temp > 70) {\n    if (sunny) {\n        System.out.println(\"Time to get outside!\");\n   }\n}\n\nUsing logical operators, you can condense a nested if statement into a single statement, for example:\n\nif (temp > 70 && sunny) {\n    System.out.println(\"Time to get outside!\");\n}\n\nAND is represented in Java as: &&. An expression using AND is true only when all its component parts are true. If any of the boolean values are false, the whole expression evaluates to false.\n\nFor example, if it is 6:30am AND it is a school day, you should wake up. You can test the expression of \u201c6:30am AND a school day.\u201d If both are true, then the whole expression evaluates to true. If either or both are false, then the whole expression is false, and you should stay in bed.\n\nboolean sixThirty = true;\nboolean schoolDay = false;\nSystem.out.println(sixThirty && schoolDay);  // because both values aren't true, it prints \"false\"\n\nFor variables p and q that can be true or false:\n\np\tq\tp AND q\ntrue\ttrue\ttrue\ntrue\tfalse\tfalse\nfalse\ttrue\tfalse\nfalse\tfalse\tfalse\n\nOR is represented in Java as ||. An expression using OR is true when all or any of its parts are true. It is only false when all of the boolean values are false.\n\nSay that you are trying to decide whether to wear a coat today. You\u2019ll wear your coat if it is raining right now or if it is cold outside. You can evaluate this expression based on the answers to those two boolean values. If it\u2019s raining, cold, or raining and cold, then you will wear your coat. The only case in which you would not wear your coat is if it\u2019s neither raining nor cold.\n\nboolean isRaining = true;\nboolean isCold = false;\nSystem.out.println(isRaining || isCold); // it's not cold, but it is raining, so it prints true\n\nFor variables p and q that can be true or false:\n\np\tq\tp OR q\ntrue\ttrue\ttrue\ntrue\tfalse\ttrue\nfalse\ttrue\ttrue\nfalse\tfalse\tfalse\n\nSince AND expressions evaluate to false if any condition is false, and OR expressions will evaluate to true if any condition is true, there is a shortcut that Java uses to make your programs run more efficiently. If the first value of the boolean expression is false in an AND operation, or the first value is true in an OR operation, the remaining conditions are irrelevant!\n\nBecause these expressions will always evaluate to false and true respectively, regardless of what the other expression evaluates to, Java will not evaluate the second expression. This process of skipping the second condition in a boolean expression is called short circuit evaluation.\n\nExpression\tResult\nfirst && second\tIf first is false, then the whole expression must be false. Don\u2019t bother evaluating second.\nfirst || second\tIf first is true, then the whole expression must be true. Don\u2019t bother evaluating second.\n\nNOT is represented in Java as !. When placed in front of a boolean value, NOT causes the boolean to take on its opposite value. For example \u201cNOT true\u201d gives the answer \u201cfalse.\u201d This is fairly intuitive \u2013 if something is not true, then it must be false. Similarly, if something is not false, then it must be true.\n\nThe example below sets up a variable hungry as being true. Then it prints out NOT hungry.\n\nboolean hungry = true;\nSystem.out.println(!hungry);  // prints \"false\"\n\nFor a variable p that can be true or false:\n\np\t!p\ntrue\tfalse\nfalse\ttrue\n\nJust like mathematical expressions have an order of operations, boolean operators also follow an order of operations. In the case of Booleans, the ! operator takes precedence over &&, and && takes precedence over ||. Here is an example:\n\nboolean a = true;\nboolean b = false;\nboolean c = a && b || b\n\nIn this example, c evaluates to false. The first part of the expression to be evaluated would be the a && b since AND takes precedence over OR. Since that part evaluates to false, the expression short circuits and returns false.\n\n###\n\n", "completion": "Question: Which of the following will result in a logical short circuit assuming a is true and b is false?\nCorrect: a || b\nIncorrect: a && b\nIncorrect: b || a\nIncorrect: !b && aEND"}, {"prompt": "In this section, you will apply some of the concepts of booleans and logical expressions as you evaluate expressions to determine whether they are equivalent.\n\nAugustus De Morgan was a British mathematician who devised two laws to help understand equivalent boolean expressions.\n\n- not(A and B) is the same as (not A) or (not B)\n- not(A or B) is the same as (not A) and (not B)\n\nCollectively these two laws are known as De Morgan\u2019s Law. At the heart of these laws, De Morgan is saying that you can transform one expression into an equivalent expression. In terms of boolean expressions, you saw that 2 expressions are equivalent if they both evaluate to the same value for all cases. In the case of De Morgan\u2019s law, that means that regardless of whether A is true or false and B is true or false, not(A and B) will always be the same as (not A) or (not B). Likewise, not(A and B) will always be the same as (not A) and (not B).\n\nTo help better understand De Morgan\u2019s Law, you can use truth tables. Truth tables look at various values of boolean variables and expressions and can be used to prove boolean identities such as De Morgan\u2019s Law.\n\nDe Morgan\u2019s First Law states that not(A and B) is the same as (not A) or (not B). If you were to put this in terms of Java, it would look like this:\n\n!(A && B) == !A || !B\n\nLet\u2019s break this down in a truth table.\n\nA\tB\tA&&B\t!(A&&B)\t!A\t!B\t!A || !B\nT\tT\tT\tF\tF\tF\tF\nT\tF\tF\tT\tF\tT\tT\nF\tT\tF\tT\tT\tF\tT\nF\tF\tF\tT\tT\tT\tT\n\nNotice in the table above how our two columns that contain expressions show the same values for each expression for all 4 possible combinations of values for A and B. As a result, you can see that the two expressions are equivalent.\n\nTurning now to De Morgan\u2019s Second Law, you can do the same thing. Expressed as a Java expression, De Morgan\u2019s second law states:\n\n!(A || B) == !A && !B\n\nLet\u2019s take a look at the truth table for this law.\n\nA\tB\tA||B\t!(A||B)\t!A\t!B\t!A && !B\nT\tT\tT\tF\tF\tF\tF\nT\tF\tT\tF\tF\tT\tF\nF\tT\tT\tF\tT\tF\tF\nF\tF\tF\tT\tT\tT\tT\n\nAgain, if you focus on the two highlighted columns, you can see that the two sides of the expression in De Morgan\u2019s second law are also equivalent.\n\nTruth tables can be powerful tools to help determine if two or more expressions are equivalent. To use a truth table, it is best to break down expressions into small pieces and then build them back up. Let\u2019s take a look at this expression:\n\nA && !B || !A && B \n\nUnder what circumstances would this expression evaluate to true? You can use a truth table to answer that question. You should lay the truth table out to follow the order of operations, which means you will evaluate the NOT operators first, then the AND operators, and finally the OR operator.\n\nA\tB\t!B\tA && !B\t!A\t!A && B\tA && !B || !A && B\nT\tT\tF\tF\tF\tF\tF\nT\tF\tT\tT\tF\tF\tT\nF\tT\tF\tF\tT\tT\tT\nF\tF\tT\tF\tT\tF\tF\n\nWhen you lay out the results in a truth table, it is easy to see that the expression will evaluate to true anytime A and B have opposite values.\n\n###\n\n", "completion": "Question: Which of the following logical statements is equivalent to\n\n!(A || B)\n\nWhere A and B are boolean values.\nCorrect: !A && !B\nIncorrect: A && B\nIncorrect: !A || !B\nIncorrect: !A || BEND"}, {"prompt": "In this section, you are going to look at how to compare objects. As you may recall from previous sections, objects, or reference variables, differ in several ways from primitive variables. The important difference that you will explore in this lesson is the way that the values are stored. Recall that primitive variables store actual values for the variable while objects store a reference to the memory location of the value.\n\nThe == comparison operator is designed to compare the value of two variables. Since the value that is stored for a reference variable is the memory location, using == will return whether or not the two objects have the same reference. When two objects have the same reference, they are said to be aliases.\n\nIf the objects are aliases of one another, then you know that they will also be equal.\n\nTake a look at the example below:\n\nRectangle one = new Rectangle(3,7);\nRectangle two = one;\n\nboolean same = one == two; // Will be true\n\nIn this example, the two rectangles are the same and they are also aliases of one another. As a result, comparing the objects with == returns true.\n\nYou can also do this comparison with != to check if two objects are not aliases, and both can be used to compare to null to determine whether the reference is actually to an object.\n\nRectangle three;\nboolean isSet = three != null; // Will be false\n\nIn this example, you can see the isSet variable will be set to false since variable three has not yet been set to reference an object.\n\nUsing == allowed us to find if two reference variables were aliases, but what if you want to find if two reference variables are the same?\n\nFor example:\n\nRectangle one = new Rectangle(3,7);\nRectangle two = new Rectangle(3,7);\n\nAre rectangles one and two the same? In this case, they appear to be, however, if you test them with ==, Java will return false. Why is that?\n\nRecall above that you saw how == compares the memory locations of the variables. Since both rectangles were instantiated as separate objects, they are stored in a different place in memory, so using == will return false.\n\nObjects can have several pieces of information associated with them. As a result, an object needs to have a specific method that can be used to determine if they are equal. For example, what would make two rectangles equal? Would it be that the rectangles have the same dimensions or can two rectangles be equal if they have different dimensions, but the same area?\n\nIn Java, the method that is used is called .equals(). This method is called from a variable and it passes a parameter to compare to in order to determine if the values are equal.\n\nIf you assume that one rectangle equals another rectangle if they have the same width and height, then .equals() can return true if the method compares the width and height of two rectangles and finds them to be the same.\n\nTake a look at the example below:\n\nRectangle one = new Rectangle(3,7);\nRectangle two = new Rectangle(3,7);\nboolean isAlias = one == two; // Will be set to false\nboolean isEqual = one.equals(two); // Will be set to true\n\nIn this example, you can see that one and two are not aliases of one another. If you compare them with the comparison operator, it will return false. Since both rectangles were created the same way, it seems logical that they are in fact equal and by using the .equals(), you can see that this is the case.\n\n###\n\n", "completion": "Question: What is the proper way to compare String values in Java?\nCorrect: The .equals() String method\nIncorrect: The = operator\nIncorrect: The == operator\nIncorrect: The && operatorEND"}, {"prompt": "while loops are a way to change the flow of control by repeating a block of code so long as some condition remains true. The condition is written in the form of a boolean expression.\n\nThe basic structure of a while loop is shown below.\n\nwhile(boolean expression)\n{\n   // code block inside of while loop to execute if the boolean expression is true\n}\n   // code outside of while loop to execute if the boolean expression is false\n\nAs long as the boolean expression remains true, code within the while loop will be executed. The moment that the boolean expression becomes false, code outside of the while loop will be executed; the loop is done.\n\nThe boolean expression evaluates before the loop executes each time, including the first time. It is possible that the condition is false initially and the loop body is never executed.\n\nHere is a basic example of a countdown.\n\nint i = 5;\nSystem.out.println(\"Initiating countdown:\");\nwhile(i >= 0) {\n  System.out.println(i + \"...\");\n  i--;\n}\n\nYou first declare a variable i and set it equal to 5. Before the while loop, you print out a message letting the user know that the countdown is about to begin. Your while loop starts by checking to see if the boolean expression, i >= 0, is true. The current value of i is 5. 5 >= 0 is true, so the code within the while loop gets executed. It prints out the number 5 and then decrements it by subtracting 1.\n\ni is now set to 4. Our while loop then checks to see if 4 >= 0. Since this condition is still true, the code within the while loop gets executed again. This will continue until i gets down to 0. After 0 gets printed to the screen, you decrement i so that it is now set to -1. Your while loop tests to see if -1 >= 0. Since -1 is not greater than or equal to 0, the boolean expression is false. The code within the while loop is skipped. The while loop has finished its execution.\n\nAfter you run the above program, this is what gets printed to the screen:\n\nInitiating countdown:\n5...\n4...\n3...\n2...\n1...\n0\n\nYou must exercise caution when using while loops to avoid the dreaded infinite loop. An infinite loop is a loop that always evaluates to true and therefore, never terminates. It never finishes its execution. It will continue to repeat until the end of time! Infinite loops will often cause a program to freeze and crash.\n\nThe countdown program above has been rewritten below, but it is missing an essential line of code. This will cause an infinite loop:\n\nint i = 5;\nSystem.out.println(\"Initiating countdown:\");\nwhile(i >= 0) {\n  System.out.println(i + \"...\");\n}\n\nBut why? Why does this cause an infinite loop?\n\nWith the omission of i--, you are no longer changing our variable. i will forever be set to 5. Our while loop will repeatedly check to see if 5 >= 0. Since this condition is always true, the code within the while loop body will execute forever. The while loop will never terminate.\n\nYour program will just keep printing a value of 5 over and over again. Thus, after running the program, your output will look something like this (assuming the browser does not freeze and crash):\n\nInitiating countdown:\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5...\n5\n\n[NOTE: This will continue printing \u201c5\u2026\u201d forever!]\n\nIn the CodeHS editor, you can manually stop the program by clicking on the \u201cSTOP\u201d button next to the \u201cRUN CODE\u201d button. Otherwise, it will continue spamming the number 5 at us until the end of time.\n\nOne way to break out of a loop, infinite or otherwise is to execute a return statement. If a while loop is set up to run in a method and a return statement is placed inside the while loop, executing the return statement will return the program to the original calling point, thus exiting the loop.\n\nHere is an example:\n\nint sumTo(int num) {\n    int i = 1;\n    int sum = 0;\n    while (true) {\n        sum += i;\n        if (sum > num) {\n            return i;\n        }\n        i++;\n    }\n}\n\nIn the example above, notice that you potentially have an infinite loop since true will always evaluate to true. The loop will not continue forever though. Once sum is greater than num the return statement will execute and exit the loop and the method.\n\nAs you start writing more and more programs, you will find many applications of while loops. You saw one application above where the while loop was used to sum numbers. Similar loops can be used to calculate average, mode, minimum, or maximum for a set of numbers.\n\nAnother application that is typically used with a while loop is to split out individual digits of a number. Here is an example of a loop that can do that.\n\nint num = 345;\n\nwhile (num > 0) {\n  // get the first digit by using the mod function\n  int digit = num % 10;\n  System.out.println(digit);\n\n  // Divide the number by 10\n  num /= 10; // Integer division truncates the number\n}\n\nIn the example above, notice how you can use mod and division to separate out each digit. If you start with the number 345, mod 10 returns the 5. When you then use integer division and divide 345 by 10, you get 34. Since 34 is greater than 0, the while loop executes again. Now the mod function splits off 4 and the division function reduces the number to 3. The program then enters the while loop again, printing out 3. When it divides 3 by 10, it gets zero. Now zero is no longer greater than 0, so the loop is complete.\n\nOther uses of while loops include identifying if an integer is or is not evenly divisible by another integer and determining the frequency with which a specific criterion is met.\n\n###\n\n", "completion": "Question: What will this while loop do?\n\nwhile(false)\n{\n    System.out.println(\"Welcome\");\n}\nCorrect: Nothing\nIncorrect: Print Welcome one time\nIncorrect: Print Welcome until program receives user input\nIncorrect: Print Welcome in an infinite loopEND"}, {"prompt": "Like while loops, for loops are a way to change the flow of control by repeating a block of code. for loops allow us to repeat code a fixed number of times.\n\nA basic for loop is structured like this:\n\nfor (int i = 0; i < COUNT; i++) \n{  \n    // Code segment that is executed COUNT times. \n}\n\nA for loop can be divided into three major parts. The first part initializes the loop variable, the second part tests some condition and the third part increments or decrements the loop variable. Each part of the for loop is separated by a semicolon (;).\n\nLet\u2019s break down the following example into its three major parts:\n\nPart 1: Initialize\nThe first part of a for loop initializes some variable. In the example above, int i = 0 initially sets the variable i equal to 0.\n\nPart 2: Condition\nThe second part of a for loop tests a condition. If the condition is true, the code within the for loop executes. If the condition is false, the code within the for loop is skipped. In the example above, i < 3 compares the current value of our variable i to determine if it is less than 3. Each time i is less than 3, the value of i will be printed to the screen. This happens three times.\n\nPart 3: Increment/Decrement\nThe third part of a for loop changes the variable after each time the loop runs. Remember, i++ means 1 is added to i. It is incremented. Conversely, i-- means 1 is subtracted from i. It is decremented.\n\nWhen a for loop runs, each of the 3 parts runs in a particular order. The initialization step only runs one time before the boolean expression is evaluated the first time. After this, the boolean expression is evaluated and if it is true, the loop executes. After the loop execution, the increment/decrement statement executes before the is evaluated again.\n\nWhat happens when you run the example for loop? What gets printed to the screen?\n\nThe first part of our for loop, int i = 0, initializes our variable. It sets our loop variable i equal to 0. Next, the condition part of the loop is evaluated. Is i< 3? Since i is currently set to 0, and 0 is indeed less than 3, the condition i < 3 is true. Thus, the code within the for loop is executed. 0 is printed to the screen. After this, i is incremented. i++ means you add 1 to i, so i is now set to 1.\n\nSince i is now set to 1, the condition i < 3 is re-evaluated. It is still true. 1 is now printed to the screen. i is incremented again and becomes set to 2.\n\nThe condition i < 3 is re-evaluated. Since i is now set to 2, our condition is still true. 2 is printed to the screen. i is incremented again and becomes set to 3.\n\nFinally, when the condition i < 3 is re-evaluated, our condition is false. 3 is not less than 3, so the code within the for loop is skipped. Nothing else gets printed. The for loop is done.\n\nThus, our output would be:\n\n0\n1\n2\n\nfor loops and while loops can be interchangeable. A for loop can be rewritten as a while loop and vice versa. Take a look at the countdown while loop from earlier.\n\nint i = 100;\nSystem.out.println(\"Initiating countdown:\");\nwhile(i >= 0) {\n  System.out.println(i + \"...\");\n  i--;\n}\n\nIn this countdown example, i is initially set to 100. The while loop checks the condition and insider the loop, i is decremented. The same process can happen in a for loop.\n\nEach piece that you saw in the while loop is still present as one of the three parts of the for loop.\n\nOne thing to be cautious of is off by one errors. Off by one errors occur when your loop doesn\u2019t start or stop at the correct place. Think about summing the numbers from 1 to 100. You may think of setting up your for loop like this:\n\nfor (int i = 1; i < 100; i++) {  ...  }\n\nDoing so will cause an off by one error since you are missing the 100. Since you want to include 100, you need to use a <= (less than or equal) instead of just a less than. Here is a correct loop to sum the numbers from 1 to 100.\n\n###\n\n", "completion": "Question: What does the following code print?\n\nfor (int i = 4; i < 8; i++)\n{\n   System.out.print(i + \", \");\n}\nCorrect: 4, 5, 6, 7,\nIncorrect: 4, 5, 6, 7, 8,\nIncorrect: 0, 1, 2, 3, 4, 5, 6, 7,\nIncorrect: This code will produce an infinite loop.END"}, {"prompt": "You looked at several string methods that can be used for a variety of functions such as taking substrings, searching Strings, and comparing them to other Strings. In this section, you will take a look at several common algorithms that can be performed with Strings.\n\nTraversing is the process of going through a String one character at a time, often using loops. for loops tend to be common for this type of task since the string length is fixed. Here is an example of a String traversal that will translate a string into a vertical column.\n\nIn this example, notice how you loop from 0 to less than the print length and then use the substring function to print the current index to the next index, which will print one character.\n\nUsing this idea, you can take a look at different algorithm examples.\n\nOne application of a substring traversal is to determine if a particular substring meets a criteria or alternately, count the number of times that it meets that criteria. Take a look at the method below where you count the number of vowels in a String:\n\npublic int numUpperCase(String string){\n    int counter = 0;\n    for(int i = 0; i < string.length(); i++) {\n        String letter = string.substring(i, i+1);\n        if(letter.equals(letter.toUpperCase())) {\n            counter++;\n        }\n    }\n    return counter;\n}\n\nIn this example, notice how you traverse the String and grab one letter each time through. Then, by checking if the letter is equal to the uppercase version of the letter, you can determine if it matches the criteria. If so, then you can increase the counter.\n\nAnother common string algorithm is to reverse a String. In the example below, a String is reversed by creating a new empty String and then adding one letter at a time to that String.\n\nNotice in this example how the loop starts at the end of the current String and loops to the beginning of the String. Each time, it still grabs a letter in the same manner as the original loop.\n\nString original = \"Let's reverse this string!\";\nSystem.out.println(original);\n\nString newString = \"\";\nfor(int i = original.length() - 1; i >= 0; i--)\n{\n    String character = original.substring(i, i+1);\n    newString += character;\n}\nSystem.out.println(\"The original string reversed = \" + newString);\n\n###\n\n", "completion": "Question: What is the general formula for traversing a String character by character?\nCorrect: for(int i = 0; i < string.length(); i++)\n{\n    String character = string.substring(i, i +1);\n}\nIncorrect: for(int i = 0; i <= string.length(); i++)\n{\n    String character = string.substring(i, i +1);\n}\nIncorrect: for(int i = 0; i < string.substring(i, i+1); i++)\n{\n    String character = string.length();\n}\nIncorrect: for(int i = string.length(); i > 0; i++)\n{\n    String character = string.substring(i, i +1);\n}END"}, {"prompt": "Earlier in this unit, you saw how to use a loop for a repeated task. For example, if you wanted to print the numbers 1 through 5 on a line, you could use a loop like this:\n\nfor(int count = 1; count < 6; count++) \n{ \n   System.out.print(count + \" \"); \n}\n\nWhat if you wanted to print something like this?\n\n1 2 3 4 5\n2 4 6 8 10\n3 6 9 12 15\n4 8 12 16 20\n5 10 15 20 25 \n\nYou could use 5 loops, one for each line and each loop starting and stopping at different values. This would get repetitive and you saw how you could use loops to avoid repetitive code. In this section, you are going to explore the concept of a nested loop.\n\nJust as you saw with if statements, putting a loop inside another loop is called nesting. A nested iteration statement is an iteration statement that appears in the body of another iteration statement.\n\nIn the example above, you can achieve the five-by-five print out using a nested for loop.\n\n// New loop outside\nfor (int row = 1; row < 6; row++) {\n    // Original loop inside\n    for(int count = 1; count < 6; count++) {\n        System.out.print(count * row + \" \" );\n    }\n    System.out.println();\n}\n\nThe original loop is now wrapped inside of a second loop. Notice how each of the loops uses a different loop variable.\n\nEach time through the outer loop, the inside loop starts over and runs to completion. After completing the inside loop and printing a row, a line feed is added, then the outer loop loops around and starts the next row.\n\nIn this example, the inner loop executes 5 times each time it is called. The outer loop also executes 5 times, each time creating a new inner loop. So each line of code inside the inner loop actually executes 25 times!\n\nJust as there are nested for loops, you can also have nested while loops, or even mixed nested loops with a for loop inside a while loop, or vice versa.\n\nint line = 1;\nwhile(line < 6) {\n    int number = 1;\n    while(number < 6) {\n        System.out.print(number*line +\" \");\n        number++;\n    }\n    System.out.println()\n    line++;\n}\n\n###\n\n", "completion": "Question: How often is the inner loop of a nested loop run?\nCorrect: Each time the outer loop runs\nIncorrect: Infinitely\nIncorrect: Twice as often as the outer loop\nIncorrect: One less time than the outer loop runsEND"}, {"prompt": "Throughout this course, you have spent a considerable amount of time developing algorithms. Algorithms are a step-by-step process that solves a problem. Many, if not all, of the programs that you have developed, are considered algorithms because they solve a problem.\n\nYou also use algorithms in our daily lives and don\u2019t think about it. Most of the tasks that you perform on a daily basis are routinized and have procedures that you follow so that you can complete them as planned. Making a PBJ sandwich is an example of a practice that you do that has a procedural, step-by-step nature.\n\nmakePBJ()\n{\n    takeBread();\n    spreadJelly();\n    spreadPeanutButter();\n    if (likeToasted){\n        toast();\n    }\n}\n\nSo what makes a good algorithm?\n\n- Correctness\n- Easy to understand by someone else\n- Efficiency (run time and memory requirements)\n\nCorrectness refers to whether the algorithm solves the given problem. Easy to understand can be a function of how the code is laid out, using appropriate variable names, and the use of comments. Efficiency can be looked at in several ways, which you will explore in this section.\n\nProgram efficiency is important because it affects both the speed and cost to execute a program. Oftentimes speed and cost are impacted by the physical computer\u2019s specification and as a programmer, you do not have much control over this.\n\nTo help estimate the cost and efficiency of a program, you can use an informal code analysis by looking at the number of statements that a program needs to execute. A statement execution count indicates the number of times a statement is executed by the program, which can be a good indicator of the cost and speed of the program.\n\nThe Statement Execution Count is the number of times a statement is executed by the program. When comparing different algorithms, you can estimate the costs for each by looking at the number of statements that need to be executed to run the program.\n\nAn execution statement might refer to:\n\n- an arithmetic operation ( + , * )\n- an assignment (int value = 2)\n- a test (x == 0)\n- an input/output\n\nTake a look at the example below:\n\npublic void computeSum (int n) {\n    int sum = 0; \n    int n = 10;\n\n    for (int i = 0; i < n; i++) {\n        sum += i; \n    }\n    System.out.println(sum); \n}\n\nIn this example, the code executes the first two assignment statements before the loop. Then the loop executes n times, followed by one additional statement. The total number of steps executes for this algorithm would be n + 3.\n\n###\n\n", "completion": "Question: How many times does the following loop iterate?\n\n// x has been initialized with a positive int value\nfor (int count = 0; count <x; count++) \n{\n    System.out.print(\"*\");\n}\nCorrect: x times\nIncorrect: x + 1 times\nIncorrect: x - 1 times\nIncorrect: Infinite number of timesEND"}, {"prompt": "In Unit 2, you had the opportunity to explore classes from the perspective of a user of the class. In this unit you will take a deeper dive and look at how you can create classes of your own. Classes allow you to create custom objects that can make your program easier to implement.\n\nIn Java, there are two main access levels that you will see in this course, private and public. Private access is used when an element (such as a variable or method) should only be able to be accessed within the declaring class. What does that mean? Access in the class is when other statements in the same class try to access a value or function. For example given the class definition below:\n\npublic class Sample {\n    private int value;\n}\n\nAny statement in the Sample class will be able to access value, but any other class that may create a Sample object will not have access to value since it is private.\n\nIn contrast, public access allows for an element to be accessed by any other class. Take a look at the updated class definition below:\n\npublic class Sample {\n    private int value;\n\n    public int getValue(){\n        return value; \n    }\n}\n\nIn this example, you will notice that the getValue method is public. In this case, if a Sample object was created in another class, you would be able to call the getValue method, and thus get indirect access to value.\n\nWhen creating classes, classes should always be declared public since they need to be accessed by other classes. Likewise, a constructor in the class should always be public since it needs to be called by external classes.\n\nWhen designing a class, programmers can make certain decisions about which elements should be public or private, however there are some basic governing rules that should be followed.\n\nWhen it comes to instance variables, all instance variables should be designated private to keep access internal to the class. There are several reasons why you should always declare instance variables private.\n\nThe first reason revolves around the idea of data encapsulation. Data encapsulation is a technique in which the implementation of details of the class are kept hidden from the user. By using the private level access, instance variables are encapsulated in the class.\n\nWhen designing a class, programmers make decisions about what data to make accessible and modifiable from an external class. Each piece of data can be either accessible or modifiable, or it can be both or neither. This access is accomplished through accessor and mutator methods (getters and setters).\n\nIn addition to data encapsulation, private access to instance variables can be used to help manage complexity. For example, think about a student object that may have an instance variable for grade and another variable to designate school level (such as middle school or high school). A programmer may decide to limit modifications to only the grade level and within the grade mutator method they also make updates to the school level. Not only does this streamline the update process, but it also controls the process to make sure you don\u2019t have a 12th grade middle school student.\n\nWhile instance variables are always declared private, methods can be declared either public or private, making them either external or internal to the class. Many behaviors need to be available externally, so oftentimes methods are declared public, but there are times when private access is preferable.\n\nPrivate access is usually used with helper methods. For example, think back to the student object described above. The programmer may decide to write a public mutator method to change the grade. Once the grade is changed, the school level needs to be checked and possibly changed. If the programmer decided to do this check and make the change using another method, then that method would be private. As a private method, it can be called from the grade mutator method, but the end user cannot call the method directly from the other class.\n\nProgrammers will use private methods when they want to have a method to use in their class, but do not want that method called and used from an instance of the object.\n\n###\n\n", "completion": "Question: Which of the following class members should NOT be public?\nCorrect: Instance Variables\nIncorrect: Constructors\nIncorrect: Accessors/Mutators\nIncorrect: Methods the user needs to manipulate the objects of the classEND"}, {"prompt": "Constructors are essentially object creators. You use constructors to create new objects using a class. When you create new objects using constructors, you also set any initial values of instance variables if necessary. These initial values of instance variables can be set either with or without the use of parameters.\n\nAn object is said to have state and behaviors. The state of an object represents the attributes and their values at a given time and is defined by instance variables belonging to the object. These instance variables create a \u201chas-a\u201d relationship. For example, if you think about a Rectangle object, you can say that the Rectangle has a length and the Rectangle has a width. At any given point in time, the state of the rectangle can be defined by the length and width of the Rectangle.\n\nConstructors are used to set the initial state of an object, which should include initial values for all instance variables.\n\nAs you saw back in unit 2, the constructor is used to instantiate a new object and is called anytime an object is created. Constructors can serve multiple purposes, but one purpose is to set the initial state of variables. Take a look at the example showing how you would write a constructor:\n\npublic class Dog\n{\n    // Instance variables\n    private String name;\n    private int age;\n    private double weight;\n    private boolean isAlive;\n\n    // Constructor\n    public Dog(String theName, int theAge, double theWeight, boolean isThisAlive)\n    {\n        // Instance variable initialization\n        name = theName;\n        age = theAge;\n        weight = theWeight;\n        isAlive = isThisAlive;\n    }\n}\n\nThe constructor parameters are local to the constructor only. Because of this, you will notice how the local constructor parameters are used inside the constructor to set the initial value of the instance variables. Additionally, it is important to note that when a mutable object is passed as a parameter, the instance variable is initialized with a copy of the variable. As a result, any modifications to the instance variable will not be reflected in the original object.\n\nWhile a constructor does play an important role, it is possible to create a class without a constructor. When no constructor is provided, Java provides what is known as a no-argument constructor. The no-argument constructor executes anytime an object is created and sets any instant variable to their default value.\n\nExample:\n\npublic class Dog\n{\n    private String name;\n    private int age;\n    private double weight;\n    private boolean isAlive;\n}\n\nIn this example, when a Dog object is created, the instance variables will be set to their default values, which is zero for the integer and double, an empty string for name, and false for the Boolean value.\n\n###\n\n", "completion": "Question: An object\u2019s state is defined by the object\u2019s\nCorrect: instance variables and their values\nIncorrect: methods and instance variables\nIncorrect: access modifiers of the instance variables\nIncorrect: methods and their return valuesEND"}, {"prompt": "There are two parts to writing a program: One part is getting it to work (the functionality). The other part is the style: How did you write the program? Did you break it down into parts? Is it clear to read? This is where comments come into play!\n\nComments are a way for you to leave notes about what your code is doing in plain English so that other people can understand it.\n\nWhy comment?\n\nEven though code is run by computers, it is read by other people. Comments help others understand your code. If you read your code ten years from now, would you be able to understand what it does?\n\nThe computer that runs your program knows to ignore comments if they are written as multi-line, single line, or Javadoc comments.\n\nUse multi-line comments to leave a comment so a reader understands what your program or method is doing. The start of a multi-line comment uses /*, each line following with a single *, and ending the multi-line comment with */.\n\n/* \n* This program does ______. \n*/\n\nUse single line comments to leave a comment for a single line in your code. For each single line comment, put two backslashes (//) before the comment.\n\n//This line does ______.\n\nAnother important part of commenting is using preconditions and postconditions. You can leave notes at the top of our methods about assumptions that you make.\n\nPreconditions: A precondition is a condition that must be true just prior to the execution of a section of program code in order for the method to behave as expected. There is no expectation that the method will check to ensure preconditions are satisfied.\n\nPostconditions: A postcondition is a condition that must always be true after the execution of a section of program code. Postconditions describe the outcome of the execution in terms of what is being returned or the state of an object.\n\nThis helps you think about the problem and make sure our methods line up.\n\n###\n\n", "completion": "Question: Which of the following is NOT a valid comment?\nCorrect: // Comment\n    Comment //\nIncorrect: // Comment\nIncorrect: // Comment //\nIncorrect: /* Comment\n    Comment */END"}, {"prompt": "One key aspect of writing classes in Java is that you can control how the class is used. As mentioned earlier, instance variables are kept private in your Java classes, but that doesn\u2019t mean that users can\u2019t access them via public methods. Access to variables is controlled by the developer through accessor methods.\n\nAn accessor method is a method that is used to return the value of an instance (or static) variable to the user. Since the method is returning a value to the user, the method header should contain the return type in place of the keyword void.\n\nWhen creating accessor methods there is a common convention you should follow. When naming your method you should always use this format: get[Variable Name] for the name. Some examples of this would be: getWidth(), getHeight(), and getColor(). As a result of this naming convention, accessor methods are sometimes referred to as \u201cgetter\u201d methods.\n\nHere is an examples of how this would look:\n\nprivate int width = 10;\nprivate int height = 3;\nprivate Color rectCol = Color.blue;\n\npublic int getWidth()\n{\n  return width;\n}\n\npublic int getHeight()\n{\n  return height;\n}\n\npublic Color getColor()\n{\n  return rectCol;\n}\n\nAs a non-void method, the accessor method returns a single value. This value needs to be compatible with the return type in the method header, for example a string needs to return a string, or a double return type needs to return a number (an int or double is compatible with a double).\n\nWhen returning a value, a copy of that value is returned to the calling method, whether the value is a primitive or an object. This is referred to as \u201creturn by value.\u201d\n\nAs soon as the return keyword is used, the program returns to the point immediately following where the method was called. This can be used to return a value or to interrupt the progress execution and end the method execution.\n\nThe toString method is a specific method that is used to return a string representation of the object. The method is often included in many classes as a way to override the default object description and provides a description of the object. It will generally include some of the values stored in instance variables, or a calculation with those values, but it doesn\u2019t have to.\n\nWhile the method can be called with using the standard dot syntax, such as obj.toString(), the method is also called by default for print statements.\n\nFor example, if there is a Shape class that has a toString method, the toString would be called int he following situation:\n\nShape s1 = new Shape(\"Rectangle\");\nSystem.out.println(s1); // calls the toString for s1\n\nShape s2 = new Shape(\"Circle\");\nSystem.out.print(s2); // calls the toString for s2\n\n###\n\n", "completion": "Question: Which of the following method signatures would be appropriate as an accessor method for an String instance variable called name?\nCorrect: public String getName()\nIncorrect: public void getName()\nIncorrect: private void getName()\nIncorrect: private String getName()END"}, {"prompt": "Just like you can control which instance variables an end user can access, developers can also control access to updating variables. This access is controlled by the mutator methods.\n\nA mutator method is a method that is used to update the value of an instance (or static) variable. Since the method is designed to update a value, the method header often contains the void keyword since it doesn\u2019t return a value.\n\nMutator methods set a new value. As such, they are often referred to as setter methods. Setter methods allow us to set the values of an object\u2019s instance variables.\n\nAs with accessor/getter methods you use a common convention when creating mutator methods. When creating mutator methods you should always use: set[Variable Name]. Some common examples include: setWidth(int width), setHeight(int height), setColor(Color color). Here are some examples of how to create these setter methods:\n\nprivate int width = 10;\nprivate int height = 3;\nprivate Color rectCol = Color.blue;\n\npublic void setWidth(int newWidth)\n{\n  width = newWidth;\n}\n\npublic void setHeight(int newHeight)\n{\n  height = newHeight;\n}\n\npublic void setColor(Color color)\n{\n  rectCol = color;\n}\n\n###\n\n", "completion": "Question: Which of the following is NOT a characteristic of a mutator?\nCorrect: Mutator methods are generally private methods\nIncorrect: Mutator methods generally have a void return type\nIncorrect: Mutator method generally have a parameter\nIncorrect: Mutator methods generally update instance variablesEND"}, {"prompt": "The last two sections looked at creating two specific types of class method focused on accessing and updating instance variables. What if you want to do something else, like perform a calculation or print out a result? Using class methods, you can write your own behaviors for a class.\n\nRecall from Unit 2 where you first methods, a method header is the first line that is used to define a method. For example:\n\npublic int addFive(int num)\n\nIn the above example, since the method is a non-void method with a parameter, the method would take the formal parameter (parameter in the method) value in, use it, and then return a computed value. The return value needs to match the return type.\n\nWhen a primitive value is passed to the method, the formal parameter is initialized with a copy of the value. In other words, any changes to the formal parameter in the method will not change the actual parameter in the calling method.\n\nHere is an example. Given a Numbers class:\n\npublic class Numbers {\n  public int addFive(int num) {\n    num += 5;\n    return num;\n  }\n}\n\nIf the following code is executed to call the addFive method:\n\nNumbers myNum = new Numbers();\nint a = 12;\nSystem.out.println(myNum.addFive(a));\n\nThe output will be 17 however, the value of a will remain unchanged at 12.\n\nIn contrast, when an object is passed to a function as a parameter, the formal parameter is initialized with a copy of the reference, not a copy of the object. What does this mean?\n\nAs a copy of the reference, both the original reference and the copy point back to the same object. This makes the actual parameter and formal parameter aliases that refer to the same object. Assuming the object is mutable, updates in the method will be reflected in the original value also getting updated.\n\nAs a note, it is good programming practice to not modify mutable objects that are passed as parameters unless required in the specification.\n\nIf the formal parameter is a reference object, you can actually access the private data associated with that reference if the method has been written in the object\u2019s class file. In the example below, because MyProgram is not the file that the Rectangle class was written in, you have to use rect.setWidth() and rect.setHeight() to access the instance variables.\n\nMyProgram.java\n\npublic void resetRect(Rectangle rect) {\n  rect.setWidth(0);\n  rect.setHeight(0);\n}\n\nIf the method was written inside the Rectangle class file, then you could access the object\u2019s data by using the .variable notation. Notice that instead of using setWidth and setHeight, you can just change the value of width and height by writing rect.width and rect.height. This works when the parameter reference object is the same as the class file.\n\nRectangle.java\n\npublic void resetRect(Rectangle rect) {\n  rect.setWidth(0);\n  rect.setHeight(0);\n}\n\n###\n\n", "completion": "Question: Each of the methods below can be found in the Student class. Which of the following methods would have access to the parameter object\u2019s private data and methods?\nCorrect: public void copy(Student other)\nIncorrect: public void copy(Person other)\nIncorrect: public void setId(Integer newId)\nIncorrect: public void setName(String newName)END"}, {"prompt": "Recall that an object is an instance of a class. The class is like the blueprint from which instances can be built. Each instance can have its own state and behavior. An object\u2019s state is stored in instance variables, and its behavior is carried out with instance methods. These are called instance variables and instance methods because they belong to a single instance of the class. But what if you wanted to keep track of a single variable or have a shared behavior across all the members of a class? Because each object has its own instance variables and methods, these won\u2019t work to store information for the entire class.\n\nSometimes it is useful to store information that is shared across all the objects of an entire class. A class variable (also referred to as a static variable) is a variable or attribute of a class that is common to all instances of a class. A class method (or static method) is a method of a class that is common to all instances of a class and is not called on any specific object instance.\n\nA new static variable defined by adding the keyword static to the variable declaration. Static variables can be either public or private.\n\nLikewise, static methods also use the keyword static. Classes can have both instance variables and static variables, but static methods can only update static variables. As a result, static methods cannot use the this reference and are unable to use non-static variables or methods.\n\nA method to return the total number of birds of the Bird class may look like:\n\nprivate static int getTotalBirds()\n{\n  return totalBirds;\n}\n\nFor example, if you run your own indoor skate park, you may want to keep track of the skaters at the park. In order to use the park, a new skater would sign up and a new instance of the Skater class would be created. What information would be useful to track about each skater? You may want to know a skater\u2019s name, age, experience level, and a history of times he or she arrived at and left the park. These are all unique to each skater and could be stored as instance variables.\n\nIt would also be useful to know how many skaters have ever skated at the park. This is a useful stat to know, but it is affected by all the skaters, not just one. Because this information is shared across the whole class, it can be stored in a class variable. The Skater class could be defined to include these:\n\npublic class Skater\n{\n  private static int totalSkaters = 0;\n\n  public Skater()\n  {\n    totalSkaters++;\n  }\n\n  public static int getTotalSkaters()\n  {\n    return totalSkaters;\n  }\n}\n\nWhenever a new skater is added, the static variable totalSkaters is increased. The totalSkaters variable is shared across all instances of the Skater class. Each object in the class has the same value for this variable, and you can get the value of this variable with the static getTotalSkaters method.\n\nBecause static methods and variables are available across an entire class, they don\u2019t need to be called on a particular instance of the class. You do not need to create a new object just to call a class method.\n\nTo find out how many skaters have been to the skate park, you can write:\n\nSkater.getTotalSkaters();\n\nThis will call the getTotalSkaters() method on the Skater class without requiring an instance of the class to be created.\n\nIf a static variable were to be declared as public, you could also access it using the dot notation, such as:\n\nSkater.totalSkaters; // Only works if variable is public\n\n###\n\n", "completion": "Question: Static methods can access\nCorrect: Only other static instance variables and class methods\nIncorrect: Any class method, but not the instance variables\nIncorrect: All instance variables and class methods\nIncorrect: Only private instance variables and private class methodsEND"}, {"prompt": "Think back to some of the examples where you had variables in methods. Some of these variables had the same name as other variables in your program, but they didn\u2019t have the same values. How can that be? Each variable has a specific scope and access level where that variable is defined. Outside that scope, a different variable can be defined with the same name. In this section, you will look at how variable scope is determined.\n\nWhen declaring a variable inside the body a constructor or a method, you create a local variable for that method. What does this mean? By local variable, it means that the variable is only defined for that specific constructor or method. These variables may only be used within the constructor or method and cannot be declared to be public or private.\n\nLikewise, another variable with the same name can be used outside the constructor or method and it will be considered a different variable.\n\npublic void addFive() {\n  int num = 10; // num is only defined inside the addFive method\n  int result = num + 5;\n  System.out.println(result); // prints 15\n}\n\npublic void addTen() {\n  int num = 20; // This is a different num variable that needs to be declared\n  int result = num + 10;\n  System.out.println(result); // prints 30\n}\n\nSometimes you will see a local variable inside a method or constructor sharing the same name as an instance variable. When this happens, the variable name in the method by default will refer to the local variable instead of the instance variable.\n\npublic class MyClass {\n  private int myNum = 10;\n\n  public void addFive() {\n    int myNum = 7;\n    // Will print 12 since the local myNum is used instead\n    // of the instance variable.\n    System.out.println(myNum + 5); \n  }\n}\n\nWhen variables are declared as formal parameters, they act the same as a variable that has been declared inside a constructor or method. That means that they are only available inside the constructor or method where they are declared and that they will take precedence over any instance variables that have the same name.\n\npublic class Name {\n  private String name = \"Karel\";\n\n  public Name(String name) {\n    // Will print the value passed in, not the value of the instance variable\n    System.out.println(name); \n  }\n}\n\nMethod decomposition is the process of breaking down large problems into smaller sub-problems by creating methods to solve the individual sub-problems.\n\nFor example, if you want to create a program that asks users a random trivia question and informs them if they got the answer correct, you could break the problem into several parts:\n\n- Build a Trivia class.\n- Create Program that uses Trivia class.\n\nYou can then break each of these problems into several parts. For example, the program that uses the trivia class might break into the following parts:\n\n1. Create a Trivia Object\n2. Ask User a random trivia question\n3. Allow User to Respond\n4. Check if Response Matches Answer\n5. Provide User with a Reply\n\nBy breaking the problem down into smaller parts, you create sub-problems that are easy to solve and combined together, they can solve a much more complicated problem.\n\n###\n\n", "completion": "Question: What would be printed the first time printGreeting was called from main?\n\npublic class Greeting\n{\n    private static String greet = \"Hi there!\";\n\n    public static void printGreeting()\n    {\n        String phrase = \"Hello!\";\n        System.out.println(phrase);\n        phrase = \"Hola!\";\n    }\n}\nCorrect: Hello!\nIncorrect: Hi there!\nIncorrect: Hola!\nIncorrect: Hi There!Hello!END"}, {"prompt": "As discussed in the previous section, when you use a variable in a method or constructor that shares the same name as an instance variable, by default, the local variable in the method or constructor is used. What if you want to refer to the instance variable?\n\nIt can often be confusing to know whether a variable in a constructor is referring to an instance variable or a variable that was passed in as an argument to the constructor. One way around this is to use different variable names for the instance variables and parameters, however using different names can get a little confusing.\n\nFortunately, Java has a way of specifying when you are referring to the object itself: this.\n\nthis refers to the current object. The this keyword allows you to be very clear whether you are referring to the object\u2019s instance variable or a parameter:\n\npublic class BMX\n{\n  private String frameSize;\n  private int numPegs;\n\n  public BMX(String frameSize, int numPegs)\n  {\n    this.frameSize = frameSize;\n    this.numPegs = numPegs;\n  }\n}\n\nNotice in the above example how you can use the same variable name. When the variable name is preceded by this., the variable is referring to the instance variable, otherwise it refers to the local variable.\n\nAs noted above, the this keyword is used to represent the current object. With that in mind, you can use this to represent the current object as needed.\n\npublic class Rectangle {\n  public int getArea(Rectangle rect) {\n    return rect.getWidth() * rect.getHeight();\n  }\n\n  public boolean hasGreaterArea(Rectangle otherRect)\n  {\n    return getArea(this) > getArea(otherRect);\n  }\n}\n\nNotice in the example above how the getArea method is called using this as an actual parameter for input into the getArea method.\n\n###\n\n", "completion": "Question: Which of the following correctly uses the this keyword?\nCorrect: public boolean isEqual(Student other)\n{\n    return this.name.equals(other.name);\n}\nIncorrect: public boolean isEqual(Student other)\n{\n    return name.equals(this.other.name);\n}\nIncorrect: public boolean isEqual(Student other)\n{\n    return name.equals(this.name);\n}\nIncorrect: public boolean isEqual(Student other)\n{\n    return name.this.equals(other.name);\n}END"}, {"prompt": "In this lesson, you will look at the professional computing code of ethics, system reliability, legal issues and intellectual property concerns, and bias in computing.\n\nThis is a time of rapid advancements in technology and automation. Software and hardware engineers increasingly have significant impacts on everyday lives with the tools and applications that they create. You see software and hardware solutions in nearly every aspect of your lives, such as the cars you drive, your bank accounts, the electrical grid, and nearly all communication such as email, text, and phone calls. If these systems fail, your lives would be greatly impacted.\n\nPart of understanding the impact of these tools and applications is understanding system reliability. System reliability is when all programs and code will work as intended. Its challenging to ensure system reliability when there are many inputs, parameters and outputs in any given programming application. System reliability is limited and programmers should make an effort to maximize system reliability. Software and hardware engineers need to be aware of the legal, social and ethical implications of the hardware and programmatic systems that they create.\n\nWhile programs are designed to achieve a specific purpose, they may have unintended consequences. Computing systems have affected humans, society, economy, and culture in many ways, both positively and negatively.\n\nOne substantial impact of computing systems is the access to information. There are several open databases of scientific publications on the internet, some of which are free and some are subscription based. This allows scientific papers to be read by anyone, not just a graduate student at a research institution. Now anyone can read these cutting edge scientific publications.\n\nBut there\u2019s a big question as to whether access to all information is actually a good thing. For example, there\u2019s a website called Wikileaks that posts classified information that either governments or corporations are trying to keep secret. On one hand this is a good thing because it promotes the transparency of information. It makes it so corporations and the governments can\u2019t keep secrets from its citizens. However, there\u2019s potential danger in having classified secrets being public. For example, our military or national security could be at risk if someone posts our government secrets to the world.\n\nLegal issues and intellectual property concerns arise when creating programs. As programmers, you have a responsibility to make sure that our programs are socially, legally, and ethically acceptable.\n\nComputer science follows the following ACMs or Association for Computing Machinery professional code of ethics. ACM has professional principles as well, but they are beyond the scope of this course. According to the ACM, a computing professional should:\n\n- Contribute to society and to human well-being, acknowledging that all people are stakeholders in computing.\n- Avoid harm.\n- Be honest and trustworthy.\n- Be fair and take action not to discriminate.\n- Respect the work required to produce new ideas, inventions, creative works, and computing artifacts.\n- Respect privacy.\n- Honor confidentiality.\n\nRemember that knowledge is power as everyone lives together in our digital world. Use your knowledge of computing for good purposes so you and everyone else can be safe and enjoy the benefits of computing.\n\n###\n\n", "completion": "Question: A computing system that is biased is likely to\nCorrect: give preferential treatment to some users\nIncorrect: be created by a small company\nIncorrect: treat all users the same\nIncorrect: operate slowerEND"}, {"prompt": "An array is a list of data. Arrays can store many different types of information. For example, if you had a shopping list, you could store the shopping list as an array.\n\nThe information stored in an array is kept in order. The items in an array are often referred to as members or elements of the array. What makes arrays unique is that they store a fixed number of elements. Once an array is created, the size of the array cannot be changed.\n\nIt is important to note that in computer science, we usually start counting from 0. So the first item in the array is actually at index position 0, the second item in the array is at index position 1, and so on.\n\nLet\u2019s say our grocery list contained these items, in this order: apples, dog food, donuts, celery, and orange juice. If we were to draw out the array, it would look something like this:\n\nindex position:\t0\t1\t  2\t\t3\t4\nlist item:\t\tapples\tdog food  donuts\tcelery\torange juice\n\nWe can see that dog food is at index 1 and celery is at index 3.\n\nTo create an array in Java, you must first know what type of data you want to store and how many elements the array will hold. In the grocery list example above, we created an array of Strings, but it\u2019s just as easy to create arrays of integers or any other data type. Arrays can store both primitive and object data types.\n\nThe format for creating an array is:\n\ntype[] arrayName = new type[numberOfElements];\n\nLet\u2019s take apart the array declaration:\n\n- type[]: This tells us what type of data is being stored in the array. For example, a list of integers would be int[]. The brackets [] indicate that this is an array and not a single int.\n- arrayName: The name by which the array will be known. It\u2019s best to pick a descriptive name, like groceryList instead of just things.\n- new: The new keyword indicates that a new array is being created.\n- type[numberOfElements]: The type of elements is mentioned again, as well as the number of items the array will store. For example, if an array int[6] were created, the array would store six int values. Once an array has been created, the number of items that can be stored in the array cannot change. This array will always store 6 items - no more, no less!\n\nFor example, if you wanted to create an array that contained 6 integers, the initialization of the array would look like this:\n\n// Create an empty array that will store 6 integers\nint[] newNumberList = new int[6];\n\nWhen an array is initially created, each index in the array is set to a default value. Java assigns a specific value for each item in the array depending on the type. int and doubles default to zero, booleans default to false, and objects (including strings) default to null.\n\nType\tDefault Value\nint\t0\ndouble\t0.0\nboolean false\nObjects null\n\nArrays can also be created and initialized with specific values. To do so, simply include the elements that will be stored in the array between curly braces in the initialization. Here\u2019s a list of 6 numbers:\n\nint[] numberList = {10,20,30,40,50,60};\n\nElements in an array can be accessed using the index position of the array. Let\u2019s create a new empty array of numbers, then add in two numbers:\n\n// Create an empty array that will store 6 integers\nint[] newNumberList = new int[6];\n\n// Add the number 11 to index position 0\nnewNumberList[0] = 11;\n\n// Add the number 13 to index position 1\nnewNumberList[1] = 13;\n\nThe array now contains two integers:\n\nIndex Position:\t0\t1\t2\t3\t4\t5\nArray Item:\t\t11\t13\t0\t0\t0\t0\n\nNotice that the rest of the indices in the array are set to the default value 0. The [] syntax can also be used to change elements in a list. Let\u2019s change 13 to 21:\n\nnewNumberList[1] = 21;\n\nIndex Position:\t0\t1\t2\t3\t4\t5\nArray Item:\t\t11\t21\t0\t0\t0\t0\n\nAccessing an element in a list uses a similar syntax. We can get and store the number at index 0 into a variable:\n\n// This variable will contain the number 11\nint firstNumber = newNumberList[0];\n\n// Two ways to print out the number 11 to the console\nSystem.out.println(firstNumber);\nSystem.out.println(newNumberList[0]);\n\n// Now print out the number at index position 1 to the console\nSystem.out.println(newNumberList[1]);\n\nThe output from the code will be:\n\n11\n11\n21\n\nAccessing a value in an array that\u2019s outside the current index value list will result in an ArrayIndexOutOfBoundsException. For example, a new double array is created with 5 values:\n\ndouble[] example = new double[5];\n\nBecause there are only five values in this array, attempting to access an index greater than or equal to five will throw an error:\n\ndouble value = example[6];   //This results in an ArrayIndexOutOfBoundsException\n\nThis program would throw an ArrayIndexOutOfBoundsException, as index six is unavailable in this particular array. If you see this error in a program, it most likely means that you\u2019re accessing an array incorrectly!\n\n###\n\n", "completion": "Question: How do you initialize an array called arr of 10 double with default values?\nCorrect: double[] arr = new double[10];\nIncorrect: double[] arr = new double[11];\nIncorrect: double arr = new double[10];\nIncorrect: double arr = new double;END"}, {"prompt": "Arrays are utilized for many operations in various programs. Since arrays store data in order, you can iterate through them to access this data. Let\u2019s say you are creating an online store that sells oranges. You would want to store the customer orders in an array so you can honor the first orders before the orders that come later.\n\nLet\u2019s say you have an array that stores the order data from your market. Here is the array:\n\nIndex:\t\t0\t\t1\t\t2\t\t3\t\t4\t\t5\nOrders:\t10 Oranges\t3 Oranges\t6 Oranges\t4 Oranges\t5 Oranges\t1 Orange\nIn Java the array will look like this:\n\nint[] orangeOrders = {10, 3, 6, 4, 5, 1};\n\nIndividual elements can be accessed by using the [] notation:\n\nint orderOne = orangeOrders[0];  //returns 10 to orderOne\n\nSince this list of orders is fairly small, it\u2019s easy to access the individual orders that are being made, but oftentimes, arrays can have hundreds, thousands, or even millions of values. How is it possible to access all values when it\u2019s not clear where a specific value might be stored? There needs to be a systematic way to access all of these values! Luckily, iteration, or traversing, an array can provide a simple solution.\n\nIn order to iterate through the items in an array, it\u2019s absolutely necessary to know how many elements there are in the array - otherwise, how would you know how many elements you need to search through?\n\nFinding the size of an array is done by using the keyword .length. .length returns the current size of an array. An array with six values is considered an array of length 6. The length of an array corresponds to the number of elements in an array, not the last index value in an array.\n\nIf you recall, arrays start at index 0 - an array with six elements will start at 0 and end at index 5:\n\nIndex:\t\t0\t\t1\t\t2\t\t3\t\t4\t\t5\nOrders:\t10 Oranges\t3 Oranges\t6 Oranges\t4 Oranges\t5 Oranges\t1 Orange\n\nIterating over an array requires the use of a for or while loop:\n\nfor(int i = 0; i < orangeOrders.length; i++)\n{\n   // This prints out the ith element!\n   System.out.println(orangeOrders[i]);\n}\n\nThis for loop iterates through every value in the orangeOrders list, and prints out the value at every index.\n\nNotice that the for loop starts at the first element (zero) and ends at the last element (array.length - 1). The for loop is set to i < orangeOrders.length, so that the greatest value of i will always be one less than the length of the array. Therefore, the last index in an array will always be array.length - 1.\n\nEach time through the loop, the value of i accesses the element at index i. This simple for loop is able to loop through the array, regardless of how many items there are in the array.\n\nThis traversal can also be written using a while loop:\n\nint index = 0;\nwhile(index < orangeOrders.length)\n{\n   System.out.println(orangeOrders[index]);\n   index++;\n}\n\nNotice that the variable index is outside of the while loop. This ensures that the variable index isn\u2019t reset to 0 every time the while loop starts a new iteration. The value of index is increased by one at the end of the while loop, ensuring that the next index in the array will be accessed.\n\nWhen developing iterative programs for use with arrays, it\u2019s important to pay attention to which values are being set as the starting and ending indices. A common mistake programmers make is setting the ending index to the length of the array, not the last index value:\n\nint index = 0;\nwhile (index <=orangeOrders.length)\n{\n   System.out. println(orangeOrders[index]);\n   index++;\n}\n\nIn this example, the final value of index will be 6, even though the last index in orangeOrders is 5. As a result, this program will lead to an ArrayIndexOutOfBoundsError. This type of error is referred to as an \u201coff by one\u201d error, as the program iterates one too many times over the array.\n\n###\n\n", "completion": "Question: What is the output after this code snippet runs?\n\ndouble[] prices = {3.45, 1.00, 2.25, 5.22, 4.50};\n\nfor (int i = 0; i < prices.length; i += 2)\n{\n       System.out.println(scores[i] = prices[i]  -  1);\n}\nCorrect: 2.45\n1.25\n3.50\nIncorrect: 2.45\n1.25\nIncorrect: 2.45\n0.00\n1.25\n4.22\n3.50\nIncorrect: 3.45\n2.25\n4.50END"}, {"prompt": "In both the for and while loop array traversals, a counter was used to determine the correct index at which an array element could be found:\n\n//for loop\nfor(int i = 0; i < array.length; i++){\n   // Do something\n}  \n\n//while loop\nint counter = 0;\nwhile(counter < array.length) { \n   // Do something\n   counter++;\n} \n\nArrays can also be traversed without the use of counters by using an enhanced for loop.\n\nEnhanced for loops are an alternate method of traversing an array:\n\nint[] numList = {5,6,7,4,2};\nfor(int number: numList)\n{\n   System.out. println(number);\n}\n\nInstead of initializing a variable for looping, the enhanced for loop header initializes a new variable, number known as the enhanced for loop variable. The type of this variable needs to match the value type of the array. In this example, since numList is an array of integers, number also needs to be an integer.\n\nAfter the enhanced for loop variable is defined, the header is completed by placing a colon and the name of the array being iterated on (numList).\n\nInside the loop, the enhanced for loop variable is assigned a copy of each value of the array without using the array index. On each iteration, the value of number changes to match an element in the array. The first value of number in this loop is 5. The second value will be 6, as it is the next item in the array. The enhanced for loop iterates in the order that the elements are found in the array, from first to last. Making changes to the enhanced for loop variable does not change the original value in the array.\n\nStandard for loops can be rewritten as enhanced for loops, and vice versa:\n\nString[] classroom = {\"julian\", \"larisa\", \"amada\", \"mikka\", \"jay\"};\n\n//Enhanced For Loop:\nfor(String student : classroom)\n{\n   System.out.println(student);\n}\n\n\n//Standard For Loop:\nfor(int i = 0; i < classroom.length; i ++)\n{\n    System.out.println(classroom[i]);\n}\n\nBoth standard and enhanced for loops are useful in different contexts. For example, since enhanced for loops make a copy of each element value, they are incapable of changing the value of the elements in an array. If elements need to be altered, standard for loops are more appropriate. In contrast, if elements just need to be accessed, enhanced for loops provide a more streamlined way to access elements without the need for a counter, or a potential ArrayIndexOutOfBounds error.\n\n###\n\n", "completion": "Question: What is the output of the following code snippet?\n\nint[] temperatures = {80, 92, 91, 68, 88};\n\nfor(int temperature : temperatures)\n{\n    System.out.println(temperature);\n}\nCorrect: 80\n92\n91\n68\n88\nIncorrect: 80 92 91 68 88\nIncorrect: ArrayIndexOutOfBounds exception will be thrown\nIncorrect: temperatureEND"}, {"prompt": "Programmers use data structures to store data. Data is often stored so that it can be used or analyzed at some point in the future. Array traversals have several important applications in regards to how data is used and analyzed. They can be used in:\n\nMathematical Analysis\n- Determine a minimum or maximum value\n- Compute a sum, average, or mode\n\nAnalyzing Element Properties\n- Determine if at least one element has a particular property\n- Determine if all elements have a particular property\n- Access all consecutive pairs of elements\n- Determine the presence or absence of duplicate elements\n- Determine the number of elements meeting specific criteria\n\nReordering Elements\n- Shift or rotate elements left or right\n- Reverse the order of the elements\n\nEach of these subsets uses a distinct algorithm to analyze arrays.\n\nComputing mathematical results, such as the sum of integers in an array or finding the average of each value in an array requires the use of a similar algorithm:\n\nint[] scores = {80, 92, 91, 68, 88};\n\n//Initialize value here\nint valueToFind = 0;\n\nfor (int i = 0; i < scores.length; i++){\n   //Perform calculation on valueToFind\n}\n\n//Report results of valueToFind\n\nIn each case, the algorithm requires the initialization of a value that will be used to store the result of a given computation outside of the for loop. Inside the loop, the initialized value, valueToFind, will be altered depending on the desired output, and the results will be displayed after the loop has terminated.\n\nFor a better understanding of this, consider this implementation of computing a sum:\n\nint[] scores = {80, 92, 91, 68, 88};\nint sum = 0;\nfor (int i = 0; i < scores.length; i++){\n   sum += scores[i];\n}\nSystem.out.println(sum);\n\nThe value of sum is changed each iteration through the for loop, adding the current score to the value of sum. This algorithm looks awfully similar to the one used to find the average value of an array:\n\nint[] scores = {80, 92, 91, 68, 88};\nint sum = 0;\nfor (int i = 0; i < scores.length; i++){\n   sum += scores[i];\n}\nSystem.out.println((double) sum / scores.length);\n\nIn both cases, the initialized value is declared before the for loop, used in mathematical computations within, and then displayed after its termination.\n\nTo determine if an element or a set of elements in an array meets specific criteria or has a specific set of properties, the following general algorithm can be used:\n\nString[] grades = {\"A\",\"C\",\"B\",\"A\",\"B\"};\n\n//Initialize tracker variable\nfor (int i = 0; i < grades.length; i++){\n   //Conditionally check properties\n}\n\n//Report results here\n\nSimilar to mathematical analysis, property analysis sets an initial tracker variable before the start of the for loop, and checks through each iteration if the element at a specific index meets the criteria. It then reports the findings after the loop has terminated.\n\nIn the following example, the tracker variable checks how many A\u2019s there are in the grade array:\n\nString[] grades = {\"A\",\"C\",\"B\",\"A\",\"B\"};\n\n//Initialize tracker variable\nint numAs = 0;\n\nfor (int i = 0; i < grades.length; i++){\n//Conditionally check properties\n   if (grades[i].equals(\"A\")){\n      numAs++;\n   }\n}\n\nSystem.out.print(\"Number of A's: \");\nSystem.out.println(numAs);\n\nIn this case, the value of the tracker variable numAs increments if the element at each index is an A. These tracker variables can also be used to store a single value that changes depending on the condition. For example, finding the minimum value of a list looks similar to the previous example, but only stores a single value:\n\nint[] scores = {80, 92, 91, 68, 88};\n\nint minIndex = 0;\n\nfor (int i = 1; i < scores.length; i++){\n   if (scores[i] < scores[minIndex]){\n      minIndex= i;\n   }\n}\nSystem.out.println(minIndex);\n\nRather than increment, this tracker keeps track of the current minimum value in the list. If the value at the current index is less than the existing minimum, then the tracker is changed to reflect that.\n\nAnother common array algorithm involves reordering or reversing our arrays. While this can be done in a few different ways, a common method is to create a new temporary array where a copy of the new order for values is stored. Once the new order is copied into the temporary array, it overwrites the original array with the temporary one:\n\nint[] numbers = {1, 2, 3, 4, 5};\nint[] temp = new int[numbers.length]; //Create default array\n\n//Loop, but stop at the last element (edge case)\nfor (int i = 0; i < numbers.length - 1; i++){\n    temp[i + 1] = numbers[i]; \n}\ntemp[0] = numbers[numbers.length - 1]; //Edge case\nnumbers = temp; //Copy over to the original array\n\nIn this example, the algorithm is shifting the values in the array to the right by one. Rather than move the values in the existing array, a new array is created to store the values in the specified order. This removes the possibility that the original array gets altered accidentally, and that changes to the new array do not impact the original.\n\n###\n\n", "completion": "Question: What will the following code segment output?\n\nString[] grades = {\"A\",\"C\",\"B\",\"C\",\"B\", \"A\"};\n\nint mystery = 0;\n\nfor (int i = 0; i < grades.length; i++)\n{\n    if (grades[i].equals(\"B\")) \n    {\n        mystery ++;\n    }\n}\n\nSystem.out.println(mystery);\nCorrect: 2\nIncorrect: 0\nIncorrect: 1\nIncorrect: 3END"}, {"prompt": "In the last unit, you learned how to store data more efficiently using arrays. Arrays are able to store a list of values of the same type in one variable, making it easier to store and keep track of data that you need for your programs. One of the limitations of using arrays to store data is the fact that they have a fixed number of items that can be added or changed. Elements can only be added to an array by creating a new array of a different size and copying the data from the initial array to the new one:\n\nint[] setSize = new int[5];\nint[] newSize = new int[6];\nsetSize = newSize;\n\nThis process is tedious, and requires a high degree of difficulty, especially if the list being used is going to change in size often. A more convenient way to create adjustable arrays is by using the ArrayList class.\n\nArrayLists are similar to arrays, except that they are a mutable list of object references, meaning that the size of the list can be adjusted freely. Creating an ArrayList is as simple as initializing a new ArrayList in a program:\n\nimport java.util.ArrayList;\n\npublic static void main(String[] args)\n{\n  ArrayList<E> list = new ArrayList<E>();\n}\n\nIn order to use the ArrayList class, the ArrayList class needs to be imported from the java util package. This can be done by writing import java.util.ArrayList at the top of the class file.\n\nArrayList objects are created in the same fashion as other object classes. The primary difference with ArrayLists is that the element type of the ArrayList must be specified using angled bracket <>. In this example, E represents the data type that will be used in the ArrayList. This can be replaced by an object data type:\n\nArrayList<String> list = new ArrayList<String>();\n\nThe declaration type for an ArrayList must match the initialization type. In this case, both types reference the String data type.\n\nWhen this line of code is executed, the ArrayList list will store an empty ArrayList with no index values. Unlike arrays, the number of items that will be stored in an ArrayList does not need to be specified. Values can be added to the ArrayList after the ArrayList is initialized. This will be explored more in the next chapter.\n\nArrayLists can actually be declared without specifying the type that will be included in the ArrayList:\n\nArrayList list = new ArrayList();\n\nWhile this appears to be a simpler initialization process, specifying the data type is highly recommended because it allows the compiler to find errors before run time. This makes it easier to find errors, and program more efficiently, as the program will indicate if there is an issue before any code is run.\n\nWhile arrays and ArrayLists are fairly similar data structures, the key differences between them lie in their creation, mutability, and the types of data that they can store.\n\nArrays are a fixed size, whereas ArrayLists can contract and expand. ArrayLists are only able to store objects, whereas arrays can store both primitive and object values. Foruntuantley, autoboxing and unboxing allows you to send many primitive variables into an ArrayList, but the ArrayList still needs to be set up using the object type.\n\nWhen choosing to use a data structure, it\u2019s important to know if the data being stored should be a fixed, or unfixed size in length. Which data structure you choose will depend on how frequently that data needs to be updated or accessed.\n\n###\n\n", "completion": "Question: How do you create an ArrayList of integers?\nCorrect: ArrayList<Integer> list = new ArrayList<Integer>();\nIncorrect: int[] list = new int[];\nIncorrect: ArrayList<int> list = new ArrayList<int>();\nIncorrect: ArratList(int) list = new ArrayList(int);END"}, {"prompt": "ArrayLists provide flexibility and functionality that arrays do not. You can think of an ArrayList as a container that will resize as you add and remove objects from it. In order to do so, there are several helper methods that are used to alter the state of an ArrayList, and get information about its content.\n\nObjects can be added to an ArrayList using the add method. The add method has several method signatures:\n\nboolean add(E obj)\nvoid add(int index, E obj)\n\nThe single parameter add method will add an element to the end of the ArrayList:\n\nimport java.util.ArrayList;\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\n\nSince the ArrayList starts with no values, the call to add will add the element 5 to the 0th index of the ArrayList. If the call list.add(8) were added to this code segment, the element 8 would be added to the 1st index position. Like arrays, ArrayLists begin at index 0. The add method returns true if the element was successfully added to the ArrayList.\n\nThe second add method signature will add an element at a specified index:\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\nlist.add(1, 4);  //Adds the value 4 at index 1.\n\nThe specified index must be between the value 0, and the current size of the ArrayList. To determine the size of the ArrayList, the method size can be used to return the current length of an ArrayList:\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\nSystem.out.println(list.size()); //returns 1\nlist.add(1, 4);\nSystem.out.println(list.size()); //returns 2\n\nNotice that the size of the ArrayList increases when a new value is added to the list. When add(int index, E obj) is called, the list items from index - size() shift up one index to allow the new value to slot in to the correct index position.\n\nElements in an ArrayList can be accessed using the get(int index) method:\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\nlist.add(3);\nlist.add(10);\nlist.add(4);\n\nint val = list.get(1);\nSystem.out.println(val); //prints the value 3\n\nThe method get returns an element at the specified index. In this case, the value stores at index 1 (3), is being stored in the variable val, and printed to the console.\n\nIndividual elements in an ArrayList can be changed using the set(int index, E obj) method:\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\nlist.add(3);\nlist.add(10);\nlist.add(4);\n\nint val = list.get(2);\nSystem.out.println(val); //prints the value 10\n\n//change the value at index 2\nlist.set(2, 34);\nval = list.get(2);\nSystem.out.println(val); //prints the value 34\n\nIn this example, the value at index 2 is changed from the value 10 to the value 34. It\u2019s important to note that the values can only be changed to another value of the same data type.\n\nThe set method also returns the value that is being replaced to the existing program. The value that has been replaced can then be stored in a variable of its own:\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\nlist.add(3);\nlist.add(10);\nlist.add(4);\n\nint val = list.set(2, 34);\nSystem.out.println(val); //prints the value 10\n\nint newVal = list.get(2);\nSystem.out.println(newVal); //prints the value 34\n\nJust as elements can be added, they can be removed from an ArrayList using the remove(int index) method. Like the set method, the remove method also returns the value that is being removed from the specified index.\n\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(5);\nlist.add(3);\nlist.add(10);\nlist.add(4);\nSystem.out.println(list.size()); // prints the value 4\n\nint val = list.remove(0);\nSystem.out.println(val); //prints the value 5\n\nSystem.out.println(list.size()); // prints the value 3\n\nIn the program above, notice that the size of the ArrayList decreases by one when the element is removed from the ArrayList. All values at the index higher will move down one index once an element is removed from an ArrayList.\n\nMany of the methods used to access and manipulate ArrayLists are functionally similar in nature to arrays:\n\nFeature\tArrays\t\t\t\tArrayLists\nInitialize\tint[] arr = new int[5];\tArrayList array = new ArrayList();\nGet Value\tarr[index]\t\t\tarray.get(index)\nGet Size\tarr.length\t\t\tarray.size()\nSet Value\tarr[index] = value;\t\tarray.set(index, value)\n\nWhen considering which data structure to use, it\u2019s important to determine early on if it\u2019s necessary to add or remove values at future points in the program. If that\u2019s the case, then ArrayLists may serve better.\n\n###\n\n", "completion": "Question: What value will be printed in the console after this series of commands? Assume that the ArrayList package has been imported.\n\nArrayList<Integer> array = new ArrayList<Integer>();\narray.add(1);\narray.add(9);\narray.add(10);\narray.remove(1);\narray.add(1);\narray.set(0, 3);\nint num = array.get(1);\nSystem.out.println(num);\nCorrect: 10\nIncorrect: 9\nIncorrect: 3\nIncorrect: 1END"}, {"prompt": "As covered in Unit 6, traversing is the process of moving through all the items in an array or data structure. Loops can be used to traverse arrays by using the incremental variable to access each individual element in an array:\n\nint[] scores = {80, 92, 91, 68, 88};\nfor(int i = 0; i < scores.length; i++) \n{ \n    // This prints out the ith element! \n    System.out.println(scores[i]);\n}\n\nThe same process is applicable to traversing elements in an ArrayList:\n\nArrayList<Integer> scores = new ArrayList<Integer>();\n\nfor(int i = 0; i < scores.size(); i++)\n{\n    // This prints out the ith element!\n    System.out.println(scores.get(i));\n}\n\nThe primary difference between array and ArrayList traversal lies in the methods used to access each element. For ArrayLists, size is used to determine the number of iterations of the increment variable, and get is used to access the element at a given index. This same difference applies to ArrayList while loop traversals and enhanced for loops:\n\n// while loop traversal\nint i = 0;\nwhile(i < scores.size())\n{\n    System.out.println(scores.get(i));\n    i++;\n}\n\n// Enhanced for loop traversal\nfor(int score: scores)\n{\n    System.out.println(score);\n}\n\nBecause ArrayLists can change size, it\u2019s necessary to take caution when traversing them, as the changing size of the ArrayList can affect which elements are being accessed.\n\nConsider the following list, and associated method:\n\nlist\n\n0\t1\t2\t3\t4\n\u201cI\u201d\t\u201cam\u201d\t\u201cAndrew\u201d\t\u201cAardvark\u201d\t\u201cJr.\u201d\n//Removes all Strings from an ArrayList that begin with the letter 'A'\npublic void removeA(ArrayList<String> list)\n{\n  for(int i = 0; i < list.size(); i++)\n  {\n    if (list.get(i).startsWith(\"A\"))\n    {\n      list.remove(i);\n    }\n  }\n}\n\nThis method intends to remove each element in a list that starts with the letter A. The implementation of this however, has unintended consequences. When i = 2, the conditional if statement will remove the item at index 2 from the list. It then will return to the for loop header, and increment the value of i to i = 3.\n\nWhen remove is used on this list, each value in the list after index 2 shifts one space down in the ArrayList:\n\nlist\n\n0\t1\t2\t3\n\u201cI\u201d\t\u201cam\u201d\t\u201cAardvark\u201d\t\u201cJr.\u201d\nHowever, the value of i in the for loop header is now 3. When the conditional statement checks for a word that starts with \u201cA\u201d at index 3, there is none. The value \u201cAardvark\u201d unintentionally stays in the list, even though the method was designed to remove all instances of words that start with \u201cA\u201d.\n\nThe solution to this problem is adding a decrement after the list item is removed:\n\n//Removes all Strings from an ArrayList that begin with the letter 'A'\n\npublic void removeA(ArrayList<String> list)\n{\n  for(int i = 0; i < list.size(); i++)\n  {\n    if (list.get(i).startsWith(\"A\"))\n    {\n       list.remove(i);\n       i --; //decrease the value of i by one!\n    }\n  }\n}\n\nNow when the list item is removed at index 2, the value of i is decreased to 1. When the for loop iterates again, the value of i will increase from 1 to 2 again, allowing the program to check the new value at index 2 after the elements shift position.\n\nWhen using these traversal methods, there are several common Exceptions that may occur if the traversal is implemented incorrectly:\n\n1. IndexOutOfBounds Exception:\n\nWhen iterating through an ArrayList, it\u2019s common that the iteration includes an index that is outside of the current index range. For example, if the for loop conditional statement occurs from i = 0 to i <= list.size(), then the iteration will include one extra iteration that searches for an index at position list.get(list.size()), even though ArrayList indices only range from 0 - list.size() - 1. Accessing an index that is not within the range of the existing ArrayList will result in an IndexOutOfBounds Exception, commonly known as an \u201coff by one\u201d error.\n\n2. ConcurrentModification Exception\n\nThis exception occurs when attempting to remove an item from an ArrayList during an enhanced for loop. This error occurs when objects are being modified while they are being iterated on, which is what happens when enhanced loops are used on ArrayLists. Generally speaking, removing and adding items from an ArrayList should not be done while using enhanced for loops.\n\n###\n\n", "completion": "Question: What is the standard method used to traverse an ArrayLists?\nCorrect: for(int index = 0; index < array.size(); index++)\n{\n     array.get(index);\n}\nIncorrect: for(int index = array.size(); index < 0; index++)\n{\n     array.get(index);\n}\nIncorrect: for(int index = 0; index <= array.length(); index++)\n{\n     array[index];\n}\nIncorrect: for(int index = 0; index <= array.size(); index++)\n{\n     array.get(index);\n}END"}, {"prompt": "Just as arrays have standard algorithms that can be applied in different situations, ArrayLists too, have standard algorithms.\n\nIn the last chapter, you learned of one such standard algorithm - the ability to remove an item from an ArrayList. While the example in the last chapter removed all elements from an ArrayList that started with the letter A, this algorithm can be repurposed for use with any condition:\n\npublic void removeElem(ArrayList<Type> list, E element)\n{\n    for(int i = 0; i < list.size(); i++)\n    {\n        if (list.get(i).equals(element))\n        {\n            list.remove(i);\n            i--;\n        }\n    }\n}\n\nIn this example, the variable element represents the property or value that is meant to be removed from the ArrayList. Remember that i-- must be included to ensure that all elements in the ArrayList are being evaluated.\n\nJust as elements can be removed from an ArrayList, they can also be added using a standard algorithm:\n\npublic void addElem(ArrayList<Type> list, E element)\n{\n    for(int index = 0; index < list.size(); index++)\n    {\n        if() //Condition for adding element\n        {\n            list.add(index, element);\n            index++;\n        }\n    }\n}\n\nNotice in this case, that index is incremented when a new element is added to the list. Including this increment largely depends on the condition that is being set to add new elements to the ArrayList. For example, if a programmer were to add odd integers to an ArrayList of even integers {2,4,6,8} in the index position of the existing element, then the increment would be necessary to avoid an infinite loop.\n\nArrayList traversals have several important applications in regards to how data is used and analyzed.\n\nThese various applications generally belong to a larger subset of applications:\n\nMathematical Analysis\n- Determine a minimum or maximum value\n- Compute a sum, average, or mode\n\nAnalyzing Element Properties\n- Determine if at least one element has a particular property\n- Determine if all elements have a particular property\n- Access all consecutive pairs of elements\n- Determine the presence or absence of duplicate elements\n- Determine the number of elements meeting specific criteria\nReordering Elements\n- Shift or rotate elements left or right\n- Reverse the order of the elements\n\nEach of these subsets uses a distinct algorithm to analyze arrays.\n\nComputing mathematical results, such as the sum of integers in an array or finding the average of each value in an array requires the use of a similar algorithm:\n\nArrayList<Integer> scores = new ArrayList<Integer>();\n//add values to scores\n\n//Initialize value here\nint valueToFind = 0;\nfor (int i = 0; i < scores.size(); i++){\n    //Perform calculation on valueToFind\n}\n//Report results of valueToFind\n\nIn each case, the algorithm requires the initialization of a value that will be used to store the result of a given computation outside of the for loop. Inside the loop, the initialized value, valueToFind, will be altered depending on the desired output, and the results will be displayed after the loop has terminated.\n\nFor a better understanding of this, consider this implementation of computing a sum:\n\nArrayList<Integer> scores = new ArrayList<Integer>();\n//add values to scores\n\nint sum = 0;\nfor (int i = 0; i < scores.size(); i++){\n    sum += scores.get(i);\n}\nSystem.out.println(sum);\n\nThe value of sum is changed each iteration through the for loop, adding the current score to the value of sum. This algorithm looks awfully similar to the one used to find the average value of an array:\n\nArrayList<Integer> scores = new ArrayList<Integer>();\n//add values to scores\n\nint sum = 0;\nfor (int i = 0; i < scores.size(); i++){\n    sum += scores.get(i);\n}\nSystem.out.println((double) sum / scores.size());\n\nIn both cases, the initialized value is declared before the for loop, used in mathematical computations within, and then displayed after its termination.\n\nTo determine if an element, or a set of elements in an ArrayList meets a specific criteria or has a specific set of properties, the following general algorithm can be used:\n\nArrayList<String> grades = new ArrayList<String>();\n//add values to grades\n\n//Initialize tracker variable\nfor (int i = 0; i < grades.size(); i++){\n    //Conditionally check properties\n}\n//Report results here\n\nSimilar to mathematical analysis, property analysis sets an initial tracker variable before the start of the for loop, and checks through each iteration if the element at a specific index meets the criteria. It then reports the findings after the loop has terminated.\n\nIn the following example, the tracker variable checks how many A\u2019s there are in the grade array:\n\nArrayList<String> grades = new ArrayList<String>();\n//add values to grades\n\n//Initialize tracker variable\nint numAs = 0;\n\nfor (int i = 0; i < grades.size(); i++){\n    //Conditionally check properties\n    if (grades.get(i).equals(\"A\")) {\n        numAs++;\n    }\n}\n\nSystem.out.print(\"Number of A's: \");\nSystem.out.println(numAs);\n\nIn this case, the value of the tracker variable numAs increments if the element at each index is an A. These tracker variables can also be used to store a single value that changes depending on the condition. For example, finding the minimum value of a list looks similar to the previous example, but only stores a single value:\n\nArrayList<Integer> scores = new ArrayList<Integer>();\n//add values to scores\n\nint minIndex = 0;\n\nfor (int i = 1; i < scores.size(); i++){\n    if (scores.get(i) < scores.get(minIndex) {\n        minIndex = i;\n    }\n}\nSystem.out.println(minIndex);\n\nRather than increment, this tracker keeps track of the current minimum value in the list. If the value at the current index is less than the existing minimum, then the tracker is changed to reflect that.\n\nAnother common ArrayList algorithm involves reordering or reversing our arrays. While this can be done in a few different ways, a common method is to create a new temporary array where a copy of the new order for values is stored. Once the new order is copied into the temporary array, it overwrites the original array with the temporary one:\n\nArrayList<Integer> numbers = new ArrayList<Integer>();\n//add values to scores\n\nArrayList<Integer> temp = new ArrayList<Integer>();\n//add values to scores\n\n//Edge case\ntemp.add(numbers.get(numbers.size() - 1));\n\n//Loop, but stop at the last element (edge case)\nfor (int i = 0; i < numbers.size() - 1; i++){\n    temp.add(i + 1, numbers.get(i));\n}\n\nnumbers = temp; //Copy over to the original ArrayList\n\nIn this example, the algorithm is shifting the values in the array to the right by one. Rather than move the values in the existing ArrayList, a new ArrayList is created to store the values in the specified order. This removes the possibility that the original ArrayList gets altered accidentally, and that changes to the new ArrayList do not impact the original. Note that the edge case is added before the for loop. This ensures that the ArrayList add method will work, as it can only add values to index values from 0 - size().\n\nSome algorithms require ArrayLists to be traversed simultaneously. One such example would be if you wanted to sum the indices of two ArrayLists:\n\n0\t1\t2\t3\t4\n5\t2\t4\t5\t0\nlist1\n+\n\n0\t1\t2\t3\t4\n3\t5\t6\t9\t12\nlist2\n=\n\n0\t1\t2\t3\t4\n8\t7\t10\t14\t12\nsummedList\n\nCreating the summedList requires that both list1 and list2 are traversed simultaneously to access and sum the individual values at each index:\n\nArrayList<Integer> summedList = new ArrayList<Integer>();\nfor(int index = 0; index < list1.size(); index++)\n{\n    int sum = list1.get(index) + list2.get(index);\n    summedList.add(sum);\n}\n\n###\n\n", "completion": "Question: Which of these method implementations would correctly insert an element into an ArrayList after every even index?\nCorrect: {\n   for(int index = 0; index < array.size(); index++)\n   {\n      if(index %2 == 0)\n      {\n         array.add(index + 1, element);\n         index++;\n      }\n   }\n}\nIncorrect: {\n   for(int index = 0; index < array.size(); index++)\n   {\n      if(index %2 == 0)\n      {\n         array.add(index, element);\n         index++;\n      }\n   }\n}\nIncorrect: {\n   for(int index = 0; index < array.size(); index++)\n   {\n      if(index %2 == 0)\n      {\n         array.add(index + 1, element);\n      }\n   }\n}\nIncorrect: {\n   for(int index = 0; index < array.size(); index++)\n   {\n      if(index %2 == 0)\n      {\n         array.add(index, element);\n      }\n   }\n}END"}, {"prompt": "As the amount of data stored in an array or ArrayList begins to grow, a common necessity is knowing where and if certain data can be found within a dataset. For example, a user is interested in buying a new car. They want to find a used car that is within their price range and a certain color. Given a database of cars, this user should be able to find the exact car that they are looking for, provided that the car exists in the database! This process of finding data, or pieces of data, that fit a specific criteria is called searching.\n\nA common way to search through a list of items is to start at the beginning of the list and continue through the list until the desired item is found. If the desired item is not found, then that means it is not in the list.\n\nSuppose that you are given a set of raffle tickets at a school raffle. Each ticket has its own number on it:\n\nTicket\t0\t1\t2\t3\t4\t5\nNumber\t44\t53\t12\t51\t64\t15\nThe 0th ticket has number 44, and the ticket at index 4 has raffle number 64. The school will randomly select a number between 1 and 100. If you have the ticket with that number, you win!\n\nWhat if the school picks 51 as the winning number? As a human, it\u2019s easy to look over the whole list and see that you have the ticket with 51 on it, but computers need a more programmatic approach to looking through the list.\n\nThe process of searching each item in a list until the desired item is found is called linear, or sequential search.\n\nLinear search is fairly easy to implement. To programmatically search the list of raffle ticket numbers, you just need to iterate through the list one number at a time. At each new number, if the number matches the desired number, then the desired number is in the list, and the program can stop searching and return the index position of the number. If the program makes it all the way to the end of the list and hasn\u2019t spotted the desired number, then that means it\u2019s not in the list.\n\nHere\u2019s what it looks like in pseudocode:\n\nfor every index in the list:\nget the current number at that index position\nif the current number matches our target number:\nreturn the index\nreturn not found\n\nThat pseudocode can be used to implement a working linear search:\n\npublic int linearSearch(int[] array, int key)\n{\n    for(int i = 0; i < array.length; i++)\n    {\n        int element = array[i];\n        if(element == key)\n        {\n            return i;\n        }\n    }\n    return -1;\n}\n\nIn the example above, key represents the value that is being searched for in the given list. If the key is an element in the list, then the index where that value can be found is returned to the program, otherwise, the value -1 will be returned.\n\nThis method can also be implemented using ArrayList:\n\npublic int linearSearch(ArrayList<Integer> arrayL, int key)\n{\n    for(int i = 0; i < arrayL.size(); i++)\n    {\n        int element = arrayL.get(i);\n        if(element == key)\n        {\n            return i;\n        }\n    }\n    return -1;\n}\n\nWhile linear search is a fairly easy algorithm to implement and understand, linear search is limited by the number of elements that are being searched. The longer the data set is, the longer linear search takes, as it must iterate through all values in order to find the correct one.\n\nSuppose the 1 millionth item in a data set were the element that you were looking for- linear search would have to iterate through the data set 1 million times in order to find it! When deciding how to search for values in a data set, it\u2019s important to consider the pros and cons of using the search mechanism.\n\n###\n\n", "completion": "Question: How does Linear Search work?\nCorrect: Linear Search traverses a list in order until the desired value is found, or until the end of the list.\nIncorrect: Linear Search uses a while loop to traverse a list for the desired value, or until the end of the array.\nIncorrect: Linear Search traverses a list from the last value to the first value until the desired value is found.\nIncorrect: Linear Search searches for desired values by searching the the next highest value in a list, and seeing if that is the desired value.END"}, {"prompt": "As datasets get larger, it\u2019s important to be able to manage and sort through data to find results and values more quickly and efficiently. When data is disorganized, it can be hard to find values easily. To find values, it\u2019s much easier to do so if they are in the correct order. That way, searches can be organized at specific points, which in turn can make sure that programs will look through less values as they search.\n\nTake this dataset for example:\n\n1\t2\t7\t44\t5\t76\t9\t0\t72\t4\t325\t2\t753\t345\t234\t53\nFinding the value 4 in this list requires you to search from the beginning all the way to the end - since the data isn\u2019t in a particular order, there is no way of knowing for certain where the element 4 will be found.\n\nIf this list were organized by smallest number to greatest:\n\n0\t1\t2\t2\t4\t5\t7\t9\t44\t53\t72\t76\t234\t325\t345\t753\nThen finding 4 would be a much easier process, as you can search certain sections of the list for the element in question where it is most likely to be found.\n\nIn programming, there are standard algorithms that can be used to sort data in ways that make finding data more manageable. Two standards algorithms that will be explored in this chapter are Selection and Insertion Sort.\n\nSelection sort sorts arrays by repeatedly finding the minimum value in an array, and moving it to the front. Consider the following, unorganized array:\n\n5\t3\t4\t1\t6\t2\nUsing selection sort to sort this array, the first index in the array is picked to start.\n\n5\t3\t4\t1\t6\t2\nThen, the list is traversed to find the minimum value in the rest of the list, which in this case is 1. The value 1 is then swapped from its current position to the position where 5 was:\n\n1\t3\t4\t5\t6\t2\nNow the value 1 at index 0 is considered sorted, and the next unsorted element at index 1 will be chosen. The value at index 1 will be compared with the rest of the unsorted items until a minimum value is found. In this case, the value 2 at index 5 is the minimum value, and it is swapped with the value at index 1.\n\n1\t2\t4\t5\t6\t3\nThis process continues until the entire list is sorted from least - greatest.\n\nHere is what this process looks like in pseudocode:\n\ntraverse each index up to the second to last element\nfind the minimum in the rest of the list\nswap the index and minIndex\n// now everything up to curIndex is sorted\n\nThis can then be used to create a working algorithm for selection sort:\n\npublic static void selectionSort(int[] array)\n{\n    for(int index = 0; index < array.length - 1; index++)\n    {\n        int minIndex = index;\n        for(int i = index; i < array.length; i ++)\n        {\n            if(array[i] < array[minIndex])\n            {\n                minIndex = i;\n            }\n        }\n        int tempValue = array[index];\n        array[index] = array[minIndex];\n        array[minIndex] = tempValue;\n    }\n}\n\nThe initial traversal goes from the first element to the second to last element (array.length - 1) because the final element in the array is considered sorted if every other element in the array has been sorted correctly. The second traversal looks for the minimum value in the array from the current element until the end of the list. It does not search the list for already sorted elements. Once the minimum element is found, it swaps positions with the current element.\n\nSelection sort is a particularly useful sorting algorithm when the elements in a list are in reverse order:\n\n6\t5\t4\t3\t2\t1\nIn this case, the algorithm only needs to swap values a few times, as each swap successfully puts each element in its correct position.\n\nInsertion sort sorts an array by sorting each element compared to the elements already sorted to their left.\n\nGiven the same list as the previous example, insertion sort marks the first element in the list as sorted:\n\n5\t3\t4\t1\t6\t2\nThe next element, 3, is then selected as the next element to sort:\n\n5\t3\t4\t1\t6\t2\nRather than find the minimum value in the unsorted segment like selection sort, insertion sort compares unsorted elements to the sorted ones, placing the element in the correct position within the sorted list:\n\n3\t5\t4\t1\t6\t2\nThe element 3 is now considered sorted, and the sort continues on to the next element, 4, and sorts it within the already sorted list:\n\n3\t4\t5\t1\t6\t2\nThis continues until all elements in the list are sorted from least to greatest.\n\nHere is a pseudocode implementation of insertion sort:\n\ntraverse each element starting from index 1\ntraverse sorted elements to find current element position\nshift sorted elements to place current element\n\nThis can be used to create a working algorithm for insertion sort:\n\npublic static void insertionSort(int[] array)\n{\n    for(int index = 1; index < array.length; index++)\n    {\n        int currentIndexValue = array[index];\n        int sortedIndex = index - 1;\n\n        while(sortedIndex > -1 && array[sortedIndex] > currentIndexValue)\n        {\n            array[sortedIndex + 1] = array[sortedIndex];\n            sortedIndex--;\n        }\n\n        array[sortedIndex + 1] = currentIndexValue;\n    }\n}\n\nInsertion sort traverses all elements from index 1 until the end of the array. Each element then traverses the sorted segment of the array, looking for the correct place in the sorted list to go. This is done using a while loop, as the number of iterations depends largely on the content of the sorted list. As the element moves through the sorted list, each element it searches through is shifted one index higher. This ensures that the element can be placed in the correct index without removing any of the pre-sorted elements from the list.\n\nInsertion sort is most useful when a list is mostly sorted:\n\n1\t2\t3\t4\t6\t5\nWhen lists are almost sorted, the number of times that insertion sort needs to iterate through the list items is limited. In this case, the while loop will not execute for the first 5 index values in this array, limiting the execution count, and reducing the amount of time the algorithm spends sorting items.\n\nWhen choosing which sorting algorithm to use, it\u2019s important to pay attention to the composition of the existing list, and determine which method will be most efficient, especially as the datasets grow.\n\n###\n\n", "completion": "Question: When is it more appropriate to use Insertion Sort than Selection Sort?\nCorrect: When the array is already mostly sorted at the start.\nIncorrect: Insertion sort is always faster than selection sort, so any array is appropriate.\nIncorrect: When the array is sorted in reverse order.\nIncorrect: Insertion sort is always slower than selection sort, so no array is appropriate.END"}, {"prompt": "On a daily basis, humans are creating more data than ever before. This is creating new challenges around protecting and securing that data for individual users, large companies, banks, small startups, doctors, movie makers, and everyone in between. This means it\u2019s more important than ever to be smart about security and privacy in the digital age of computing.\n\nIn order to understand the impact of data collection on privacy and security, it\u2019s important to understand what each of these terms mean.\n\nPrivacy is the right to be free from unwarranted intrusion and to keep certain matters from public view.\n\nSecurity is the state of being free from danger or threat. Its the warm, fuzzy feeling you have when you don\u2019t have to worry about feeling threatened by harm from others or things in the world around us!\n\nDigital technology has forever changed the way society is operating and the way people live. Everyday, there are new ways to work and to play which include new methods of interacting with one another. As people\u2019s digital footprints grow, people form their own online identities.\n\nDigital security is the protection of these online identities.\n\nA digital footprint is the information about a particular person that exists on the Internet as a result of their online activity. This includes emails you send, comments you leave, pictures you post, your search history, and apps you use. Even your work on CodeHS is part of your digital footprint! All of these ways and more are the ways that you are sharing your own data! Any time you use the Internet you are building your digital footprint. Every time you use a device, your data can be collected!\n\nA lot of people think that hackers are going to steal their data, which they can and do, but truthfully, most people give up their data freely without thinking about it too much. It\u2019s important to be aware of your own personal data and how you choose to share your data with others so that you can keep your data secure and private.\n\nHere are some quick tips to maintain your digital footprint and protect your personal data.\n\n- First, use privacy settings on apps and sites to limit your exposure.\n- Review posts that your friends tag you in and address questionable content.\n- Delete any old social media accounts you don\u2019t really use.\n- Search yourself to see what other people see when they search for you on Google.\n- Use strong passwords for every account you have.\n- Stay on secure sites by sticking with httpS, not just http\u2026if you see a site that starts with http, it is not a secure site!\n- Be sure to monitor your webcam and microphone use and make sure you don\u2019t leave them on when you are not using them.\n- Be aware of your location sharing on apps like Find Friends or whenever Google or a site asks if you want to share your location.\n- Skim privacy policies and see if anything jumps out that concerns you about how the site or app shares or uses your data.\n- Watch for phishing attempts in emails. If someone you don\u2019t know sends you an email that seems odd or sounds too good to be true, don\u2019t click through any links or download any content until you\u2019ve looked into it more.\n- Be careful logging into public computers like at a library, for example. Your data is logged on those devices and may not always be wiped to a clean state after you use it.\n- Stay up to date on the best web security practices like 2-factor authentication where you have to enter a code that is sent to your phone before you can proceed on an app or site. This code confirms you are who you say you are and not someone trying to pretend to be you!\n- If you think your personal data has been compromised, contact your parent or guardian, the company that owns the site or app, and/or a school IT person so you can get help or advice.\n\nAll data is shared on the internet via what are called protocols. Protocols for data sharing on the internet are rules and conventions for communication between network devices.\n\nThe Internet is a packet-switched system through which digital data is sent by breaking the data into blocks of bits called packets. Packets contain both the data being transmitted and control information, or metadata, that helps route the data. It is only able to work because all machines have agreed to use the same protocols for creating and reading packets. Your computer and any server are able to share data because they use the same protocols. They are agreeing to talk in the same language.\n\nComputer use and the creation of programs have an impact on personal security that can be beneficial and/or harmful.\n\nBeneficial Impacts:\n\n- Instant Communication: You share data whenever you email, make a video call, or post on social media. All of these have made it possible to communicate instantly with others and consume information at a very rapid pace.\n\n- Improved Collaboration: Sharing data enables collaborative problem solving on a very large scale. Foldit is an example of citizen science that harnesses the problem solving capacity from hundreds of thousands of citizens on the internet to solve really complicated problems. Foldit is an online game where players attempt to solve the folding structures of very important proteins. By determining the structures of these proteins, researchers are able to develop vaccines and understand diseases better. Once the foldit game went live on the internet, players were able to produce an accurate structure of an AIDs causing virus in only 10 days. This virus had been unsolved by computer simulations and researchers for 15 years!\n\n- Increased Access to Goods and Services: You share your data whenever you make an online purchase. Sharing data has provided online shopping that has enabled you to buy directly from retailers. You can easily purchase from other people who don\u2019t have the funds to run a physical store. You are able to find the best product at the lowest price, rather than being disadvantaged by location or lack of knowledge because you can view ratings and reviews across all retailers.\n\n- Access to Information: Sharing data allows more access to information. Anyone on the internet can read cutting edge scientific publications now.\n\n- GPS and Location Sharing: GPS has completely changed how you navigate the world. You can leave your home with just your smartphone and you\u2019ll generally have no problem finding the place that you need to be. You share your current location, which is data, and you are provided data around your position such as images and directions.\n\n- Entertainment: When you upload videos to YouTube, you share your data! There are also online gaming communities so you can play games with someone in another country who speaks a different language or you could be playing a video game with hundreds of other players simultaneously. You share things like your location and more with them, as well. When companies like NetFlix and Hulu stream videos to your home TV or device, theres a big exchange of data, too. They share digital content with you and your family must share payment information and device information to allow access.\n\nFor all of the amazing things that data sharing can provide, there are some substantial negative drawbacks as well.\n\nHarmful Impacts:\n\n- Access to Confidential Information: The website called Wikileaks posts classified information that either governments or corporations are trying to keep secret. On one hand, this is a good thing because it promotes the transparency of information. It makes it so corporations and the governments cant keep secrets from its citizens. However, there\u2019s potential danger in having classified secrets being public, especially if that information is protecting people from harm or hiding their location purposefully.\n\n- Illegal Sharing/Downloading: Peer-to-peer networks allow people to share content or data that they have on their computers. This is fine if the files are their own creation, but oftentimes shared content is NOT owned by the people sharing it. It\u2019s easier than ever to distribute information or content that is not your own, such as copyrighted works of art or copyrighted software.\n\n- Anonymity: You can tell who internet users are by the data they share. How identifiable should Internet users be? On one hand, anonymity supports equality for all on the Internet. If all users are anonymous, users wont be targeted or discriminated against like for their gender or race, because that information won\u2019t be available. However, having complete anonymity provides opportunities for cyber bullying. If all users are anonymous, no one is accountable for their actions.\n\nRegardless of the positive impacts that certain technologies might have on society, they can also have unintended consequences that have a negative impact on society, law, and ethics. Programmers have a responsibility to make sure that their programs are socially, legally, and ethically acceptable.\n\nA computing professional should:\n\n- Contribute to society and to human well-being, acknowledging that all people are stakeholders in computing.\n- Avoid harm.\n- Be honest and trustworthy.\n- Be fair and take action not to discriminate.\n- Respect the work required to produce new ideas, inventions, creative works, and computing artifacts.\n- Respect privacy.\n- Honor confidentiality.\n- Remember that knowledge is power as you live with others in this digital world. Use your knowledge of computing for good purposes so you and everyone else can be safe and enjoy the benefits of computing.\n\n###\n\n", "completion": "Question: Which of the following are some good ways to protect your own personal data?\n\nI. Use privacy settings to limit exposure\nII. Post often on social media while traveling\nIII. Permanently delete old social media accounts you don\u2019t use\nIV. Google yourself on a regular basis\nV. Use short, easy to remember passwords so you don\u2019t have to write them down\nVi. Stay on sites with http://\nCorrect: Only I, III, IV, VI\nIncorrect: Only III, IV, V, VI\nIncorrect: Only I, III, IV, V, VI\nIncorrect: All of theseEND"}, {"prompt": "In Unit 6, you learned how to create arrays, which store a fixed number of elements of the same type in one variable. Arrays can store a series of data in list form to make it easier to access information. Imagine you were a teacher trying to keep track of student scores on exams. This could be done easily using an array:\n\nint[] exam1 = {90, 87, 86, 56, 96}; \nSystem.out.println(\"Student 1's score: \" + exam1[0]); \n\nEach index in exam1 corresponds to a different student in the class, allowing you as the teacher to access student scores. Even this process can become tedious if the amount of data begins to grow consistently. Suppose there were 20 exams in the school year - keeping track of exams 1-20 in 20 different variables can be tedious and can lead to careless mistakes if you aren\u2019t careful.\n\nLuckily, there is a way to store all of this exam information in a single variable. Because arrays store elements of the same type, we can actually store an array of arrays:\n\nint[] exam1 = {90, 87, 86, 56, 96};\nint[] exam2 = {34, 25, 100, 56, 45};\nint[] exam3 = {65, 76, 34, 74, 90};\n\n//An array that stores a list of int[] \nint[][] exams = {exam1, exam2, exam3}; \n\nArrays that store a list of arrays is referred to as a 2D array.\n\nAs noted above, 2D arrays can be declared by including an additional [] at the end of the declaration:\n\nint[][] exams;\n\nNotice that the type of the array still needs to be declared. Arrays can only store values of the same type, so a 2D array can only store arrays of the same type. This 2D array can only store integer arrays.\n\nTo initialize a 2D array, an additional [] also needs to be used to indicate the length of each array in the 2D array:\n\nint[][] exams = new int[3][3];\n\nThis indicates that a new 2D array of three integer arrays will be created that each store three integer values. This can be visualized as such:\n\nexams:\n\nint[]\t0\t0\t0\nint[]\t0\t0\t0\nint[]\t0\t0\t0\n2D arrays can also be initialized using array values, as demonstrated above:\n\nint[] exam1 = {90, 87, 86, 56, 96};\nint[] exam2 = {34, 25, 100, 56, 45};\nint[] exam3 = {65, 76, 34, 74, 90};\n\n//An array that stores a list of int[] \nint[][] exams = {exam1, exam2, exam3};\n\nArrays that store arrays are referred to as 2D arrays because the way they store elements is akin to a two-dimensional shape. As discussed in unit 6, arrays can access elements in an array by using the [] notation:\n\nint[] exam1 = {90, 87, 86, 56, 96};\nSystem.out.println(\"Student 1's score: \" + exam1[0]);  //prints out 90\n\nIn a 2D array, accessing an index will return an array:\n\nint[] exam1 = {90, 87, 86, 56, 96};\nint[] exam2 = {34, 25, 100, 56, 45};\nint[] exam3 = {65, 76, 34, 74, 90};\n\n//An array that stores a list of int[] \nint[][] exams = {exam1, exam2, exam3};\nSystem.out.println(exams[0]); // will print a reference address for exam1\n\nThat array can then be indexed to return a particular element:\n\nint[] exam1 = {90, 87, 86, 56, 96};\nint[] exam2 = {34, 25, 100, 56, 45};\nint[] exam3 = {65, 76, 34, 74, 90};\n\n//An array that stores a list of int[] \nint[][] exams = {exam1, exam2, exam3};\n\nSystem.out.println(exams[0][0]); //will print 90\n\nTo access a single element in a 2D array, the specific list that the element is located in needs to be accessed, then the element itself needs to be accessed from that array:\n\nint score = exams[2][3];\nSystem.out.println(score);  // will print 74\n\nIndex Value\tArray\t0\t1\t2\t3\t4\n0\texam1\t90\t87\t86\t56\t96\n1\texam2\t34\t25\t100\t56\t45\n2\texam3\t65\t76\t34\t74\t90\nAs evident in the visualization, each list in the 2D array can be thought of as a row in the 2D array, and each element in a list can be thought of as a column. Thus, the general format for accessing an element in a 2D array is exams[row][column].\n\nElements in a 2D array can also be modified using the [row][column] notation. The second element in exam1, can be changed to 41 by writing:\n\nexams[0][1] = 41;\n\nNow, the 2D array has an updated value at index 1 of array exam1:\n\nIndex Value\tArray\t0\t1\t2\t3\t4\n0\texam1\t90\t41\t86\t56\t96\n1\texam2\t34\t25\t100\t56\t45\n2\texam3\t65\t76\t34\t74\t90\n\n###\n\n", "completion": "Question: double[][] table = new double[3][4]\n\nWhat is the value of table[0].length?\nCorrect: 4\nIncorrect: 0\nIncorrect: 3\nIncorrect: 12END"}, {"prompt": "As discussed in the previous lesson, individual elements in a 2D array can be accessed using [row][column] indexing:\n\nString[][] cities = {{\"New York City\",\"Albany\", \"Ithaca\"},\n{\"Los Angeles\", \"San Francisco\", \"San Jose\"},\n{\"Houston\", \"Dallas\", \"San Antonio\"}}; \n\nSystem.out.println(cities[1][1]);  // prints San Francisco\n\nThe process of accessing an individual element can be used during a 2D array traversal, which can be used to return all elements in a 2D array.\n\nTraversing a 1D array required the use of a for loop to iterate through each element in the array:\n\nint[] nums = {1,2,3,4,5};\nfor(int index = 0; index < nums.length; index++)\n{\n   System.out.println(nums[index]);\n}\n\nFor a 2D array, this initial traversal is used to access each array in the 2D array, and a nested for loop is needed to access each element within the selected array:\n\nint[][] nums = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}};\nfor(int row = 0; row < nums.length; row++)\n{\n   for(int col = 0; col < nums[row].length; col++)\n   {\n      System.out.println(nums[row][col]);\n   }\n}\n\nThe outer for loop accesses each list in the 2D array nums, while the inner for loop accesses each value within the list. During the first iteration of the outer for loop, the value of row is 0. When the inner for loop iterates, the value of col will increase each time. The values nums[0][0], nums[0][1], nums[0][2], nums[0][3], nums[0][4] will all be printed to the console, and then the value of row will increase to 1. This process will continue until all values in the 2D array have been printed.\n\nNotice that the inner for loop uses the length of the individual list that is being accessed. This ensures that each element in the array will be iterated over.\n\nThis form of iteration is referred to as row-major order. Row-major order is the practice of iterating over each row in an array. In the example above, each list is searched from beginning to end before the next list is searched:\n\n2D arrays can also be searched in column-major order, where a single column in a 2D array is searched before the next column is iterated over:\n\nColumn major order requires a slight alteration to the row-major traversal algorithm:\n\n//column-major order\nint[][] nums = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}};\nfor(int col = 0; col < nums[0].length; row++)\n{\n   for(int row = 0; row < nums.length; row++)\n   {\n      System.out.println(nums[row][col]);\n  }\n}\n\nFor column-major order, the inner for loop iterates through all row values, while the outer for loop iterates through each column. During the first iteration of the outer for loop, the value of col is 0. When the inner loop iterates, the value of row increases by one until the entire 2D array has been searched. The values num[0][0], nums[1][0], nums[2][0] will be printed to the console before the value of col increases to 1.\n\nWhile column-row major can be useful when iterating through 2D arrays, Java is more efficient at iterating over row-major order iterations. For smaller 2D arrays, this difference is inconsequential, but for larger 2D arrays, column-major order iteration may take a substantial amount of time compared to row-major iteration.\n\n2D arrays can also be iterated over using an enhanced for loop:\n\n//enhanced for loop\nint[][] nums = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}};\nfor(int[] list: nums)\n{\n   for(int num: list)\n   {\n      System.out.println(num);\n   }\n}\n\nEnhanced for loops with 2D arrays still require the use of nested loops. In the outer for loop, the enhanced for loop is accessing each list in the 2D array. Notice that the data type int[] is included in the for loop call, indicating that the variable list in each iteration will be an array of integers. The inner for loop then iterates over each item in the list, and prints out the integer which has been stored in the variable num. The type of the variable in the inner for loop should match the same type of the array.\n\nBecause enhanced for loops iterate through each array in a 2D array, enhanced for loops always use row-major order to iterate through a 2D array.\n\nJust as arrays used linear search to find elements, 2D arrays can also use linear search to find values. Here is the general algorithm for searching a 2D array:\n\npublic String search(int[][] array2D, int key)\n{\n   for(int rowIndex = 0; rowIndex < array2D.length; rowIndex++)\n   {\n      for(int colIndex = 0; colIndex < array2D[rowIndex].length; colIndex++)\n      {\n         if(array2D[rowIndex][colIndex] == key) \n         {\n            return key + \" is located at: \" + rowIndex + \",\" + colIndex;\n         }\n      }\n   }\n   return key + \"is not in this 2D array.\";\n}\n\nIn the case of 2D arrays, each row needs to be searched individually. The outer loop simply accesses each individual row of the 2D array while the inner loop is applying search to the array. If the item is not found in any of the arrays, then the return value indicating that the key cannot be found should be placed outside of both for loops. This is to ensure that this only returns if none of the arrays in the 2D array contain that particular value.\n\n2D arrays have a series of standard algorithms that can be used to traverse their values:\n\nMathematical Analysis\n- Determine a minimum or maximum value\n- Compute a sum, average, or mode\n\nAnalyzing Element Properties\n- Determine if at least one element has a particular property\n- Determine if all elements have a particular property\n- Access all consecutive pairs of elements\n- Determine the presence or absence of duplicate elements\n- Determine the number of elements meeting specific criteria\n\nReordering Elements\n- Shift or rotate elements left or right\n- Reverse the order of the elements\n\nEach of these subsets uses a distinct algorithm to analyze arrays:\n\nMathematical Analysis\nMathematical analysis is done by initializing a value, like sum before the nested for loops, and then performing calculations on the array values within the inner for loop so that all values in the 2D array are added to the final calculation. The results can be reported after the nested loop is finished executing:\n\nint[][] scores = {{2,3,4,5,6},{7,6,5,4,3}}\n\n//Initialize value here\nfor(int[] row : scores)\n{\n   for (int i = 0; i < row.length; i++){\n   //Perform calculation here\n\n   }\n}\n\n//Report results here\n\nAnalyzing Element Properties\nTo determine if elements have a particular property, initialize a tracker value before the nested for loop traversal, and then conditionally check for that tracker while traversing the array:\n\nint[][] scores = {{2,3,4,5,6},{7,6,5,4,3}}\n\n//Initialize tracker variable\nfor(int[] row : scores)\n{\n   for (int i = 0; i < row.length; i++){\n      //Conditionally check properties\n      if(condition){ ... }\n   }\n}\n\n//Report results here\n\nReordering Elements\n\nTo make alterations to the list, such as reverse the order or shifting elements, the general format requires that a new 2D is created that will then hold the values in the order that they should be rearranged. Each iteration through the initial array will add a value from the initial array to the altered array:\n\nint[][] scores = {{2,3,4,5,6},{7,6,5,4,3}}\nint[][] alteredScores;\nfor(int row = 0; row < scores.length; row++)\n{\n   for (int col = 0; col < scores[row].length; col++){\n      //add values from grade to alteredArray\n\n   }\n}\n\n//Report results here\n\n###\n\n", "completion": "Question: A 2D double array is declared and initialized to track the terrain of a city park. Each value in the 2D array represents the height of a particular latitude and longitude above sea level. Longitude is represented by the columns in the 2D array and latitude is represented by each row in the 2D array.\n\nThe creator of this 2D array would like to look at the height of the city park along the latitude 100.0 - which traversal method would make the most sense in order to do so?\nCorrect: Row-Major Order\nIncorrect: Column-Major Order\nIncorrect: Enhanced for loop\nIncorrect: This isn\u2019t possible given the 2D array.END"}, {"prompt": "Large classes often rely on several different instance variables in order to successfully create comprehensive programming solutions. For example, a Person class might have several instance variables, like name or birthday. These instance variables are said to have a \u201cHas-A\u201d relationship to their class objects. A Person has a name, and has a birthday. Values that use a \u201chas a\u201d relationship represent instance variables in our projects.\n\nAnother type of relationship in object-oriented programming is the \u201cIs-A\u201d relationship. \u201cIs-A\u201d is used when one thing is a more specific version of another thing. As an example, think about the relationship of a Student to a Person. A Student does not have a Person, but rather, a Student is a Person. In this example, a Student is a more specific example of a Person. While it\u2019s possible to say that every Student is a Person, it\u2019s not possible to say that every Person is a Student. The Person class is a more general class and the Student class is a more specific class. Some other examples of is-a relationships are:\n\n- A Dog is an Animal.\n- A Square is a Rectangle.\n- San Francisco is a City.\n- Computer science is a Class.\n\nSince many classes, like Person and Student, have an is-a relationship, they share some common attributes. Just as a Person has a name, and a birthday, a Student has the same attributes. Since these two classes share many of the same attributes, there should be a way to consolidate these two classes so as to avoid writing the same attributes and instance variables in each class.\n\nIn Java, the is-a relationship is expressed in the form of superclasses and subclasses. A class hierarchy can be developed by putting common attributes and behaviors of related classes into a single class called a superclass. In the current example, the attributes name and birthday belong to both Person and Student, so they should be written in a superclass.\n\nSubclasses inherit the public attributes and behaviors from the superclass. As a result, a subclass object can use any public attribute or behavior without having to repeat these in its code. A superclass object does not have access to the attributes and behaviors of the subclass class. In this case, a Student object will have access to all the attributes and behaviors of both the Student class, like GPA and grade level, and the Person class, but the Person object will only have access to the attributes and behaviors of the Person class.\n\nTo create a superclass/subclass relationship, the keyword extends is added to a class header followed by the name of the superclass:\n\npublic class Student extends Person\n{\n   //Student class implementation\n\n}\n\nThis creates the subclass. Student, in this case, is a subclass of Person, which is the superclass. Subclasses are only capable of extending a single superclass. While a class can only extend one class, it can extend a class that has already been extended:\n\npublic class Person {\n   // Person class implementation\n}\n\npublic class Student extends Person {\n   // Student class implementation\n}\n\npublic class HighSchoolStudent extends Student {\n   // HighSchoolStudent class implementation\n}\n\nIn this case, a HighSchoolStudent object will have access to all the attributes and behaviors of the HighSchoolStudent class, the Student class, and the Person class.\n\nAs programs become more complicated, oftentimes creating a hierarchy of classes allows for the reuse of common attributes and behaviors. Figuring out which variables and methods are shared across class implementations is the first step to developing a successful hierarchical structure.\n\n###\n\n", "completion": "Question: Which of the following best describes a Subclass / Superclass relationship?\nCorrect: Banana / Fruit\nIncorrect: Banana / Color\nIncorrect: Banana / Peel\nIncorrect: Banana / CountEND"}, {"prompt": "Classes can form a hierarchy where each of the subclasses has access to all of the public methods of a parent, or superclass. But what if a subclass doesn\u2019t want to inherit a method from the superclass? For example, what if the Student class wants to use a different toString() method than the Person class to include additional pieces of information about the object?\n\nPerson Class:\n\npublic String toString()\n{\n   return name + \" was born \" + birthday;\n}\n\nStudent Class:\n\npublic String toString() {\n   return super.getName() + \" is in grade \" + grade; \n} \n\nClasses like Student are able to use their own toString method through a process called method overriding. In a method override, a subclass can redefine a method instead of inheriting that method from the superclass.\n\nA method override occurs when a public method in a subclass has the same method signature as a public method in the superclass. When something has the same method signature, it means that the methods have the same name and input parameters. In the example above, both toString() methods in Person and Student have the same name and input parameters - the Student toString(), when called in the Student class, will override the toString() method from Person.\n\nTo denote an override in Java, the best practice is to use the @Override keyword in the line above the method signature. It is important to note that a method overrides a superclass when it has the same method signature, not because it includes the @Override keyword.\n\nStudent Class:\n\n@Override\npublic String toString() {\n    return super.getName() + \" is in grade \" + grade;\n}\n\nIncluding @Override is not required, but is considered best practice for two main reasons. First, using the @Override signals to Java that you are trying to override a superclass method. The Java compiler will check to make sure it actually does override a method correctly and will throw an error if you do not override correctly. Second, it helps to make your code more readable by telling other programmers that a particular method is being used over a similar method in the superclass.\n\nWhen designing class hierarchies, methods and variables that will be used by all the classes are generally put in the superclass. Subclasses are built to add additional methods and instance variables for more specific classes.\n\nAs an example, consider the Person and Student classes again. The Person superclass will have name and birthday as the instance variables and may have a toString() and age() method.\n\nThe Student class would still need the name and birthday, but will also need a grade and GPA as instance variables. These are specific only to a student, so they are added to the subclass, not the superclass. Likewise, it may include a change grade method and a modified toString() method with an override.\n\nWhen calling methods for an object, Java starts by looking in that object class for that method signature. If it finds it there, it will use that particular method, otherwise, it will go to the superclass and look for the method. This will continue until it reaches the top of the class hierarchy. Any method that is called must be defined someplace in this class hierarchy, otherwise, Java will throw an error.\n\n###\n\n", "completion": "Question: Why might we want to override a superclass method? Select the best option.\nCorrect: We override a method because a subclass needs to define a behavior in a different way than the superclass.\nIncorrect: We override methods so that we can see how a method is working within the class.\nIncorrect: We override methods because superclasses cannot correctly define most subclass behaviors.\nIncorrect: We override methods to make Java run more efficiently.END"}, {"prompt": "When a subclass object is created, a superclass object is created in the process. This is evident in the initial call to super that is made in the constructor:\n\npublic class Student extends Person { \n   private int grade;\n   private double gpa;\n\n   public Student (String name, String birthday, int grade, double gpa) {\n      super(name,birthday);\n      this.grade = grade; this.gpa = gpa;\n   }\n\n   public int getGrade(){\n      return grade;\n   }\n} \n\nIn addition to creating the superclass object, the super keyword can be used to reference the super object in other methods within the subclass.\n\nThe keyword super is similar to the keyword this. this refers to the current object, while super refers to the superclass object. Just as it\u2019s possible to reference methods and pass parameters using the this keyword, methods can be referenced and passed parameters using the super keyword.\n\nsuper refers to the superclass object and can call methods using:\n\nsuper.methodName(parameters)\n\nHere is a sample superclass Animal:\n\npublic class Animal {\n\n   private String type;\n   private String sound;\n\n   public Animal (String type, String sound) {\n      this.type = type;\n      this.sound = sound;\n   }\n\n   public void speak(int number){\n      for (int i = 0; i < number; i++)\n         System.out.println(sound);\n      }\n   }\n\nThe Dog class extends the Animal class, inheriting its methods and instance variables:\n\npublic class Dog extends Animal {\n\n   public Dog () {\n      super(\"Dog\", \"Bark\");\n   }\n\n   public void bark(int number){\n      super.speak(number);\n   }\n\n}\n\nIn this example, the Dog subclass constructor uses the super keyword to call the Animal constructor. The Dog class bark() method also calls the superclass speak() method by passing it a parameter that will then get used in the speak() method.\n\n###\n\n", "completion": "Question: Given the following code, what is the correct way for the subclass to call the speak method in the Person class?\n\npublic class Person {\n\n    public void speak(String sound) {\n        System.out.println(sound);\n    }\n}\n\npublic class EnglishSpeaker extends Person {\n\n    public void greet() {\n        /* Missing code */\n    }\n}\nCorrect: super.speak(\"Hello\");\nIncorrect: super(\"Hello\");\nIncorrect: speak(\"Hello\");\nIncorrect: Person.speak(\"Hello\");END"}, {"prompt": "Up to this point, every object declaration and initialization that you\u2019ve written has created objects where the Reference type matched the Object type.\n\nWhile this is often the way that objects should be written, the object type and reference type can be different. The Reference type of an object variable can be declared with a superclass, then instantiated with a subclass:\n\nPerson student1 = new Student();\n\nDoing so facilitates polymorphism. Polymorphism is the capability of a method to do different things depending on the object it is acting upon. In Java and other object-oriented programming languages, the concept of polymorphism means that an object can take on different forms depending on its implementation. Java can call the correct method even when an object is disguised as a more generic reference type.\n\nIn standard Java Documentation, superclasses are denoted with the letter T, while subclasses are denoted with the letter S. If class S is a class T, then S is a subclass to the T superclass.\n\nThis terminology will be used throughout this chapter to refer to the relationship between superclasses and subclasses.\n\nAs mentioned earlier, the superclass can be used as the reference type for an object instantiated with a subclass.\n\nPerson student1 = new Student();\n\nMore broadly, this means that when the Superclass is used as a reference type, then an object can be created as either the Superclass T, or any Subclass S. For example, the Person reference type can be used when instantiating an object as a Person, Student, or Worker, so long as the instantiated type is a subclass of the Person class:\n\nPerson student1 = new Person();\nPerson student1 = new Worker();\nPerson student1 = new Student();\n\nThe ability to declare an object with the superclass Reference type enables the use of polymorphism, where methods are able to change their behavior. This is most useful and evident in the following ways:\n\nIt enables the use of type T as a formal parameter in a method, which can then pass any object of type T or S.\nIt enables the creation of arrays and ArrayList of type T that stores any type T or S objects.\nFor the former, consider the following method:\n\npublic static void greeting(Person person)\n{\n    System.out.println(\"Hello \" + person.getName());\n}\n\nThe formal parameter in this method specifies that the object type that is being passed is of type Person. A Student object can still be passed to this method if it is declared with the Person reference type:\n\nPerson karel = new Student(\"Karel\");\ngreeting(karel); //prints 'Hello Karel'\n\nThis same concept applies to storing values in an array or ArrayList. If an array is declared with type Person, then Student objects are still able to be added when declared as type Person:\n\nPerson karel = new Student(\"Karel\");\nPerson jeremy = new Person(\"Jeremy\");\nPerson[] people = {karel, jeremy};\n\nThis process illustrates how polymorphism can be used to broaden the use of methods and data structures to include objects of multiple classes within a hierarchy.\n\n###\n\n", "completion": "Question: Given the following class structure:\n\npublic class Vehicle {\n   /* implementation not shown */\n}\n\npublic class Truck extends Vehicle {\n   /* implementation not shown */\n}\n\nWhich of the following objects can be created?\n\nVehicle obj1 = new Vehicle();\nVehicle obj2 = new Truck();\nTruck obj3 = new Truck();\nTruck obj4 = new Vehicle();\nCorrect: obj1, obj2, obj3\nIncorrect: obj3 & obj1\nIncorrect: obj1, obj3, obj4\nIncorrect: All of these are validEND"}, {"prompt": "As discussed in the previous chapter, polymorphism is the capability of a method to do different things depending on the object it is acting upon. This process allows for the declaration of objects using a superclass that can then be instantiated as a specific subclass. This enables Arrays and methods to utilize polymorphism.\n\nPolymorphism is also capable of calling the correct method for an object even when that object is disguised as a more generic reference type. This process is evident when looking at how object methods are called in compile time and run time.\n\nAt the time a program gets compiled, methods in or inherited by the declared type determine the correctness of a non-static method call. During the process of compiling a program, Java checks the declared type of an object to determine if all of the called methods exist:\n\nPerson person1 = new Student();\nperson1.getName();\n\nThe Java compiler will only check the Person class to see if the getName method exists. It will only successfully compile if it exists in the Person class, regardless of whether or not it exists in the Student class. This means that objects declared as a superclass type but instantiated as a subclass type can only call methods that exist in both classes.\n\nAt the time a program runs, the methods in the actual object type get executed. If the method doesn\u2019t exist there, Java looks to the superclass for the method. From the previous example, at run time, Java will look for the getName method in the Student class first. If it doesn\u2019t exist, it will look in the parent class.\n\n###\n\n", "completion": "Question: In order for a program to compile, any method that an object uses \u2026\nCorrect: Must be defined in the class where the object is declared.\nIncorrect: Must be defined in the class where the object is instantiated.\nIncorrect: Must be defined in both the class where the object is declared and where it is instantiated.\nIncorrect: Doesn\u2019t have to be defined anywhere. Java only checks for the method at run time.END"}, {"prompt": "Classes can form a hierarchy where each of the subclasses has access to all of the public methods of a parent. At the top of the hierarchy is the Object class, which is a part of the built-in java.lang package. All other classes can use the Object class through inheritance.\n\nThe Object class contains several useful methods that are used and inherited by its subclasses. Two such methods are equals() and toString().\n\nThe equals method compares two objects and is often overridden by a subclass. Using the Object level version of the equals() method, Java returns true only if the two objects are represented by the same object in memory. This is often not very helpful, as == also returns the same result, which is why this method is often overridden by subclasses.\n\nOne example where equals() is overridden is the String class. The String class equals() method compares each character of the string to determine if they are the same, not just if they are the same objects.\n\nThe toString() method is another commonly used and commonly overridden method from the Object class. When an object name is called with no method, the toString() is returned as a String representation of the object. The generic toString() for an object is to return the object type followed by an @ symbol and then the unsigned hexadecimal representation of the object. This has limited value, which is why it is often overridden.\n\nObject obj1 = new Object();\nSystem.out.println(obj1);   //prints java.lang.Object@27c170f0\n\nThere are many examples where the toString() method is overridden. For example, in the Person class you\u2019ve created earlier in this chapter, the toString() method is overridden to return the name of the person:\n\nPerson person1 = new Person(\"Steve\");\nSystem.out.println(person1);  //prints Steve\n\n###\n\n", "completion": "Question: Which of the following methods would you find in the Object class?\nCorrect: toString\nIncorrect: comparesTo\nIncorrect: delete\nIncorrect: overrideEND"}, {"prompt": "As discussed in previous chapters, iteration is a useful programming tool that makes programs more efficient and readable. So far, you\u2019ve used for loops and while loops to create iterative programs:\n\npublic int sum(int num)\n{\n    int sum = 0; \n    for(int i = 0; i <= num; i++)\n    {\n        sum += i;\n    }\n    return sum;\n}\n\nIn addition to these iterative control structures, iteration can be implemented in programs using a process called recursion.\n\nRecursion is an iterative approach where a method calls itself. Recursion is used to break a complex problem down into a slightly simpler version. This is done until the problem is so small that it is easily solvable.\n\nThe example summing algorithm written above can actually be written using a recursive algorithm. If the call sum(10) were made to the method, each value from 0 - 10 would be summed together:\n\nsum(10) = 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0\n\nWhen looking at the summation this way, a pattern begins to emerge. Within the call to sum(10) is actually a call to sum(9), as sum(9) will sum all values from 0 - 9.\n\nThus, we can rewrite our original summation as:\n\nsum(10) = 10 + sum(9)\n\nSince sum(9) is inherent in the sum of all values 0 - 10, sum(8) must be a part of the solution for sum(9). This pattern continues until the smallest value 0 is reached:\n\nsum(9) = 9 + sum(8)\nsum(8) = 8 + sum(7)\n\u2026\nsum(1) = 1 + sum(0)\nsum(0) = 0\n\nEach time through, the problem gets a little simpler. When the process gets to the point where it can\u2019t be simplified anymore, the final result is considered the base case. In this example, the base case is sum(0) = 0. If there isn\u2019t a base case, then the recursion would continue on forever.\n\nAll of the other numbers can be represented generically with a formula such as the one below:\n\nsum(n) = n + sum(n - 1)\n\nThe generic formula is considered the recursive case. The recursive case is the step that the algorithm takes to make the problem one step smaller so that it moves towards the base case.\n\nIf the recursive case doesn\u2019t simplify or make the program smaller, then the recursion would go on forever as well. The base case and the recursive case need to be designed in tandem so that they eventually lead to a method that terminates.\n\nThese two cases can be used to create a full recursive version of the sum method:\n\npublic static int sum(int n)\n{\n    if (n == 0)\n    {\n        return 0;\n    }\n\n    return n + sum(n - 1);\n}\n\nWhen the call sum(3) is made to this method, the first call to the method will return the value 3 + sum(2). This will call the sum method again, this time with the actual parameter of 2. The value returned by this call will be 2 + sum(1). This process continues until sum(0), when the value 0 will be returned to the program. When this call happens, all previous return values are returned to each call of the sum method, and the final result is returned:\n\nsum(3)\tsum(2)\tsum(1)\tsum(0)\nValue of num\t3\t2\t1\t0\nResult of num == 0\tFalse\tFalse\tFalse\tTrue\nreturn value\t3 + sum(2)\t2 + sum(1)\t1 + sum(0)\t0\n\nAs illustrated in the table above, each recursive call has its own set of local variables, including the formal parameters. These parameter values capture the progress of a recursive process, much like loop control variable values capture the progress of a loop. Just like the other iterative structures, recursion can be used to traverse Strings, arrays and ArrayLists.\n\n###\n\n", "completion": "Question: Why do we use recursion?\nCorrect: We use it to break complex problems down into simpler problems that become easier to solve.\nIncorrect: Recursion is always a more efficient way to use iteration.\nIncorrect: Both of these\nIncorrect: Neither of theseEND"}, {"prompt": "As discussed in previous chapters, searching and sorting data is an integral part of data storage and management in Java. Searching algorithms, such as Insertion and Selection sort, rely on the use of iterative control structures, like for loops and while loops, to traverse data structures and find a desired value:\n\n//Selection sort relies on iteration to traverse data structures\nfor(int index = 0; index < array.length - 1; index++)\n{\n    int minIndex = index;\n    for(int i = index; i < array.length; i ++)\n    {\n        if(array[i] < array[minIndex])\n        {\n            minIndex = i;\n        }\n    }\n    int tempValue = array[index]; array[index] = array[minIndex];\n    array[minIndex] = tempValue;\n}\n\nJust as for loops and while loops can be used for traversals, recursion too can be applied to searching algorithms.\n\nOne search method that relies on the use of recursion is binary search.\n\nA binary search finds the middle of an array and tests that point. If the target is greater than the midpoint value, then the search eliminates the lower half. Likewise, if the target is less than the midpoint value, the top half can be eliminated. This process is then repeated, finding a new midpoint each time. It\u2019s important to note that the array must be sorted for a binary search to work properly.\n\nNotice how each iteration eliminates half of the values. While this process is slightly more efficient for smaller arrays, it is significantly more efficient for larger arrays. A linear search of 10,000 records could have a worst case scenario of 10,000 comparisons. With binary search, the worst case is only 15 comparisons to find the value.\n\nWhen comparing Linear Search to Binary Search, there are a few significant differences. First, binary searches are much more efficient than linear searches. Second, linear searches will work on any array, but binary searches only work on a sorted array. Finally, the algorithm for binary searches is a little more complex than our linear search.\n\nLinear\tBinary\nNot efficient\tVery efficient\nWorks on sorted or unsorted arrays.\tOnly works on sorted arrays.\nEasy to code\tSlightly more complex to code\n\nHere is a non-recursive implementation of binary search:\n\npublic int binaryLoop(int[] array, int target) {\n    int begin = 0;\n    int end = array.length - 1;\n\n    while (begin <= end) {\n        int mid = (begin + end) / 2;\n        if (target < array[mid]) {\n            end = mid - 1;\n        }\n        else if (target > array[mid]) {\n            begin = mid + 1;\n        }\n        else if (target == array[mid]) { \n            return mid;\n        }\n    }\n    return -1; // not found\n}\n\nNotice in the loop how the midpoint is calculated, then tested before updating the beginning and ending points each time based on the results. Initially, the array is passed to the method, where the values begin and end are set to the first index and the last index in the array. The while loop then checks that begin is less than end, and calculates the midpoint of the array. The method then checks if the target value is greater than, less than, or equal to the midpoint. If the target is greater than the midpoint, then the method removes the begin to midpoint values from the search. As noted earlier, this only works if the values are sorted before being searched. The method then returns to the beginning of the while loop, and finds a new midpoint between the new begin value and end. It does so until the target has been found, or the array has been fully halved and searched.\n\nThis method can also be written using recursion. Since recursion attempts to create a simpler version of a problem each time a recursive method is called, binary search lends itself well to its use, as the array is reduced in size each time, all the way to a single value at times. Here is the implementation of binary search with recursion:\n\npublic int binaryRec(int[] array, int target, int begin, int end) {\n    if (begin <= end)\n    {\n        int mid = (begin + end) / 2;\n\n        if (target == array[mid]) { \n            return mid; // Base Case\n        }\n\n        if (target < array[mid]) {\n            return binaryRec(array, target, begin, mid - 1);\n        }\n\n        if (target > array[mid]) {\n            return binaryRec(array, target, mid + 1, end);\n        }\n    }\n    return -1;  //Alternate Base Case\n}\n\nThe biggest change at the start of this code is that the beginning and ending values are being passed into the method. From there, the midpoint is calculated the same way as before.\n\nThe base case is where the value is found. In the first iteration, the base case is skipped, and the recursive case is called. The recursive call passes the original array, the target value, but then updates the starting point as it makes the call. Once the value is found, the index value of the target is then returned back through each of the recursive return statements until it eventually gets back to the original call statement.\n\n###\n\n", "completion": "Question: Using the binary search algorithm, what is the maximum number of iterations needed to find an element in an array containing 128 elements?\nCorrect: 7\nIncorrect: 6\nIncorrect: 64\nIncorrect: 128END"}, {"prompt": "Just as recursion can be used to search data structures, it can be used to sort them. One of the most common recursive sorting algorithms is called merge sort.\n\nA merge sort is a sort where the list is divided then merged back together in the correct order. This is done recursively as the list is repeatedly divided in half until it is only one item long. Then each of these lists gets combined back together in the correct order.\n\nMerge sort starts at the top with the entire list, then it breaks this list into two halves.\n\nIt continues this process on both of the halves by breaking it down further. The halves continue to break down until they get to individual items.\n\nOnce it gets broken down, it then starts putting it back together in the correct order.\n\nThis occurs on each halve in the order that they appear in the array.\n\nAs it runs through, note how it only works on a portion of the items in the list. You can see how it works on the first half of the data, segment by segment. After completing the first half, the process is repeated on the second half before finally joining the two pieces together. As it joins the two halves, it moves each value from one half or the other into its final sorted place.\n\nThe merge sort is generally more efficient than the insertion sort or selection sort, and its performance is independent of the initial state of our array. In other words, a randomly sorted array and a nearly sorted array perform at the same speed.\n\nThe downside to the merge sort is that the implementation uses a fairly complex recursive algorithm. The implementation usually involves two methods - the merge sort method to break down the array and a helper method to reassemble it in the correct order.\n\nHere is an implementation of mergeSort:\n\npublic static void mergeSort(int[] current, int length) {\n    if (length < 2) {\n      return;\n    }\n    int mid = length / 2;\n    int[] left = new int[mid];\n    int[] right = new int[length - mid];\n\n    for (int i = 0; i < mid; i++) {\n      left[i] = current[i];\n    }\n    for (int i = mid; i < length; i++) {\n      right[i - mid] = current[i];\n    }\n    mergeSort(left, mid);\n    mergeSort(right, length - mid);\n\n    merge(current, left, right);\n}\n\nThe main purpose of this method is to break the array into smaller pieces, then when it can\u2019t go any further, this method calls the merge method to start combining arrays. Using recursion, the base case is when there is only one element in the array. If the base case is not called, the middle part of this method creates two arrays, a left and a right, and puts half the current array into each of these new arrays. A recursive call is made with each half of the array.\n\nWhen the base case is reached with an array length of 1, the recursive calls return. The method is then ready to combine the left and right array in the correct order. This is accomplished using the merge method:\n\npublic static void merge(\n  int[] current, int[] left, int[] right) {\n\n  int leftSize = left.length;\n  int rightSize = right.length;\n\n  int i = 0, j = 0, k = 0;\n  while (i < leftSize && j < rightSize) {\n    if (left[i] <= right[j]) {\n      current[k++] = left[i++];\n    }\n    else {\n      current[k++] = right[j++];\n    }\n  }\n  while (i < leftSize) {\n    current[k++] = left[i++];\n  }\n  while (j < rightSize) {\n    current[k++] = right[j++];\n  }\n}\n\nThe merge method takes the current array as well as the left and right arrays as input. It will then go through the two arrays to merge them. Notice that it doesn\u2019t return anything. This is because the actual array object is passed to the method and updated. Changes can then be read in other methods.\n\nThe merge method walks through the next element in each array, determining if the left or right array has the smaller value, then inserting into the current array. Once it\u2019s finished going through one of the arrays, there may still be elements remaining in either the left or right array. This last step adds any remaining elements to the end of the current array.\n\n###\n\n", "completion": "Question: Which of the following is NOT true about a merge sort?\nCorrect: The merge sort code is not as complex as other sort codes\nIncorrect: Merge sorts work well on all different types of lists\nIncorrect: Merge sorts use recursion to make the process easier\nIncorrect: A merge sort works by dividing a list into parts, then merging it back together in the correct order.END"}]